{"id": 5, "slug": "longest-palindromic-substring", "title": "Longest Palindromic Substring", "difficulty": "Medium", "content": "Given a string `s`, return _the longest_ _palindromic_ _substring_ in `s`.\n\n**Example 1:**\n\n**Input:** s =  \"babad \"\n**Output:**  \"bab \"\n**Explanation:**  \"aba \" is also a valid answer.\n\n**Example 2:**\n\n**Input:** s =  \"cbbd \"\n**Output:**  \"bb \"\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consist of only digits and English letters.", "java": "\n    ```java\npublic String longestPalindromicSubstring(String s) {\n    int n = s.length();\n    if (n == 0) return \"\";\n\n    int start = 0, maxLength = 1;\n\n    for (int i = 0; i < n; ++i) {\n        int l = i, r = i;\n\n        while (r < n - 1 && s.charAt(r) == s.charAt(r + 1))\n            r++;\n        i = r;\n\n        while (l > 0 && r < n - 1 && s.charAt(l - 1) == s.charAt(r + 1)) {\n            l--;\n            r++;\n        }\n\n        int length = r - l + 1;\n        if (length > maxLength) {\n            start = l;\n            maxLength = length;\n        }\n    }\n\n    return s.substring(start, start + maxLength);\n}\n```\n    \n    1. Initialize `start` and `maxLength` for result substring.\n2. Iterate through the given string `s` using the index `i`.\n3. For each index `i`, create two pointers `l` and `r` starting at `i`.\n4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.\n5. Update the index `i` to the current value of `r`.\n6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.\n7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.\n8. Return the longest palindromic substring using the `start` and `maxLength`.\n    ", "c++": "\n    ```cpp\n#include <string>\n\nstd::string longestPalindromicSubstring(std::string s) {\n  int n = s.size();\n  if (n == 0) return \"\";\n  int start = 0, maxLength = 1;\n\n  for (int i = 0; i < n; ++i) {\n    int l = i, r = i;\n\n    while (r < n - 1 && s[r] == s[r + 1])\n      r++;\n    i = r;\n\n    while (l > 0 && r < n - 1 && s[l - 1] == s[r + 1]) {\n      l--;\n      r++;\n    }\n\n    int length = r - l + 1;\n    if (length > maxLength) {\n      start = l;\n      maxLength = length;\n    }\n  }\n\n  return s.substr(start, maxLength);\n}\n```\n    \n    1. Initialize `start` and `maxLength` for result substring.\n2. Iterate through the given string `s` using the index `i`.\n3. For each index `i`, create two pointers `l` and `r` starting at `i`.\n4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.\n5. Update the index `i` to the current value of `r`.\n6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.\n7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.\n8. Return the longest palindromic substring using the `start` and `maxLength`.\n    ", "python": "\n    ```python\ndef longest_palindromic_substring(s: str) -> str:\n    n = len(s)\n    if n == 0: return \"\"\n\n    start, max_length = 0, 1\n\n    for i in range(n):\n        l, r = i, i\n\n        while r < n - 1 and s[r] == s[r + 1]:\n            r += 1\n        i = r\n\n        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\n            l -= 1\n            r += 1\n\n        length = r - l + 1\n        if length > max_length:\n            start, max_length = l, length\n\n    return s[start:start + max_length]\n```\n    \n    1. Initialize `start` and `maxLength` for result substring.\n2. Iterate through the given string `s` using the index `i`.\n3. For each index `i`, create two pointers `l` and `r` starting at `i`.\n4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.\n5. Update the index `i` to the current value of `r`.\n6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.\n7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.\n8. Return the longest palindromic substring using the `start` and `maxLength`.\n    ", "javascript": "\n    ```javascript\nfunction longestPalindromicSubstring(s) {\n  let n = s.length;\n  if (n === 0) return \"\";\n\n  let start = 0, maxLength = 1;\n\n  for (let i = 0; i < n; ++i) {\n    let l = i, r = i;\n\n    while (r < n - 1 && s[r] === s[r + 1])\n      r++;\n    i = r;\n\n    while (l > 0 && r < n - 1 && s[l - 1] === s[r + 1]) {\n      l--;\n      r++;\n    }\n\n    let length = r - l + 1;\n    if (length > maxLength) {\n      start = l;\n      maxLength = length;\n    }\n  }\n\n  return s.substring(start, start + maxLength);\n}\n```\n    \n    1. Initialize `start` and `maxLength` for result substring.\n2. Iterate through the given string `s` using the index `i`.\n3. For each index `i`, create two pointers `l` and `r` starting at `i`.\n4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.\n5. Update the index `i` to the current value of `r`.\n6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.\n7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.\n8. Return the longest palindromic substring using the `start` and `maxLength`.\n    "}
{"id": 10, "slug": "regular-expression-matching", "title": "Regular Expression Matching", "difficulty": "Hard", "content": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\n*   `'.'` Matches any single character.\u200b\u200b\u200b\u200b\n*   `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the **entire** input string (not partial).\n\n**Example 1:**\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n\n**Example 2:**\n\n**Input:** s =  \"aa \", p =  \"a\\* \"\n**Output:** true\n**Explanation:** '\\*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes  \"aa \".\n\n**Example 3:**\n\n**Input:** s =  \"ab \", p =  \".\\* \"\n**Output:** true\n**Explanation:**  \".\\* \" means  \"zero or more (\\*) of any character (.) \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `1 <= p.length <= 20`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'.'`, and `'*'`.\n*   It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.", "java": "\n    ```java\npublic boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p.charAt(j - 1) == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p.charAt(j - 1) == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    ", "c++": "\n    ```cpp\nbool isMatch(std::string s, std::string p) {\n    int m = s.length(), n = p.length();\n    std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p[j - 1] == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p[j - 1] == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    ", "python": "\n    ```python\ndef is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        if p[j - 1] == '*' and dp[0][j - 2]:\n            dp[0][j] = True\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n\n    return dp[m][n]\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    ", "javascript": "\n    ```javascript\nfunction isMatch(s, p) {\n    const m = s.length, n = p.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(false));\n    dp[0][0] = true;\n\n    for (let j = 1; j <= n; j++) {\n        if (p[j - 1] === '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n          if (p[j - 1] === s[i - 1] || p[j - 1] === '.') {\n              dp[i][j] = dp[i - 1][j - 1];\n          } else if (p[j - 1] === '*') {\n              dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.'));\n          }\n      }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    "}
{"id": 22, "slug": "generate-parentheses", "title": "Generate Parentheses", "difficulty": "Medium", "content": "Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"\\]\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\"()\"\\]\n\n**Constraints:**\n\n*   `1 <= n <= 8`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generateParenthesis(int n) {\n    List<String> result = new ArrayList<>();\n    generateParenthesisHelper(n, 0, \"\", result);\n    return result;\n}\n\nprivate void generateParenthesisHelper(int open, int close, String current, List<String> result) {\n    if (open == 0 && close == 0) {\n        result.add(current);\n        return;\n    }\n    if (open > 0) {\n        generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n    }\n    if (close > 0) {\n        generateParenthesisHelper(open, close - 1, current + ')', result);\n    }\n}\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nvoid generateParenthesisHelper(int open, int close, std::string current, std::vector<std::string>& result) {\n    if (open == 0 && close == 0) {\n        result.push_back(current);\n        return;\n    }\n    if (open > 0) {\n        generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n    }\n    if (close > 0) {\n        generateParenthesisHelper(open, close - 1, current + ')', result);\n    }\n}\n\nstd::vector<std::string> generateParenthesis(int n) {\n    std::vector<std::string> result;\n    generateParenthesisHelper(n, 0, \"\", result);\n    return result;\n}\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    ", "python": "\n    ```python\ndef generate_parenthesis(n):\n    def generate_parenthesis_helper(open, close, current):\n        if open == 0 and close == 0:\n            result.append(current)\n            return\n        if open > 0:\n            generate_parenthesis_helper(open - 1, close + 1, current + '(')\n        if close > 0:\n            generate_parenthesis_helper(open, close - 1, current + ')')\n\n    result = []\n    generate_parenthesis_helper(n, 0, '')\n    return result\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    ", "javascript": "\n    ```javascript\nfunction generateParenthesis(n) {\n    function generateParenthesisHelper(open, close, current, result) {\n        if (open === 0 && close === 0) {\n            result.push(current);\n            return;\n        }\n        if (open > 0) {\n            generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n        }\n        if (close > 0) {\n            generateParenthesisHelper(open, close - 1, current + ')', result);\n        }\n    }\n\n    let result = [];\n    generateParenthesisHelper(n, 0, '', result);\n    return result;\n}\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    "}
{"id": 32, "slug": "longest-valid-parentheses", "title": "Longest Valid Parentheses", "difficulty": "Hard", "content": "Given a string containing just the characters `'('` and `')'`, return _the length of the longest valid (well-formed) parentheses_ _substring_.\n\n**Example 1:**\n\n**Input:** s =  \"(() \"\n**Output:** 2\n**Explanation:** The longest valid parentheses substring is  \"() \".\n\n**Example 2:**\n\n**Input:** s =  \")()()) \"\n**Output:** 4\n**Explanation:** The longest valid parentheses substring is  \"()() \".\n\n**Example 3:**\n\n**Input:** s =  \" \"\n**Output:** 0\n\n**Constraints:**\n\n*   `0 <= s.length <= 3 * 104`\n*   `s[i]` is `'('`, or `')'`.", "java": "\n    ```java\nimport java.util.Stack;\n\npublic int longestValidParentheses(String s) {\n    int n = s.length();\n    int result = 0;\n    Stack<Integer> st = new Stack<>();\n\n    for (int i = 0; i < n; ++i) {\n        if (s.charAt(i) == '(') {\n            st.push(i);\n        } else {\n            if (!st.empty() && s.charAt(st.peek()) == '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.empty()) {\n        result = n;\n    } else {\n        int right = n, left = 0;\n        while (!st.empty()) {\n            left = st.pop();\n            result = Math.max(result, right - left - 1);\n            right = left;\n        }\n        result = Math.max(result, right);\n    }\n\n    return result;\n}\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    ", "c++": "\n    ```cpp\n#include <stack>\n\nint longestValidParentheses(string s) {\n    int n = s.length();\n    int result = 0;\n    std::stack<int> st;\n\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '(') {\n            st.push(i);\n        } else {\n            if (!st.empty() && s[st.top()] == '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.empty()) {\n        result = n;\n    } else {\n        int right = n, left = 0;\n        while (!st.empty()) {\n            left = st.top();\n            st.pop();\n            result = std::max(result, right - left - 1);\n            right = left;\n        }\n        result = std::max(result, right);\n    }\n\n    return result;\n}\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    ", "python": "\n    ```python\ndef longest_valid_parentheses(s: str) -> int:\n    n = len(s)\n    result = 0\n    st = []\n\n    for i in range(n):\n        if s[i] == '(':\n            st.append(i)\n        else:\n            if st and s[st[-1]] == '(':\n                st.pop()\n            else:\n                st.append(i)\n\n    if not st:\n        result = n\n    else:\n        right, left = n, 0\n        while st:\n            left = st.pop()\n            result = max(result, right - left - 1)\n            right = left\n        result = max(result, right)\n\n    return result\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    ", "javascript": "\n    ```javascript\nfunction longestValidParentheses(s) {\n    const n = s.length;\n    let result = 0;\n    const st = [];\n\n    for (let i = 0; i < n; ++i) {\n        if (s[i] === '(') {\n            st.push(i);\n        } else {\n            if (st.length > 0 && s[st[st.length - 1]] === '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.length === 0) {\n        result = n;\n    } else {\n        let right = n, left = 0;\n        while (st.length > 0) {\n            left = st.pop();\n            result = Math.max(result, right - left - 1);\n            right = left;\n        }\n        result = Math.max(result, right);\n    }\n\n    return result;\n}\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    "}
{"id": 42, "slug": "trapping-rain-water", "title": "Trapping Rain Water", "difficulty": "Hard", "content": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n\n**Example 1:**\n\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n\n**Example 2:**\n\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n\n**Constraints:**\n\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`", "java": "\n    ```java\npublic int trap(int[] height) {\n    int n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint trap(vector<int>& height) {\n    int n = height.size();\n    int left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    ", "python": "\n    ```python\ndef trap(height):\n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    return water\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    ", "javascript": "\n    ```javascript\nfunction trap(height) {\n    const n = height.length;\n    let left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    "}
{"id": 44, "slug": "wildcard-matching", "title": "Wildcard Matching", "difficulty": "Hard", "content": "Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n*   `'?'` Matches any single character.\n*   `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the **entire** input string (not partial).\n\n**Example 1:**\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n\n**Example 2:**\n\n**Input:** s =  \"aa \", p =  \"\\* \"\n**Output:** true\n**Explanation:** '\\*' matches any sequence.\n\n**Example 3:**\n\n**Input:** s =  \"cb \", p =  \"?a \"\n**Output:** false\n**Explanation:** '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n\n**Constraints:**\n\n*   `0 <= s.length, p.length <= 2000`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'?'` or `'*'`.", "java": "\n    ```java\npublic boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    int i = 0, j = 0, asterisk = -1, match = 0;\n    while (i < m) {\n        if (j < n && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {\n            i++; j++;\n        } else if (j < n && p.charAt(j) == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk != -1) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p.charAt(j) == '*') j++;\n    return j == n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ", "c++": "\n    ```cpp\nbool isMatch(const std::string& s, const std::string& p) {\n    int m = s.size(), n = p.size();\n    int i = 0, j = 0, asterisk = -1, match;\n    while (i < m) {\n        if (j < n && (s[i] == p[j] || p[j] == '?')) {\n            i++; j++;\n        } else if (j < n && p[j] == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] == '*') j++;\n    return j == n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ", "python": "\n    ```python\ndef is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    i = j = 0\n    match = asterisk = -1\n    while i < m:\n        if j < n and (s[i] == p[j] or p[j] == '?'):\n            i, j = i + 1, j + 1\n        elif j < n and p[j] == '*':\n            match, asterisk = i, j\n            j += 1\n        elif asterisk >= 0:\n            i, j = match + 1, asterisk + 1\n            match += 1\n        else:\n            return False\n    while j < n and p[j] == '*':\n        j += 1\n    return j == n\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ", "javascript": "\n    ```javascript\nfunction isMatch(s, p) {\n    let m = s.length,\n        n = p.length;\n    let i = 0,\n        j = 0,\n        asterisk = -1,\n        match = 0;\n    while (i < m) {\n        if (j < n && (s[i] === p[j] || p[j] === '?')) {\n            i++;\n            j++;\n        } else if (j < n && p[j] === '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] === '*') j++;\n    return j === n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    "}
{"id": 45, "slug": "jump-game-ii", "title": "Jump Game II", "difficulty": "Medium", "content": "You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.\n\nEach element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:\n\n*   `0 <= j <= nums[i]` and\n*   `i + j < n`\n\nReturn _the minimum number of jumps to reach_ `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,1,1,4\\]\n**Output:** 2\n**Explanation:** The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n**Example 2:**\n\n**Input:** nums = \\[2,3,0,1,4\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 1000`\n*   It's guaranteed that you can reach `nums[n - 1]`.", "java": "\n    ```java\npublic int jump(int[] nums) {\n    int jumps = 0, currentEnd = 0, currentFarthest = 0;\n    \n    for (int i = 0; i < nums.length - 1; i++) {\n        currentFarthest = Math.max(currentFarthest, i + nums[i]);\n        if (i == currentEnd) {\n            jumps++;\n            currentEnd = currentFarthest;\n        }\n    }\n    return jumps;\n}\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ", "c++": "\n    ```cpp\nint jump(vector<int>& nums) {\n    int jumps = 0, current_end = 0, current_farthest = 0;\n    \n    for (int i = 0; i < nums.size() - 1; i++) {\n        current_farthest = max(current_farthest, i + nums[i]);\n        if (i == current_end) {\n            jumps++;\n            current_end = current_farthest;\n        }\n    }\n    return jumps;\n}\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ", "python": "\n    ```python\ndef jump(nums):\n    jumps = 0\n    current_end = 0\n    current_farthest = 0\n\n    for i in range(len(nums) - 1):\n        current_farthest = max(current_farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = current_farthest\n\n    return jumps\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ", "javascript": "\n    ```javascript\nfunction jump(nums) {\n    let jumps = 0, currentEnd = 0, currentFarthest = 0;\n\n    for (let i = 0; i < nums.length - 1; i++) {\n        currentFarthest = Math.max(currentFarthest, i + nums[i]);\n        if (i === currentEnd) {\n            jumps++;\n            currentEnd = currentFarthest;\n        }\n    }\n    return jumps;\n}\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    "}
{"id": 53, "slug": "maximum-subarray", "title": "Maximum Subarray", "difficulty": "Medium", "content": "Given an integer array `nums`, find the subarray with the largest sum, and return _its sum_.\n\n**Example 1:**\n\n**Input:** nums = \\[-2,1,-3,4,-1,2,1,-5,4\\]\n**Output:** 6\n**Explanation:** The subarray \\[4,-1,2,1\\] has the largest sum 6.\n\n**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** 1\n**Explanation:** The subarray \\[1\\] has the largest sum 1.\n\n**Example 3:**\n\n**Input:** nums = \\[5,4,-1,7,8\\]\n**Output:** 23\n**Explanation:** The subarray \\[5,4,-1,7,8\\] has the largest sum 23.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`\n\n**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.", "java": "\n    ```java\npublic int maxSubArray(int[] nums) {\n    int max_sum = nums[0];\n    int current_sum = max_sum;\n\n    for (int i = 1; i < nums.length; i++) {\n        current_sum = Math.max(current_sum + nums[i], nums[i]);\n        max_sum = Math.max(max_sum, current_sum);\n    }\n\n    return max_sum;\n}\n```\n    \n    The algorithm uses the \"Kadane's Algorithm\" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.\n\nFor each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.\n\nIn the end, max_sum contains the largest sum of the contiguous subarray.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n    ", "c++": "\n    ```cpp\nint maxSubArray(vector<int>& nums) {\n    int max_sum = nums[0];\n    int current_sum = max_sum;\n    \n    for (int i = 1; i < nums.size(); i++) {\n        current_sum = max(current_sum + nums[i], nums[i]);\n        max_sum = max(max_sum, current_sum);\n    }\n    \n    return max_sum;\n}\n```\n    \n    The algorithm uses the \"Kadane's Algorithm\" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.\n\nFor each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.\n\nIn the end, max_sum contains the largest sum of the contiguous subarray.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n    ", "python": "\n    ```python\ndef maxSubArray(nums):\n    max_sum = current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n```\n    \n    The algorithm uses the \"Kadane's Algorithm\" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.\n\nFor each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.\n\nIn the end, max_sum contains the largest sum of the contiguous subarray.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n    ", "javascript": "\n    ```javascript\nfunction maxSubArray(nums) {\n    let max_sum = nums[0];\n    let current_sum = max_sum;\n\n    for (let i = 1; i < nums.length; i++) {\n        current_sum = Math.max(current_sum + nums[i], nums[i]);\n        max_sum = Math.max(max_sum, current_sum);\n    }\n\n    return max_sum;\n}\n```\n    \n    The algorithm uses the \"Kadane's Algorithm\" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.\n\nFor each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.\n\nIn the end, max_sum contains the largest sum of the contiguous subarray.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n    "}
{"id": 55, "slug": "jump-game", "title": "Jump Game", "difficulty": "Medium", "content": "You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` _if you can reach the last index, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,1,1,4\\]\n**Output:** true\n**Explanation:** Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n**Example 2:**\n\n**Input:** nums = \\[3,2,1,0,4\\]\n**Output:** false\n**Explanation:** You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 105`", "java": "\n    ```java\npublic boolean canJump(int[] nums) {\n    int maxReach = 0;\n    for (int i = 0; i < nums.length; ++i) {\n        if (i > maxReach) return false;\n        maxReach = Math.max(maxReach, i + nums[i]);\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the `nums` array, keeping track of the maximum reachable index in `maxReach`. In each iteration, it compares the current index `i` with `maxReach`. If `i` is greater than `maxReach`, it means that the last index cannot be reached. Otherwise, it updates the `maxReach` by taking the maximum value between the current `maxReach` and the sum of the current index `i` and the value of `nums[i]`. If the end of iteration is reached, it means that the last index can be reached, so the function returns true.\n    ", "c++": "\n    ```cpp\nbool canJump(vector<int>& nums) {\n    int maxReach = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (i > maxReach) return false;\n        maxReach = max(maxReach, i + nums[i]);\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the `nums` array, keeping track of the maximum reachable index in `maxReach`. In each iteration, it compares the current index `i` with `maxReach`. If `i` is greater than `maxReach`, it means that the last index cannot be reached. Otherwise, it updates the `maxReach` by taking the maximum value between the current `maxReach` and the sum of the current index `i` and the value of `nums[i]`. If the end of iteration is reached, it means that the last index can be reached, so the function returns true.\n    ", "python": "\n    ```python\ndef canJump(nums):\n    max_reach = 0\n    for i, num in enumerate(nums):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + num)\n    return True\n```\n    \n    The algorithm iterates through the `nums` array, keeping track of the maximum reachable index in `maxReach`. In each iteration, it compares the current index `i` with `maxReach`. If `i` is greater than `maxReach`, it means that the last index cannot be reached. Otherwise, it updates the `maxReach` by taking the maximum value between the current `maxReach` and the sum of the current index `i` and the value of `nums[i]`. If the end of iteration is reached, it means that the last index can be reached, so the function returns true.\n    ", "javascript": "\n    ```javascript\nfunction canJump(nums) {\n    let maxReach = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        if (i > maxReach) return false;\n        maxReach = Math.max(maxReach, i + nums[i]);\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the `nums` array, keeping track of the maximum reachable index in `maxReach`. In each iteration, it compares the current index `i` with `maxReach`. If `i` is greater than `maxReach`, it means that the last index cannot be reached. Otherwise, it updates the `maxReach` by taking the maximum value between the current `maxReach` and the sum of the current index `i` and the value of `nums[i]`. If the end of iteration is reached, it means that the last index can be reached, so the function returns true.\n    "}
{"id": 62, "slug": "unique-paths", "title": "Unique Paths", "difficulty": "Medium", "content": "There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe test cases are generated so that the answer will be less than or equal to `2 * 109`.\n\n**Example 1:**\n\n**Input:** m = 3, n = 7\n**Output:** 28\n\n**Example 2:**\n\n**Input:** m = 3, n = 2\n**Output:** 3\n**Explanation:** From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n\n**Constraints:**\n\n*   `1 <= m, n <= 100`", "java": "\n    ```java\npublic int uniquePaths(int m, int n) {\n    int[][] dp = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    ", "c++": "\n    ```cpp\nint uniquePaths(int m, int n) {\n    vector<vector<int>> dp(m, vector<int>(n, 1));\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    ", "python": "\n    ```python\ndef uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m - 1][n - 1]\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    ", "javascript": "\n    ```javascript\nfunction uniquePaths(m, n) {\n    const dp = Array.from({ length: m }, () => Array(n).fill(1));\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    "}
{"id": 63, "slug": "unique-paths-ii", "title": "Unique Paths II", "difficulty": "Medium", "content": "You are given an `m x n` integer array `grid`. There is a robot initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nAn obstacle and space are marked as `1` or `0` respectively in `grid`. A path that the robot takes cannot include **any** square that is an obstacle.\n\nReturn _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe testcases are generated so that the answer will be less than or equal to `2 * 109`.\n\n**Example 1:**\n\n**Input:** obstacleGrid = \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n**Output:** 2\n**Explanation:** There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\n**Example 2:**\n\n**Input:** obstacleGrid = \\[\\[0,1\\],\\[0,0\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == obstacleGrid.length`\n*   `n == obstacleGrid[i].length`\n*   `1 <= m, n <= 100`\n*   `obstacleGrid[i][j]` is `0` or `1`.", "java": "\n    ```java\npublic int uniquePathsWithObstacles(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    if (grid[0][0] == 1) return 0;\n    \n    grid[0][0] = 1;\n    for (int i = 1; i < m; ++i)\n        grid[i][0] = (grid[i][0] == 0 && grid[i - 1][0] == 1) ? 1 : 0;\n    for (int i = 1; i < n; ++i)\n        grid[0][i] = (grid[0][i] == 0 && grid[0][i - 1] == 1) ? 1 : 0;\n\n    for (int i = 1; i < m; ++i)\n        for (int j = 1; j < n; ++j)\n            if (grid[i][j] == 0)\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            else\n                grid[i][j] = 0;\n\n    return grid[m - 1][n - 1];\n}\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    ", "c++": "\n    ```cpp\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    if (grid[0][0] == 1) return 0;\n    \n    grid[0][0] = 1;\n    for (int i = 1; i < m; ++i)\n        grid[i][0] = (grid[i][0] == 0 && grid[i - 1][0] == 1) ? 1 : 0;\n    for (int i = 1; i < n; ++i)\n        grid[0][i] = (grid[0][i] == 0 && grid[0][i - 1] == 1) ? 1 : 0;\n\n    for (int i = 1; i < m; ++i)\n        for (int j = 1; j < n; ++j)\n            if (grid[i][j] == 0) \n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            else \n                grid[i][j] = 0;\n\n    return grid[m - 1][n - 1];\n}\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    ", "python": "\n    ```python\ndef uniquePathsWithObstacles(grid):\n    m, n = len(grid), len(grid[0])\n    if grid[0][0] == 1:\n        return 0\n\n    grid[0][0] = 1\n    for i in range(1, m):\n        grid[i][0] = 1 if grid[i][0] == 0 and grid[i - 1][0] == 1 else 0\n    for i in range(1, n):\n        grid[0][i] = 1 if grid[0][i] == 0 and grid[0][i - 1] == 1 else 0\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n            else:\n                grid[i][j] = 0\n\n    return grid[m - 1][n - 1]\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    ", "javascript": "\n    ```javascript\nfunction uniquePathsWithObstacles(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    if (grid[0][0] === 1) return 0;\n\n    grid[0][0] = 1;\n    for (let i = 1; i < m; ++i) {\n        grid[i][0] = (grid[i][0] === 0 && grid[i - 1][0] === 1) ? 1 : 0;\n    }\n    for (let i = 1; i < n; ++i) {\n        grid[0][i] = (grid[0][i] === 0 && grid[0][i - 1] === 1) ? 1 : 0;\n    }\n\n    for (let i = 1; i < m; ++i) {\n        for (let j = 1; j < n; ++j) {\n            if (grid[i][j] === 0) {\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            } else {\n                grid[i][j] = 0;\n            }\n        }\n    }\n\n    return grid[m - 1][n - 1];\n}\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    "}
{"id": 64, "slug": "minimum-path-sum", "title": "Minimum Path Sum", "difficulty": "Medium", "content": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\n**Note:** You can only move either down or right at any point in time.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`", "java": "\n    ```java\npublic int minPathSum(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n        \n    for(int i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(int i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(int i = 1; i < m; i++){\n        for(int j = 1; j < n; j++){\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n```\n    \n    The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner.\n    ", "c++": "\n    ```cpp\nint minPathSum(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n        \n    for(int i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(int i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(int i = 1; i < m; i++){\n        for(int j = 1; j < n; j++){\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n```\n    \n    The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner.\n    ", "python": "\n    ```python\ndef minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n\n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n    return grid[m - 1][n - 1]\n```\n    \n    The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner.\n    ", "javascript": "\n    ```javascript\nfunction minPathSum(grid) {\n    let m = grid.length, n = grid[0].length;\n        \n    for(let i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(let i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(let i = 1; i < m; i++){\n        for(let j = 1; j < n; j++){\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n```\n    \n    The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner.\n    "}
{"id": 70, "slug": "climbing-stairs", "title": "Climbing Stairs", "difficulty": "Easy", "content": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:** There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n**Constraints:**\n\n*   `1 <= n <= 45`", "java": "\n    ```java\npublic int climbStairs(int n) {\n    if(n <= 2) return n;\n    int a = 1, b = 2, c;\n    for(int i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ", "c++": "\n    ```cpp\nint climbStairs(int n) {\n    if(n <= 2) return n;\n    int a = 1, b = 2, c;\n    for(int i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ", "python": "\n    ```python\ndef climbStairs(n):\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n+1):\n        a, b = b, a + b\n    return b\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ", "javascript": "\n    ```javascript\nfunction climbStairs(n) {\n    if(n <= 2) return n;\n    let a = 1, b = 2, c;\n    for(let i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    "}
{"id": 72, "slug": "edit-distance", "title": "Edit Distance", "difficulty": "Hard", "content": "Given two strings `word1` and `word2`, return _the minimum number of operations required to convert `word1` to `word2`_.\n\nYou have the following three operations permitted on a word:\n\n*   Insert a character\n*   Delete a character\n*   Replace a character\n\n**Example 1:**\n\n**Input:** word1 =  \"horse \", word2 =  \"ros \"\n**Output:** 3\n**Explanation:** \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\n**Example 2:**\n\n**Input:** word1 =  \"intention \", word2 =  \"execution \"\n**Output:** 5\n**Explanation:** \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n\n**Constraints:**\n\n*   `0 <= word1.length, word2.length <= 500`\n*   `word1` and `word2` consist of lowercase English letters.", "java": "\n    ```java\npublic int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n```\n    \n    The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n].\n    ", "c++": "\n    ```cpp\nint minDistance(string word1, string word2) {\n    int m = word1.size();\n    int n = word2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] == word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n```\n    \n    The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n].\n    ", "python": "\n    ```python\ndef minDistance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n    \n    return dp[m][n]\n```\n    \n    The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n].\n    ", "javascript": "\n    ```javascript\nfunction minDistance(word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (let i = 0; i <= m; i++) {\n        for (let j = 0; j <= n; j++) {\n            if (i === 0) {\n                dp[i][j] = j;\n            } else if (j === 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n```\n    \n    The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n].\n    "}
{"id": 85, "slug": "maximal-rectangle", "title": "Maximal Rectangle", "difficulty": "Hard", "content": "Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return _its area_.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 6\n**Explanation:** The maximal rectangle is shown in the above picture.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[ \"1 \"\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `rows == matrix.length`\n*   `cols == matrix[i].length`\n*   `1 <= row, cols <= 200`\n*   `matrix[i][j]` is `'0'` or `'1'`.", "java": "\n    ```java\nimport java.util.Stack;\n\npublic int maximalRectangle(char[][] matrix) {\n    if (matrix.length == 0) return 0;\n\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int[] height = new int[n + 1];\n    int maxArea = 0;\n\n    for (int i = 0; i < m; ++i) {\n        Stack<Integer> s = new Stack<>();\n        for (int j = 0; j <= n; ++j) {\n            if (j < n) {\n                height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;\n            }\n            while (!s.empty() && height[j] < height[s.peek()]) {\n                int h = height[s.pop()];\n                int w = s.empty() ? j : j - s.peek() - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\nusing namespace std;\n\nint maximalRectangle(vector<vector<char>>& matrix) {\n    if (matrix.empty()) return 0;\n\n    int m = matrix.size();\n    int n = matrix[0].size();\n    vector<int> height(n + 1, 0);\n    int maxArea = 0;\n\n    for (int i = 0; i < m; ++i) {\n        stack<int> s;\n        for (int j = 0; j <= n; ++j) {\n            if (j < n) {\n                height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;\n            }\n            while (!s.empty() && height[j] < height[s.top()]) {\n                int h = height[s.top()];\n                s.pop();\n                int w = s.empty() ? j : j - s.top() - 1;\n                maxArea = max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    ", "python": "\n    ```python\ndef maximalRectangle(matrix):\n    if not matrix:\n        return 0\n\n    m = len(matrix)\n    n = len(matrix[0])\n    height = [0] * (n + 1)\n    max_area = 0\n\n    for i in range(m):\n        s = []\n        for j in range(n + 1):\n            if j < n:\n                height[j] = height[j] + 1 if matrix[i][j] == '1' else 0\n            while s and height[j] < height[s[-1]]:\n                h = height[s.pop()]\n                w = j if not s else j - s[-1] - 1\n                max_area = max(max_area, h * w)\n            s.append(j)\n\n    return max_area\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    ", "javascript": "\n    ```javascript\nfunction maximalRectangle(matrix) {\n    if (!matrix.length) return 0;\n\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let height = Array(n + 1).fill(0);\n    let maxArea = 0;\n\n    for (let i = 0; i < m; i++) {\n        let s = [];\n        for (let j = 0; j <= n; j++) {\n            if (j < n) {\n                height[j] = matrix[i][j] === '1' ? height[j] + 1 : 0;\n            }\n            while (s.length && height[j] < height[s[s.length - 1]]) {\n                let h = height[s.pop()];\n                let w = !s.length ? j : j - s[s.length - 1] - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    "}
{"id": 87, "slug": "scramble-string", "title": "Scramble String", "difficulty": "Hard", "content": "We can scramble a string s to get a string t using the following algorithm:\n\n1.  If the length of the string is 1, stop.\n2.  If the length of the string is > 1, do the following:\n    *   Split the string into two non-empty substrings at a random index, i.e., if the string is `s`, divide it to `x` and `y` where `s = x + y`.\n    *   **Randomly** decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`.\n    *   Apply step 1 recursively on each of the two substrings `x` and `y`.\n\nGiven two strings `s1` and `s2` of **the same length**, return `true` if `s2` is a scrambled string of `s1`, otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** s1 =  \"great \", s2 =  \"rgeat \"\n**Output:** true\n**Explanation:** One possible scenario applied on s1 is:\n \"great \" -->  \"gr/eat \" // divide at random index.\n \"gr/eat \" -->  \"gr/eat \" // random decision is not to swap the two substrings and keep them in order.\n \"gr/eat \" -->  \"g/r / e/at \" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n \"g/r / e/at \" -->  \"r/g / e/at \" // random decision was to swap the first substring and to keep the second substring in the same order.\n \"r/g / e/at \" -->  \"r/g / e/ a/t \" // again apply the algorithm recursively, divide  \"at \" to  \"a/t \".\n \"r/g / e/ a/t \" -->  \"r/g / e/ a/t \" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is  \"rgeat \" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n\n**Example 2:**\n\n**Input:** s1 =  \"abcde \", s2 =  \"caebd \"\n**Output:** false\n\n**Example 3:**\n\n**Input:** s1 =  \"a \", s2 =  \"a \"\n**Output:** true\n\n**Constraints:**\n\n*   `s1.length == s2.length`\n*   `1 <= s1.length <= 30`\n*   `s1` and `s2` consist of lowercase English letters.", "java": "\n    ```java\npublic boolean isScramble(String s1, String s2) {\n    if (s1.equals(s2)) return true;\n    if (sorted(s1).equals(sorted(s2)) == false) return false;\n\n    for (int i = 1; i < s1.length(); i++) {\n        if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i)))\n            return true;\n        if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) && isScramble(s1.substring(i), s2.substring(0, s2.length() - i)))\n            return true;\n    }\n    return false;\n}\n\nprivate String sorted(String s) {\n    char[] chars = s.toCharArray();\n    Arrays.sort(chars);\n    return new String(chars);\n}\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    ", "c++": "\n    ```cpp\nbool isScramble(string s1, string s2) {\n    if (s1 == s2) return true;\n    if (s1.size() != s2.size() || sort(s1.begin(), s1.end()) != sort(s2.begin(), s2.end())) return false;\n\n    for (int i = 1; i < s1.size(); i++) {\n        if (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\n            return true;\n        if (isScramble(s1.substr(0, i), s2.substr(s2.size() - i)) && isScramble(s1.substr(i), s2.substr(0, s2.size() - i)))\n            return true;\n    }\n    return false;\n}\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    ", "python": "\n    ```python\ndef isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2) or sorted(s1) != sorted(s2):\n        return False\n\n    for i in range(1, len(s1)):\n        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n           (isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i])):\n            return True\n    return False\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    ", "javascript": "\n    ```javascript\nfunction isScramble(s1, s2) {\n    if (s1 === s2) return true;\n    if (s1.length !== s2.length || sorted(s1) !== sorted(s2)) return false;\n\n    for (let i = 1; i < s1.length; i++) {\n        if ((isScramble(s1.slice(0, i), s2.slice(0, i)) && isScramble(s1.slice(i), s2.slice(i))) || \n            (isScramble(s1.slice(0, i), s2.slice(s2.length - i)) && isScramble(s1.slice(i), s2.slice(0, s2.length - i))))\n            return true;\n    }\n    return false;\n}\n\nfunction sorted(s) {\n    return s.split('').sort().join('');\n}\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    "}
{"id": 91, "slug": "decode-ways", "title": "Decode Ways", "difficulty": "Medium", "content": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\nGiven a string `s` containing only digits, return _the **number** of ways to **decode** it_.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.\n\n**Example 1:**\n\n**Input:** s =  \"12 \"\n**Output:** 2\n**Explanation:**  \"12 \" could be decoded as  \"AB \" (1 2) or  \"L \" (12).\n\n**Example 2:**\n\n**Input:** s =  \"226 \"\n**Output:** 3\n**Explanation:**  \"226 \" could be decoded as  \"BZ \" (2 26),  \"VF \" (22 6), or  \"BBF \" (2 2 6).\n\n**Example 3:**\n\n**Input:** s =  \"06 \"\n**Output:** 0\n**Explanation:**  \"06 \" cannot be mapped to  \"F \" because of the leading zero ( \"6 \" is different from  \"06 \").\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` contains only digits and may contain leading zero(s).", "java": "\n    ```java\npublic int numDecodings(String s) {\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = s.charAt(0) != '0' ? 1 : 0;\n\n    for (int i = 2; i <= n; i++) {\n        int oneDigit = Integer.parseInt(s.substring(i - 1, i));\n        int twoDigits = Integer.parseInt(s.substring(i - 2, i));\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n}\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint numDecodings(std::string s) {\n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = s[0] != '0' ? 1 : 0;\n\n    for (int i = 2; i <= n; ++i) {\n        int oneDigit = stoi(s.substr(i - 1, 1));\n        int twoDigits = stoi(s.substr(i - 2, 2));\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n}\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    ", "python": "\n    ```python\ndef numDecodings(s: str) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if s[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(s[i - 1:i])\n        two_digits = int(s[i - 2:i])\n\n        if one_digit >= 1:\n            dp[i] += dp[i - 1]\n        if two_digits >= 10 and two_digits <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    ", "javascript": "\n    ```javascript\nvar numDecodings = function(s) {\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = s[0] !== '0' ? 1 : 0;\n\n    for (let i = 2; i <= n; i++) {\n        const oneDigit = parseInt(s.slice(i - 1, i), 10);\n        const twoDigits = parseInt(s.slice(i - 2, i), 10);\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n};\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    "}
{"id": 95, "slug": "unique-binary-search-trees-ii", "title": "Unique Binary Search Trees II", "difficulty": "Medium", "content": "Given an integer `n`, return _all the structurally unique **BST'**s (binary search trees), which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`. Return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\\[1,null,2,null,3\\],\\[1,null,3,2\\],\\[2,1,3\\],\\[3,1,null,null,2\\],\\[3,2,null,1\\]\\]\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\\[1\\]\\]\n\n**Constraints:**\n\n*   `1 <= n <= 8`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    public List<TreeNode> generateTrees(int start, int end) {\n        List<TreeNode> trees = new ArrayList<>();\n        if (start > end) {\n            trees.add(null);\n            return trees;\n        }\n\n        for (int i = start; i <= end; i++) {\n            List<TreeNode> leftSubtrees = generateTrees(start, i - 1);\n            List<TreeNode> rightSubtrees = generateTrees(i + 1, end);\n\n            for (TreeNode left : leftSubtrees) {\n                for (TreeNode right : rightSubtrees) {\n                    TreeNode newNode = new TreeNode(i);\n                    newNode.left = left;\n                    newNode.right = right;\n                    trees.add(newNode);\n                }\n            }\n        }\n\n        return trees;\n    }\n\n    public List<TreeNode> generateTrees(int n) {\n        if (n == 0) {\n            return new ArrayList<TreeNode>();\n        }\n        return generateTrees(1, n);\n    }\n}\n```\n\n    \n    The algorithm is a recursive one. It starts by iterating from `start` to `end`. For every value `i`, it generates left and right subtrees by calling itself recursively with the modified start and end values,  i.e., `generateTrees(start, i - 1)` for the left subtree and `generateTrees(i + 1, end)` for the right subtree. It then creates new nodes with the value `i` and combinations of left and right subtrees, adding the newly created nodes to the `trees` list.\n\nFinally, the function returns the list of trees when the recursive calls end.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nstd::vector<TreeNode*> generateTrees(int start, int end) {\n    std::vector<TreeNode*> trees;\n    if (start > end) {\n        trees.push_back(nullptr);\n        return trees;\n    }\n\n    for (int i = start; i <= end; i++) {\n        std::vector<TreeNode*> leftSubtrees = generateTrees(start, i - 1);\n        std::vector<TreeNode*> rightSubtrees = generateTrees(i + 1, end);\n\n        for (TreeNode* left : leftSubtrees) {\n            for (TreeNode* right : rightSubtrees) {\n                TreeNode* newNode = new TreeNode(i);\n                newNode->left = left;\n                newNode->right = right;\n                trees.push_back(newNode);\n            }\n        }\n    }\n\n    return trees;\n}\n\nstd::vector<TreeNode*> generateTrees(int n) {\n    if (n == 0) {\n        return std::vector<TreeNode*>();\n    }\n    return generateTrees(1, n);\n}\n```\n\n    \n    The algorithm is a recursive one. It starts by iterating from `start` to `end`. For every value `i`, it generates left and right subtrees by calling itself recursively with the modified start and end values,  i.e., `generateTrees(start, i - 1)` for the left subtree and `generateTrees(i + 1, end)` for the right subtree. It then creates new nodes with the value `i` and combinations of left and right subtrees, adding the newly created nodes to the `trees` list.\n\nFinally, the function returns the list of trees when the recursive calls end.\n    ", "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef generate_trees(start, end):\n    trees = []\n    if start > end:\n        trees.append(None)\n        return trees\n\n    for i in range(start, end + 1):\n        left_subtrees = generate_trees(start, i - 1)\n        right_subtrees = generate_trees(i + 1, end)\n\n        for left in left_subtrees:\n            for right in right_subtrees:\n                new_node = TreeNode(i)\n                new_node.left = left\n                new_node.right = right\n                trees.append(new_node)\n\n    return trees\n\ndef generate_trees(n):\n    if n == 0:\n        return []\n    return generate_trees(1, n)\n```\n\n    \n    The algorithm is a recursive one. It starts by iterating from `start` to `end`. For every value `i`, it generates left and right subtrees by calling itself recursively with the modified start and end values,  i.e., `generateTrees(start, i - 1)` for the left subtree and `generateTrees(i + 1, end)` for the right subtree. It then creates new nodes with the value `i` and combinations of left and right subtrees, adding the newly created nodes to the `trees` list.\n\nFinally, the function returns the list of trees when the recursive calls end.\n    ", "javascript": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction generateTrees(start, end) {\n    const trees = [];\n    if (start > end) {\n        trees.push(null);\n        return trees;\n    }\n\n    for (let i = start; i <= end; i++) {\n        const leftSubtrees = generateTrees(start, i - 1);\n        const rightSubtrees = generateTrees(i + 1, end);\n\n        for (const left of leftSubtrees) {\n            for (const right of rightSubtrees) {\n                const newNode = new TreeNode(i);\n                newNode.left = left;\n                newNode.right = right;\n                trees.push(newNode);\n            }\n        }\n    }\n\n    return trees;\n}\n\nfunction generateTrees(n) {\n    if (n === 0) {\n        return [];\n    }\n    return generateTrees(1, n);\n}\n```\n\n    \n    The algorithm is a recursive one. It starts by iterating from `start` to `end`. For every value `i`, it generates left and right subtrees by calling itself recursively with the modified start and end values,  i.e., `generateTrees(start, i - 1)` for the left subtree and `generateTrees(i + 1, end)` for the right subtree. It then creates new nodes with the value `i` and combinations of left and right subtrees, adding the newly created nodes to the `trees` list.\n\nFinally, the function returns the list of trees when the recursive calls end.\n    "}
{"id": 96, "slug": "unique-binary-search-trees", "title": "Unique Binary Search Trees", "difficulty": "Medium", "content": "Given an integer `n`, return _the number of structurally unique **BST'**s (binary search trees) which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 5\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 19`", "java": "\n    ```java\npublic int numTrees(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes.\n    ", "c++": "\n    ```cpp\nint numTrees(int n) {\n    vector<int> dp(n + 1, 0);\n    dp[0] = dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes.\n    ", "python": "\n    ```python\ndef numTrees(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[n]\n```\n    \n    The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes.\n    ", "javascript": "\n    ```javascript\nfunction numTrees(n) {\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n    for (let i = 2; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes.\n    "}
{"id": 97, "slug": "interleaving-string", "title": "Interleaving String", "difficulty": "Medium", "content": "Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an **interleaving** of `s1` and `s2`.\n\nAn **interleaving** of two strings `s` and `t` is a configuration where `s` and `t` are divided into `n` and `m` substrings respectively, such that:\n\n*   `s = s1 + s2 + ... + sn`\n*   `t = t1 + t2 + ... + tm`\n*   `|n - m| <= 1`\n*   The **interleaving** is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`\n\n**Note:** `a + b` is the concatenation of strings `a` and `b`.\n\n**Example 1:**\n\n**Input:** s1 =  \"aabcc \", s2 =  \"dbbca \", s3 =  \"aadbbcbcac \"\n**Output:** true\n**Explanation:** One way to obtain s3 is:\nSplit s1 into s1 =  \"aa \" +  \"bc \" +  \"c \", and s2 into s2 =  \"dbbc \" +  \"a \".\nInterleaving the two splits, we get  \"aa \" +  \"dbbc \" +  \"bc \" +  \"a \" +  \"c \" =  \"aadbbcbcac \".\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\n**Example 2:**\n\n**Input:** s1 =  \"aabcc \", s2 =  \"dbbca \", s3 =  \"aadbbbaccc \"\n**Output:** false\n**Explanation:** Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\n**Example 3:**\n\n**Input:** s1 =  \" \", s2 =  \" \", s3 =  \" \"\n**Output:** true\n\n**Constraints:**\n\n*   `0 <= s1.length, s2.length <= 100`\n*   `0 <= s3.length <= 200`\n*   `s1`, `s2`, and `s3` consist of lowercase English letters.\n\n**Follow up:** Could you solve it using only `O(s2.length)` additional memory space?", "java": "\n    ```java\npublic boolean isInterleave(String s1, String s2, String s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) ||\n                       (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use a dynamic programming approach (2D DP) to solve this problem. The algorithm checks whether the s3[position] is equal to s1 or s2 in the same dp[position]. If so, we take the value of the previous dp[i-1] or dp[j-1] accordingly if the characters match. For the base case, we start with initializing dp[0][0] to true since two empty strings can form an empty s3.\n\nAt the end of the iterations, the last element in the dp matrix (i.e. dp[m][n]) will represent whether s3 can be formed by an interleaving of s1 and s2.\n    ", "c++": "\n    ```cpp\nbool isInterleave(string s1, string s2, string s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\n                       (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use a dynamic programming approach (2D DP) to solve this problem. The algorithm checks whether the s3[position] is equal to s1 or s2 in the same dp[position]. If so, we take the value of the previous dp[i-1] or dp[j-1] accordingly if the characters match. For the base case, we start with initializing dp[0][0] to true since two empty strings can form an empty s3.\n\nAt the end of the iterations, the last element in the dp matrix (i.e. dp[m][n]) will represent whether s3 can be formed by an interleaving of s1 and s2.\n    ", "python": "\n    ```python\ndef isInterleave(s1, s2, s3):\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\n                       (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n```\n    \n    We use a dynamic programming approach (2D DP) to solve this problem. The algorithm checks whether the s3[position] is equal to s1 or s2 in the same dp[position]. If so, we take the value of the previous dp[i-1] or dp[j-1] accordingly if the characters match. For the base case, we start with initializing dp[0][0] to true since two empty strings can form an empty s3.\n\nAt the end of the iterations, the last element in the dp matrix (i.e. dp[m][n]) will represent whether s3 can be formed by an interleaving of s1 and s2.\n    ", "javascript": "\n    ```javascript\nfunction isInterleave(s1, s2, s3) {\n    let m = s1.length, n = s2.length;\n    if (m + n !== s3.length) return false;\n\n    let dp = new Array(m + 1).fill(null).map(() => new Array(n + 1).fill(false));\n    dp[0][0] = true;\n    for (let i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] === s3[i - 1];\n    for (let j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] === s3[j - 1];\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) ||\n                       (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use a dynamic programming approach (2D DP) to solve this problem. The algorithm checks whether the s3[position] is equal to s1 or s2 in the same dp[position]. If so, we take the value of the previous dp[i-1] or dp[j-1] accordingly if the characters match. For the base case, we start with initializing dp[0][0] to true since two empty strings can form an empty s3.\n\nAt the end of the iterations, the last element in the dp matrix (i.e. dp[m][n]) will represent whether s3 can be formed by an interleaving of s1 and s2.\n    "}
{"id": 115, "slug": "distinct-subsequences", "title": "Distinct Subsequences", "difficulty": "Hard", "content": "Given two strings `s` and `t`, return _the number of distinct_ **_subsequences_** _of_ `s` _which equals_ `t`.\n\nThe test cases are generated so that the answer fits on a 32-bit signed integer.\n\n**Example 1:**\n\n**Input:** s =  \"rabbbit \", t =  \"rabbit \"\n**Output:** 3\n**Explanation:**\nAs shown below, there are 3 ways you can generate  \"rabbit \" from s.\n`**rabb**b**it**`\n`**ra**b**bbit**`\n`**rab**b**bit**`\n\n**Example 2:**\n\n**Input:** s =  \"babgbag \", t =  \"bag \"\n**Output:** 5\n**Explanation:**\nAs shown below, there are 5 ways you can generate  \"bag \" from s.\n`**ba**b**g**bag`\n`**ba**bgba**g**`\n`**b**abgb**ag**`\n`ba**b**gb**ag**`\n`babg**bag**`\n\n**Constraints:**\n\n*   `1 <= s.length, t.length <= 1000`\n*   `s` and `t` consist of English letters.", "java": "\n    ```java\npublic int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    ", "c++": "\n    ```cpp\nint numDistinct(string s, string t) {\n    int m = s.size(), n = t.size();\n    vector<vector<unsigned int>> dp(m + 1, vector<unsigned int>(n + 1, 0));\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    ", "python": "\n    ```python\ndef numDistinct(s: str, t: str) -> int:\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    ", "javascript": "\n    ```javascript\nfunction numDistinct(s, t) {\n    const m = s.length, n = t.length;\n    const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));\n\n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (s[i - 1] === t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    "}
{"id": 118, "slug": "pascals-triangle", "title": "Pascal's Triangle", "difficulty": "Easy", "content": "Given an integer `numRows`, return the first numRows of **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:\n\n**Example 1:**\n\n**Input:** numRows = 5\n**Output:** \\[\\[1\\],\\[1,1\\],\\[1,2,1\\],\\[1,3,3,1\\],\\[1,4,6,4,1\\]\\]\n\n**Example 2:**\n\n**Input:** numRows = 1\n**Output:** \\[\\[1\\]\\]\n\n**Constraints:**\n\n*   `1 <= numRows <= 30`", "java": "\n    ```java\npublic List<List<Integer>> generate(int numRows) {\n    List<List<Integer>> pascalsTriangle = new ArrayList<>();\n    for (int i = 0; i < numRows; i++) {\n        List<Integer> row = new ArrayList<>();\n        row.add(1);\n        for (int j = 1; j < i; j++) {\n            row.add(pascalsTriangle.get(i - 1).get(j - 1) + pascalsTriangle.get(i - 1).get(j));\n        }\n        if (i > 0) row.add(1);\n        pascalsTriangle.add(row);\n    }\n    return pascalsTriangle;\n}\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    ", "c++": "\n    ```cpp\nvector<vector<int>> generate(int numRows) {\n    vector<vector<int>> pascalsTriangle(numRows);\n    for (int i = 0; i < numRows; i++) {\n        pascalsTriangle[i].resize(i + 1);\n        pascalsTriangle[i][0] = pascalsTriangle[i][i] = 1;\n        for (int j = 1; j < i; j++) {\n            pascalsTriangle[i][j] = pascalsTriangle[i - 1][j - 1] + pascalsTriangle[i - 1][j];\n        }\n    }\n    return pascalsTriangle;\n}\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    ", "python": "\n    ```python\ndef generate(numRows):\n    pascalsTriangle = []\n    for i in range(numRows):\n        row = [1]\n        if i > 0:\n            for j in range(1, i):\n                row.append(pascalsTriangle[i-1][j-1] + pascalsTriangle[i-1][j])\n            row.append(1)\n        pascalsTriangle.append(row)\n    return pascalsTriangle\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    ", "javascript": "\n    ```javascript\nfunction generate(numRows) {\n    const pascalsTriangle = [];\n    for (let i = 0; i < numRows; i++) {\n        const row = [1];\n        for (let j = 1; j < i; j++) {\n            row.push(pascalsTriangle[i - 1][j - 1] + pascalsTriangle[i - 1][j]);\n        }\n        if (i > 0) row.push(1);\n        pascalsTriangle.push(row);\n    }\n    return pascalsTriangle;\n}\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    "}
{"id": 119, "slug": "pascals-triangle-ii", "title": "Pascal's Triangle II", "difficulty": "Easy", "content": "Given an integer `rowIndex`, return the `rowIndexth` (**0-indexed**) row of the **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:\n\n**Example 1:**\n\n**Input:** rowIndex = 3\n**Output:** \\[1,3,3,1\\]\n\n**Example 2:**\n\n**Input:** rowIndex = 0\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** rowIndex = 1\n**Output:** \\[1,1\\]\n\n**Constraints:**\n\n*   `0 <= rowIndex <= 33`\n\n**Follow up:** Could you optimize your algorithm to use only `O(rowIndex)` extra space?", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> getRow(int rowIndex) {\n    List<Integer> row = new ArrayList<>();\n    for (int i = 0; i <= rowIndex; i++) {\n        row.add(1);\n        for (int j = i - 1; j > 0; j--) {\n            row.set(j, row.get(j) + row.get(j - 1));\n        }\n    }\n    return row;\n}\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> getRow(int rowIndex) {\n    vector<int> row(rowIndex + 1, 1);\n    for (int i = 1; i <= rowIndex; i++) {\n        for (int j = i - 1; j > 0; j--) {\n            row[j] += row[j - 1];\n        }\n    }\n    return row;\n}\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    ", "python": "\n    ```python\ndef get_row(rowIndex):\n    row = [1] * (rowIndex + 1)\n    for i in range(1, rowIndex + 1):\n        for j in range(i - 1, 0, -1):\n            row[j] += row[j - 1]\n    return row\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    ", "javascript": "\n    ```javascript\nfunction getRow(rowIndex) {\n    const row = new Array(rowIndex + 1).fill(1);\n    for (let i = 1; i <= rowIndex; i++) {\n        for (let j = i - 1; j > 0; j--) {\n            row[j] += row[j - 1];\n        }\n    }\n    return row;\n}\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    "}
{"id": 120, "slug": "triangle", "title": "Triangle", "difficulty": "Medium", "content": "Given a `triangle` array, return _the minimum path sum from top to bottom_.\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.\n\n**Example 1:**\n\n**Input:** triangle = \\[\\[2\\],\\[3,4\\],\\[6,5,7\\],\\[4,1,8,3\\]\\]\n**Output:** 11\n**Explanation:** The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n\n**Example 2:**\n\n**Input:** triangle = \\[\\[-10\\]\\]\n**Output:** -10\n\n**Constraints:**\n\n*   `1 <= triangle.length <= 200`\n*   `triangle[0].length == 1`\n*   `triangle[i].length == triangle[i - 1].length + 1`\n*   `-104 <= triangle[i][j] <= 104`\n\n**Follow up:** Could you do this using only `O(n)` extra space, where `n` is the total number of rows in the triangle?", "java": "\n    ```java\npublic int minimumTotal(List<List<Integer>> triangle) {\n    for (int row = triangle.size() - 2; row >= 0; row--) {\n        for (int col = 0; col < triangle.get(row).size(); col++) {\n            int minSum = Math.min(triangle.get(row + 1).get(col), triangle.get(row + 1).get(col + 1));\n            triangle.get(row).set(col, triangle.get(row).get(col) + minSum);\n        }\n    }\n    return triangle.get(0).get(0);\n}\n```\n    \n    The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete.\n    ", "c++": "\n    ```cpp\nint minimumTotal(vector<vector<int>>& triangle) {\n    for (int row = triangle.size() - 2; row >= 0; row--) {\n        for (int col = 0; col < triangle[row].size(); col++) {\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1]);\n        }\n    }\n    return triangle[0][0];\n}\n```\n    \n    The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete.\n    ", "python": "\n    ```python\ndef minimumTotal(triangle):\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]\n```\n    \n    The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete.\n    ", "javascript": "\n    ```javascript\nfunction minimumTotal(triangle) {\n    for (let row = triangle.length - 2; row >= 0; row--) {\n        for (let col = 0; col < triangle[row].length; col++) {\n            triangle[row][col] += Math.min(triangle[row + 1][col], triangle[row + 1][col + 1]);\n        }\n    }\n    return triangle[0][0];\n}\n```\n    \n    The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete.\n    "}
{"id": 121, "slug": "best-time-to-buy-and-sell-stock", "title": "Best Time to Buy and Sell Stock", "difficulty": "Easy", "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\n\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n\n**Example 1:**\n\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n**Example 2:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n\n**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`", "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int minPrice = Integer.MAX_VALUE;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ", "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int minPrice = INT_MAX;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = min(minPrice, price);\n        maxProfit = max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ", "python": "\n    ```python\ndef maxProfit(prices):\n    minPrice = float('inf')\n    maxProfit = 0\n    for price in prices:\n        minPrice = min(minPrice, price)\n        maxProfit = max(maxProfit, price - minPrice)\n    return maxProfit\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ", "javascript": "\n    ```javascript\nfunction maxProfit(prices) {\n    let minPrice = Number.MAX_VALUE;\n    let maxProfit = 0;\n    for (const price of prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    "}
{"id": 122, "slug": "best-time-to-buy-and-sell-stock-ii", "title": "Best Time to Buy and Sell Stock II", "difficulty": "Medium", "content": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\n\nFind and return _the **maximum** profit you can achieve_.\n\n**Example 1:**\n\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n**Example 3:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n**Constraints:**\n\n*   `1 <= prices.length <= 3 * 104`\n*   `0 <= prices[i] <= 104`", "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int max_profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ", "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int max_profit = 0;\n    for (int i = 1; i < prices.size(); i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ", "python": "\n    ```python\ndef max_profit(prices):\n    max_profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            max_profit += prices[i] - prices[i - 1]\n    return max_profit\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ", "javascript": "\n    ```javascript\nfunction maxProfit(prices) {\n    let max_profit = 0;\n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    "}
{"id": 123, "slug": "best-time-to-buy-and-sell-stock-iii", "title": "Best Time to Buy and Sell Stock III", "difficulty": "Hard", "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete **at most two transactions**.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n**Example 1:**\n\n**Input:** prices = \\[3,3,5,0,0,3,1,4\\]\n**Output:** 6\n**Explanation:** Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n\n**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\n**Example 3:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transaction is done, i.e. max profit = 0.\n\n**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 105`", "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int buy1 = Integer.MAX_VALUE, buy2 = Integer.MAX_VALUE;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}\n```\n    \n    1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions.\n    ", "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int buy1 = INT_MAX, buy2 = INT_MAX;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = min(buy1, price);\n        profit1 = max(profit1, price - buy1);\n        buy2 = min(buy2, price - profit1);\n        profit2 = max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}\n```\n    \n    1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions.\n    ", "python": "\n    ```python\ndef maxProfit(prices):\n    buy1, buy2 = float(\"inf\"), float(\"inf\")\n    profit1, profit2 = 0, 0\n\n    for price in prices:\n        buy1 = min(buy1, price)\n        profit1 = max(profit1, price - buy1)\n        buy2 = min(buy2, price - profit1)\n        profit2 = max(profit2, price - buy2)\n\n    return profit2\n```\n    \n    1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions.\n    ", "javascript": "\n    ```javascript\nfunction maxProfit(prices) {\n    let buy1 = Infinity, buy2 = Infinity;\n    let profit1 = 0, profit2 = 0;\n\n    for (let price of prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n\n    return profit2;\n}\n```\n    \n    1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions.\n    "}
{"id": 124, "slug": "binary-tree-maximum-path-sum", "title": "Binary Tree Maximum Path Sum", "difficulty": "Hard", "content": "A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\nGiven the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n**Example 2:**\n\n**Input:** root = \\[-10,9,20,null,null,15,7\\]\n**Output:** 42\n**Explanation:** The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 3 * 104]`.\n*   `-1000 <= Node.val <= 1000`", "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic int maxPathSum(TreeNode root) {\n    int[] maxSum = new int[]{Integer.MIN_VALUE};\n    helper(root, maxSum);\n    return maxSum[0];\n}\n\nprivate int helper(TreeNode root, int[] maxSum) {\n    if (root == null) return 0;\n\n    int left = Math.max(0, helper(root.left, maxSum));\n    int right = Math.max(0, helper(root.right, maxSum));\n\n    maxSum[0] = Math.max(maxSum[0], left + right + root.val);\n\n    return Math.max(left, right) + root.val;\n}\n```\n    \n    The algorithm is based on Depth First Search (DFS) traversal of the binary tree.\n\n1. Create a helper function that takes the root and maximum path sum reference as the input parameters.\n2. If the current node (root) is null, return 0.\n3. Call the helper function recursively for the left and right child nodes:\n   - Set `left` as the maximum of 0 and the helper function call for the left child.\n   - Set `right` as the maximum of 0 and the helper function call for the right child.\n4. Update the maximum path sum using the current maximum, the sum of the current node's value, and the left and right children's values.\n5. Return the sum of the current node's value and the maximum of the left and right subtrees.\n\nCall the helper function with the given binary tree root and return the maximum path sum.\n    ", "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nint helper(TreeNode* root, int& maxSum) {\n    if(!root) return 0;\n\n    int left = max(0, helper(root->left, maxSum));\n    int right = max(0, helper(root->right, maxSum));\n\n    maxSum = max(maxSum, left + right + root->val);\n\n    return max(left, right) + root->val;\n}\n\nint maxPathSum(TreeNode* root) {\n    int maxSum = INT_MIN;\n    helper(root, maxSum);\n    return maxSum;\n}\n```\n    \n    The algorithm is based on Depth First Search (DFS) traversal of the binary tree.\n\n1. Create a helper function that takes the root and maximum path sum reference as the input parameters.\n2. If the current node (root) is null, return 0.\n3. Call the helper function recursively for the left and right child nodes:\n   - Set `left` as the maximum of 0 and the helper function call for the left child.\n   - Set `right` as the maximum of 0 and the helper function call for the right child.\n4. Update the maximum path sum using the current maximum, the sum of the current node's value, and the left and right children's values.\n5. Return the sum of the current node's value and the maximum of the left and right subtrees.\n\nCall the helper function with the given binary tree root and return the maximum path sum.\n    ", "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxPathSum(root: TreeNode) -> int:\n    def helper(root):\n        nonlocal maxSum\n        if not root:\n            return 0\n\n        left = max(0, helper(root.left))\n        right = max(0, helper(root.right))\n\n        maxSum = max(maxSum, left + right + root.val)\n\n        return max(left, right) + root.val\n\n    maxSum = float('-inf')\n    helper(root)\n    return maxSum\n```\n    \n    The algorithm is based on Depth First Search (DFS) traversal of the binary tree.\n\n1. Create a helper function that takes the root and maximum path sum reference as the input parameters.\n2. If the current node (root) is null, return 0.\n3. Call the helper function recursively for the left and right child nodes:\n   - Set `left` as the maximum of 0 and the helper function call for the left child.\n   - Set `right` as the maximum of 0 and the helper function call for the right child.\n4. Update the maximum path sum using the current maximum, the sum of the current node's value, and the left and right children's values.\n5. Return the sum of the current node's value and the maximum of the left and right subtrees.\n\nCall the helper function with the given binary tree root and return the maximum path sum.\n    ", "javascript": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction maxPathSum(root) {\n    let maxSum = Number.MIN_SAFE_INTEGER;\n    \n    function helper(node) {\n        if (node === null) return 0;\n        \n        const left = Math.max(0, helper(node.left));\n        const right = Math.max(0, helper(node.right));\n        \n        maxSum = Math.max(maxSum, left + right + node.val);\n        \n        return Math.max(left, right) + node.val;\n    }\n    \n    helper(root);\n    return maxSum;\n}\n```\n    \n    The algorithm is based on Depth First Search (DFS) traversal of the binary tree.\n\n1. Create a helper function that takes the root and maximum path sum reference as the input parameters.\n2. If the current node (root) is null, return 0.\n3. Call the helper function recursively for the left and right child nodes:\n   - Set `left` as the maximum of 0 and the helper function call for the left child.\n   - Set `right` as the maximum of 0 and the helper function call for the right child.\n4. Update the maximum path sum using the current maximum, the sum of the current node's value, and the left and right children's values.\n5. Return the sum of the current node's value and the maximum of the left and right subtrees.\n\nCall the helper function with the given binary tree root and return the maximum path sum.\n    "}
{"id": 131, "slug": "palindrome-partitioning", "title": "Palindrome Partitioning", "difficulty": "Medium", "content": "Given a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return _all possible palindrome partitioning of_ `s`.\n\n**Example 1:**\n\n**Input:** s = \"aab\"\n**Output:** \\[\\[\"a\",\"a\",\"b\"\\],\\[\"aa\",\"b\"\\]\\]\n\n**Example 2:**\n\n**Input:** s = \"a\"\n**Output:** \\[\\[\"a\"\\]\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 16`\n*   `s` contains only lowercase English letters.", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    private boolean isPalindrome(String s, int start, int end) {\n        while (start < end) {\n            if (s.charAt(start++) != s.charAt(end--)) return false;\n        }\n        return true;\n    }\n\n    private void dfs(String s, int start, List<List<String>> results, List<String> current) {\n        if (start == s.length()) {\n            results.add(new ArrayList<>(current));\n            return;\n        }\n        \n        for (int end = start; end < s.length(); end++) {\n            if (isPalindrome(s, start, end)) {\n                current.add(s.substring(start, end + 1));\n                dfs(s, end + 1, results, current);\n                current.remove(current.size() - 1);\n            }\n        }\n    }\n\n    public List<List<String>> partition(String s) {\n        List<List<String>> results = new ArrayList<>();\n        List<String> current = new ArrayList<>();\n        dfs(s, 0, results, current);\n        return results;\n    }\n}\n```\n    \n    The algorithm is based on depth-first search (DFS). It starts by iterating over substrings at each position and checks if the substring is a palindrome. If it is a palindrome, it adds the substring to the current list and does a depth-first search at the next position. When the search reaches the end of the string, it adds the current list to the results list. After searching at a given position, it backtracks to the previous position and continues to search for palindromes. The overall time complexity is O(N * 2^N) where N is the length of the string.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nbool isPalindrome(const std::string& s, int start, int end) {\n    while (start < end) {\n        if (s[start++] != s[end--]) return false;\n    }\n    return true;\n}\n\nvoid dfs(const std::string& s, int start, std::vector<std::vector<std::string>>& results, std::vector<std::string> current) {\n    if (start == s.length()) {\n        results.push_back(current);\n        return;\n    }\n    \n    for (int end = start; end < s.length(); ++end) {\n        if (isPalindrome(s, start, end)) {\n            current.push_back(s.substr(start, end - start + 1));\n            dfs(s, end + 1, results, current);\n            current.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> partition(std::string s) {\n    std::vector<std::vector<std::string>> results;\n    std::vector<std::string> current;\n    dfs(s, 0, results, current);\n    return results;\n}\n```\n    \n    The algorithm is based on depth-first search (DFS). It starts by iterating over substrings at each position and checks if the substring is a palindrome. If it is a palindrome, it adds the substring to the current list and does a depth-first search at the next position. When the search reaches the end of the string, it adds the current list to the results list. After searching at a given position, it backtracks to the previous position and continues to search for palindromes. The overall time complexity is O(N * 2^N) where N is the length of the string.\n    ", "python": "\n    ```python\ndef isPalindrome(s, start, end):\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\ndef dfs(s, start, results, current):\n    if start == len(s):\n        results.append(current[:])\n        return\n    \n    for end in range(start, len(s)):\n        if isPalindrome(s, start, end):\n            current.append(s[start:end+1])\n            dfs(s, end + 1, results, current)\n            current.pop()\n\ndef partition(s):\n    results = []\n    dfs(s, 0, results, [])\n    return results\n```\n    \n    The algorithm is based on depth-first search (DFS). It starts by iterating over substrings at each position and checks if the substring is a palindrome. If it is a palindrome, it adds the substring to the current list and does a depth-first search at the next position. When the search reaches the end of the string, it adds the current list to the results list. After searching at a given position, it backtracks to the previous position and continues to search for palindromes. The overall time complexity is O(N * 2^N) where N is the length of the string.\n    ", "javascript": "\n    ```javascript\nfunction isPalindrome(s, start, end) {\n    while (start < end) {\n        if (s[start++] !== s[end--]) return false;\n    }\n    return true;\n}\n\nfunction dfs(s, start, results, current) {\n    if (start === s.length) {\n        results.push([...current]);\n        return;\n    }\n    \n    for (let end = start; end < s.length; end++) {\n        if (isPalindrome(s, start, end)) {\n            current.push(s.slice(start, end + 1));\n            dfs(s, end + 1, results, current);\n            current.pop();\n        }\n    }\n}\n\nfunction partition(s) {\n    let results = [];\n    dfs(s, 0, results, []);\n    return results;\n}\n```\n    \n    The algorithm is based on depth-first search (DFS). It starts by iterating over substrings at each position and checks if the substring is a palindrome. If it is a palindrome, it adds the substring to the current list and does a depth-first search at the next position. When the search reaches the end of the string, it adds the current list to the results list. After searching at a given position, it backtracks to the previous position and continues to search for palindromes. The overall time complexity is O(N * 2^N) where N is the length of the string.\n    "}
{"id": 132, "slug": "palindrome-partitioning-ii", "title": "Palindrome Partitioning II", "difficulty": "Hard", "content": "Given a string `s`, partition `s` such that every substring of the partition is a palindrome.\n\nReturn _the **minimum** cuts needed for a palindrome partitioning of_ `s`.\n\n**Example 1:**\n\n**Input:** s =  \"aab \"\n**Output:** 1\n**Explanation:** The palindrome partitioning \\[ \"aa \", \"b \"\\] could be produced using 1 cut.\n\n**Example 2:**\n\n**Input:** s =  \"a \"\n**Output:** 0\n\n**Example 3:**\n\n**Input:** s =  \"ab \"\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase English letters only.", "java": "\n    ```java\npublic int minCut(String s) {\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    boolean[][] isPalindrome = new boolean[n][n];\n    \n    for (int i=0; i <= n; i++) {\n        dp[i] = i - 1;\n    }\n    \n    for (int j=1; j < n; j++) {\n        for (int i=j; i >= 0; i--) {\n            if (s.charAt(i) == s.charAt(j) && (j - i < 2 || isPalindrome[i + 1][j - 1])) {\n                isPalindrome[i][j] = true;\n                dp[j + 1] = Math.min(dp[j + 1], dp[i] + 1);\n            }\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    The solution uses dynamic programming with an array `dp` of length `n+1` representing  the minimum cuts. `is_palindrome` is a 2D matrix that stores whether the substring from `i` to `j` of string `s` is palindromic or not.\n\nWe first initialize the `dp` array with values (i-1) for each index 'i'. This represents the maximum possible cuts needed to satisfy the condition.\n\nThen, we iterate over the string in a nested loop. For each substring `s[i:j]`, we check if it is a palindrome. If it is a palindrome, we'll update the `dp` array with the minimum value between the current value of the `dp` array and the value of the `dp` array at `[i]` plus 1. By doing this, we are considering all possible cuts for a palindromic partition of string `s`.\n\nFinally, we return the last element in the `dp` array, representing the minimum cuts needed for a palindrome partitioning of string `s`.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint minCut(std::string s) {\n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    std::vector<std::vector<bool>> isPalindrome(n, std::vector<bool>(n, false));\n    \n    for (int i = 0; i <= n; i++) {\n        dp[i] = i - 1;\n    }\n    \n    for (int j = 1; j < n; j++) {\n        for (int i = j; i >= 0; i--) {\n            if (s[i] == s[j] && (j - i < 2 || isPalindrome[i + 1][j - 1])) {\n                isPalindrome[i][j] = true;\n                dp[j + 1] = std::min(dp[j + 1], dp[i] + 1);\n            }\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    The solution uses dynamic programming with an array `dp` of length `n+1` representing  the minimum cuts. `is_palindrome` is a 2D matrix that stores whether the substring from `i` to `j` of string `s` is palindromic or not.\n\nWe first initialize the `dp` array with values (i-1) for each index 'i'. This represents the maximum possible cuts needed to satisfy the condition.\n\nThen, we iterate over the string in a nested loop. For each substring `s[i:j]`, we check if it is a palindrome. If it is a palindrome, we'll update the `dp` array with the minimum value between the current value of the `dp` array and the value of the `dp` array at `[i]` plus 1. By doing this, we are considering all possible cuts for a palindromic partition of string `s`.\n\nFinally, we return the last element in the `dp` array, representing the minimum cuts needed for a palindrome partitioning of string `s`.\n    ", "python": "\n    ```python\ndef minCut(s):\n    n = len(s)\n    dp = [i - 1 for i in range(n + 1)]\n    is_palindrome = [[False] * n for _ in range(n)]\n    \n    for j in range(1, n):\n        for i in range(j, -1, -1):\n            if s[i] == s[j] and (j - i < 2 or is_palindrome[i + 1][j - 1]):\n                is_palindrome[i][j] = True\n                dp[j + 1] = min(dp[j + 1], dp[i] + 1)\n                \n    return dp[n]\n```\n    \n    The solution uses dynamic programming with an array `dp` of length `n+1` representing  the minimum cuts. `is_palindrome` is a 2D matrix that stores whether the substring from `i` to `j` of string `s` is palindromic or not.\n\nWe first initialize the `dp` array with values (i-1) for each index 'i'. This represents the maximum possible cuts needed to satisfy the condition.\n\nThen, we iterate over the string in a nested loop. For each substring `s[i:j]`, we check if it is a palindrome. If it is a palindrome, we'll update the `dp` array with the minimum value between the current value of the `dp` array and the value of the `dp` array at `[i]` plus 1. By doing this, we are considering all possible cuts for a palindromic partition of string `s`.\n\nFinally, we return the last element in the `dp` array, representing the minimum cuts needed for a palindrome partitioning of string `s`.\n    ", "javascript": "\n    ```javascript\nfunction minCut(s) {\n    const n = s.length;\n    const dp = Array.from({ length: n + 1 }, (_, i) => i - 1);\n    const isPalindrome = Array.from({ length: n }, () => Array(n).fill(false));\n    \n    for (let j = 1; j < n; j++) {\n        for (let i = j; i >= 0; i--) {\n            if (s[i] === s[j] && (j - i < 2 || isPalindrome[i + 1][j - 1])) {\n                isPalindrome[i][j] = true;\n                dp[j + 1] = Math.min(dp[j + 1], dp[i] + 1);\n            }\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    The solution uses dynamic programming with an array `dp` of length `n+1` representing  the minimum cuts. `is_palindrome` is a 2D matrix that stores whether the substring from `i` to `j` of string `s` is palindromic or not.\n\nWe first initialize the `dp` array with values (i-1) for each index 'i'. This represents the maximum possible cuts needed to satisfy the condition.\n\nThen, we iterate over the string in a nested loop. For each substring `s[i:j]`, we check if it is a palindrome. If it is a palindrome, we'll update the `dp` array with the minimum value between the current value of the `dp` array and the value of the `dp` array at `[i]` plus 1. By doing this, we are considering all possible cuts for a palindromic partition of string `s`.\n\nFinally, we return the last element in the `dp` array, representing the minimum cuts needed for a palindrome partitioning of string `s`.\n    "}
{"id": 139, "slug": "word-break", "title": "Word Break", "difficulty": "Medium", "content": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n\n**Example 1:**\n\n**Input:** s =  \"leetcode \", wordDict = \\[ \"leet \", \"code \"\\]\n**Output:** true\n**Explanation:** Return true because  \"leetcode \" can be segmented as  \"leet code \".\n\n**Example 2:**\n\n**Input:** s =  \"applepenapple \", wordDict = \\[ \"apple \", \"pen \"\\]\n**Output:** true\n**Explanation:** Return true because  \"applepenapple \" can be segmented as  \"apple pen apple \".\nNote that you are allowed to reuse a dictionary word.\n\n**Example 3:**\n\n**Input:** s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= s.length <= 300`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 20`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.", "java": "\n    ```java\nimport java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic boolean wordBreak(String s, List<String> wordDict) {\n    Set<String> dict = new HashSet<>(wordDict);\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true;\n    for (int i = 1; i <= s.length(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (dp[j] && dict.contains(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.length()];\n}\n```\n\n    \n    The algorithm uses dynamic programming to solve the problem. The dp array is created with the size of the input string s plus 1. dp[i] is true if there exists a segmentation of the first i characters of the string s into words from the dictionary. The algorithm initializes dp[0] as true since an empty string can be segmented.\n\nFor each character in the input string s, the algorithm checks all substrings ending at this character. If the substring s[j:i] is in the dictionary (or wordDict for Java and C++) and dp[j] is true, set dp[i] to true and break from the inner loop.\n\nAt the end of the algorithm, dp[s.size()] (or dp[s.length()] for Java and JavaScript, or dp[len(s)] in Python) contains the result for the entire input string s. If this value is true, the input string can be segmented into a sequence of one or more dictionary words, otherwise it cannot.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\n\nbool wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());\n    std::vector<bool> dp(s.size() + 1, false);\n    dp[0] = true;\n    for (size_t i = 1; i <= s.size(); ++i) {\n        for (size_t j = 0; j < i; ++j) {\n            if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.size()];\n}\n```\n\n    \n    The algorithm uses dynamic programming to solve the problem. The dp array is created with the size of the input string s plus 1. dp[i] is true if there exists a segmentation of the first i characters of the string s into words from the dictionary. The algorithm initializes dp[0] as true since an empty string can be segmented.\n\nFor each character in the input string s, the algorithm checks all substrings ending at this character. If the substring s[j:i] is in the dictionary (or wordDict for Java and C++) and dp[j] is true, set dp[i] to true and break from the inner loop.\n\nAt the end of the algorithm, dp[s.size()] (or dp[s.length()] for Java and JavaScript, or dp[len(s)] in Python) contains the result for the entire input string s. If this value is true, the input string can be segmented into a sequence of one or more dictionary words, otherwise it cannot.\n    ", "python": "\n    ```python\ndef word_break(s, word_dict):\n    word_set = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(s)]\n```\n\n    \n    The algorithm uses dynamic programming to solve the problem. The dp array is created with the size of the input string s plus 1. dp[i] is true if there exists a segmentation of the first i characters of the string s into words from the dictionary. The algorithm initializes dp[0] as true since an empty string can be segmented.\n\nFor each character in the input string s, the algorithm checks all substrings ending at this character. If the substring s[j:i] is in the dictionary (or wordDict for Java and C++) and dp[j] is true, set dp[i] to true and break from the inner loop.\n\nAt the end of the algorithm, dp[s.size()] (or dp[s.length()] for Java and JavaScript, or dp[len(s)] in Python) contains the result for the entire input string s. If this value is true, the input string can be segmented into a sequence of one or more dictionary words, otherwise it cannot.\n    ", "javascript": "\n    ```javascript\nfunction wordBreak(s, wordDict) {\n    const dict = new Set(wordDict);\n    const dp = Array(s.length + 1).fill(false);\n    dp[0] = true;\n    for (let i = 1; i <= s.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (dp[j] && dict.has(s.slice(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.length];\n}\n```\n\n    \n    The algorithm uses dynamic programming to solve the problem. The dp array is created with the size of the input string s plus 1. dp[i] is true if there exists a segmentation of the first i characters of the string s into words from the dictionary. The algorithm initializes dp[0] as true since an empty string can be segmented.\n\nFor each character in the input string s, the algorithm checks all substrings ending at this character. If the substring s[j:i] is in the dictionary (or wordDict for Java and C++) and dp[j] is true, set dp[i] to true and break from the inner loop.\n\nAt the end of the algorithm, dp[s.size()] (or dp[s.length()] for Java and JavaScript, or dp[len(s)] in Python) contains the result for the entire input string s. If this value is true, the input string can be segmented into a sequence of one or more dictionary words, otherwise it cannot.\n    "}
{"id": 140, "slug": "word-break-ii", "title": "Word Break II", "difficulty": "Hard", "content": "Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in **any order**.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n\n**Example 1:**\n\n**Input:** s =  \"catsanddog \", wordDict = \\[ \"cat \", \"cats \", \"and \", \"sand \", \"dog \"\\]\n**Output:** \\[ \"cats and dog \", \"cat sand dog \"\\]\n\n**Example 2:**\n\n**Input:** s =  \"pineapplepenapple \", wordDict = \\[ \"apple \", \"pen \", \"applepen \", \"pine \", \"pineapple \"\\]\n**Output:** \\[ \"pine apple pen apple \", \"pineapple pen apple \", \"pine applepen apple \"\\]\n**Explanation:** Note that you are allowed to reuse a dictionary word.\n\n**Example 3:**\n\n**Input:** s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 10`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.\n*   Input is generated in a way that the length of the answer doesn't exceed 105.", "java": "\n    ```java\nimport java.util.*;\n\npublic List<String> wordBreak(String s, List<String> wordDict) {\n    HashSet<String> dict = new HashSet<>(wordDict);\n    HashMap<String, List<String>> memo = new HashMap<>();\n    return helper(s, dict, memo);\n}\n\nprivate List<String> helper(String s, HashSet<String> dict, HashMap<String, List<String>> memo) {\n    if (memo.containsKey(s)) {\n        return memo.get(s);\n    }\n    \n    List<String> res = new ArrayList<>();\n    if (dict.contains(s)) {\n        res.add(s);\n    }\n    \n    for (int i = 1; i < s.length(); ++i) {\n        String prefix = s.substring(0, i);\n        if (!dict.contains(prefix)) continue;\n        String suffix = s.substring(i);\n        List<String> temp = helper(suffix, dict, memo);\n        for (String t : temp) {\n            res.add(prefix + \" \" + t);\n        }\n    }\n\n    memo.put(s, res);\n    return res;\n}\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\n\nstd::vector<std::string> helper(const std::string& s, const std::unordered_set<std::string>& dict, std::unordered_map<std::string, std::vector<std::string>>& memo) {\n    if (memo.count(s)) return memo[s];\n\n    std::vector<std::string> res;\n    if (dict.count(s)) res.push_back(s);\n\n    for (int i = 1; i < s.size(); ++i) {\n        std::string prefix = s.substr(0, i);\n        if (!dict.count(prefix)) continue;\n        std::string suffix = s.substr(i);\n        auto temp = helper(suffix, dict, memo);\n        for (const auto& t : temp) {\n            res.push_back(prefix + \" \" + t);\n        }\n    }\n    memo[s] = res;\n    return res;\n}\n\nstd::vector<std::string> wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());\n    std::unordered_map<std::string, std::vector<std::string>> memo;\n    return helper(s, dict, memo);\n}\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    ", "python": "\n    ```python\ndef word_break(s, word_dict):\n    def helper(s, dict, memo):\n        if s in memo:\n            return memo[s]\n\n        res = []\n        if s in dict:\n            res.append(s)\n\n        for i in range(1, len(s)):\n            prefix = s[:i]\n            if prefix not in dict:\n                continue\n            suffix = s[i:]\n            temp = helper(suffix, dict, memo)\n            for t in temp:\n                res.append(prefix + \" \" + t)\n\n        memo[s] = res\n        return res\n\n    word_set = set(word_dict)\n    memo = {}\n    return helper(s, word_set, memo)\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    ", "javascript": "\n    ```javascript\nfunction wordBreak(s, wordDict) {\n    const dict = new Set(wordDict);\n    const memo = {};\n\n    function helper(s, dict, memo) {\n        if (s in memo) {\n            return memo[s];\n        }\n        \n        const res = [];\n        if (dict.has(s)) {\n            res.push(s);\n        }\n        \n        for (let i = 1; i < s.length; ++i) {\n            const prefix = s.slice(0, i);\n            if (!dict.has(prefix)) continue;\n            const suffix = s.slice(i);\n            const temp = helper(suffix, dict, memo);\n            for (const t of temp) {\n                res.push(prefix + \" \" + t);\n            }\n        }\n\n        memo[s] = res;\n        return res;\n    }\n\n    return helper(s, dict, memo);\n}\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    "}
{"id": 152, "slug": "maximum-product-subarray", "title": "Maximum Product Subarray", "difficulty": "Medium", "content": "Given an integer array `nums`, find a subarray that has the largest product, and return _the product_.\n\nThe test cases are generated so that the answer will fit in a **32-bit** integer.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,-2,4\\]\n**Output:** 6\n**Explanation:** \\[2,3\\] has the largest product 6.\n\n**Example 2:**\n\n**Input:** nums = \\[-2,0,-1\\]\n**Output:** 0\n**Explanation:** The result cannot be 2, because \\[-2,-1\\] is not a subarray.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `-10 <= nums[i] <= 10`\n*   The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.", "java": "\n    ```java\npublic int maxProduct(int[] nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            int temp = max_so_far;\n            max_so_far = min_so_far;\n            min_so_far = temp;\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    ", "c++": "\n    ```cpp\nint maxProduct(vector<int>& nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] < 0)\n            swap(max_so_far, min_so_far);\n        \n        max_so_far = max(nums[i], max_so_far * nums[i]);\n        min_so_far = min(nums[i], min_so_far * nums[i]);\n        result = max(result, max_so_far);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    ", "python": "\n    ```python\ndef maxProduct(nums):\n    max_so_far = min_so_far = result = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n        \n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        result = max(result, max_so_far)\n    \n    return result\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    ", "javascript": "\n    ```javascript\nfunction maxProduct(nums) {\n    let max_so_far = nums[0];\n    let min_so_far = nums[0];\n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            [max_so_far, min_so_far] = [min_so_far, max_so_far];\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    "}
{"id": 174, "slug": "dungeon-game", "title": "Dungeon Game", "difficulty": "Hard", "content": "The demons had captured the princess and imprisoned her in **the bottom-right corner** of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in **the top-left room** and must fight his way through `dungeon` to rescue the princess.\n\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.\n\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n\nTo reach the princess as quickly as possible, the knight decides to move only **rightward** or **downward** in each step.\n\nReturn _the knight's minimum initial health so that he can rescue the princess_.\n\n**Note** that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n\n**Example 1:**\n\n**Input:** dungeon = \\[\\[-2,-3,3\\],\\[-5,-10,1\\],\\[10,30,-5\\]\\]\n**Output:** 7\n**Explanation:** The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n\n**Example 2:**\n\n**Input:** dungeon = \\[\\[0\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == dungeon.length`\n*   `n == dungeon[i].length`\n*   `1 <= m, n <= 200`\n*   `-1000 <= dungeon[i][j] <= 1000`", "java": "\n    ```java\npublic int calculateMinimumHP(int[][] dungeon) {\n    int m = dungeon.length, n = dungeon[0].length;\n    int[][] dp = new int[m][n];\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i == m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j == n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    ", "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\n    int m = dungeon.size(), n = dungeon[0].size();\n    vector<vector<int>> dp(m, vector<int>(n));\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1){\n                dp[i][j] = min(0, dungeon[i][j]);\n            }\n            else if (i == m - 1) {\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j]);\n            }\n            else if (j == n - 1) {\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j]);\n            }\n            else {\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n            }\n        }\n    }\n\n    return abs(dp[0][0]) + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    ", "python": "\n    ```python\ndef calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = min(0, dungeon[i][j])\n            elif i == m - 1:\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j])\n            elif j == n - 1:\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j])\n            else:\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j])\n\n    return abs(dp[0][0]) + 1\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    ", "javascript": "\n    ```javascript\nfunction calculateMinimumHP(dungeon) {\n    const m = dungeon.length, n = dungeon[0].length;\n    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\n\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            if (i === m - 1 && j === n - 1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i === m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j === n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    "}
{"id": 188, "slug": "best-time-to-buy-and-sell-stock-iv", "title": "Best Time to Buy and Sell Stock IV", "difficulty": "Hard", "content": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`.\n\nFind the maximum profit you can achieve. You may complete at most `k` transactions: i.e. you may buy at most `k` times and sell at most `k` times.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n**Example 1:**\n\n**Input:** k = 2, prices = \\[2,4,1\\]\n**Output:** 2\n**Explanation:** Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\n**Example 2:**\n\n**Input:** k = 2, prices = \\[3,2,6,5,0,3\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n\n**Constraints:**\n\n*   `1 <= k <= 100`\n*   `1 <= prices.length <= 1000`\n*   `0 <= prices[i] <= 1000`", "java": "\n    ```java\npublic int maxProfit(int k, int[] prices) {\n    int n = prices.length;\n    if (k > n / 2) {\n        int maxProfit = 0;\n        for (int i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    int[][] dp = new int[k + 1][n];\n    for (int i = 1; i <= k; ++i) {\n        int maxDiff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nint maxProfit(int k, std::vector<int>& prices) {\n    int n = prices.size();\n    if (k > n / 2) {\n        int max_profit = 0;\n        for (int i = 1; i < n; ++i)\n            max_profit += std::max(prices[i] - prices[i - 1], 0);\n        return max_profit;  \n    }\n\n    std::vector<std::vector<int>> dp(k + 1, std::vector<int>(n, 0));\n    for (int i = 1; i <= k; ++i) {\n        int max_diff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = std::max(dp[i][j - 1], prices[j] + max_diff);\n            max_diff = std::max(max_diff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    ", "python": "\n    ```python\ndef maxProfit(k, prices):\n    n = len(prices)\n    if k > n // 2:\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    return dp[k][n - 1]\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    ", "javascript": "\n    ```javascript\nfunction maxProfit(k, prices) {\n    let n = prices.length;\n    if (k > n / 2) {\n        let maxProfit = 0;\n        for (let i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    let dp = new Array(k + 1).fill(null).map(() => new Array(n).fill(0));\n    for (let i = 1; i <= k; ++i) {\n        let maxDiff = -prices[0];\n        for (let j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    "}
{"id": 198, "slug": "house-robber", "title": "House Robber", "difficulty": "Medium", "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n**Example 2:**\n\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`", "java": "\n    ```java\npublic int rob(int[] nums) {\n    int prev1 = 0, prev2 = 0;\n    for (int num : nums) {\n        int temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}\n```\n    \n    We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return.\n    ", "c++": "\n    ```cpp\nint rob(vector<int>& nums) {\n    int prev1 = 0, prev2 = 0;\n    for (const auto& num : nums) {\n        int tmp = prev1;\n        prev1 = max(prev2 + num, prev1);\n        prev2 = tmp;\n    }\n    return prev1;\n}\n```\n    \n    We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return.\n    ", "python": "\n    ```python\ndef rob(nums):\n    prev1, prev2 = 0, 0\n    for num in nums:\n        prev1, prev2 = max(prev2 + num, prev1), prev1\n    return prev1\n```\n    \n    We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return.\n    ", "javascript": "\n    ```javascript\nfunction rob(nums) {\n    let prev1 = 0, prev2 = 0;\n    for (let num of nums) {\n        let temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}\n```\n    \n    We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return.\n    "}
{"id": 213, "slug": "house-robber-ii", "title": "House Robber II", "difficulty": "Medium", "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`", "java": "\n    ```java\npublic int rob(int[] nums) {\n    if (nums.length == 1) return nums[0];\n    int prev = 0, curr = 0;\n    for (int i = 0; i < nums.length - 1; i++) {\n        int temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    int res = curr;\n    prev = 0;\n    curr = 0;\n    for (int i = 1; i < nums.length; i++) {\n        int temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    return Math.max(res, curr);\n}\n```\n    \n    The main idea here is to divide the problem into two subproblems: rob houses from the first to the second last, and rob houses from the second to the last. First, initialize two variables prev and curr to store the maximum amount obtained till the current house. Then, loop through the houses from the first to the second last, and at each step, update the maximum amount till the current house by choosing between two options: rob the current house (prev + nums[i]) or skip it (curr). Repeat the process for houses from the second to the last. Finally, return the maximum amount among both subproblems.\n    ", "c++": "\n    ```cpp\nint rob(vector<int>& nums) {\n    if (nums.size() == 1) return nums[0];\n    int prev = 0, curr = 0;\n    for (int i = 0; i < nums.size() - 1; i++) {\n        int temp = max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    int res = curr;\n    prev = 0;\n    curr = 0;\n    for (int i = 1; i < nums.size(); i++) {\n        int temp = max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    return max(res, curr);\n}\n```\n    \n    The main idea here is to divide the problem into two subproblems: rob houses from the first to the second last, and rob houses from the second to the last. First, initialize two variables prev and curr to store the maximum amount obtained till the current house. Then, loop through the houses from the first to the second last, and at each step, update the maximum amount till the current house by choosing between two options: rob the current house (prev + nums[i]) or skip it (curr). Repeat the process for houses from the second to the last. Finally, return the maximum amount among both subproblems.\n    ", "python": "\n    ```python\ndef rob(nums):\n    if len(nums) == 1:\n        return nums[0]\n    prev, curr = 0, 0\n    for i in range(len(nums) - 1):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    res = curr\n    prev, curr = 0, 0\n    for i in range(1, len(nums)):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    return max(res, curr)\n```\n    \n    The main idea here is to divide the problem into two subproblems: rob houses from the first to the second last, and rob houses from the second to the last. First, initialize two variables prev and curr to store the maximum amount obtained till the current house. Then, loop through the houses from the first to the second last, and at each step, update the maximum amount till the current house by choosing between two options: rob the current house (prev + nums[i]) or skip it (curr). Repeat the process for houses from the second to the last. Finally, return the maximum amount among both subproblems.\n    ", "javascript": "\n    ```javascript\nfunction rob(nums) {\n    if (nums.length === 1) return nums[0];\n    let prev = 0, curr = 0;\n    for (let i = 0; i < nums.length - 1; i++) {\n        let temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    let res = curr;\n    prev = 0;\n    curr = 0;\n    for (let i = 1; i < nums.length; i++) {\n        let temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    return Math.max(res, curr);\n}\n```\n    \n    The main idea here is to divide the problem into two subproblems: rob houses from the first to the second last, and rob houses from the second to the last. First, initialize two variables prev and curr to store the maximum amount obtained till the current house. Then, loop through the houses from the first to the second last, and at each step, update the maximum amount till the current house by choosing between two options: rob the current house (prev + nums[i]) or skip it (curr). Repeat the process for houses from the second to the last. Finally, return the maximum amount among both subproblems.\n    "}
{"id": 221, "slug": "maximal-square", "title": "Maximal Square", "difficulty": "Medium", "content": "Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, _find the largest square containing only_ `1`'s _and return its area_.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 4\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \", \"1 \"\\],\\[ \"1 \", \"0 \"\\]\\]\n**Output:** 1\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 300`\n*   `matrix[i][j]` is `'0'` or `'1'`.", "java": "\n    ```java\npublic int maximalSquare(char[][] matrix) {\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int[][] dp = new int[m + 1][n + 1];\n    int maxSize = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n                maxSize = Math.max(maxSize, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSize * maxSize;\n}\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    ", "c++": "\n    ```cpp\nint maximalSquare(vector<vector<char>>& matrix) {\n    int m = matrix.size();\n    int n = matrix[0].size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    int maxSize = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;\n                maxSize = max(maxSize, dp[i][j]);\n            }\n        }\n    }\n    \n    return maxSize * maxSize;\n}\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    ", "python": "\n    ```python\ndef maximalSquare(matrix):\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxSize = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                maxSize = max(maxSize, dp[i][j])\n\n    return maxSize * maxSize\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    ", "javascript": "\n    ```javascript\nfunction maximalSquare(matrix) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    let maxSize = 0;\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] === '1') {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n                maxSize = Math.max(maxSize, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSize * maxSize;\n}\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    "}
{"id": 233, "slug": "number-of-digit-one", "title": "Number of Digit One", "difficulty": "Hard", "content": "Given an integer `n`, count _the total number of digit_ `1` _appearing in all non-negative integers less than or equal to_ `n`.\n\n**Example 1:**\n\n**Input:** n = 13\n**Output:** 6\n\n**Example 2:**\n\n**Input:** n = 0\n**Output:** 0\n\n**Constraints:**\n\n*   `0 <= n <= 109`", "java": "\n    ```java\npublic int countDigitOne(int n) {\n    int count = 0;\n    for(long i = 1; i <= n; i *= 10){\n        long divider = i * 10;\n        count += (n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ", "c++": "\n    ```cpp\nint countDigitOne(int n) {\n    int count = 0;\n    for(long long i = 1; i <= n; i *= 10){\n        int divider = i * 10;\n        count += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\n    }\n    return count;\n}\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ", "python": "\n    ```python\ndef countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        divider = i * 10\n        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n        i *= 10\n    return count\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ", "javascript": "\n    ```javascript\nfunction countDigitOne(n) {\n    let count = 0;\n    for(let i = 1; i <= n; i *= 10){\n        let divider = i * 10;\n        count += Math.floor(n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    "}
{"id": 241, "slug": "different-ways-to-add-parentheses", "title": "Different Ways to Add Parentheses", "difficulty": "Medium", "content": "Given a string `expression` of numbers and operators, return _all possible results from computing all the different possible ways to group numbers and operators_. You may return the answer in **any order**.\n\nThe test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed `104`.\n\n**Example 1:**\n\n**Input:** expression =  \"2-1-1 \"\n**Output:** \\[0,2\\]\n**Explanation:**\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n\n**Example 2:**\n\n**Input:** expression =  \"2\\*3-4\\*5 \"\n**Output:** \\[-34,-14,-10,-10,10\\]\n**Explanation:**\n(2\\*(3-(4\\*5))) = -34 \n((2\\*3)-(4\\*5)) = -14 \n((2\\*(3-4))\\*5) = -10 \n(2\\*((3-4)\\*5)) = -10 \n(((2\\*3)-4)\\*5) = 10\n\n**Constraints:**\n\n*   `1 <= expression.length <= 20`\n*   `expression` consists of digits and the operator `'+'`, `'-'`, and `'*'`.\n*   All the integer values in the input expression are in the range `[0, 99]`.", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> diffWaysToCompute(String input) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < input.length(); i++) {\n        char c = input.charAt(i);\n        if (c == '+' || c == '-' || c == '*') {\n            List<Integer> left = diffWaysToCompute(input.substring(0, i));\n            List<Integer> right = diffWaysToCompute(input.substring(i + 1));\n            for (int l : left) {\n                for (int r : right) {\n                    if (c == '+') result.add(l + r);\n                    else if (c == '-') result.add(l - r);\n                    else if (c == '*') result.add(l * r);\n                }\n            }\n        }\n    }\n    if (result.isEmpty()) result.add(Integer.parseInt(input));\n    return result;\n}\n```\n    \n    The algorithm is a recursive divide-and-conquer approach. It starts by iterating through the `input` string and looks for operators (+, -, *). When an operator is found, the problem is divided into two sub-problems: left and right. These sub-problems are independently solved through recursively calling the `diffWaysToCompute` function with corresponding substrings. \n\nEach recursion returns a list of possible results for each sub-problem. For each operator, we combine these results by iterating through both lists and performing the corresponding operation (addition, subtraction, or multiplication).\n\nIf no operators are present in the input string, a base case is reached, and the current number in the input string is returned as the only result. The recursion ultimately produces a list of all possible results for the original expression by combining results from all sub-problems.\n    ", "c++": "\n    ```cpp\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nvector<int> diffWaysToCompute(string input) {\n    vector<int> result;\n    for (int i = 0; i < input.size(); i++) {\n        char c = input[i];\n        if (c == '+' || c == '-' || c == '*') {\n            auto left = diffWaysToCompute(input.substr(0, i));\n            auto right = diffWaysToCompute(input.substr(i + 1));\n            for (int l : left) {\n                for (int r : right) {\n                    if (c == '+') result.push_back(l + r);\n                    else if (c == '-') result.push_back(l - r);\n                    else if (c == '*') result.push_back(l * r);\n                }\n            }\n        }\n    }\n    if (result.empty()) result.push_back(stoi(input));\n    return result;\n}\n```\n    \n    The algorithm is a recursive divide-and-conquer approach. It starts by iterating through the `input` string and looks for operators (+, -, *). When an operator is found, the problem is divided into two sub-problems: left and right. These sub-problems are independently solved through recursively calling the `diffWaysToCompute` function with corresponding substrings. \n\nEach recursion returns a list of possible results for each sub-problem. For each operator, we combine these results by iterating through both lists and performing the corresponding operation (addition, subtraction, or multiplication).\n\nIf no operators are present in the input string, a base case is reached, and the current number in the input string is returned as the only result. The recursion ultimately produces a list of all possible results for the original expression by combining results from all sub-problems.\n    ", "python": "\n    ```python\ndef diffWaysToCompute(input: str):\n    result = []\n    for i in range(len(input)):\n        c = input[i]\n        if c == '+' or c == '-' or c == '*':\n            left = diffWaysToCompute(input[:i])\n            right = diffWaysToCompute(input[i + 1:])\n            for l in left:\n                for r in right:\n                    if c == '+': result.append(l + r)\n                    elif c == '-': result.append(l - r)\n                    elif c == '*': result.append(l * r)\n    if not result:\n        result.append(int(input))\n    return result\n```\n    \n    The algorithm is a recursive divide-and-conquer approach. It starts by iterating through the `input` string and looks for operators (+, -, *). When an operator is found, the problem is divided into two sub-problems: left and right. These sub-problems are independently solved through recursively calling the `diffWaysToCompute` function with corresponding substrings. \n\nEach recursion returns a list of possible results for each sub-problem. For each operator, we combine these results by iterating through both lists and performing the corresponding operation (addition, subtraction, or multiplication).\n\nIf no operators are present in the input string, a base case is reached, and the current number in the input string is returned as the only result. The recursion ultimately produces a list of all possible results for the original expression by combining results from all sub-problems.\n    ", "javascript": "\n    ```javascript\nfunction diffWaysToCompute(input) {\n    const result = [];\n    for (let i = 0; i < input.length; i++) {\n        const c = input[i];\n        if (c === '+' || c === '-' || c === '*') {\n            const left = diffWaysToCompute(input.slice(0, i));\n            const right = diffWaysToCompute(input.slice(i + 1));\n            for (const l of left) {\n                for (const r of right) {\n                    if (c === '+') result.push(l + r);\n                    else if (c === '-') result.push(l - r);\n                    else if (c === '*') result.push(l * r);\n                }\n            }\n        }\n    }\n    if (result.length === 0) result.push(parseInt(input));\n    return result;\n}\n```\n    \n    The algorithm is a recursive divide-and-conquer approach. It starts by iterating through the `input` string and looks for operators (+, -, *). When an operator is found, the problem is divided into two sub-problems: left and right. These sub-problems are independently solved through recursively calling the `diffWaysToCompute` function with corresponding substrings. \n\nEach recursion returns a list of possible results for each sub-problem. For each operator, we combine these results by iterating through both lists and performing the corresponding operation (addition, subtraction, or multiplication).\n\nIf no operators are present in the input string, a base case is reached, and the current number in the input string is returned as the only result. The recursion ultimately produces a list of all possible results for the original expression by combining results from all sub-problems.\n    "}
{"id": 264, "slug": "ugly-number-ii", "title": "Ugly Number II", "difficulty": "Medium", "content": "An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.\n\nGiven an integer `n`, return _the_ `nth` _**ugly number**_.\n\n**Example 1:**\n\n**Input:** n = 10\n**Output:** 12\n**Explanation:** \\[1, 2, 3, 4, 5, 6, 8, 9, 10, 12\\] is the sequence of the first 10 ugly numbers.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n\n**Constraints:**\n\n*   `1 <= n <= 1690`", "java": "\n    ```java\npublic int nthUglyNumber(int n) {\n    int[] uglyNumbers = new int[n];\n    uglyNumbers[0] = 1;\n    int i2 = 0, i3 = 0, i5 = 0;\n\n    for (int i = 1; i < n; i++) {\n        uglyNumbers[i] = Math.min(Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3), uglyNumbers[i5] * 5);\n        if (uglyNumbers[i] == uglyNumbers[i2] * 2) i2++;\n        if (uglyNumbers[i] == uglyNumbers[i3] * 3) i3++;\n        if (uglyNumbers[i] == uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers[n - 1];\n}\n```\n\n    \n    1. Initialize an array of size n and set the first element to 1 (the first ugly number).\n2. Create three variables (i2, i3, and i5) to keep track of the current index of ugly numbers multiplied by 2, 3, and 5.\n3. Iterate through the array from index 1 to n-1, calculating the next ugly number as the minimum of (uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, and uglyNumbers[i5] * 5).\n4. Update the indices (i2, i3, and i5) based on which ugly number was used in the minimum calculation.\n5. The last element of the array is the nth ugly number.\n    ", "c++": "\n    ```cpp\nint nthUglyNumber(int n) {\n    vector<int> uglyNumbers(n);\n    uglyNumbers[0] = 1;\n    int i2 = 0, i3 = 0, i5 = 0;\n\n    for (int i = 1; i < n; i++) {\n        uglyNumbers[i] = min({uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, uglyNumbers[i5] * 5});\n        if (uglyNumbers[i] == uglyNumbers[i2] * 2) i2++;\n        if (uglyNumbers[i] == uglyNumbers[i3] * 3) i3++;\n        if (uglyNumbers[i] == uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers[n - 1];\n}\n```\n\n    \n    1. Initialize an array of size n and set the first element to 1 (the first ugly number).\n2. Create three variables (i2, i3, and i5) to keep track of the current index of ugly numbers multiplied by 2, 3, and 5.\n3. Iterate through the array from index 1 to n-1, calculating the next ugly number as the minimum of (uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, and uglyNumbers[i5] * 5).\n4. Update the indices (i2, i3, and i5) based on which ugly number was used in the minimum calculation.\n5. The last element of the array is the nth ugly number.\n    ", "python": "\n    ```python\ndef nthUglyNumber(n: int) -> int:\n    ugly_numbers = [0] * n\n    ugly_numbers[0] = 1\n    i2, i3, i5 = 0, 0, 0\n\n    for i in range(1, n):\n        ugly_numbers[i] = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)\n        if ugly_numbers[i] == ugly_numbers[i2] * 2: i2 += 1\n        if ugly_numbers[i] == ugly_numbers[i3] * 3: i3 += 1\n        if ugly_numbers[i] == ugly_numbers[i5] * 5: i5 += 1\n\n    return ugly_numbers[n - 1]\n\n```\n\n    \n    1. Initialize an array of size n and set the first element to 1 (the first ugly number).\n2. Create three variables (i2, i3, and i5) to keep track of the current index of ugly numbers multiplied by 2, 3, and 5.\n3. Iterate through the array from index 1 to n-1, calculating the next ugly number as the minimum of (uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, and uglyNumbers[i5] * 5).\n4. Update the indices (i2, i3, and i5) based on which ugly number was used in the minimum calculation.\n5. The last element of the array is the nth ugly number.\n    ", "javascript": "\n    ```javascript\nfunction nthUglyNumber(n) {\n    let uglyNumbers = new Array(n);\n    uglyNumbers[0] = 1;\n    let i2 = 0, i3 = 0, i5 = 0;\n\n    for (let i = 1; i < n; i++) {\n        uglyNumbers[i] = Math.min(Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3), uglyNumbers[i5] * 5);\n        if (uglyNumbers[i] === uglyNumbers[i2] * 2) i2++;\n        if (uglyNumbers[i] === uglyNumbers[i3] * 3) i3++;\n        if (uglyNumbers[i] === uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers[n - 1];\n}\n```\n\n    \n    1. Initialize an array of size n and set the first element to 1 (the first ugly number).\n2. Create three variables (i2, i3, and i5) to keep track of the current index of ugly numbers multiplied by 2, 3, and 5.\n3. Iterate through the array from index 1 to n-1, calculating the next ugly number as the minimum of (uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, and uglyNumbers[i5] * 5).\n4. Update the indices (i2, i3, and i5) based on which ugly number was used in the minimum calculation.\n5. The last element of the array is the nth ugly number.\n    "}
{"id": 279, "slug": "perfect-squares", "title": "Perfect Squares", "difficulty": "Medium", "content": "Given an integer `n`, return _the least number of perfect square numbers that sum to_ `n`.\n\nA **perfect square** is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, `1`, `4`, `9`, and `16` are perfect squares while `3` and `11` are not.\n\n**Example 1:**\n\n**Input:** n = 12\n**Output:** 3\n**Explanation:** 12 = 4 + 4 + 4.\n\n**Example 2:**\n\n**Input:** n = 13\n**Output:** 2\n**Explanation:** 13 = 4 + 9.\n\n**Constraints:**\n\n*   `1 <= n <= 104`", "java": "\n    ```java\npublic int numSquares(int n) {\n    int[] dp = new int[n + 1];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j * j <= i; j++) {\n            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    We use Dynamic Programming (DP) to solve this problem. We initialize a 1-dimensional DP array, `dp`, of size `n + 1`, where `n` is given in the problem statement. We set `dp[0]` to `0` because it takes zero square numbers to sum up to zero. We fill the rest of the DP array with a maximum or infinite value, depending on the language used.\n\nWe iterate through the DP array from index `1` to index `n`, inclusive. For each index `i`, we iterate through all perfect square numbers `j * j` smaller than or equal to `i` to find the least number of perfect square numbers that sum up to `i`. We update the `dp` array with the minimum value of the current value at `dp[i]` and `dp[i - j * j] + 1`.\n\nAfter completing the iterations, the value at `dp[n]` represents the least number of perfect squares that sum to `n`.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <limits>\n#include <cmath>\n\nint numSquares(int n) {\n    std::vector<int> dp(n + 1, std::numeric_limits<int>::max());\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j * j <= i; j++) {\n            dp[i] = std::min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    We use Dynamic Programming (DP) to solve this problem. We initialize a 1-dimensional DP array, `dp`, of size `n + 1`, where `n` is given in the problem statement. We set `dp[0]` to `0` because it takes zero square numbers to sum up to zero. We fill the rest of the DP array with a maximum or infinite value, depending on the language used.\n\nWe iterate through the DP array from index `1` to index `n`, inclusive. For each index `i`, we iterate through all perfect square numbers `j * j` smaller than or equal to `i` to find the least number of perfect square numbers that sum up to `i`. We update the `dp` array with the minimum value of the current value at `dp[i]` and `dp[i - j * j] + 1`.\n\nAfter completing the iterations, the value at `dp[n]` represents the least number of perfect squares that sum to `n`.\n    ", "python": "\n    ```python\ndef numSquares(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n            \n    return dp[n]\n```\n    \n    We use Dynamic Programming (DP) to solve this problem. We initialize a 1-dimensional DP array, `dp`, of size `n + 1`, where `n` is given in the problem statement. We set `dp[0]` to `0` because it takes zero square numbers to sum up to zero. We fill the rest of the DP array with a maximum or infinite value, depending on the language used.\n\nWe iterate through the DP array from index `1` to index `n`, inclusive. For each index `i`, we iterate through all perfect square numbers `j * j` smaller than or equal to `i` to find the least number of perfect square numbers that sum up to `i`. We update the `dp` array with the minimum value of the current value at `dp[i]` and `dp[i - j * j] + 1`.\n\nAfter completing the iterations, the value at `dp[n]` represents the least number of perfect squares that sum to `n`.\n    ", "javascript": "\n    ```javascript\nfunction numSquares(n) {\n    const dp = new Array(n + 1).fill(Infinity);\n    dp[0] = 0;\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j * j <= i; j++) {\n            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n\n    return dp[n];\n}\n```\n    \n    We use Dynamic Programming (DP) to solve this problem. We initialize a 1-dimensional DP array, `dp`, of size `n + 1`, where `n` is given in the problem statement. We set `dp[0]` to `0` because it takes zero square numbers to sum up to zero. We fill the rest of the DP array with a maximum or infinite value, depending on the language used.\n\nWe iterate through the DP array from index `1` to index `n`, inclusive. For each index `i`, we iterate through all perfect square numbers `j * j` smaller than or equal to `i` to find the least number of perfect square numbers that sum up to `i`. We update the `dp` array with the minimum value of the current value at `dp[i]` and `dp[i - j * j] + 1`.\n\nAfter completing the iterations, the value at `dp[n]` represents the least number of perfect squares that sum to `n`.\n    "}
{"id": 300, "slug": "longest-increasing-subsequence", "title": "Longest Increasing Subsequence", "difficulty": "Medium", "content": "Given an integer array `nums`, return _the length of the longest **strictly increasing**_ _**subsequence**_.\n\n**Example 1:**\n\n**Input:** nums = \\[10,9,2,5,3,7,101,18\\]\n**Output:** 4\n**Explanation:** The longest increasing subsequence is \\[2,3,7,101\\], therefore the length is 4.\n\n**Example 2:**\n\n**Input:** nums = \\[0,1,0,3,2,3\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** nums = \\[7,7,7,7,7,7,7\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2500`\n*   `-104 <= nums[i] <= 104`\n\n**Follow up:** Can you come up with an algorithm that runs in `O(n log(n))` time complexity?", "java": "\n    ```java\npublic int lengthOfLIS(int[] nums) {\n    int[] dp = new int[nums.length];\n    int max_length = 1;\n    Arrays.fill(dp, 1);\n    for (int i = 1; i < nums.length; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = Math.max(max_length, dp[i]);\n    }\n    return max_length;\n}\n```\n    \n    The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence.\n    ", "c++": "\n    ```cpp\nint lengthOfLIS(vector<int>& nums) {\n    vector<int> dp(nums.size(), 1);\n    int max_length = 1;\n    for (int i = 1; i < nums.size(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = max(max_length, dp[i]);\n    }\n    return max_length;\n}\n```\n    \n    The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence.\n    ", "python": "\n    ```python\ndef lengthOfLIS(nums):\n    dp = [1] * len(nums)\n    max_length = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_length = max(max_length, dp[i])\n    return max_length\n```\n    \n    The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence.\n    ", "javascript": "\n    ```javascript\nfunction lengthOfLIS(nums) {\n    const dp = new Array(nums.length).fill(1);\n    let max_length = 1;\n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = Math.max(max_length, dp[i]);\n    }\n    return max_length;\n}\n```\n    \n    The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence.\n    "}
{"id": 309, "slug": "best-time-to-buy-and-sell-stock-with-cooldown", "title": "Best Time to Buy and Sell Stock with Cooldown", "difficulty": "Medium", "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\n*   After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n**Example 1:**\n\n**Input:** prices = \\[1,2,3,0,2\\]\n**Output:** 3\n**Explanation:** transactions = \\[buy, sell, cooldown, buy, sell\\]\n\n**Example 2:**\n\n**Input:** prices = \\[1\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= prices.length <= 5000`\n*   `0 <= prices[i] <= 1000`", "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        profit += Math.max(prices[i] - prices[i - 1], 0);\n    }\n    return profit;\n}\n```\n    \n    The algorithm iterates through the given `prices` array. For each day, starting from day 1 (index 1), it calculates the difference between the current day's price and the previous day's price. If the difference is positive, it means there is profit to be made by selling on this day after buying on the previous day. The profitable difference is then added to the total profit. This is done for all consecutive days in the array. By the end of the iteration, the total accumulated profit will be the maximum possible, considering the constraints given in the problem statement. No additional transactions are needed because selling and buying again at the same price does not change the profit.\n    ", "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int profit = 0;\n    for (int i = 1; i < prices.size(); ++i) {\n        profit += max(prices[i] - prices[i - 1], 0);\n    }\n    return profit;\n}\n```\n    \n    The algorithm iterates through the given `prices` array. For each day, starting from day 1 (index 1), it calculates the difference between the current day's price and the previous day's price. If the difference is positive, it means there is profit to be made by selling on this day after buying on the previous day. The profitable difference is then added to the total profit. This is done for all consecutive days in the array. By the end of the iteration, the total accumulated profit will be the maximum possible, considering the constraints given in the problem statement. No additional transactions are needed because selling and buying again at the same price does not change the profit.\n    ", "python": "\n    ```python\ndef maxProfit(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n    return profit\n```\n    \n    The algorithm iterates through the given `prices` array. For each day, starting from day 1 (index 1), it calculates the difference between the current day's price and the previous day's price. If the difference is positive, it means there is profit to be made by selling on this day after buying on the previous day. The profitable difference is then added to the total profit. This is done for all consecutive days in the array. By the end of the iteration, the total accumulated profit will be the maximum possible, considering the constraints given in the problem statement. No additional transactions are needed because selling and buying again at the same price does not change the profit.\n    ", "javascript": "\n    ```javascript\nfunction maxProfit(prices) {\n    let profit = 0;\n    for (let i = 1; i < prices.length; i++) {\n        profit += Math.max(prices[i] - prices[i - 1], 0);\n    }\n    return profit;\n}\n```\n    \n    The algorithm iterates through the given `prices` array. For each day, starting from day 1 (index 1), it calculates the difference between the current day's price and the previous day's price. If the difference is positive, it means there is profit to be made by selling on this day after buying on the previous day. The profitable difference is then added to the total profit. This is done for all consecutive days in the array. By the end of the iteration, the total accumulated profit will be the maximum possible, considering the constraints given in the problem statement. No additional transactions are needed because selling and buying again at the same price does not change the profit.\n    "}
{"id": 312, "slug": "burst-balloons", "title": "Burst Balloons", "difficulty": "Hard", "content": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n\nIf you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n\nReturn _the maximum coins you can collect by bursting the balloons wisely_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,1,5,8\\]\n**Output:** 167\n**Explanation:**\nnums = \\[3,1,5,8\\] --> \\[3,5,8\\] --> \\[3,8\\] --> \\[8\\] --> \\[\\]\ncoins =  3\\*1\\*5    +   3\\*5\\*8   +  1\\*3\\*8  + 1\\*8\\*1 = 167\n\n**Example 2:**\n\n**Input:** nums = \\[1,5\\]\n**Output:** 10\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 300`\n*   `0 <= nums[i] <= 100`", "java": "\n    ```java\npublic int maxCoins(int[] nums) {\n    int n = nums.length;\n    int[] newNums = new int[n + 2];\n    newNums[0] = 1;\n    newNums[n + 1] = 1;\n    for (int i = 1; i <= n; i++) {\n        newNums[i] = nums[i - 1];\n    }\n\n    int[][] dp = new int[n + 2][n + 2];\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], newNums[left - 1] * newNums[i] * newNums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ", "c++": "\n    ```cpp\nint maxCoins(vector<int>& nums) {\n    int n = nums.size();\n    nums.insert(nums.begin(), 1);\n    nums.push_back(1);\n\n    vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ", "python": "\n    ```python\ndef maxCoins(nums):\n    nums = [1] + nums + [1]\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(1, n - 1):\n        for left in range(1, n - length):\n            right = left + length - 1\n            for i in range(left, right + 1):\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right])\n\n    return dp[1][n - 2]\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ", "javascript": "\n    ```javascript\nfunction maxCoins(nums) {\n    nums.unshift(1);\n    nums.push(1);\n    const n = nums.length;\n\n    const dp = [];\n    for (let i = 0; i < n; i++) {\n        dp.push(new Array(n).fill(0));\n    }\n\n    for (let len = 1; len <= n - 2; len++) {\n        for (let left = 1; left <= n - len - 1; left++) {\n            const right = left + len - 1;\n            for (let i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n - 2];\n}\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    "}
{"id": 313, "slug": "super-ugly-number", "title": "Super Ugly Number", "difficulty": "Medium", "content": "A **super ugly number** is a positive integer whose prime factors are in the array `primes`.\n\nGiven an integer `n` and an array of integers `primes`, return _the_ `nth` _**super ugly number**_.\n\nThe `nth` **super ugly number** is **guaranteed** to fit in a **32-bit** signed integer.\n\n**Example 1:**\n\n**Input:** n = 12, primes = \\[2,7,13,19\\]\n**Output:** 32\n**Explanation:** \\[1,2,4,7,8,13,14,16,19,26,28,32\\] is the sequence of the first 12 super ugly numbers given primes = \\[2,7,13,19\\].\n\n**Example 2:**\n\n**Input:** n = 1, primes = \\[2,3,5\\]\n**Output:** 1\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are in the array primes = \\[2,3,5\\].\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= primes.length <= 100`\n*   `2 <= primes[i] <= 1000`\n*   `primes[i]` is **guaranteed** to be a prime number.\n*   All the values of `primes` are **unique** and sorted in **ascending order**.", "java": "\n    ```java\npublic int nthSuperUglyNumber(int n, int[] primes) {\n    int[] ugly = new int[n];\n    ugly[0] = 1;\n    int[] indices = new int[primes.length];\n\n    for (int i = 1; i < n; i++) {\n        int minVal = Integer.MAX_VALUE;\n\n        for (int j = 0; j < primes.length; j++)\n            minVal = Math.min(minVal, ugly[indices[j]] * primes[j]);\n\n        ugly[i] = minVal;\n\n        for (int j = 0; j < primes.length; j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n\n    return ugly[n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the nth super ugly number. We first create an `ugly` array of size `n`, where `ugly[i]` will store the (i+1)th super ugly number. We initialize `ugly[0]` as 1, since 1 is always a super ugly number.\n\nMaintain an `indices` array of size `primes.length`, initialized with zeros. Each element `indices[j]` represents the index of the next super ugly number to multiply by `primes[j]`.\n\nFor each `i` from 1 to n, we calculate `ugly[i]` as the minimum of `ugly[indices[j]] * primes[j]` for all `j`. Then we increment the index `indices[j]` for which the condition `ugly[i] == ugly[indices[j]] * primes[j]` holds.\n\nFinally, we return the last element of the `ugly` array, which is the nth super ugly number.\n    ", "c++": "\n    ```cpp\nint nthSuperUglyNumber(int n, vector<int>& primes) {\n    vector<int> ugly(n);\n    ugly[0] = 1;\n    vector<int> indices(primes.size(), 0);\n    \n    for (int i = 1; i < n; i++) {\n        int min_val = INT_MAX;\n        \n        for (int j = 0; j < primes.size(); j++)\n            min_val = min(min_val, ugly[indices[j]] * primes[j]);\n        \n        ugly[i] = min_val;\n        \n        for (int j = 0; j < primes.size(); j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n    \n    return ugly.back();\n}\n```\n    \n    The algorithm uses dynamic programming to find the nth super ugly number. We first create an `ugly` array of size `n`, where `ugly[i]` will store the (i+1)th super ugly number. We initialize `ugly[0]` as 1, since 1 is always a super ugly number.\n\nMaintain an `indices` array of size `primes.length`, initialized with zeros. Each element `indices[j]` represents the index of the next super ugly number to multiply by `primes[j]`.\n\nFor each `i` from 1 to n, we calculate `ugly[i]` as the minimum of `ugly[indices[j]] * primes[j]` for all `j`. Then we increment the index `indices[j]` for which the condition `ugly[i] == ugly[indices[j]] * primes[j]` holds.\n\nFinally, we return the last element of the `ugly` array, which is the nth super ugly number.\n    ", "python": "\n    ```python\ndef nthSuperUglyNumber(n, primes):\n    ugly = [0] * n\n    ugly[0] = 1\n    indices = [0] * len(primes)\n\n    for i in range(1, n):\n        min_val = float(\"inf\")\n\n        for j in range(len(primes)):\n            min_val = min(min_val, ugly[indices[j]] * primes[j])\n\n        ugly[i] = min_val\n\n        for j in range(len(primes)):\n            if ugly[i] == ugly[indices[j]] * primes[j]:\n                indices[j] += 1\n\n    return ugly[-1]\n```\n    \n    The algorithm uses dynamic programming to find the nth super ugly number. We first create an `ugly` array of size `n`, where `ugly[i]` will store the (i+1)th super ugly number. We initialize `ugly[0]` as 1, since 1 is always a super ugly number.\n\nMaintain an `indices` array of size `primes.length`, initialized with zeros. Each element `indices[j]` represents the index of the next super ugly number to multiply by `primes[j]`.\n\nFor each `i` from 1 to n, we calculate `ugly[i]` as the minimum of `ugly[indices[j]] * primes[j]` for all `j`. Then we increment the index `indices[j]` for which the condition `ugly[i] == ugly[indices[j]] * primes[j]` holds.\n\nFinally, we return the last element of the `ugly` array, which is the nth super ugly number.\n    ", "javascript": "\n    ```javascript\nfunction nthSuperUglyNumber(n, primes) {\n    let ugly = new Array(n);\n    ugly[0] = 1;\n    let indices = new Array(primes.length).fill(0);\n\n    for (let i = 1; i < n; i++) {\n        let minVal = Number.MAX_SAFE_INTEGER;\n\n        for (let j = 0; j < primes.length; j++)\n            minVal = Math.min(minVal, ugly[indices[j]] * primes[j]);\n\n        ugly[i] = minVal;\n\n        for (let j = 0; j < primes.length; j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n\n    return ugly[n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the nth super ugly number. We first create an `ugly` array of size `n`, where `ugly[i]` will store the (i+1)th super ugly number. We initialize `ugly[0]` as 1, since 1 is always a super ugly number.\n\nMaintain an `indices` array of size `primes.length`, initialized with zeros. Each element `indices[j]` represents the index of the next super ugly number to multiply by `primes[j]`.\n\nFor each `i` from 1 to n, we calculate `ugly[i]` as the minimum of `ugly[indices[j]] * primes[j]` for all `j`. Then we increment the index `indices[j]` for which the condition `ugly[i] == ugly[indices[j]] * primes[j]` holds.\n\nFinally, we return the last element of the `ugly` array, which is the nth super ugly number.\n    "}
{"id": 322, "slug": "coin-change", "title": "Coin Change", "difficulty": "Medium", "content": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n**Example 1:**\n\n**Input:** coins = \\[1,2,5\\], amount = 11\n**Output:** 3\n**Explanation:** 11 = 5 + 5 + 1\n\n**Example 2:**\n\n**Input:** coins = \\[2\\], amount = 3\n**Output:** -1\n\n**Example 3:**\n\n**Input:** coins = \\[1\\], amount = 0\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= coins.length <= 12`\n*   `1 <= coins[i] <= 231 - 1`\n*   `0 <= amount <= 104`", "java": "\n    ```java\npublic int coinChange(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1);\n    dp[0] = 0;\n    \n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n        }\n    }\n\n    return dp[amount] <= amount ? dp[amount] : -1;\n}\n```\n    \n    The algorithm here is based on dynamic programming. We create a `dp` array with indices from 0 to the total `amount` we need to target. We initialize the `dp` array with a value greater than the amount (amount + 1). This is because this value can never be achieved using the coins, and the initialization ensures that we always get a valid minimum number of coins.\n\nWe start by initializing `dp[0]` to 0 as there will be 0 coins needed to make a sum of 0.\n\nThen, we iterate through the given coins array and for each coin, we start another iteration from the value of the coin to the total amount. For each index `i` in this inner loop, we update `dp[i]` as the minimum of its current value `dp[i]` and `dp[i - coins[j]] + 1`. This ensures that we get the minimum number of coins required to create the total amount.\n\nAfter this iteration, if the value at `dp[amount]` is less than or equal to the target amount, we return the value as the minimum number of coins required. Otherwise, if it's greater than the amount, it means we couldn't find a combination of coins to make up the total amount, so we return -1.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint coinChange(std::vector<int>& coins, int amount) {\n    std::vector<int> dp(amount + 1, amount + 1);\n    dp[0] = 0;\n    \n    for (int i = 0; i < coins.size(); i++) {\n        for (int j = coins[i]; j <= amount; j++) {\n            dp[j] = std::min(dp[j], dp[j - coins[i]] + 1);\n        }\n    }\n\n    return dp[amount] <= amount ? dp[amount] : -1;\n}\n```\n    \n    The algorithm here is based on dynamic programming. We create a `dp` array with indices from 0 to the total `amount` we need to target. We initialize the `dp` array with a value greater than the amount (amount + 1). This is because this value can never be achieved using the coins, and the initialization ensures that we always get a valid minimum number of coins.\n\nWe start by initializing `dp[0]` to 0 as there will be 0 coins needed to make a sum of 0.\n\nThen, we iterate through the given coins array and for each coin, we start another iteration from the value of the coin to the total amount. For each index `i` in this inner loop, we update `dp[i]` as the minimum of its current value `dp[i]` and `dp[i - coins[j]] + 1`. This ensures that we get the minimum number of coins required to create the total amount.\n\nAfter this iteration, if the value at `dp[amount]` is less than or equal to the target amount, we return the value as the minimum number of coins required. Otherwise, if it's greater than the amount, it means we couldn't find a combination of coins to make up the total amount, so we return -1.\n    ", "python": "\n    ```python\ndef coinChange(coins, amount):\n    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] <= amount else -1\n```\n    \n    The algorithm here is based on dynamic programming. We create a `dp` array with indices from 0 to the total `amount` we need to target. We initialize the `dp` array with a value greater than the amount (amount + 1). This is because this value can never be achieved using the coins, and the initialization ensures that we always get a valid minimum number of coins.\n\nWe start by initializing `dp[0]` to 0 as there will be 0 coins needed to make a sum of 0.\n\nThen, we iterate through the given coins array and for each coin, we start another iteration from the value of the coin to the total amount. For each index `i` in this inner loop, we update `dp[i]` as the minimum of its current value `dp[i]` and `dp[i - coins[j]] + 1`. This ensures that we get the minimum number of coins required to create the total amount.\n\nAfter this iteration, if the value at `dp[amount]` is less than or equal to the target amount, we return the value as the minimum number of coins required. Otherwise, if it's greater than the amount, it means we couldn't find a combination of coins to make up the total amount, so we return -1.\n    ", "javascript": "\n    ```javascript\nfunction coinChange(coins, amount) {\n    const dp = new Array(amount + 1).fill(amount + 1);\n    dp[0] = 0;\n\n    for (const coin of coins) {\n        for (let i = coin; i <= amount; i++) {\n            dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n        }\n    }\n\n    return dp[amount] <= amount ? dp[amount] : -1;\n}\n```\n    \n    The algorithm here is based on dynamic programming. We create a `dp` array with indices from 0 to the total `amount` we need to target. We initialize the `dp` array with a value greater than the amount (amount + 1). This is because this value can never be achieved using the coins, and the initialization ensures that we always get a valid minimum number of coins.\n\nWe start by initializing `dp[0]` to 0 as there will be 0 coins needed to make a sum of 0.\n\nThen, we iterate through the given coins array and for each coin, we start another iteration from the value of the coin to the total amount. For each index `i` in this inner loop, we update `dp[i]` as the minimum of its current value `dp[i]` and `dp[i - coins[j]] + 1`. This ensures that we get the minimum number of coins required to create the total amount.\n\nAfter this iteration, if the value at `dp[amount]` is less than or equal to the target amount, we return the value as the minimum number of coins required. Otherwise, if it's greater than the amount, it means we couldn't find a combination of coins to make up the total amount, so we return -1.\n    "}
{"id": 329, "slug": "longest-increasing-path-in-a-matrix", "title": "Longest Increasing Path in a Matrix", "difficulty": "Hard", "content": "Given an `m x n` integers `matrix`, return _the length of the longest increasing path in_ `matrix`.\n\nFrom each cell, you can either move in four directions: left, right, up, or down. You **may not** move **diagonally** or move **outside the boundary** (i.e., wrap-around is not allowed).\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[9,9,4\\],\\[6,6,8\\],\\[2,1,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[1, 2, 6, 9]`.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[3,4,5\\],\\[3,2,6\\],\\[2,2,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[3, 4, 5, 6]`. Moving diagonally is not allowed.\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= matrix[i][j] <= 231 - 1`", "java": "\n    ```java\nint[] dx = {0, 0, 1, -1};\nint[] dy = {1, -1, 0, 0};\n\npublic int dfs(int[][] matrix, int[][] memo, int i, int j) {\n    if (memo[i][j] != 0) return memo[i][j];\n    \n    int max_len = 0;\n    for (int k = 0; k < 4; ++k) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (ni >= 0 && ni < matrix.length && nj >= 0 && nj < matrix[0].length && matrix[ni][nj] > matrix[i][j]) {\n            max_len = Math.max(max_len, dfs(matrix, memo, ni, nj));\n        }\n    }\n    \n    memo[i][j] = max_len + 1;\n    return memo[i][j];\n}\n\npublic int longestIncreasingPath(int[][] matrix) {\n    int m = matrix.length, n = matrix[0].length;\n    \n    int[][] memo = new int[m][n];\n    \n    int ans = 0;\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            ans = Math.max(ans, dfs(matrix, memo, i, j));\n    \n    return ans;\n}\n```\n\n    \n    We use a depth-first search (DFS) to explore the grid. The basic idea is to start from each cell and move in the four directions allowed (left, right, up, and down). We can only move to a neighboring cell if the value in that cell is greater than the current cell (increasing path).\n\nWe use memoization to store the longest increasing path starting from each cell to avoid redundant calculations. For each cell `(i, j)`, we call the DFS function and compute the longest increasing path starting from that cell by exploring the neighboring cells in all four directions.\n\nFinally, we return the longest increasing path found in the grid.\n\nThe time complexity of this algorithm is O(m * n) as we visit each cell once, where m is the number of rows and n is the number of columns in the given matrix.\n    ", "c++": "\n    ```cpp\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint dfs(vector<vector<int>>& matrix, vector<vector<int>>& memo, int i, int j) {\n    if (memo[i][j] != 0) return memo[i][j];\n    \n    int max_len = 0;\n    for (int k = 0; k < 4; ++k) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (ni >= 0 && ni < matrix.size() && nj >= 0 && nj < matrix[0].size() && matrix[ni][nj] > matrix[i][j]) {\n            max_len = max(max_len, dfs(matrix, memo, ni, nj));\n        }\n    }\n    \n    memo[i][j] = max_len + 1;\n    return memo[i][j];\n}\n\nint longestIncreasingPath(vector<vector<int>>& matrix) {\n    int m = matrix.size(), n = matrix[0].size();\n    \n    vector<vector<int>> memo(m, vector<int>(n, 0));\n    \n    int ans = 0;\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            ans = max(ans, dfs(matrix, memo, i, j));\n    \n    return ans;\n}\n```\n\n    \n    We use a depth-first search (DFS) to explore the grid. The basic idea is to start from each cell and move in the four directions allowed (left, right, up, and down). We can only move to a neighboring cell if the value in that cell is greater than the current cell (increasing path).\n\nWe use memoization to store the longest increasing path starting from each cell to avoid redundant calculations. For each cell `(i, j)`, we call the DFS function and compute the longest increasing path starting from that cell by exploring the neighboring cells in all four directions.\n\nFinally, we return the longest increasing path found in the grid.\n\nThe time complexity of this algorithm is O(m * n) as we visit each cell once, where m is the number of rows and n is the number of columns in the given matrix.\n    ", "python": "\n    ```python\ndx = (0, 0, 1, -1)\ndy = (1, -1, 0, 0)\n\ndef dfs(matrix, memo, i, j):\n    if memo[i][j] != 0:\n        return memo[i][j]\n    \n    max_len = 0\n    for k in range(4):\n        ni, nj = i + dx[k], j + dy[k]\n        if (0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and matrix[ni][nj] > matrix[i][j]):\n            max_len = max(max_len, dfs(matrix, memo, ni, nj))\n    \n    memo[i][j] = max_len + 1\n    return memo[i][j]\n\ndef longest_increasing_path(matrix):\n    m, n = len(matrix), len(matrix[0])\n    \n    memo = [[0] * n for _ in range(m)]\n    \n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            ans = max(ans, dfs(matrix, memo, i, j))\n    \n    return ans\n```\n\n    \n    We use a depth-first search (DFS) to explore the grid. The basic idea is to start from each cell and move in the four directions allowed (left, right, up, and down). We can only move to a neighboring cell if the value in that cell is greater than the current cell (increasing path).\n\nWe use memoization to store the longest increasing path starting from each cell to avoid redundant calculations. For each cell `(i, j)`, we call the DFS function and compute the longest increasing path starting from that cell by exploring the neighboring cells in all four directions.\n\nFinally, we return the longest increasing path found in the grid.\n\nThe time complexity of this algorithm is O(m * n) as we visit each cell once, where m is the number of rows and n is the number of columns in the given matrix.\n    ", "javascript": "\n    ```javascript\nconst dx = [0, 0, 1, -1];\nconst dy = [1, -1, 0, 0];\n\nfunction dfs(matrix, memo, i, j) {\n    if (memo[i][j] !== 0) return memo[i][j];\n    \n    let max_len = 0;\n    for (let k = 0; k < 4; ++k) {\n        const ni = i + dx[k], nj = j + dy[k];\n        if (ni >= 0 && ni < matrix.length && nj >= 0 && nj < matrix[0].length && matrix[ni][nj] > matrix[i][j]) {\n            max_len = Math.max(max_len, dfs(matrix, memo, ni, nj));\n        }\n    }\n    \n    memo[i][j] = max_len + 1;\n    return memo[i][j];\n}\n\nfunction longestIncreasingPath(matrix) {\n    const m = matrix.length, n = matrix[0].length;\n    \n    const memo = Array.from({length: m}, () => Array.from({length: n}, () => 0));\n    \n    let ans = 0;\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            ans = Math.max(ans, dfs(matrix, memo, i, j));\n        }\n    }\n    \n    return ans;\n}\n```\n\n    \n    We use a depth-first search (DFS) to explore the grid. The basic idea is to start from each cell and move in the four directions allowed (left, right, up, and down). We can only move to a neighboring cell if the value in that cell is greater than the current cell (increasing path).\n\nWe use memoization to store the longest increasing path starting from each cell to avoid redundant calculations. For each cell `(i, j)`, we call the DFS function and compute the longest increasing path starting from that cell by exploring the neighboring cells in all four directions.\n\nFinally, we return the longest increasing path found in the grid.\n\nThe time complexity of this algorithm is O(m * n) as we visit each cell once, where m is the number of rows and n is the number of columns in the given matrix.\n    "}
{"id": 337, "slug": "house-robber-iii", "title": "House Robber III", "difficulty": "Medium", "content": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called `root`.\n\nBesides the `root`, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if **two directly-linked houses were broken into on the same night**.\n\nGiven the `root` of the binary tree, return _the maximum amount of money the thief can rob **without alerting the police**_.\n\n**Example 1:**\n\n**Input:** root = \\[3,2,3,null,3,null,1\\]\n**Output:** 7\n**Explanation:** Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n\n**Example 2:**\n\n**Input:** root = \\[3,4,5,1,3,null,1\\]\n**Output:** 9\n**Explanation:** Maximum amount of money the thief can rob = 4 + 5 = 9.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `0 <= Node.val <= 104`", "java": "\n    ```java\npublic int rob(TreeNode root) {\n    int[] result = robHelper(root);\n    return Math.max(result[0], result[1]);\n}\n\nprivate int[] robHelper(TreeNode node) {\n    if (node == null) return new int[2];\n\n    int[] left = robHelper(node.left);\n    int[] right = robHelper(node.right);\n    int[] result = new int[2];\n\n    result[0] = node.val + left[1] + right[1];\n    result[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n    return result;\n}\n```\n    \n    The algorithm uses a dynamic programming approach to find the optimal sum for each subtree. The helper function has two main cases for each node:\n\n1. Include the current node value in the sum (includeNode): If the current node is included in the sum, its children nodes cannot be included. Therefore, we add the current node value to the sum of the node's grandchildren.\n\n2. Exclude the current node value in the sum (excludeNode): If the current node is not included in the sum, its children can be included. We add the maximum of the children nodes' sum including or excluding the children in the sum.\n\nThe helper function is called recursively for each child node until the leaves are reached. For each node, the helper function returns two values indicating the maximum sum including and excluding the current node. At the end of the recursion, we return the maximum of these two values for the root node as the result.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree.\n    ", "c++": "\n    ```cpp\nint robHelper(TreeNode* node, int& includeNode, int& excludeNode) {\n    if (!node) return 0;\n\n    int left_include, left_exclude, right_include, right_exclude;\n\n    robHelper(node->left, left_include, left_exclude);\n    robHelper(node->right, right_include, right_exclude);\n\n    includeNode = node->val + left_exclude + right_exclude;\n    excludeNode = max(left_include, left_exclude) + max(right_include, right_exclude);\n    return max(includeNode, excludeNode);\n}\n\nint rob(TreeNode* root) {\n    int includeNode = 0, excludeNode = 0;\n    return robHelper(root, includeNode, excludeNode);\n}\n```\n    \n    The algorithm uses a dynamic programming approach to find the optimal sum for each subtree. The helper function has two main cases for each node:\n\n1. Include the current node value in the sum (includeNode): If the current node is included in the sum, its children nodes cannot be included. Therefore, we add the current node value to the sum of the node's grandchildren.\n\n2. Exclude the current node value in the sum (excludeNode): If the current node is not included in the sum, its children can be included. We add the maximum of the children nodes' sum including or excluding the children in the sum.\n\nThe helper function is called recursively for each child node until the leaves are reached. For each node, the helper function returns two values indicating the maximum sum including and excluding the current node. At the end of the recursion, we return the maximum of these two values for the root node as the result.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree.\n    ", "python": "\n    ```python\ndef rob(self, root: TreeNode) -> int:\n    def rob_helper(node):\n        if not node:\n            return 0, 0\n\n        left_with_node, left_without_node = rob_helper(node.left)\n        right_with_node, right_without_node = rob_helper(node.right)\n\n        with_node = node.val + left_without_node + right_without_node\n        without_node = max(left_with_node, left_without_node) + max(right_with_node, right_without_node)\n        return with_node, without_node\n\n    return max(rob_helper(root))\n```\n    \n    The algorithm uses a dynamic programming approach to find the optimal sum for each subtree. The helper function has two main cases for each node:\n\n1. Include the current node value in the sum (includeNode): If the current node is included in the sum, its children nodes cannot be included. Therefore, we add the current node value to the sum of the node's grandchildren.\n\n2. Exclude the current node value in the sum (excludeNode): If the current node is not included in the sum, its children can be included. We add the maximum of the children nodes' sum including or excluding the children in the sum.\n\nThe helper function is called recursively for each child node until the leaves are reached. For each node, the helper function returns two values indicating the maximum sum including and excluding the current node. At the end of the recursion, we return the maximum of these two values for the root node as the result.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree.\n    ", "javascript": "\n    ```javascript\nvar rob = function(root) {\n    const [withNode, withoutNode] = robHelper(root);\n    return Math.max(withNode, withoutNode);\n};\n\nfunction robHelper(node) {\n    if (!node) return [0, 0];\n\n    const [leftWithNode, leftWithoutNode] = robHelper(node.left);\n    const [rightWithNode, rightWithoutNode] = robHelper(node.right);\n\n    const withNode = node.val + leftWithoutNode + rightWithoutNode;\n    const withoutNode = Math.max(leftWithNode, leftWithoutNode) + Math.max(rightWithNode, rightWithoutNode);\n    return [withNode, withoutNode];\n}\n```\n    \n    The algorithm uses a dynamic programming approach to find the optimal sum for each subtree. The helper function has two main cases for each node:\n\n1. Include the current node value in the sum (includeNode): If the current node is included in the sum, its children nodes cannot be included. Therefore, we add the current node value to the sum of the node's grandchildren.\n\n2. Exclude the current node value in the sum (excludeNode): If the current node is not included in the sum, its children can be included. We add the maximum of the children nodes' sum including or excluding the children in the sum.\n\nThe helper function is called recursively for each child node until the leaves are reached. For each node, the helper function returns two values indicating the maximum sum including and excluding the current node. At the end of the recursion, we return the maximum of these two values for the root node as the result.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree.\n    "}
{"id": 338, "slug": "counting-bits", "title": "Counting Bits", "difficulty": "Easy", "content": "Given an integer `n`, return _an array_ `ans` _of length_ `n + 1` _such that for each_ `i` (`0 <= i <= n`)_,_ `ans[i]` _is the **number of**_ `1`_**'s** in the binary representation of_ `i`.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[0,1,1\\]\n**Explanation:**\n0 --> 0\n1 --> 1\n2 --> 10\n\n**Example 2:**\n\n**Input:** n = 5\n**Output:** \\[0,1,1,2,1,2\\]\n**Explanation:**\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\n\n**Constraints:**\n\n*   `0 <= n <= 105`\n\n**Follow up:**\n\n*   It is very easy to come up with a solution with a runtime of `O(n log n)`. Can you do it in linear time `O(n)` and possibly in a single pass?\n*   Can you do it without using any built-in function (i.e., like `__builtin_popcount` in C++)?", "java": "\n    ```java\npublic int[] countBits(int n) {\n    int[] ans = new int[n + 1];\n    for (int i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> countBits(int n) {\n    vector<int> ans(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    ", "python": "\n    ```python\ndef countBits(n):\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i & (i - 1)] + 1\n    return ans\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    ", "javascript": "\n    ```javascript\nfunction countBits(n) {\n    const ans = new Array(n + 1).fill(0);\n    for (let i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    "}
{"id": 343, "slug": "integer-break", "title": "Integer Break", "difficulty": "Medium", "content": "Given an integer `n`, break it into the sum of `k` **positive integers**, where `k >= 2`, and maximize the product of those integers.\n\nReturn _the maximum product you can get_.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** 2 = 1 + 1, 1 \\* 1 = 1.\n\n**Example 2:**\n\n**Input:** n = 10\n**Output:** 36\n**Explanation:** 10 = 3 + 3 + 4, 3 \\* 3 \\* 4 = 36.\n\n**Constraints:**\n\n*   `2 <= n <= 58`", "java": "\n    ```java\npublic int integerBreak(int n) {\n    if (n <= 3) return n - 1;\n    int product = 1;\n    while (n > 4) {\n        product *= 3;\n        n -= 3;\n    }\n    return product * n;\n}\n```\n    \n    The algorithm is based on the fact that the optimal factorization for the integer n consists of as many 3s as possible, and maybe a 2 or a 4. If we have a factor composed of five 1s, we can always break it into two 2s and a 3, which has a larger product (2 * 2 * 3 > 1 * 1 * 1 * 1 * 1). This means that the factors included in the final product will never be smaller than 2.\n\nThe solution is to repeatedly subtract 3 from the given number `n` and multiply the product by 3. If we end up with `n` being 2, 3, or 4 after this process, we multiply the product by `n` and return it.\n\nThis solution runs in O(n) time complexity.\n    ", "c++": "\n    ```cpp\nint integerBreak(int n) {\n    if (n <= 3) return n - 1;\n    int product = 1;\n    while (n > 4) {\n        product *= 3;\n        n -= 3;\n    }\n    return product * n;\n}\n```\n    \n    The algorithm is based on the fact that the optimal factorization for the integer n consists of as many 3s as possible, and maybe a 2 or a 4. If we have a factor composed of five 1s, we can always break it into two 2s and a 3, which has a larger product (2 * 2 * 3 > 1 * 1 * 1 * 1 * 1). This means that the factors included in the final product will never be smaller than 2.\n\nThe solution is to repeatedly subtract 3 from the given number `n` and multiply the product by 3. If we end up with `n` being 2, 3, or 4 after this process, we multiply the product by `n` and return it.\n\nThis solution runs in O(n) time complexity.\n    ", "python": "\n    ```python\ndef integer_break(n):\n    if n <= 3:\n        return n - 1\n    product = 1\n    while n > 4:\n        product *= 3\n        n -= 3\n    return product * n\n```\n    \n    The algorithm is based on the fact that the optimal factorization for the integer n consists of as many 3s as possible, and maybe a 2 or a 4. If we have a factor composed of five 1s, we can always break it into two 2s and a 3, which has a larger product (2 * 2 * 3 > 1 * 1 * 1 * 1 * 1). This means that the factors included in the final product will never be smaller than 2.\n\nThe solution is to repeatedly subtract 3 from the given number `n` and multiply the product by 3. If we end up with `n` being 2, 3, or 4 after this process, we multiply the product by `n` and return it.\n\nThis solution runs in O(n) time complexity.\n    ", "javascript": "\n    ```javascript\nfunction integerBreak(n) {\n    if (n <= 3) return n - 1;\n    let product = 1;\n    while (n > 4) {\n        product *= 3;\n        n -= 3;\n    }\n    return product * n;\n}\n```\n    \n    The algorithm is based on the fact that the optimal factorization for the integer n consists of as many 3s as possible, and maybe a 2 or a 4. If we have a factor composed of five 1s, we can always break it into two 2s and a 3, which has a larger product (2 * 2 * 3 > 1 * 1 * 1 * 1 * 1). This means that the factors included in the final product will never be smaller than 2.\n\nThe solution is to repeatedly subtract 3 from the given number `n` and multiply the product by 3. If we end up with `n` being 2, 3, or 4 after this process, we multiply the product by `n` and return it.\n\nThis solution runs in O(n) time complexity.\n    "}
{"id": 354, "slug": "russian-doll-envelopes", "title": "Russian Doll Envelopes", "difficulty": "Hard", "content": "You are given a 2D array of integers `envelopes` where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn _the maximum number of envelopes you can Russian doll (i.e., put one inside the other)_.\n\n**Note:** You cannot rotate an envelope.\n\n**Example 1:**\n\n**Input:** envelopes = \\[\\[5,4\\],\\[6,4\\],\\[6,7\\],\\[2,3\\]\\]\n**Output:** 3\n**Explanation:** The maximum number of envelopes you can Russian doll is `3` (\\[2,3\\] => \\[5,4\\] => \\[6,7\\]).\n\n**Example 2:**\n\n**Input:** envelopes = \\[\\[1,1\\],\\[1,1\\],\\[1,1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= envelopes.length <= 105`\n*   `envelopes[i].length == 2`\n*   `1 <= wi, hi <= 105`", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int maxEnvelopes(int[][] envelopes) {\n    Arrays.sort(envelopes, new Comparator<int[]>() {\n        public int compare(int[] a, int[] b) {\n            return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];\n        }\n    });\n\n    int[] dp = new int[envelopes.length];\n    int len = 0;\n    for (int[] envelope : envelopes) {\n        int idx = Arrays.binarySearch(dp, 0, len, envelope[1]);\n        if (idx < 0) {\n            idx = -(idx + 1);\n        }\n        dp[idx] = envelope[1];\n        if (idx == len) {\n            len++;\n        }\n    }\n\n    return len;\n}\n```\n    \n    1. Sort the envelopes based on width and in ascending order. If the widths are equal, sort by height in descending order.\n2. Create an empty list `dp` to maintain the increasing subsequence.\n3. Iterate through the sorted envelopes and for each envelope, find the index of the height in `dp` with binary search. If the index is equal to the length of `dp`, append the height to `dp`. Otherwise, replace the element at the index in `dp` with the current height.\n4. The length of `dp` will be the maximum number of envelopes that can be put one inside the other.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxEnvelopes(std::vector<std::vector<int>>& envelopes) {\n    std::sort(envelopes.begin(), envelopes.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\n    });\n    \n    std::vector<int> dp;\n    for (const auto& envelope : envelopes) {\n        auto it = std::lower_bound(dp.begin(), dp.end(), envelope[1]);\n        if (it == dp.end()) {\n            dp.push_back(envelope[1]);\n        } else {\n            *it = envelope[1];\n        }\n    }\n    \n    return dp.size();\n}\n```\n    \n    1. Sort the envelopes based on width and in ascending order. If the widths are equal, sort by height in descending order.\n2. Create an empty list `dp` to maintain the increasing subsequence.\n3. Iterate through the sorted envelopes and for each envelope, find the index of the height in `dp` with binary search. If the index is equal to the length of `dp`, append the height to `dp`. Otherwise, replace the element at the index in `dp` with the current height.\n4. The length of `dp` will be the maximum number of envelopes that can be put one inside the other.\n    ", "python": "\n    ```python\nfrom bisect import bisect_left\n\ndef max_envelopes(envelopes):\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n    \n    for _, h in envelopes:\n        idx = bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)\n        else:\n            dp[idx] = h\n\n    return len(dp)\n```\n    \n    1. Sort the envelopes based on width and in ascending order. If the widths are equal, sort by height in descending order.\n2. Create an empty list `dp` to maintain the increasing subsequence.\n3. Iterate through the sorted envelopes and for each envelope, find the index of the height in `dp` with binary search. If the index is equal to the length of `dp`, append the height to `dp`. Otherwise, replace the element at the index in `dp` with the current height.\n4. The length of `dp` will be the maximum number of envelopes that can be put one inside the other.\n    ", "javascript": "\n    ```javascript\nfunction maxEnvelopes(envelopes) {\n    envelopes.sort((a, b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0]);\n    const dp = [];\n\n    for (const envelope of envelopes) {\n        const idx = lowerBound(dp, envelope[1]);\n        if (idx === dp.length) {\n            dp.push(envelope[1]);\n        } else {\n            dp[idx] = envelope[1];\n        }\n    }\n\n    return dp.length;\n\n    function lowerBound(arr, target) {\n        let low = 0, high = arr.length;\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (arr[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n}\n```\n    \n    1. Sort the envelopes based on width and in ascending order. If the widths are equal, sort by height in descending order.\n2. Create an empty list `dp` to maintain the increasing subsequence.\n3. Iterate through the sorted envelopes and for each envelope, find the index of the height in `dp` with binary search. If the index is equal to the length of `dp`, append the height to `dp`. Otherwise, replace the element at the index in `dp` with the current height.\n4. The length of `dp` will be the maximum number of envelopes that can be put one inside the other.\n    "}
{"id": 357, "slug": "count-numbers-with-unique-digits", "title": "Count Numbers with Unique Digits", "difficulty": "Medium", "content": "Given an integer `n`, return the count of all numbers with unique digits, `x`, where `0 <= x < 10n`.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 91\n**Explanation:** The answer should be the total numbers in the range of 0 <= x < 100, excluding 11,22,33,44,55,66,77,88,99\n\n**Example 2:**\n\n**Input:** n = 0\n**Output:** 1\n\n**Constraints:**\n\n*   `0 <= n <= 8`", "java": "\n    ```java\npublic int countNumbersWithUniqueDigits(int n) {\n    if (n == 0) return 1;\n\n    int total = 10;\n    int uniqueDigits = 9;\n    int currentAvailableDigits = 9;\n\n    while (n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned.\n    ", "c++": "\n    ```cpp\nint countNumbersWithUniqueDigits(int n) {\n    if (n == 0) return 1;\n    \n    int total = 10;\n    int uniqueDigits = 9;\n    int currentAvailableDigits = 9;\n    \n    while(n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n    \n    return total;\n}\n```\n\n    \n    The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned.\n    ", "python": "\n    ```python\ndef countNumbersWithUniqueDigits(n):\n    if n == 0:\n        return 1\n    \n    total = 10\n    unique_digits = 9\n    current_available_digits = 9\n    \n    while n > 1 and current_available_digits > 0:\n        unique_digits *= current_available_digits\n        total += unique_digits\n        current_available_digits -= 1\n        n -= 1\n        \n    return total\n```\n\n    \n    The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned.\n    ", "javascript": "\n    ```javascript\nfunction countNumbersWithUniqueDigits(n) {\n    if (n === 0) return 1;\n\n    let total = 10;\n    let uniqueDigits = 9;\n    let currentAvailableDigits = 9;\n\n    while (n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned.\n    "}
{"id": 368, "slug": "largest-divisible-subset", "title": "Largest Divisible Subset", "difficulty": "Medium", "content": "Given a set of **distinct** positive integers `nums`, return the largest subset `answer` such that every pair `(answer[i], answer[j])` of elements in this subset satisfies:\n\n*   `answer[i] % answer[j] == 0`, or\n*   `answer[j] % answer[i] == 0`\n\nIf there are multiple solutions, return any of them.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[1,2\\]\n**Explanation:** \\[1,3\\] is also accepted.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,4,8\\]\n**Output:** \\[1,2,4,8\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 2 * 109`\n*   All the integers in `nums` are **unique**.", "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> largestDivisibleSubset(int[] nums) {\n    Arrays.sort(nums);\n    int n = nums.length;\n    int[] count = new int[n];\n    int[] prev = new int[n];\n    int max_idx = 0;\n    Arrays.fill(prev, -1);\n    Arrays.fill(count, 1);\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] % nums[j] == 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) max_idx = i;\n    }\n\n    List<Integer> res = new ArrayList<>();\n    for (int i = max_idx; i >= 0; i = prev[i]) {\n        res.add(nums[i]);\n    }\n\n    return res;\n}\n```\n    \n    1. Sort the input array.\n2. Initialize two arrays: count and prev, both with the same length as the input array.\n   - count will store the length of the largest subsets ending at index i.\n   - prev stores the index of the previous element in the largest subset.\n3. Initialize max_idx to store the index of the maximum count.\n4. Loop through the sorted array, and for each element, compare it with its previous elements.\n   - If it is divisible by the previous element, update the count and prev arrays accordingly.\n5. After looping and updating the arrays, use max_idx to trace back the elements forming the largest subset.\n6. Return the largest subset.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> largestDivisibleSubset(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    vector<int> count(n, 1), prev(n, -1), res;\n    int max_idx = 0;\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] % nums[j] == 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) max_idx = i;\n    }\n\n    for (int i = max_idx; i >= 0; i = prev[i]) {\n        res.push_back(nums[i]);\n    }\n\n    return res;\n}\n```\n    \n    1. Sort the input array.\n2. Initialize two arrays: count and prev, both with the same length as the input array.\n   - count will store the length of the largest subsets ending at index i.\n   - prev stores the index of the previous element in the largest subset.\n3. Initialize max_idx to store the index of the maximum count.\n4. Loop through the sorted array, and for each element, compare it with its previous elements.\n   - If it is divisible by the previous element, update the count and prev arrays accordingly.\n5. After looping and updating the arrays, use max_idx to trace back the elements forming the largest subset.\n6. Return the largest subset.\n    ", "python": "\n    ```python\ndef largestDivisibleSubset(nums):\n    nums.sort()\n    n = len(nums)\n    count = [1] * n\n    prev = [-1] * n\n\n    max_idx = 0\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and count[i] < count[j] + 1:\n                count[i] = count[j] + 1\n                prev[i] = j\n        if count[max_idx] < count[i]:\n            max_idx = i\n\n    res = []\n    i = max_idx\n    while i >= 0:\n        res.append(nums[i])\n        i = prev[i]\n\n    return res\n```\n    \n    1. Sort the input array.\n2. Initialize two arrays: count and prev, both with the same length as the input array.\n   - count will store the length of the largest subsets ending at index i.\n   - prev stores the index of the previous element in the largest subset.\n3. Initialize max_idx to store the index of the maximum count.\n4. Loop through the sorted array, and for each element, compare it with its previous elements.\n   - If it is divisible by the previous element, update the count and prev arrays accordingly.\n5. After looping and updating the arrays, use max_idx to trace back the elements forming the largest subset.\n6. Return the largest subset.\n    ", "javascript": "\n    ```javascript\nfunction largestDivisibleSubset(nums) {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    const count = new Array(n).fill(1);\n    const prev = new Array(n).fill(-1);\n    let max_idx = 0;\n\n    for (let i = 1; i < n; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] % nums[j] === 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) {\n            max_idx = i;\n        }\n    }\n\n    const res = [];\n    for (let i = max_idx; i >= 0; i = prev[i]) {\n        res.push(nums[i]);\n    }\n\n    return res;\n}\n```\n    \n    1. Sort the input array.\n2. Initialize two arrays: count and prev, both with the same length as the input array.\n   - count will store the length of the largest subsets ending at index i.\n   - prev stores the index of the previous element in the largest subset.\n3. Initialize max_idx to store the index of the maximum count.\n4. Loop through the sorted array, and for each element, compare it with its previous elements.\n   - If it is divisible by the previous element, update the count and prev arrays accordingly.\n5. After looping and updating the arrays, use max_idx to trace back the elements forming the largest subset.\n6. Return the largest subset.\n    "}
{"id": 375, "slug": "guess-number-higher-or-lower-ii", "title": "Guess Number Higher or Lower II", "difficulty": "Medium", "content": "We are playing the Guessing Game. The game will work as follows:\n\n1.  I pick a number between `1` and `n`.\n2.  You guess a number.\n3.  If you guess the right number, **you win the game**.\n4.  If you guess the wrong number, then I will tell you whether the number I picked is **higher or lower**, and you will continue guessing.\n5.  Every time you guess a wrong number `x`, you will pay `x` dollars. If you run out of money, **you lose the game**.\n\nGiven a particular `n`, return _the minimum amount of money you need to **guarantee a win regardless of what number I pick**_.\n\n**Example 1:**\n\n**Input:** n = 10\n**Output:** 16\n**Explanation:** The winning strategy is as follows:\n- The range is \\[1,10\\]. Guess 7.\n    - If this is my number, your total is $0. Otherwise, you pay $7.\n    - If my number is higher, the range is \\[8,10\\]. Guess 9.\n        - If this is my number, your total is $7. Otherwise, you pay $9.\n        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n    - If my number is lower, the range is \\[1,6\\]. Guess 3.\n        - If this is my number, your total is $7. Otherwise, you pay $3.\n        - If my number is higher, the range is \\[4,6\\]. Guess 5.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n        - If my number is lower, the range is \\[1,2\\]. Guess 1.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\nThe worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 0\n**Explanation:** There is only one possible number, so you can guess 1 and not have to pay anything.\n\n**Example 3:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** There are two possible numbers, 1 and 2.\n- Guess 1.\n    - If this is my number, your total is $0. Otherwise, you pay $1.\n    - If my number is higher, it must be 2. Guess 2. Your total is $1.\nThe worst case is that you pay $1.\n\n**Constraints:**\n\n*   `1 <= n <= 200`", "java": "\n    ```java\npublic int getMoneyAmount(int n) {\n    int[][] dp = new int[n + 1][n + 1];\n    for (int i = n - 1; i >= 1; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int min_cost = Integer.MAX_VALUE;\n            for (int k = i; k < j; k++) {\n                int cost = k + Math.max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = Math.min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum cost required to guarantee a win. We create a 2D array `dp` where `dp[i][j]` represents the minimum cost required to guess the correct number from numbers between i and j inclusive.\n\nWe fill in this array from the bottom right corner, and move towards the top left corner. For each value of `i` and `j`, we calculate the cost by guessing a number `k` between `i` and `j`. The cost is equal to `k + max(dp[i][k-1], dp[k+1][j])`, which means that we pay `k` and take the worst-case scenario, and we try to minimize this cost.\n\nAfter filling the `dp` array, the minimum cost required to win the game when guessing numbers from 1 to `n` is stored in `dp[1][n]`.\n    ", "c++": "\n    ```cpp\nint getMoneyAmount(int n) {\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    for (int i = n - 1; i >= 1; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int min_cost = INT_MAX;\n            for (int k = i; k < j; k++) {\n                int cost = k + max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum cost required to guarantee a win. We create a 2D array `dp` where `dp[i][j]` represents the minimum cost required to guess the correct number from numbers between i and j inclusive.\n\nWe fill in this array from the bottom right corner, and move towards the top left corner. For each value of `i` and `j`, we calculate the cost by guessing a number `k` between `i` and `j`. The cost is equal to `k + max(dp[i][k-1], dp[k+1][j])`, which means that we pay `k` and take the worst-case scenario, and we try to minimize this cost.\n\nAfter filling the `dp` array, the minimum cost required to win the game when guessing numbers from 1 to `n` is stored in `dp[1][n]`.\n    ", "python": "\n    ```python\ndef getMoneyAmount(n: int) -> int:\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, 0, -1):\n        for j in range(i + 1, n + 1):\n            min_cost = float(\"inf\")\n            for k in range(i, j):\n                cost = k + max(dp[i][k - 1], dp[k + 1][j])\n                min_cost = min(min_cost, cost)\n            dp[i][j] = min_cost\n    return dp[1][n]\n```\n    \n    The algorithm uses dynamic programming to find the minimum cost required to guarantee a win. We create a 2D array `dp` where `dp[i][j]` represents the minimum cost required to guess the correct number from numbers between i and j inclusive.\n\nWe fill in this array from the bottom right corner, and move towards the top left corner. For each value of `i` and `j`, we calculate the cost by guessing a number `k` between `i` and `j`. The cost is equal to `k + max(dp[i][k-1], dp[k+1][j])`, which means that we pay `k` and take the worst-case scenario, and we try to minimize this cost.\n\nAfter filling the `dp` array, the minimum cost required to win the game when guessing numbers from 1 to `n` is stored in `dp[1][n]`.\n    ", "javascript": "\n    ```javascript\nfunction getMoneyAmount(n) {\n    const dp = Array.from(Array(n + 1), () => Array(n + 1).fill(0));\n    for (let i = n - 1; i >= 1; i--) {\n        for (let j = i + 1; j <= n; j++) {\n            let min_cost = Infinity;\n            for (let k = i; k < j; k++) {\n                const cost = k + Math.max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = Math.min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum cost required to guarantee a win. We create a 2D array `dp` where `dp[i][j]` represents the minimum cost required to guess the correct number from numbers between i and j inclusive.\n\nWe fill in this array from the bottom right corner, and move towards the top left corner. For each value of `i` and `j`, we calculate the cost by guessing a number `k` between `i` and `j`. The cost is equal to `k + max(dp[i][k-1], dp[k+1][j])`, which means that we pay `k` and take the worst-case scenario, and we try to minimize this cost.\n\nAfter filling the `dp` array, the minimum cost required to win the game when guessing numbers from 1 to `n` is stored in `dp[1][n]`.\n    "}
{"id": 376, "slug": "wiggle-subsequence", "title": "Wiggle Subsequence", "difficulty": "Medium", "content": "A **wiggle sequence** is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n\n*   For example, `[1, 7, 4, 9, 2, 5]` is a **wiggle sequence** because the differences `(6, -3, 5, -7, 3)` alternate between positive and negative.\n*   In contrast, `[1, 4, 7, 2, 5]` and `[1, 7, 4, 5, 5]` are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\n\nA **subsequence** is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\n\nGiven an integer array `nums`, return _the length of the longest **wiggle subsequence** of_ `nums`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,7,4,9,2,5\\]\n**Output:** 6\n**Explanation:** The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\n\n**Example 2:**\n\n**Input:** nums = \\[1,17,5,10,13,15,10,5,16,8\\]\n**Output:** 7\n**Explanation:** There are several subsequences that achieve this length.\nOne is \\[1, 17, 10, 13, 10, 16, 8\\] with differences (16, -7, 3, -3, 6, -8).\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7,8,9\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 1000`\n\n**Follow up:** Could you solve this in `O(n)` time?", "java": "\n    ```java\npublic int wiggleMaxLength(int[] nums) {\n    int len = nums.length;\n    if (len < 2) return len;\n\n    int up = 1, down = 1;\n    for (int i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return Math.max(up, down);\n}\n```\n    \n    The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory.\n    ", "c++": "\n    ```cpp\nint wiggleMaxLength(vector<int>& nums) {\n    int len = nums.size();\n    if (len < 2) return len;\n\n    int up = 1, down = 1;\n    for (int i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return max(up, down);\n}\n```\n    \n    The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory.\n    ", "python": "\n    ```python\ndef wiggleMaxLength(nums):\n    if len(nums) < 2:\n        return len(nums)\n\n    up, down = 1, 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)\n```\n    \n    The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory.\n    ", "javascript": "\n    ```javascript\nfunction wiggleMaxLength(nums) {\n    let len = nums.length;\n    if (len < 2) return len;\n\n    let up = 1, down = 1;\n    for (let i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return Math.max(up, down);\n}\n```\n    \n    The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory.\n    "}
{"id": 377, "slug": "combination-sum-iv", "title": "Combination Sum IV", "difficulty": "Medium", "content": "Given an array of **distinct** integers `nums` and a target integer `target`, return _the number of possible combinations that add up to_ `target`.\n\nThe test cases are generated so that the answer can fit in a **32-bit** integer.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\], target = 4\n**Output:** 7\n**Explanation:**\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.\n\n**Example 2:**\n\n**Input:** nums = \\[9\\], target = 3\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `1 <= nums[i] <= 1000`\n*   All the elements of `nums` are **unique**.\n*   `1 <= target <= 1000`\n\n**Follow up:** What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?", "java": "\n    ```java\npublic int combinationSum(int[] nums, int target) {\n    int[] dp = new int[target + 1];\n    dp[0] = 1;\n\n    for(int num : nums) {\n        for(int i = num; i <= target; i++) {\n            dp[i] += dp[i - num];\n        }\n    }\n\n    return dp[target];\n}\n```\n\n    \n    The basic idea is to use dynamic programming to solve this question. We create an array called \"dp\" with a length of target + 1, initializing all values to 0 except for dp[0], which is set to 1. This is because there is always one way to make a sum of 0.\n\nWe then start iterating through the given `nums` array. For each number in the `nums` array, we iterate from the `num` itself to the `target`. At each step, we add the number of ways we can make the previous sub-target (i.e., `dp[i - num]`) and store this updated count in the `dp[i]`.\n\nFinally, after iterating through all numbers and sub-targets, the value at `dp[target]` will give the number of possible combinations that add up to `target`.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint combinationSum(vector<int>& nums, int target) {\n    vector<int> dp(target + 1, 0);\n    dp[0] = 1;\n    \n    for(int num : nums) {\n        for(int i = num; i <= target; i++) {\n            dp[i] += dp[i - num];\n        }\n    }\n    \n    return dp[target];\n}\n```\n\n    \n    The basic idea is to use dynamic programming to solve this question. We create an array called \"dp\" with a length of target + 1, initializing all values to 0 except for dp[0], which is set to 1. This is because there is always one way to make a sum of 0.\n\nWe then start iterating through the given `nums` array. For each number in the `nums` array, we iterate from the `num` itself to the `target`. At each step, we add the number of ways we can make the previous sub-target (i.e., `dp[i - num]`) and store this updated count in the `dp[i]`.\n\nFinally, after iterating through all numbers and sub-targets, the value at `dp[target]` will give the number of possible combinations that add up to `target`.\n    ", "python": "\n    ```python\ndef combination_sum(nums, target):\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]\n```\n\n    \n    The basic idea is to use dynamic programming to solve this question. We create an array called \"dp\" with a length of target + 1, initializing all values to 0 except for dp[0], which is set to 1. This is because there is always one way to make a sum of 0.\n\nWe then start iterating through the given `nums` array. For each number in the `nums` array, we iterate from the `num` itself to the `target`. At each step, we add the number of ways we can make the previous sub-target (i.e., `dp[i - num]`) and store this updated count in the `dp[i]`.\n\nFinally, after iterating through all numbers and sub-targets, the value at `dp[target]` will give the number of possible combinations that add up to `target`.\n    ", "javascript": "\n    ```javascript\nfunction combinationSum(nums, target) {\n    let dp = new Array(target + 1).fill(0);\n    dp[0] = 1;\n\n    for(let num of nums) {\n        for(let i = num; i <= target; i++) {\n            dp[i] += dp[i - num];\n        }\n    }\n\n    return dp[target];\n}\n```\n\n    \n    The basic idea is to use dynamic programming to solve this question. We create an array called \"dp\" with a length of target + 1, initializing all values to 0 except for dp[0], which is set to 1. This is because there is always one way to make a sum of 0.\n\nWe then start iterating through the given `nums` array. For each number in the `nums` array, we iterate from the `num` itself to the `target`. At each step, we add the number of ways we can make the previous sub-target (i.e., `dp[i - num]`) and store this updated count in the `dp[i]`.\n\nFinally, after iterating through all numbers and sub-targets, the value at `dp[target]` will give the number of possible combinations that add up to `target`.\n    "}
{"id": 392, "slug": "is-subsequence", "title": "Is Subsequence", "difficulty": "Easy", "content": "Given two strings `s` and `t`, return `true` _if_ `s` _is a **subsequence** of_ `t`_, or_ `false` _otherwise_.\n\nA **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not).\n\n**Example 1:**\n\n**Input:** s = \"abc\", t = \"ahbgdc\"\n**Output:** true\n\n**Example 2:**\n\n**Input:** s = \"axc\", t = \"ahbgdc\"\n**Output:** false\n\n**Constraints:**\n\n*   `0 <= s.length <= 100`\n*   `0 <= t.length <= 104`\n*   `s` and `t` consist only of lowercase English letters.\n\n**Follow up:** Suppose there are lots of incoming `s`, say `s1, s2, ..., sk` where `k >= 109`, and you want to check one by one to see if `t` has its subsequence. In this scenario, how would you change your code?", "java": "\n    ```java\nboolean isSubsequence(String s, String t) {\n    int si = 0, ti = 0;\n\n    while (si < s.length() && ti < t.length()) {\n        if (s.charAt(si) == t.charAt(ti))\n            si++;\n        ti++;\n    }\n\n    return si == s.length();\n}\n```\n\n    \n    We use two pointers to iterate through the strings `s` and `t`. The `si` pointer will be used to iterate through the string `s` and the `ti` pointer will be used for `t`. \n\nAt each iteration of the loop, if the character at the current position of both strings is the same, we increment the `si` pointer. We will always increment the `ti` pointer.\n\nThe loop will continue until we have checked all the characters in the `s` string or until we have checked all the characters in the `t` string. If the `si` pointer is equal to the length of the `s` string, it means we've found all the characters in the `t` string and the function returns true. Otherwise, it returns false.\n\nThis algorithm runs with a time complexity of O(max(n, m)) where n and m are the lengths of the strings s and t, respectively.\n    ", "c++": "\n    ```cpp\nbool isSubsequence(std::string s, std::string t) {\n    int si = 0, ti = 0;\n\n    while (si < s.size() && ti < t.size()) {\n        if (s[si] == t[ti])\n            si++;\n        ti++;\n    }\n\n    return si == s.size();\n}\n```\n\n    \n    We use two pointers to iterate through the strings `s` and `t`. The `si` pointer will be used to iterate through the string `s` and the `ti` pointer will be used for `t`. \n\nAt each iteration of the loop, if the character at the current position of both strings is the same, we increment the `si` pointer. We will always increment the `ti` pointer.\n\nThe loop will continue until we have checked all the characters in the `s` string or until we have checked all the characters in the `t` string. If the `si` pointer is equal to the length of the `s` string, it means we've found all the characters in the `t` string and the function returns true. Otherwise, it returns false.\n\nThis algorithm runs with a time complexity of O(max(n, m)) where n and m are the lengths of the strings s and t, respectively.\n    ", "python": "\n    ```python\ndef is_subsequence(s, t):\n    si, ti = 0, 0\n\n    while si < len(s) and ti < len(t):\n        if s[si] == t[ti]:\n            si += 1\n        ti += 1\n\n    return si == len(s)\n```\n\n    \n    We use two pointers to iterate through the strings `s` and `t`. The `si` pointer will be used to iterate through the string `s` and the `ti` pointer will be used for `t`. \n\nAt each iteration of the loop, if the character at the current position of both strings is the same, we increment the `si` pointer. We will always increment the `ti` pointer.\n\nThe loop will continue until we have checked all the characters in the `s` string or until we have checked all the characters in the `t` string. If the `si` pointer is equal to the length of the `s` string, it means we've found all the characters in the `t` string and the function returns true. Otherwise, it returns false.\n\nThis algorithm runs with a time complexity of O(max(n, m)) where n and m are the lengths of the strings s and t, respectively.\n    ", "javascript": "\n    ```javascript\nfunction isSubsequence(s, t) {\n    let si = 0, ti = 0;\n\n    while (si < s.length && ti < t.length) {\n        if (s[si] === t[ti])\n            si++;\n        ti++;\n    }\n\n    return si === s.length;\n}\n```\n\n    \n    We use two pointers to iterate through the strings `s` and `t`. The `si` pointer will be used to iterate through the string `s` and the `ti` pointer will be used for `t`. \n\nAt each iteration of the loop, if the character at the current position of both strings is the same, we increment the `si` pointer. We will always increment the `ti` pointer.\n\nThe loop will continue until we have checked all the characters in the `s` string or until we have checked all the characters in the `t` string. If the `si` pointer is equal to the length of the `s` string, it means we've found all the characters in the `t` string and the function returns true. Otherwise, it returns false.\n\nThis algorithm runs with a time complexity of O(max(n, m)) where n and m are the lengths of the strings s and t, respectively.\n    "}
{"id": 396, "slug": "rotate-function", "title": "Rotate Function", "difficulty": "Medium", "content": "You are given an integer array `nums` of length `n`.\n\nAssume `arrk` to be an array obtained by rotating `nums` by `k` positions clock-wise. We define the **rotation function** `F` on `nums` as follow:\n\n*   `F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].`\n\nReturn _the maximum value of_ `F(0), F(1), ..., F(n-1)`.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.\n\n**Example 1:**\n\n**Input:** nums = \\[4,3,2,6\\]\n**Output:** 26\n**Explanation:**\nF(0) = (0 \\* 4) + (1 \\* 3) + (2 \\* 2) + (3 \\* 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 \\* 6) + (1 \\* 4) + (2 \\* 3) + (3 \\* 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 \\* 2) + (1 \\* 6) + (2 \\* 4) + (3 \\* 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 \\* 3) + (1 \\* 2) + (2 \\* 6) + (3 \\* 4) = 0 + 2 + 12 + 12 = 26\nSo the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\n\n**Example 2:**\n\n**Input:** nums = \\[100\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `-100 <= nums[i] <= 100`", "java": "\n    ```java\npublic int maxRotateFunction(int[] nums) {\n    int n = nums.length;\n    int total_sum = 0;\n    int f = 0;\n\n    for (int i = 0; i < n; i++) {\n        total_sum += nums[i];\n        f += i * nums[i];\n    }\n\n    int max_f = f;\n    for (int i = 1; i < n; i++) {\n        f += total_sum - (n * nums[n - i]);\n        max_f = Math.max(max_f, f);\n    }\n\n    return max_f;\n}\n```\n\n    \n    1. Calculate the total_sum of elements in the given array.\n2. Calculate the initial value of the rotation function F(0) and assign it to f.\n3. Initialize max_f with the value of f.\n4. Iterate through the array with index i from 1 to n-1.\n5. For each iteration, calculate the value of the rotation function F(i) by adding total_sum to the previous value of the rotation function and subtracting the product of n and nums[n - i]. Update f with the new value.\n6. Compare the new value of f with max_f and update max_f with the maximum value.\n7. Return max_f after finishing the loop.\n    ", "c++": "\n    ```cpp\nint maxRotateFunction(vector<int>& nums) {\n    int n = nums.size();\n    int total_sum = 0;\n    int f = 0;\n\n    for (int i = 0; i < n; i++) {\n        total_sum += nums[i];\n        f += i * nums[i];\n    }\n\n    int max_f = f;\n    for (int i = 1; i < n; i++) {\n        f += total_sum - n * nums[n - i];\n        max_f = max(max_f, f);\n    }\n\n    return max_f;\n}\n```\n\n    \n    1. Calculate the total_sum of elements in the given array.\n2. Calculate the initial value of the rotation function F(0) and assign it to f.\n3. Initialize max_f with the value of f.\n4. Iterate through the array with index i from 1 to n-1.\n5. For each iteration, calculate the value of the rotation function F(i) by adding total_sum to the previous value of the rotation function and subtracting the product of n and nums[n - i]. Update f with the new value.\n6. Compare the new value of f with max_f and update max_f with the maximum value.\n7. Return max_f after finishing the loop.\n    ", "python": "\n    ```python\ndef maxRotateFunction(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n    f = sum(i * num for i, num in enumerate(nums))\n\n    max_f = f\n    for i in range(1, n):\n        f += total_sum - n * nums[-i]\n        max_f = max(max_f, f)\n\n    return max_f\n```\n\n    \n    1. Calculate the total_sum of elements in the given array.\n2. Calculate the initial value of the rotation function F(0) and assign it to f.\n3. Initialize max_f with the value of f.\n4. Iterate through the array with index i from 1 to n-1.\n5. For each iteration, calculate the value of the rotation function F(i) by adding total_sum to the previous value of the rotation function and subtracting the product of n and nums[n - i]. Update f with the new value.\n6. Compare the new value of f with max_f and update max_f with the maximum value.\n7. Return max_f after finishing the loop.\n    ", "javascript": "\n    ```javascript\nfunction maxRotateFunction(nums) {\n    let n = nums.length;\n    let total_sum = nums.reduce((a, b) => a + b, 0);\n    let f = nums.reduce((acc, val, i) => acc + i * val, 0);\n\n    let max_f = f;\n    for (let i = 1; i < n; i++) {\n        f += total_sum - n * nums[n - i];\n        max_f = Math.max(max_f, f);\n    }\n\n    return max_f;\n}\n```\n\n    \n    1. Calculate the total_sum of elements in the given array.\n2. Calculate the initial value of the rotation function F(0) and assign it to f.\n3. Initialize max_f with the value of f.\n4. Iterate through the array with index i from 1 to n-1.\n5. For each iteration, calculate the value of the rotation function F(i) by adding total_sum to the previous value of the rotation function and subtracting the product of n and nums[n - i]. Update f with the new value.\n6. Compare the new value of f with max_f and update max_f with the maximum value.\n7. Return max_f after finishing the loop.\n    "}
{"id": 397, "slug": "integer-replacement", "title": "Integer Replacement", "difficulty": "Medium", "content": "Given a positive integer `n`, you can apply one of the following operations:\n\n1.  If `n` is even, replace `n` with `n / 2`.\n2.  If `n` is odd, replace `n` with either `n + 1` or `n - 1`.\n\nReturn _the minimum number of operations needed for_ `n` _to become_ `1`.\n\n**Example 1:**\n\n**Input:** n = 8\n**Output:** 3\n**Explanation:** 8 -> 4 -> 2 -> 1\n\n**Example 2:**\n\n**Input:** n = 7\n**Output:** 4\n**Explanation:** 7 -> 8 -> 4 -> 2 -> 1\nor 7 -> 6 -> 3 -> 2 -> 1\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`", "java": "\n    ```java\nint minOperations(int n) {\n    int steps = 0;\n    while(n > 1) {\n        n = (n % 2 == 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ", "c++": "\n    ```cpp\nint minOperations(int n) {\n    int steps = 0;\n    while(n > 1) {\n        n = (n % 2 == 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ", "python": "\n    ```python\ndef min_operations(n):\n    steps = 0\n    while n > 1:\n        n = n // 2 if n % 2 == 0 else n - 1\n        steps += 1\n    return steps\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ", "javascript": "\n    ```javascript\nfunction minOperations(n) {\n    let steps = 0;\n    while(n > 1) {\n        n = (n % 2 === 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    "}
{"id": 403, "slug": "frog-jump", "title": "Frog Jump", "difficulty": "Hard", "content": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n\nGiven a list of `stones`' positions (in units) in sorted **ascending order**, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be `1` unit.\n\nIf the frog's last jump was `k` units, its next jump must be either `k - 1`, `k`, or `k + 1` units. The frog can only jump in the forward direction.\n\n**Example 1:**\n\n**Input:** stones = \\[0,1,3,5,6,8,12,17\\]\n**Output:** true\n**Explanation:** The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n\n**Example 2:**\n\n**Input:** stones = \\[0,1,2,3,4,8,9,11\\]\n**Output:** false\n**Explanation:** There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n\n**Constraints:**\n\n*   `2 <= stones.length <= 2000`\n*   `0 <= stones[i] <= 231 - 1`\n*   `stones[0] == 0`\n*   `stones` is sorted in a strictly increasing order.", "java": "\n    ```java\nimport java.util.*;\n\npublic boolean canCross(int[] stones) {\n    Map<Integer, Set<Integer>> dp = new HashMap<>();\n    for (int stone : stones)\n        dp.put(stone, new HashSet<>());\n    dp.get(0).add(0);\n\n    for (int stone : stones) {\n        for (int k : dp.get(stone)) {\n            for (int jump : new int[]{k - 1, k, k + 1}) {\n                if (jump > 0 && dp.containsKey(stone + jump))\n                    dp.get(stone + jump).add(jump);\n            }\n        }\n    }\n    return !dp.get(stones[stones.length - 1]).isEmpty();\n}\n```\n\n    \n    The algorithm initializes an empty hash map `dp` with a key for each stone position and the values set to be an empty set. We then add the initial jump (0) to the first stone in the `dp` hash map. The algorithm proceeds iteratively for each of the stones. For each stone, the algorithm checks all possible jump lengths (`k`) in the `dp` hash map for the stone. The next possible jumps are then calculated (k - 1, k, and k + 1) and added to their respective stone positions in the `dp` map. This process continues until all stones are traversed. At the end, if the last stone in `dp` map contains any elements, it means the frog can reach the last stone, and the function returns True/True or False. Otherwise, the function returns False/false.\n    ", "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nbool canCross(vector<int>& stones) {\n    unordered_map<int, unordered_set<int>> dp;\n    int n = stones.size();\n    for (int stone : stones)\n        dp[stone] = unordered_set<int>();\n    dp[0].insert(0);\n\n    for (int stone : stones) {\n        for (int k : dp[stone]) {\n            for (int jump : {k - 1, k, k + 1}) {\n                if (jump > 0 && dp.count(stone + jump))\n                    dp[stone + jump].insert(jump);\n            }\n        }\n    }\n    return !dp[stones.back()].empty();\n}\n```\n\n    \n    The algorithm initializes an empty hash map `dp` with a key for each stone position and the values set to be an empty set. We then add the initial jump (0) to the first stone in the `dp` hash map. The algorithm proceeds iteratively for each of the stones. For each stone, the algorithm checks all possible jump lengths (`k`) in the `dp` hash map for the stone. The next possible jumps are then calculated (k - 1, k, and k + 1) and added to their respective stone positions in the `dp` map. This process continues until all stones are traversed. At the end, if the last stone in `dp` map contains any elements, it means the frog can reach the last stone, and the function returns True/True or False. Otherwise, the function returns False/false.\n    ", "python": "\n    ```python\ndef can_cross(stones):\n    dp = {stone: set() for stone in stones}\n    dp[0].add(0)\n\n    for stone in stones:\n        for k in dp[stone]:\n            for jump in (k - 1, k, k + 1):\n                if jump > 0 and stone + jump in dp:\n                    dp[stone + jump].add(jump)\n\n    return bool(dp[stones[-1]])\n```\n\n    \n    The algorithm initializes an empty hash map `dp` with a key for each stone position and the values set to be an empty set. We then add the initial jump (0) to the first stone in the `dp` hash map. The algorithm proceeds iteratively for each of the stones. For each stone, the algorithm checks all possible jump lengths (`k`) in the `dp` hash map for the stone. The next possible jumps are then calculated (k - 1, k, and k + 1) and added to their respective stone positions in the `dp` map. This process continues until all stones are traversed. At the end, if the last stone in `dp` map contains any elements, it means the frog can reach the last stone, and the function returns True/True or False. Otherwise, the function returns False/false.\n    ", "javascript": "\n    ```javascript\nfunction canCross(stones) {\n    const dp = new Map();\n    stones.forEach(stone => dp.set(stone, new Set()));\n    dp.get(0).add(0);\n\n    for (const stone of stones) {\n        for (const k of dp.get(stone)) {\n            for (const jump of [k - 1, k, k + 1]) {\n                if (jump > 0 && dp.has(stone + jump))\n                    dp.get(stone + jump).add(jump);\n            }\n        }\n    }\n    return dp.get(stones[stones.length - 1]).size > 0;\n}\n```\n\n    \n    The algorithm initializes an empty hash map `dp` with a key for each stone position and the values set to be an empty set. We then add the initial jump (0) to the first stone in the `dp` hash map. The algorithm proceeds iteratively for each of the stones. For each stone, the algorithm checks all possible jump lengths (`k`) in the `dp` hash map for the stone. The next possible jumps are then calculated (k - 1, k, and k + 1) and added to their respective stone positions in the `dp` map. This process continues until all stones are traversed. At the end, if the last stone in `dp` map contains any elements, it means the frog can reach the last stone, and the function returns True/True or False. Otherwise, the function returns False/false.\n    "}
{"id": 410, "slug": "split-array-largest-sum", "title": "Split Array Largest Sum", "difficulty": "Hard", "content": "Given an integer array `nums` and an integer `k`, split `nums` into `k` non-empty subarrays such that the largest sum of any subarray is **minimized**.\n\nReturn _the minimized largest sum of the split_.\n\nA **subarray** is a contiguous part of the array.\n\n**Example 1:**\n\n**Input:** nums = \\[7,2,5,10,8\\], k = 2\n**Output:** 18\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[7,2,5\\] and \\[10,8\\], where the largest sum among the two subarrays is only 18.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5\\], k = 2\n**Output:** 9\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[1,2,3\\] and \\[4,5\\], where the largest sum among the two subarrays is only 9.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 106`\n*   `1 <= k <= min(50, nums.length)`", "java": "\n    ```java\npublic int splitArray(int[] nums, int m) {\n    long left = 0, right = 0;\n    for (int num : nums) {\n        left = Math.max(left, num);\n        right += num;\n    }\n\n    while (left < right) {\n        long mid = (left + right) / 2;\n        int count = 1;\n        long curSum = 0;\n        for (int num : nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return (int)left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ", "c++": "\n    ```cpp\nint splitArray(vector<int>& nums, int m) {\n    long long left = 0, right = 0;\n    for (int num : nums) {\n        left = max(left, (long long)num);\n        right += num;\n    }\n\n    while (left < right) {\n        long long mid = (left + right) / 2;\n        int count = 1;\n        long long curSum = 0;\n        for (int num : nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return (int)left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ", "python": "\n    ```python\ndef splitArray(nums, m):\n    left, right = max(nums), sum(nums)\n\n    while left < right:\n        mid = (left + right) // 2\n        count, cur_sum = 1, 0\n        for num in nums:\n            cur_sum += num\n            if cur_sum > mid:\n                cur_sum = num\n                count += 1\n\n        if count > m:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ", "javascript": "\n    ```javascript\nfunction splitArray(nums, m) {\n    let left = 0, right = 0;\n    for (let num of nums) {\n        left = Math.max(left, num);\n        right += num;\n    }\n\n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        let count = 1;\n        let curSum = 0;\n        for (let num of nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    "}
{"id": 413, "slug": "arithmetic-slices", "title": "Arithmetic Slices", "difficulty": "Medium", "content": "An integer array is called arithmetic if it consists of **at least three elements** and if the difference between any two consecutive elements is the same.\n\n*   For example, `[1,3,5,7,9]`, `[7,7,7,7]`, and `[3,-1,-5,-9]` are arithmetic sequences.\n\nGiven an integer array `nums`, return _the number of arithmetic **subarrays** of_ `nums`.\n\nA **subarray** is a contiguous subsequence of the array.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 3\n**Explanation:** We have 3 arithmetic slices in nums: \\[1, 2, 3\\], \\[2, 3, 4\\] and \\[1,2,3,4\\] itself.\n\n**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `-1000 <= nums[i] <= 1000`", "java": "\n    ```java\npublic int numberOfArithmeticSlices(int[] nums) {\n    int n = nums.length, count = 0, cur = 0;\n    for (int i = 2; i < n; ++i) {\n        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\n            cur++;\n            count += cur;\n        } else {\n            cur = 0;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given integer array `nums`. Starting from the third element (index 2), for each element, it checks if the difference between the current and the previous element is the same as the difference between the previous and the element before the previous one. If the differences are the same, that means we have an arithmetic subarray, so we increment the `cur` value to keep track of the consecutive arithmetic subarrays, and then add `cur` to the `count` which tracks the total number of arithmetic subarrays. If the differences are not the same, we reset `cur` to 0. Finally, the `count` is returned as the result.\n    ", "c++": "\n    ```cpp\nint numberOfArithmeticSlices(vector<int>& nums) {\n    int n = nums.size(), count = 0, cur = 0;\n    for (int i = 2; i < n; ++i) {\n        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\n            cur++;\n            count += cur;\n        } else {\n            cur = 0;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given integer array `nums`. Starting from the third element (index 2), for each element, it checks if the difference between the current and the previous element is the same as the difference between the previous and the element before the previous one. If the differences are the same, that means we have an arithmetic subarray, so we increment the `cur` value to keep track of the consecutive arithmetic subarrays, and then add `cur` to the `count` which tracks the total number of arithmetic subarrays. If the differences are not the same, we reset `cur` to 0. Finally, the `count` is returned as the result.\n    ", "python": "\n    ```python\ndef numberOfArithmeticSlices(nums):\n    n = len(nums)\n    count, cur = 0, 0\n    for i in range(2, n):\n        if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n            cur += 1\n            count += cur\n        else:\n            cur = 0\n    return count\n```\n    \n    The algorithm iterates through the given integer array `nums`. Starting from the third element (index 2), for each element, it checks if the difference between the current and the previous element is the same as the difference between the previous and the element before the previous one. If the differences are the same, that means we have an arithmetic subarray, so we increment the `cur` value to keep track of the consecutive arithmetic subarrays, and then add `cur` to the `count` which tracks the total number of arithmetic subarrays. If the differences are not the same, we reset `cur` to 0. Finally, the `count` is returned as the result.\n    ", "javascript": "\n    ```javascript\nfunction numberOfArithmeticSlices(nums) {\n    let n = nums.length, count = 0, cur = 0;\n    for (let i = 2; i < n; ++i) {\n        if (nums[i] - nums[i - 1] === nums[i - 1] - nums[i - 2]) {\n            cur++;\n            count += cur;\n        } else {\n            cur = 0;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given integer array `nums`. Starting from the third element (index 2), for each element, it checks if the difference between the current and the previous element is the same as the difference between the previous and the element before the previous one. If the differences are the same, that means we have an arithmetic subarray, so we increment the `cur` value to keep track of the consecutive arithmetic subarrays, and then add `cur` to the `count` which tracks the total number of arithmetic subarrays. If the differences are not the same, we reset `cur` to 0. Finally, the `count` is returned as the result.\n    "}
{"id": 416, "slug": "partition-equal-subset-sum", "title": "Partition Equal Subset Sum", "difficulty": "Medium", "content": "Given an integer array `nums`, return `true` _if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,11,5\\]\n**Output:** true\n**Explanation:** The array can be partitioned as \\[1, 5, 5\\] and \\[11\\].\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,5\\]\n**Output:** false\n**Explanation:** The array cannot be partitioned into equal sum subsets.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `1 <= nums[i] <= 100`", "java": "\n    ```java\npublic boolean canPartition(int[] nums) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    \n    if (sum % 2 != 0) return false;\n    \n    int target = sum / 2;\n    boolean[] dp = new boolean[target + 1];\n    dp[0] = true;\n    \n    for (int num : nums) {\n        for (int i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}\n```\n    \n    The algorithm is using Dynamic Programming to solve the partition problem. To determine if the array can be divided into two subsets with equal sum, first find the total sum of the array. If the total sum is odd, it's not possible to divide it into two equal subsets, so return false. If the total sum is even, find the target sum by dividing the total sum by 2.\n\nThe key idea is to find if there is a subset whose sum is equal to the target sum. Create a boolean dp array, where dp[i] represents if there is a subset with sum i. Initialize dp[0] to true, since the sum of 0 can be achieved with an empty subset.\n\nIterate through each number in the array, and for each number, iterate through the dp array backwards starting from the target sum. Update dp[i] to be true if dp[i - num] is true, meaning a subset with sum i - num is possible, and adding the current number num results in a subset with sum i.\n\nFinally, if dp[target] is true, it means there is a subset in the array with sum equal to target, so the array can be partitioned into two equal subsets. Otherwise, it cannot be partitioned.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool canPartition(vector<int>& nums) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    \n    if (sum % 2 != 0) return false;\n    \n    int target = sum / 2;\n    vector<bool> dp(target + 1, false);\n    dp[0] = true;\n    \n    for (int num : nums) {\n        for (int i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}\n```\n    \n    The algorithm is using Dynamic Programming to solve the partition problem. To determine if the array can be divided into two subsets with equal sum, first find the total sum of the array. If the total sum is odd, it's not possible to divide it into two equal subsets, so return false. If the total sum is even, find the target sum by dividing the total sum by 2.\n\nThe key idea is to find if there is a subset whose sum is equal to the target sum. Create a boolean dp array, where dp[i] represents if there is a subset with sum i. Initialize dp[0] to true, since the sum of 0 can be achieved with an empty subset.\n\nIterate through each number in the array, and for each number, iterate through the dp array backwards starting from the target sum. Update dp[i] to be true if dp[i - num] is true, meaning a subset with sum i - num is possible, and adding the current number num results in a subset with sum i.\n\nFinally, if dp[target] is true, it means there is a subset in the array with sum equal to target, so the array can be partitioned into two equal subsets. Otherwise, it cannot be partitioned.\n    ", "python": "\n    ```python\ndef canPartition(nums):\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    \n    target = total_sum // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    \n    return dp[target]\n```\n    \n    The algorithm is using Dynamic Programming to solve the partition problem. To determine if the array can be divided into two subsets with equal sum, first find the total sum of the array. If the total sum is odd, it's not possible to divide it into two equal subsets, so return false. If the total sum is even, find the target sum by dividing the total sum by 2.\n\nThe key idea is to find if there is a subset whose sum is equal to the target sum. Create a boolean dp array, where dp[i] represents if there is a subset with sum i. Initialize dp[0] to true, since the sum of 0 can be achieved with an empty subset.\n\nIterate through each number in the array, and for each number, iterate through the dp array backwards starting from the target sum. Update dp[i] to be true if dp[i - num] is true, meaning a subset with sum i - num is possible, and adding the current number num results in a subset with sum i.\n\nFinally, if dp[target] is true, it means there is a subset in the array with sum equal to target, so the array can be partitioned into two equal subsets. Otherwise, it cannot be partitioned.\n    ", "javascript": "\n    ```javascript\nfunction canPartition(nums) {\n    const sum = nums.reduce((a, b) => a + b);\n    if (sum % 2 !== 0) return false;\n\n    const target = sum / 2;\n    const dp = new Array(target + 1).fill(false);\n    dp[0] = true;\n\n    for (const num of nums) {\n        for (let i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}\n```\n\n    \n    The algorithm is using Dynamic Programming to solve the partition problem. To determine if the array can be divided into two subsets with equal sum, first find the total sum of the array. If the total sum is odd, it's not possible to divide it into two equal subsets, so return false. If the total sum is even, find the target sum by dividing the total sum by 2.\n\nThe key idea is to find if there is a subset whose sum is equal to the target sum. Create a boolean dp array, where dp[i] represents if there is a subset with sum i. Initialize dp[0] to true, since the sum of 0 can be achieved with an empty subset.\n\nIterate through each number in the array, and for each number, iterate through the dp array backwards starting from the target sum. Update dp[i] to be true if dp[i - num] is true, meaning a subset with sum i - num is possible, and adding the current number num results in a subset with sum i.\n\nFinally, if dp[target] is true, it means there is a subset in the array with sum equal to target, so the array can be partitioned into two equal subsets. Otherwise, it cannot be partitioned.\n    "}
{"id": 435, "slug": "non-overlapping-intervals", "title": "Non-overlapping Intervals", "difficulty": "Medium", "content": "Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[1,3\\]\\]\n**Output:** 1\n**Explanation:** \\[1,3\\] can be removed and the rest of the intervals are non-overlapping.\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[1,2\\],\\[1,2\\]\\]\n**Output:** 2\n**Explanation:** You need to remove two \\[1,2\\] to make the rest of the intervals non-overlapping.\n\n**Example 3:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** 0\n**Explanation:** You don't need to remove any of the intervals since they're already non-overlapping.\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 105`\n*   `intervals[i].length == 2`\n*   `-5 * 104 <= starti < endi <= 5 * 104`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals.length == 0) return 0;\n\n    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n\n    int count = 0;\n    int prev_end = intervals[0][1];\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nbool compare(const std::vector<int>& a, const std::vector<int>& b) {\n    return a[1] < b[1];\n}\n\nint eraseOverlapIntervals(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return 0;\n    \n    std::sort(intervals.begin(), intervals.end(), compare);\n    \n    int count = 0;\n    int prev_end = intervals[0][1];\n    \n    for (size_t i = 1; i < intervals.size(); i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n    \n    return count;\n}\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ", "python": "\n    ```python\ndef eraseOverlapIntervals(intervals):\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    prev_end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        if intervals[i][0] < prev_end:\n            count += 1\n        else:\n            prev_end = intervals[i][1]\n    \n    return count\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ", "javascript": "\n    ```javascript\nfunction eraseOverlapIntervals(intervals) {\n    if (intervals.length === 0) return 0;\n\n    intervals.sort((a, b) => a[1] - b[1]);\n\n    let count = 0;\n    let prev_end = intervals[0][1];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    "}
{"id": 446, "slug": "arithmetic-slices-ii-subsequence", "title": "Arithmetic Slices II - Subsequence", "difficulty": "Hard", "content": "Given an integer array `nums`, return _the number of all the **arithmetic subsequences** of_ `nums`.\n\nA sequence of numbers is called arithmetic if it consists of **at least three elements** and if the difference between any two consecutive elements is the same.\n\n*   For example, `[1, 3, 5, 7, 9]`, `[7, 7, 7, 7]`, and `[3, -1, -5, -9]` are arithmetic sequences.\n*   For example, `[1, 1, 2, 5, 7]` is not an arithmetic sequence.\n\nA **subsequence** of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\n*   For example, `[2,5,10]` is a subsequence of `[1,2,1,**2**,4,1,**5**,**10**]`.\n\nThe test cases are generated so that the answer fits in **32-bit** integer.\n\n**Example 1:**\n\n**Input:** nums = \\[2,4,6,8,10\\]\n**Output:** 7\n**Explanation:** All arithmetic subsequence slices are:\n\\[2,4,6\\]\n\\[4,6,8\\]\n\\[6,8,10\\]\n\\[2,4,6,8\\]\n\\[4,6,8,10\\]\n\\[2,4,6,8,10\\]\n\\[2,6,10\\]\n\n**Example 2:**\n\n**Input:** nums = \\[7,7,7,7,7\\]\n**Output:** 16\n**Explanation:** Any subsequence of this array is arithmetic.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `-231 <= nums[i] <= 231 - 1`", "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int numberOfArithmeticSlices(int[] nums) {\n    int res = 0;\n    int n = nums.length;\n    Map<Integer, Integer>[] dp = new HashMap[n];\n\n    for (int i = 0; i < n; ++i) {\n        dp[i] = new HashMap<>();\n        for (int j = 0; j < i; ++j) {\n            long diff = (long)nums[i] - (long)nums[j];\n            if (diff <= Integer.MIN_VALUE || diff > Integer.MAX_VALUE) continue;\n\n            int delta = (int)diff;\n            dp[i].put(delta, dp[i].getOrDefault(delta, 0) + 1);\n\n            if (dp[j].containsKey(delta)) {\n                res += dp[j].get(delta);\n                dp[i].put(delta, dp[i].get(delta) + dp[j].get(delta));\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nint numberOfArithmeticSlices(std::vector<int>& nums) {\n    int res = 0;\n    int n = nums.size();\n    std::vector<std::unordered_map<int, int>> dp(n);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            long diff = (long)nums[i] - (long)nums[j];\n            if (diff <= INT_MIN || diff > INT_MAX) continue;\n\n            int delta = (int)diff;\n            dp[i][delta] += 1;\n\n            if (dp[j].count(delta)) {\n                res += dp[j][delta];\n                dp[i][delta] += dp[j][delta];\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences.\n    ", "python": "\n    ```python\ndef numberOfArithmeticSlices(nums):\n    res = 0\n    n = len(nums)\n    dp = [dict() for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            if diff <= -2**31 or diff > 2**31:\n                continue\n\n            dp[i][diff] = dp[i].get(diff, 0) + 1\n\n            if diff in dp[j]:\n                res += dp[j][diff]\n                dp[i][diff] += dp[j][diff]\n\n    return res\n```\n\n    \n    To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences.\n    ", "javascript": "\n    ```javascript\nfunction numberOfArithmeticSlices(nums) {\n    let res = 0;\n    const n = nums.length;\n    const dp = new Array(n).fill(0).map(() => new Map());\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            const diff = nums[i] - nums[j];\n            if (diff <= Number.MIN_SAFE_INTEGER || diff > Number.MAX_SAFE_INTEGER) continue;\n\n            if (!dp[i].has(diff)) {\n                dp[i].set(diff, 0);\n            }\n\n            dp[i].set(diff, dp[i].get(diff) + 1);\n\n            if (dp[j].has(diff)) {\n                res += dp[j].get(diff);\n                dp[i].set(diff, dp[i].get(diff) + dp[j].get(diff));\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences.\n    "}
{"id": 458, "slug": "poor-pigs", "title": "Poor Pigs", "difficulty": "Hard", "content": "There are `buckets` buckets of liquid, where **exactly one** of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have `minutesToTest` minutes to determine which bucket is poisonous.\n\nYou can feed the pigs according to these steps:\n\n1.  Choose some live pigs to feed.\n2.  For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n3.  Wait for `minutesToDie` minutes. You may **not** feed any other pigs during this time.\n4.  After `minutesToDie` minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n5.  Repeat this process until you run out of time.\n\nGiven `buckets`, `minutesToDie`, and `minutesToTest`, return _the **minimum** number of pigs needed to figure out which bucket is poisonous within the allotted time_.\n\n**Example 1:**\n\n**Input:** buckets = 4, minutesToDie = 15, minutesToTest = 15\n**Output:** 2\n**Explanation:** We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\nAt time 15, there are 4 possible outcomes:\n- If only the first pig dies, then bucket 1 must be poisonous.\n- If only the second pig dies, then bucket 3 must be poisonous.\n- If both pigs die, then bucket 2 must be poisonous.\n- If neither pig dies, then bucket 4 must be poisonous.\n\n**Example 2:**\n\n**Input:** buckets = 4, minutesToDie = 15, minutesToTest = 30\n**Output:** 2\n**Explanation:** We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\nAt time 15, there are 2 possible outcomes:\n- If either pig dies, then the poisonous bucket is the one it was fed.\n- If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\nAt time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed.\n\n**Constraints:**\n\n*   `1 <= buckets <= 1000`\n*   `1 <= minutesToDie <= minutesToTest <= 100`", "java": "\n    ```java\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    while (Math.pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n```\n\n    \n    The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed.\n    ", "c++": "\n    ```cpp\nint poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    while (pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n```\n\n    \n    The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed.\n    ", "python": "\n    ```python\ndef poor_pigs(buckets, minutes_to_die, minutes_to_test):\n    pigs = 0\n    while (minutes_to_test // minutes_to_die + 1) ** pigs < buckets:\n        pigs += 1\n    return pigs\n```\n\n    \n    The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed.\n    ", "javascript": "\n    ```javascript\nfunction poorPigs(buckets, minutesToDie, minutesToTest) {\n    let pigs = 0;\n    while (Math.pow(Math.floor(minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n```\n\n    \n    The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed.\n    "}
{"id": 464, "slug": "can-i-win", "title": "Can I Win", "difficulty": "Medium", "content": "In the \"100 game \" two players take turns adding, to a running total, any integer from `1` to `10`. The player who first causes the running total to **reach or exceed** 100 wins.\n\nWhat if we change the game so that players **cannot** re-use integers?\n\nFor example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n\nGiven two integers `maxChoosableInteger` and `desiredTotal`, return `true` if the first player to move can force a win, otherwise, return `false`. Assume both players play **optimally**.\n\n**Example 1:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 11\n**Output:** false\n**Explanation:**\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\n\n**Example 2:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 0\n**Output:** true\n\n**Example 3:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 1\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= maxChoosableInteger <= 20`\n*   `0 <= desiredTotal <= 300`", "java": "\n    ```java\nimport java.util.HashMap;\n\npublic class Solution {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (maxChoosableInteger >= desiredTotal) return true;\n        if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false;\n        \n        HashMap<Integer, Boolean> memo = new HashMap<>();\n        int state = 0;\n        return canWin(maxChoosableInteger, desiredTotal, state, memo);\n    }\n    \n    private boolean canWin(int maxChoosableInteger, int desiredTotal, int state, HashMap<Integer, Boolean> memo) {\n        if (desiredTotal <= 0) return false;\n        if (memo.containsKey(state)) return memo.get(state);\n        \n        for (int i = 1; i <= maxChoosableInteger; i++) {\n            int bitCheck = 1 << i;\n            if ((state & bitCheck) == 0) {\n                if (!canWin(maxChoosableInteger, desiredTotal - i, state | bitCheck, memo)) {\n                    memo.put(state, true);\n                    return true;\n                }\n            }\n        }\n        \n        memo.put(state, false);\n        return false;\n    }\n}\n```\n\n    \n    We use a state, represented by an integer where each bit indicates if a number has been taken or not, and store the states in a memoization table. With each function call, we try to take each number from 1 to maxChoosableInteger if it hasn't been taken before, and update the state accordingly. If no moves can be made which forces a win, return false. If the desired total is equal to or less than zero, then the player has lost, and we return false. \n\nBoth players play optimally, so we can recursively call the function for each possible number and check if it doesn't result in a win for the other player. If we find such a scenario, then the first player can force a win. At the end, we return the final result from the memoization table.\n    ", "c++": "\n    ```cpp\n#include <unordered_map>\n\nbool canWin(int maxChoosableInteger, int desiredTotal, int state, std::unordered_map<int, bool>& memo) {\n    if(desiredTotal <= 0) {\n        return false;\n    }\n    if(memo.count(state) > 0) {\n        return memo[state];\n    }\n    for(int i = 1; i <= maxChoosableInteger; i++) {\n        int bitCheck = 1 << i;\n        if((state & bitCheck) == 0) {\n            if(!canWin(maxChoosableInteger, desiredTotal - i, state | bitCheck, memo)) {\n                memo[state] = true;\n                return true;\n            }\n        }\n    }\n    memo[state] = false;\n    return false;\n}\n\nbool canIWin(int maxChoosableInteger, int desiredTotal) {\n    if (maxChoosableInteger >= desiredTotal) return true;\n    if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false;\n\n    std::unordered_map<int, bool> memo;\n    int state = 0;\n    return canWin(maxChoosableInteger, desiredTotal, state, memo);\n}\n```\n\n    \n    We use a state, represented by an integer where each bit indicates if a number has been taken or not, and store the states in a memoization table. With each function call, we try to take each number from 1 to maxChoosableInteger if it hasn't been taken before, and update the state accordingly. If no moves can be made which forces a win, return false. If the desired total is equal to or less than zero, then the player has lost, and we return false. \n\nBoth players play optimally, so we can recursively call the function for each possible number and check if it doesn't result in a win for the other player. If we find such a scenario, then the first player can force a win. At the end, we return the final result from the memoization table.\n    ", "python": "\n    ```python\ndef canIWin(maxChoosableInteger, desiredTotal):\n    if maxChoosableInteger >= desiredTotal: return True\n    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal: return False\n\n    memo = {}\n        \n    def canWin(state):\n        if state in memo:\n            return memo[state]\n        for i in range(1, maxChoosableInteger + 1):\n            bitCheck = 1 << i\n            if (state & bitCheck) == 0:\n                if not canWin(state | bitCheck):\n                    memo[state] = True\n                    return True\n    \n        memo[state] = False\n        return False\n\n    return canWin(0)\n```\n\n    \n    We use a state, represented by an integer where each bit indicates if a number has been taken or not, and store the states in a memoization table. With each function call, we try to take each number from 1 to maxChoosableInteger if it hasn't been taken before, and update the state accordingly. If no moves can be made which forces a win, return false. If the desired total is equal to or less than zero, then the player has lost, and we return false. \n\nBoth players play optimally, so we can recursively call the function for each possible number and check if it doesn't result in a win for the other player. If we find such a scenario, then the first player can force a win. At the end, we return the final result from the memoization table.\n    ", "javascript": "\n    ```javascript\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\n    if (maxChoosableInteger >= desiredTotal) return true;\n    if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\n\n    const memo = new Map();\n\n    function canWin(state) {\n        if (memo.has(state)) return memo.get(state);\n\n        for (let i = 1; i <= maxChoosableInteger; i++) {\n            let bitCheck = 1 << i;\n            if ((state & bitCheck) === 0) {\n                if (!canWin(state | bitCheck)) {\n                    memo.set(state, true);\n                    return true;\n                }\n            }\n        }\n\n        memo.set(state, false);\n        return false;\n    }\n\n    return canWin(0);\n}\n```\n\n    \n    We use a state, represented by an integer where each bit indicates if a number has been taken or not, and store the states in a memoization table. With each function call, we try to take each number from 1 to maxChoosableInteger if it hasn't been taken before, and update the state accordingly. If no moves can be made which forces a win, return false. If the desired total is equal to or less than zero, then the player has lost, and we return false. \n\nBoth players play optimally, so we can recursively call the function for each possible number and check if it doesn't result in a win for the other player. If we find such a scenario, then the first player can force a win. At the end, we return the final result from the memoization table.\n    "}
{"id": 466, "slug": "count-the-repetitions", "title": "Count The Repetitions", "difficulty": "Hard", "content": "We define `str = [s, n]` as the string `str` which consists of the string `s` concatenated `n` times.\n\n*   For example, `str == [ \"abc \", 3] == \"abcabcabc \"`.\n\nWe define that string `s1` can be obtained from string `s2` if we can remove some characters from `s2` such that it becomes `s1`.\n\n*   For example, `s1 = \"abc \"` can be obtained from `s2 = \"ab**dbe**c \"` based on our definition by removing the bolded underlined characters.\n\nYou are given two strings `s1` and `s2` and two integers `n1` and `n2`. You have the two strings `str1 = [s1, n1]` and `str2 = [s2, n2]`.\n\nReturn _the maximum integer_ `m` _such that_ `str = [str2, m]` _can be obtained from_ `str1`.\n\n**Example 1:**\n\n**Input:** s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n**Output:** 2\n\n**Example 2:**\n\n**Input:** s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 100`\n*   `s1` and `s2` consist of lowercase English letters.\n*   `1 <= n1, n2 <= 106`", "java": "\n    ```java\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1.charAt(i) == s2.charAt(j)) {\n            j++;\n            if (j == s2.length()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.length()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}\n```\n\n    \n    1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m.\n    ", "c++": "\n    ```cpp\nint getMaxRepetitions(string s1, int n1, string s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1[i] == s2[j]) {\n            j++;\n            if (j == s2.size()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.size()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}\n```\n\n    \n    1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m.\n    ", "python": "\n    ```python\ndef getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    count1, count2, i, j = 0, 0, 0, 0\n    while count1 < n1:\n        if s1[i] == s2[j]:\n            j += 1\n            if j == len(s2):\n                j = 0\n                count2 += 1\n        i += 1\n        if i == len(s1):\n            i = 0\n            count1 += 1\n    return count2 // n2\n```\n\n    \n    1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m.\n    ", "javascript": "\n    ```javascript\nfunction getMaxRepetitions(s1, n1, s2, n2) {\n    let count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1.charAt(i) === s2.charAt(j)) {\n            j++;\n            if (j === s2.length) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i === s1.length) {\n            i = 0;\n            count1++;\n        }\n    }\n    return Math.floor(count2 / n2);\n}\n```\n\n    \n    1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m.\n    "}
{"id": 467, "slug": "unique-substrings-in-wraparound-string", "title": "Unique Substrings in Wraparound String", "difficulty": "Medium", "content": "We define the string `base` to be the infinite wraparound string of `\"abcdefghijklmnopqrstuvwxyz \"`, so `base` will look like this:\n\n*   `\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd.... \"`.\n\nGiven a string `s`, return _the number of **unique non-empty substrings** of_ `s` _are present in_ `base`.\n\n**Example 1:**\n\n**Input:** s =  \"a \"\n**Output:** 1\n**Explanation:** Only the substring  \"a \" of s is in base.\n\n**Example 2:**\n\n**Input:** s =  \"cac \"\n**Output:** 2\n**Explanation:** There are two substrings ( \"a \",  \"c \") of s in base.\n\n**Example 3:**\n\n**Input:** s =  \"zab \"\n**Output:** 6\n**Explanation:** There are six substrings ( \"z \",  \"a \",  \"b \",  \"za \",  \"ab \", and  \"zab \") of s in base.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters.", "java": "\n    ```java\npublic int findSubstringInWraproundString(String p) {\n    int[] cnt = new int[26];\n    int length = 0;\n\n    for (int i = 0; i < p.length(); i++) {\n        if (i > 0 && (p.charAt(i) == p.charAt(i - 1) + 1 || p.charAt(i - 1) - p.charAt(i) == 25)) {\n            length++;\n        } else {\n            length = 1;\n        }\n        cnt[p.charAt(i) - 'a'] = Math.max(cnt[p.charAt(i) - 'a'], length);\n    }\n\n    int sum = 0;\n    for (int v : cnt) {\n        sum += v;\n    }\n    return sum;\n}\n```\n\n    \n    1. Initialize an array cnt of size 26 to keep the count of the maximum length of contiguous characters ending with a given character.\n2. Initialize a variable length to keep track of the current count of contiguous characters.\n3. Iterate through the given string p.\n   - If the current character is the next character of the previous one or wraps around from 'z' to 'a', increment length by 1.\n   - Otherwise, reset length to 1.\n   - Update cnt for the current character with the maximum of its current value and length.\n4. Return the sum of all the counts in cnt.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\nint findSubstringInWraproundString(const std::string& p) {\n    std::vector<int> cnt(26, 0);\n    int length = 0;\n\n    for (int i = 0; i < p.size(); i++) {\n        if (i > 0 && (p[i] == p[i - 1] + 1 || p[i - 1] - p[i] == 25)) {\n            length++;\n        } else {\n            length = 1;\n        }\n        cnt[p[i] - 'a'] = std::max(cnt[p[i] - 'a'], length);\n    }\n\n    return std::accumulate(cnt.begin(), cnt.end(), 0);\n}\n```\n\n    \n    1. Initialize an array cnt of size 26 to keep the count of the maximum length of contiguous characters ending with a given character.\n2. Initialize a variable length to keep track of the current count of contiguous characters.\n3. Iterate through the given string p.\n   - If the current character is the next character of the previous one or wraps around from 'z' to 'a', increment length by 1.\n   - Otherwise, reset length to 1.\n   - Update cnt for the current character with the maximum of its current value and length.\n4. Return the sum of all the counts in cnt.\n    ", "python": "\n    ```python\ndef findSubstringInWraproundString(p: str) -> int:\n    cnt = [0] * 26\n    length = 0\n\n    for i in range(len(p)):\n        if i > 0 and (p[i] == chr(ord(p[i - 1]) + 1) or ord(p[i - 1]) - ord(p[i]) == 25):\n            length += 1\n        else:\n            length = 1\n        cnt[ord(p[i]) - ord('a')] = max(cnt[ord(p[i]) - ord('a')], length)\n\n    return sum(cnt)\n```\n\n    \n    1. Initialize an array cnt of size 26 to keep the count of the maximum length of contiguous characters ending with a given character.\n2. Initialize a variable length to keep track of the current count of contiguous characters.\n3. Iterate through the given string p.\n   - If the current character is the next character of the previous one or wraps around from 'z' to 'a', increment length by 1.\n   - Otherwise, reset length to 1.\n   - Update cnt for the current character with the maximum of its current value and length.\n4. Return the sum of all the counts in cnt.\n    ", "javascript": "\n    ```javascript\nfunction findSubstringInWraproundString(p) {\n    const cnt = new Array(26).fill(0);\n    let length = 0;\n\n    for (let i = 0; i < p.length; i++) {\n        if (i > 0 && (p.charCodeAt(i) === p.charCodeAt(i - 1) + 1 || p.charCodeAt(i - 1) - p.charCodeAt(i) === 25)) {\n            length++;\n        } else {\n            length = 1;\n        }\n        cnt[p.charCodeAt(i) - 'a'.charCodeAt(0)] = Math.max(cnt[p.charCodeAt(i) - 'a'.charCodeAt(0)], length);\n    }\n\n    return cnt.reduce((a, b) => a + b, 0);\n}\n```\n\n    \n    1. Initialize an array cnt of size 26 to keep the count of the maximum length of contiguous characters ending with a given character.\n2. Initialize a variable length to keep track of the current count of contiguous characters.\n3. Iterate through the given string p.\n   - If the current character is the next character of the previous one or wraps around from 'z' to 'a', increment length by 1.\n   - Otherwise, reset length to 1.\n   - Update cnt for the current character with the maximum of its current value and length.\n4. Return the sum of all the counts in cnt.\n    "}
{"id": 472, "slug": "concatenated-words", "title": "Concatenated Words", "difficulty": "Hard", "content": "Given an array of strings `words` (**without duplicates**), return _all the **concatenated words** in the given list of_ `words`.\n\nA **concatenated word** is defined as a string that is comprised entirely of at least two shorter words (not necesssarily distinct) in the given array.\n\n**Example 1:**\n\n**Input:** words = \\[ \"cat \", \"cats \", \"catsdogcats \", \"dog \", \"dogcatsdog \", \"hippopotamuses \", \"rat \", \"ratcatdogcat \"\\]\n**Output:** \\[ \"catsdogcats \", \"dogcatsdog \", \"ratcatdogcat \"\\]\n**Explanation:**  \"catsdogcats \" can be concatenated by  \"cats \",  \"dog \" and  \"cats \"; \n \"dogcatsdog \" can be concatenated by  \"dog \",  \"cats \" and  \"dog \"; \n \"ratcatdogcat \" can be concatenated by  \"rat \",  \"cat \",  \"dog \" and  \"cat \".\n\n**Example 2:**\n\n**Input:** words = \\[ \"cat \", \"dog \", \"catdog \"\\]\n**Output:** \\[ \"catdog \"\\]\n\n**Constraints:**\n\n*   `1 <= words.length <= 104`\n*   `1 <= words[i].length <= 30`\n*   `words[i]` consists of only lowercase English letters.\n*   All the strings of `words` are **unique**.\n*   `1 <= sum(words[i].length) <= 105`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class Solution {\n    public boolean isConcatenated(String word, Set<String> wordDict) {\n        int n = word.length();\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = true;\n\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (dp[j] && wordDict.contains(word.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n\n    public List<String> findAllConcatenatedWords(String[] words) {\n        Set<String> wordDict = new HashSet<>();\n        for (String word : words) {\n            wordDict.add(word);\n        }\n\n        List<String> result = new ArrayList<>();\n        for (String word : words) {\n            if (isConcatenated(word, wordDict)) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n}\n```\n    \n    The algorithm uses dynamic programming to determine if a given word is a concatenated word. The function `isConcatenated` checks if a word can be formed by concatenating two or more words from the input array. It iterates through the characters of the word and uses a boolean array `dp` to keep track of whether or not the substring from the start of the word up to a certain index can be formed by concatenating the words from the input array.\n\nThen, the main function `findAllConcatenatedWords` iterates through each word in the array, and if the word is a concatenated word, adds it to the result list/array.\n\nThe four implementations in C++, Java, Python, and JavaScript use the same algorithm described above but are adapted to their respective language syntax and standard libraries.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool isConcatenated(const string& word, unordered_set<string>& wordDict) {\n    int n = word.size();\n    vector<bool> dp(n + 1, false);\n    dp[0] = true;\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (dp[j] && wordDict.count(word.substr(j, i - j))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n\nvector<string> findAllConcatenatedWords(vector<string>& words) {\n    unordered_set<string> wordDict(words.begin(), words.end());\n    vector<string> result;\n\n    for (const string& word : words) {\n        if (isConcatenated(word, wordDict)) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm uses dynamic programming to determine if a given word is a concatenated word. The function `isConcatenated` checks if a word can be formed by concatenating two or more words from the input array. It iterates through the characters of the word and uses a boolean array `dp` to keep track of whether or not the substring from the start of the word up to a certain index can be formed by concatenating the words from the input array.\n\nThen, the main function `findAllConcatenatedWords` iterates through each word in the array, and if the word is a concatenated word, adds it to the result list/array.\n\nThe four implementations in C++, Java, Python, and JavaScript use the same algorithm described above but are adapted to their respective language syntax and standard libraries.\n    ", "python": "\n    ```python\ndef is_concatenated(word, word_dict):\n    n = len(word)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and word[j:i] in word_dict:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ndef find_all_concatenated_words(words):\n    word_dict = set(words)\n    result = []\n\n    for word in words:\n        if is_concatenated(word, word_dict):\n            result.append(word)\n\n    return result\n```\n    \n    The algorithm uses dynamic programming to determine if a given word is a concatenated word. The function `isConcatenated` checks if a word can be formed by concatenating two or more words from the input array. It iterates through the characters of the word and uses a boolean array `dp` to keep track of whether or not the substring from the start of the word up to a certain index can be formed by concatenating the words from the input array.\n\nThen, the main function `findAllConcatenatedWords` iterates through each word in the array, and if the word is a concatenated word, adds it to the result list/array.\n\nThe four implementations in C++, Java, Python, and JavaScript use the same algorithm described above but are adapted to their respective language syntax and standard libraries.\n    ", "javascript": "\n    ```javascript\nfunction isConcatenated(word, wordDict) {\n    const n = word.length;\n    const dp = Array(n + 1).fill(false);\n    dp[0] = true;\n\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            if (dp[j] && wordDict.has(word.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n\nfunction findAllConcatenatedWords(words) {\n    const wordDict = new Set(words);\n    const result = [];\n\n    for (const word of words) {\n        if (isConcatenated(word, wordDict)) {\n            result.push(word);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses dynamic programming to determine if a given word is a concatenated word. The function `isConcatenated` checks if a word can be formed by concatenating two or more words from the input array. It iterates through the characters of the word and uses a boolean array `dp` to keep track of whether or not the substring from the start of the word up to a certain index can be formed by concatenating the words from the input array.\n\nThen, the main function `findAllConcatenatedWords` iterates through each word in the array, and if the word is a concatenated word, adds it to the result list/array.\n\nThe four implementations in C++, Java, Python, and JavaScript use the same algorithm described above but are adapted to their respective language syntax and standard libraries.\n    "}
{"id": 473, "slug": "matchsticks-to-square", "title": "Matchsticks to Square", "difficulty": "Medium", "content": "You are given an integer array `matchsticks` where `matchsticks[i]` is the length of the `ith` matchstick. You want to use **all the matchsticks** to make one square. You **should not break** any stick, but you can link them up, and each matchstick must be used **exactly one time**.\n\nReturn `true` if you can make this square and `false` otherwise.\n\n**Example 1:**\n\n**Input:** matchsticks = \\[1,1,2,2,2\\]\n**Output:** true\n**Explanation:** You can form a square with length 2, one side of the square came two sticks with length 1.\n\n**Example 2:**\n\n**Input:** matchsticks = \\[3,3,3,3,4\\]\n**Output:** false\n**Explanation:** You cannot find a way to form a square with all the matchsticks.\n\n**Constraints:**\n\n*   `1 <= matchsticks.length <= 15`\n*   `1 <= matchsticks[i] <= 108`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic class Solution {\n    public boolean makesquare(int[] matchsticks) {\n        if (matchsticks == null || matchsticks.length < 4) return false;\n        int sum = 0;\n        for (int matchstick : matchsticks) sum += matchstick;\n        if (sum % 4 != 0) return false;\n        int target = sum / 4;\n        Arrays.sort(matchsticks);\n        reverse(matchsticks);\n        int[] sums = new int[4];\n        return dfs(matchsticks, sums, target, 0);\n    }\n\n    private void reverse(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int temp = nums[left];\n            nums[left] = nums[right];\n            nums[right] = temp;\n            left++;\n            right--;\n        }\n    }\n\n    private boolean dfs(int[] matchsticks, int[] sums, int target, int index) {\n        if (index == matchsticks.length) {\n            return sums[0] == target && sums[1] == target && sums[2] == target;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (sums[i] + matchsticks[index] <= target) {\n                sums[i] += matchsticks[index];\n                if (dfs(matchsticks, sums, target, index + 1)) return true;\n                sums[i] -= matchsticks[index];\n            }\n        }\n        return false;\n    }\n}\n```\n\n    \n    1. First, we check if there are enough matchsticks and if the total length of matchsticks can be divided by 4 to form a square. If not, return false.\n2. Sort the matchsticks in descending order to traverse them from the largest to the smallest. This helps to prune branches in the depth-first search.\n3. Utilize a recursive depth-first search function to try placing matchsticks i (0 <= i < 4) to form each side. If we reach the sum of all the matchsticks in a square, return true.\n4. Make sure each matchstick is used exactly once and check if the assigned sums satisfy the required target.\n5. If we reach the end and could not make a square, return false.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool makesquare(std::vector<int>& matchsticks) {\n    if (matchsticks.size() < 4) return false;\n    int sum = std::accumulate(matchsticks.begin(), matchsticks.end(), 0);\n    if (sum % 4) return false;\n    int target = sum / 4;\n    std::sort(matchsticks.rbegin(), matchsticks.rend());\n    std::vector<int> sums(4, 0);\n    return dfs(matchsticks, sums, target, 0);\n}\n\nbool dfs(std::vector<int>& matchsticks, std::vector<int>& sums, int target, int index) {\n    if (index == matchsticks.size()) {\n        return sums[0] == target && sums[1] == target && sums[2] == target;\n    }\n    for (int i = 0; i < 4; ++i) {\n        if (sums[i] + matchsticks[index] <= target) {\n            sums[i] += matchsticks[index];\n            if (dfs(matchsticks, sums, target, index + 1)) return true;\n            sums[i] -= matchsticks[index];\n        }\n    }\n    return false;\n}\n```\n\n    \n    1. First, we check if there are enough matchsticks and if the total length of matchsticks can be divided by 4 to form a square. If not, return false.\n2. Sort the matchsticks in descending order to traverse them from the largest to the smallest. This helps to prune branches in the depth-first search.\n3. Utilize a recursive depth-first search function to try placing matchsticks i (0 <= i < 4) to form each side. If we reach the sum of all the matchsticks in a square, return true.\n4. Make sure each matchstick is used exactly once and check if the assigned sums satisfy the required target.\n5. If we reach the end and could not make a square, return false.\n    ", "python": "\n    ```python\nfrom itertools import chain\n\ndef makesquare(matchsticks):\n    if len(matchsticks) < 4:\n        return False\n    total = sum(matchsticks)\n    if total % 4:\n        return False\n    target = total // 4\n    matchsticks.sort(reverse=True)\n    sums = [0]*4\n    return dfs(matchsticks, sums, target, 0)\n\ndef dfs(matchsticks, sums, target, index):\n    if index == len(matchsticks):\n        return sums[0] == target and sums[1] == target and sums[2] == target\n    for i in range(4):\n        if sums[i] + matchsticks[index] <= target:\n            sums[i] += matchsticks[index]\n            if dfs(matchsticks, sums, target, index + 1):\n                return True\n            sums[i] -= matchsticks[index]\n    return False\n```\n\n    \n    1. First, we check if there are enough matchsticks and if the total length of matchsticks can be divided by 4 to form a square. If not, return false.\n2. Sort the matchsticks in descending order to traverse them from the largest to the smallest. This helps to prune branches in the depth-first search.\n3. Utilize a recursive depth-first search function to try placing matchsticks i (0 <= i < 4) to form each side. If we reach the sum of all the matchsticks in a square, return true.\n4. Make sure each matchstick is used exactly once and check if the assigned sums satisfy the required target.\n5. If we reach the end and could not make a square, return false.\n    ", "javascript": "\n    ```javascript\nfunction makesquare(matchsticks) {\n    if (matchsticks.length < 4) return false;\n    const total = matchsticks.reduce((a, b) => a + b, 0);\n    if (total % 4 !== 0) return false;\n    const target = total / 4;\n    matchsticks.sort((a, b) => b - a);\n    const sums = [0, 0, 0, 0];\n    return dfs(matchsticks, sums, target, 0);\n}\n\nfunction dfs(matchsticks, sums, target, index) {\n    if (index === matchsticks.length) {\n        return sums[0] === target && sums[1] === target && sums[2] === target;\n    }\n    for (let i = 0; i < 4; i++) {\n        if (sums[i] + matchsticks[index] <= target) {\n            sums[i] += matchsticks[index];\n            if (dfs(matchsticks, sums, target, index + 1)) return true;\n            sums[i] -= matchsticks[index];\n        }\n    }\n    return false;\n}\n```\n\n    \n    1. First, we check if there are enough matchsticks and if the total length of matchsticks can be divided by 4 to form a square. If not, return false.\n2. Sort the matchsticks in descending order to traverse them from the largest to the smallest. This helps to prune branches in the depth-first search.\n3. Utilize a recursive depth-first search function to try placing matchsticks i (0 <= i < 4) to form each side. If we reach the sum of all the matchsticks in a square, return true.\n4. Make sure each matchstick is used exactly once and check if the assigned sums satisfy the required target.\n5. If we reach the end and could not make a square, return false.\n    "}
{"id": 474, "slug": "ones-and-zeroes", "title": "Ones and Zeroes", "difficulty": "Medium", "content": "You are given an array of binary strings `strs` and two integers `m` and `n`.\n\nReturn _the size of the largest subset of `strs` such that there are **at most**_ `m` `0`_'s and_ `n` `1`_'s in the subset_.\n\nA set `x` is a **subset** of a set `y` if all elements of `x` are also elements of `y`.\n\n**Example 1:**\n\n**Input:** strs = \\[ \"10 \", \"0001 \", \"111001 \", \"1 \", \"0 \"\\], m = 5, n = 3\n**Output:** 4\n**Explanation:** The largest subset with at most 5 0's and 3 1's is { \"10 \",  \"0001 \",  \"1 \",  \"0 \"}, so the answer is 4.\nOther valid but smaller subsets include { \"0001 \",  \"1 \"} and { \"10 \",  \"1 \",  \"0 \"}.\n{ \"111001 \"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\n\n**Example 2:**\n\n**Input:** strs = \\[ \"10 \", \"0 \", \"1 \"\\], m = 1, n = 1\n**Output:** 2\n**Explanation:** The largest subset is { \"0 \",  \"1 \"}, so the answer is 2.\n\n**Constraints:**\n\n*   `1 <= strs.length <= 600`\n*   `1 <= strs[i].length <= 100`\n*   `strs[i]` consists only of digits `'0'` and `'1'`.\n*   `1 <= m, n <= 100`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int findMaxForm(String[] strs, int m, int n) {\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (String str: strs) {\n        int ones = (int) str.chars().filter(ch -> ch == '1').count();\n        int zeros = str.length() - ones;\n        \n        for (int i = m; i >= zeros; --i) {\n            for (int j = n; j >= ones; --j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}\n```\n    \n    1. Initialize a 2-dimensional DP table dp, where dp[i][j] represents the maximum size of a subset with i 0's and j 1's.\n2. Loop through each string in strs.\n3. Count the number of 0's (zeros) and 1's (ones) in each string.\n4. Iterate backward through the DP table, updating dp[i][j] to the maximum of its current value and dp[i - zeros][j - ones] + 1. This is because a string with zeros 0's and ones 1's will be included in the subset if i 0's and j 1's are available.\n5. After processing all the strings, return dp[m][n], which represents the size of the largest subset with at most m 0's and n 1's.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nint findMaxForm(std::vector<std::string>& strs, int m, int n) {\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1));\n    \n    for (const std::string& str: strs) {\n        int ones = std::count(str.begin(), str.end(), '1');\n        int zeros = str.length() - ones;\n        \n        for (int i = m; i >= zeros; --i) {\n            for (int j = n; j >= ones; --j) {\n                dp[i][j] = std::max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}\n```\n    \n    1. Initialize a 2-dimensional DP table dp, where dp[i][j] represents the maximum size of a subset with i 0's and j 1's.\n2. Loop through each string in strs.\n3. Count the number of 0's (zeros) and 1's (ones) in each string.\n4. Iterate backward through the DP table, updating dp[i][j] to the maximum of its current value and dp[i - zeros][j - ones] + 1. This is because a string with zeros 0's and ones 1's will be included in the subset if i 0's and j 1's are available.\n5. After processing all the strings, return dp[m][n], which represents the size of the largest subset with at most m 0's and n 1's.\n    ", "python": "\n    ```python\ndef findMaxForm(strs, m, n):\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for s in strs:\n        ones = s.count('1')\n        zeros = len(s) - ones\n        \n        for i in range(m, zeros - 1, -1):\n            for j in range(n, ones - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n    \n    return dp[m][n]\n```\n    \n    1. Initialize a 2-dimensional DP table dp, where dp[i][j] represents the maximum size of a subset with i 0's and j 1's.\n2. Loop through each string in strs.\n3. Count the number of 0's (zeros) and 1's (ones) in each string.\n4. Iterate backward through the DP table, updating dp[i][j] to the maximum of its current value and dp[i - zeros][j - ones] + 1. This is because a string with zeros 0's and ones 1's will be included in the subset if i 0's and j 1's are available.\n5. After processing all the strings, return dp[m][n], which represents the size of the largest subset with at most m 0's and n 1's.\n    ", "javascript": "\n    ```javascript\nfunction findMaxForm(strs, m, n) {\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (const str of strs) {\n        const ones = str.split('').filter(ch => ch === '1').length;\n        const zeros = str.length - ones;\n        \n        for (let i = m; i >= zeros; --i) {\n            for (let j = n; j >= ones; --j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}\n```\n    \n    1. Initialize a 2-dimensional DP table dp, where dp[i][j] represents the maximum size of a subset with i 0's and j 1's.\n2. Loop through each string in strs.\n3. Count the number of 0's (zeros) and 1's (ones) in each string.\n4. Iterate backward through the DP table, updating dp[i][j] to the maximum of its current value and dp[i - zeros][j - ones] + 1. This is because a string with zeros 0's and ones 1's will be included in the subset if i 0's and j 1's are available.\n5. After processing all the strings, return dp[m][n], which represents the size of the largest subset with at most m 0's and n 1's.\n    "}
{"id": 486, "slug": "predict-the-winner", "title": "Predict the Winner", "difficulty": "Medium", "content": "You are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.\n\nPlayer 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of `0`. At each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) which reduces the size of the array by `1`. The player adds the chosen number to their score. The game ends when there are no more elements in the array.\n\nReturn `true` if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return `true`. You may assume that both players are playing optimally.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,2\\]\n**Output:** false\n**Explanation:** Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,233,7\\]\n**Output:** true\n**Explanation:** Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 20`\n*   `0 <= nums[i] <= 107`", "java": "\n    ```java\npublic boolean canWin(int[] nums) {\n    int n = nums.length;\n    int[][] dp = new int[n][n];\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (int len = 1; len < n; len++) {\n        for (int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n        }\n    }\n    return dp[0][n - 1] >= 0;\n}\n```\n\n    \n    We use dynamic programming to solve this problem. We create a 2D table `dp` of size `n x n` where `n` is the length of the input array `nums`. `dp[i][j]` represents the maximum score difference that player 1 can get when playing optimally on the subarray from index `i` to index `j`.\n\nWe initialize the diagonal elements of the table: `dp[i][i] = nums[i]`, since if there's only one element left in the game, the player will have to pick it up.\n\nWe iterate through the table by fixing the distance `len` between the start and end indices of the subarray. For each subarray `nums[i...j]` where `j = i + len`, player 1 has two choices: picking the first element of the subarray `nums[i]`, or picking the last element of the subarray `nums[j]`. Since both players play optimally, we consider the score difference after player 2 plays their turn. This can be found in the `dp` table from the following subproblems:\n\n1. If player 1 picks `nums[i]`, then the score difference after player 2's turn will be `nums[i] - dp[i + 1][j]`.\n2. If player 1 picks `nums[j]`, then the score difference after player 2's turn will be `nums[j] - dp[i][j - 1]`.\n\nWe choose the option which gives the maximum score difference for player 1: `dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])`.\n\nFinally, we return `true` if `dp[0][n - 1] >= 0`, which means that player 1 has a score greater than or equal to player 2 when playing optimally on the entire input array. Otherwise, we return `false`.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nbool canWin(const std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (int len = 1; len < n; len++) {\n        for (int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = std::max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n        }\n    }\n    return dp[0][n - 1] >= 0;\n}\n```\n\n    \n    We use dynamic programming to solve this problem. We create a 2D table `dp` of size `n x n` where `n` is the length of the input array `nums`. `dp[i][j]` represents the maximum score difference that player 1 can get when playing optimally on the subarray from index `i` to index `j`.\n\nWe initialize the diagonal elements of the table: `dp[i][i] = nums[i]`, since if there's only one element left in the game, the player will have to pick it up.\n\nWe iterate through the table by fixing the distance `len` between the start and end indices of the subarray. For each subarray `nums[i...j]` where `j = i + len`, player 1 has two choices: picking the first element of the subarray `nums[i]`, or picking the last element of the subarray `nums[j]`. Since both players play optimally, we consider the score difference after player 2 plays their turn. This can be found in the `dp` table from the following subproblems:\n\n1. If player 1 picks `nums[i]`, then the score difference after player 2's turn will be `nums[i] - dp[i + 1][j]`.\n2. If player 1 picks `nums[j]`, then the score difference after player 2's turn will be `nums[j] - dp[i][j - 1]`.\n\nWe choose the option which gives the maximum score difference for player 1: `dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])`.\n\nFinally, we return `true` if `dp[0][n - 1] >= 0`, which means that player 1 has a score greater than or equal to player 2 when playing optimally on the entire input array. Otherwise, we return `false`.\n    ", "python": "\n    ```python\ndef can_win(nums):\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = nums[i]\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n    return dp[0][n - 1] >= 0\n```\n\n    \n    We use dynamic programming to solve this problem. We create a 2D table `dp` of size `n x n` where `n` is the length of the input array `nums`. `dp[i][j]` represents the maximum score difference that player 1 can get when playing optimally on the subarray from index `i` to index `j`.\n\nWe initialize the diagonal elements of the table: `dp[i][i] = nums[i]`, since if there's only one element left in the game, the player will have to pick it up.\n\nWe iterate through the table by fixing the distance `len` between the start and end indices of the subarray. For each subarray `nums[i...j]` where `j = i + len`, player 1 has two choices: picking the first element of the subarray `nums[i]`, or picking the last element of the subarray `nums[j]`. Since both players play optimally, we consider the score difference after player 2 plays their turn. This can be found in the `dp` table from the following subproblems:\n\n1. If player 1 picks `nums[i]`, then the score difference after player 2's turn will be `nums[i] - dp[i + 1][j]`.\n2. If player 1 picks `nums[j]`, then the score difference after player 2's turn will be `nums[j] - dp[i][j - 1]`.\n\nWe choose the option which gives the maximum score difference for player 1: `dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])`.\n\nFinally, we return `true` if `dp[0][n - 1] >= 0`, which means that player 1 has a score greater than or equal to player 2 when playing optimally on the entire input array. Otherwise, we return `false`.\n    ", "javascript": "\n    ```javascript\nfunction canWin(nums) {\n    const n = nums.length;\n    const dp = Array.from({ length: n }, () => Array(n).fill(0));\n    for (let i = 0; i < n; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (let len = 1; len < n; len++) {\n        for (let i = 0; i < n - len; i++) {\n            const j = i + len;\n            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n        }\n    }\n    return dp[0][n - 1] >= 0;\n}\n```\n\n    \n    We use dynamic programming to solve this problem. We create a 2D table `dp` of size `n x n` where `n` is the length of the input array `nums`. `dp[i][j]` represents the maximum score difference that player 1 can get when playing optimally on the subarray from index `i` to index `j`.\n\nWe initialize the diagonal elements of the table: `dp[i][i] = nums[i]`, since if there's only one element left in the game, the player will have to pick it up.\n\nWe iterate through the table by fixing the distance `len` between the start and end indices of the subarray. For each subarray `nums[i...j]` where `j = i + len`, player 1 has two choices: picking the first element of the subarray `nums[i]`, or picking the last element of the subarray `nums[j]`. Since both players play optimally, we consider the score difference after player 2 plays their turn. This can be found in the `dp` table from the following subproblems:\n\n1. If player 1 picks `nums[i]`, then the score difference after player 2's turn will be `nums[i] - dp[i + 1][j]`.\n2. If player 1 picks `nums[j]`, then the score difference after player 2's turn will be `nums[j] - dp[i][j - 1]`.\n\nWe choose the option which gives the maximum score difference for player 1: `dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])`.\n\nFinally, we return `true` if `dp[0][n - 1] >= 0`, which means that player 1 has a score greater than or equal to player 2 when playing optimally on the entire input array. Otherwise, we return `false`.\n    "}
{"id": 488, "slug": "zuma-game", "title": "Zuma Game", "difficulty": "Hard", "content": "You are playing a variation of the game Zuma.\n\nIn this variation of Zuma, there is a **single row** of colored balls on a board, where each ball can be colored red `'R'`, yellow `'Y'`, blue `'B'`, green `'G'`, or white `'W'`. You also have several colored balls in your hand.\n\nYour goal is to **clear all** of the balls from the board. On each turn:\n\n*   Pick **any** ball from your hand and insert it in between two balls in the row or on either end of the row.\n*   If there is a group of **three or more consecutive balls** of the **same color**, remove the group of balls from the board.\n    *   If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.\n*   If there are no more balls on the board, then you win the game.\n*   Repeat this process until you either win or do not have any more balls in your hand.\n\nGiven a string `board`, representing the row of balls on the board, and a string `hand`, representing the balls in your hand, return _the **minimum** number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return_ `-1`.\n\n**Example 1:**\n\n**Input:** board =  \"WRRBBW \", hand =  \"RB \"\n**Output:** -1\n**Explanation:** It is impossible to clear all the balls. The best you can do is:\n- Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.\n- Insert 'B' so the board becomes WBBBW. WBBBW -> WW.\nThere are still balls remaining on the board, and you are out of balls to insert.\n\n**Example 2:**\n\n**Input:** board =  \"WWRRBBWW \", hand =  \"WRBRW \"\n**Output:** 2\n**Explanation:** To make the board empty:\n- Insert 'R' so the board becomes WWRRRBBWW. WWRRRBBWW -> WWBBWW.\n- Insert 'B' so the board becomes WWBBBWW. WWBBBWW -> WWWW -> empty.\n2 balls from your hand were needed to clear the board.\n\n**Example 3:**\n\n**Input:** board =  \"G \", hand =  \"GGGGG \"\n**Output:** 2\n**Explanation:** To make the board empty:\n- Insert 'G' so the board becomes GG.\n- Insert 'G' so the board becomes GGG. GGG -> empty.\n2 balls from your hand were needed to clear the board.\n\n**Constraints:**\n\n*   `1 <= board.length <= 16`\n*   `1 <= hand.length <= 5`\n*   `board` and `hand` consist of the characters `'R'`, `'Y'`, `'B'`, `'G'`, and `'W'`.\n*   The initial row of balls on the board will **not** have any groups of three or more consecutive balls of the same color.", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int findMinStep(String board, String hand) {\n        HashMap<Character, Integer> handMap = new HashMap<>();\n        for (char c : hand.toCharArray()) handMap.put(c, handMap.getOrDefault(c, 0) + 1);\n\n        return findMinStepHelper(board, new HashMap<String, Integer>(), handMap);\n    }\n\n    private int findMinStepHelper(String board, HashMap<String, Integer> memo, HashMap<Character, Integer> hand) {\n        if (board.isEmpty()) return 0;\n        if (memo.containsKey(board)) return memo.get(board);\n\n        int result = Integer.MAX_VALUE;\n        for (int i = 0, j = 0; i < board.length(); i = j) {\n            while (j < board.length() && board.charAt(i) == board.charAt(j)) ++j;\n            char color = board.charAt(i);\n            int required = 3 - (j - i);\n            if (hand.getOrDefault(color, 0) >= required) {\n                hand.put(color, hand.get(color) - required);\n                String nextBoard = board.substring(0, i) + board.substring(j);\n                int tmp = findMinStepHelper(nextBoard, memo, hand);\n                if (tmp != -1) result = Math.min(result, tmp + required);\n                hand.put(color, hand.get(color) + required);\n            }\n        }\n\n        int res = (result == Integer.MAX_VALUE) ? -1 : result;\n        memo.put(board, res);\n        return res;\n    }\n}\n```\n\n    \n    The algorithm uses a backtracking approach along with memoization. The base case for the recursion is when there is an empty board, in which case the minimum number of balls to clear the board is 0.\n\nThe function loops through the board to find sequences of the same color. For each sequence, it calculates the number of balls needed to reach at least 3 in a row. If the required number of balls are available in hand, it removes the required balls from hand and proceeds recursively with the rest of the board.\n\nAfter the recursive call, the removed balls are added back to the hand.\n\nThe memoization is used to store the results of subproblems based on the current state of the board.\n\nThe result is -1 if the balls in hand cannot clear the board, otherwise, the minimum number of balls required to clear the board is returned.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nint find_min_step_helper(string& board, unordered_map<string, int>& memo, unordered_map<char, int>& hand) {\n    if (board.empty()) return 0;\n    if (memo.count(board)) return memo[board];\n\n    int result = INT_MAX;\n    for (int i = 0, j = 0; i < board.size(); i = j) {\n        while (j < board.size() and board[i] == board[j]) ++j;\n        char color = board[i];\n        int required = 3 - (j - i);\n        if (hand[color] >= required) {\n            hand[color] -= required;\n            string next_board = board.substr(0, i) + board.substr(j);\n            int tmp = find_min_step_helper(next_board, memo, hand);\n            if (tmp != -1) result = min(result, tmp + required);\n            hand[color] += required;\n        }\n    }\n\n    memo[board] = result == INT_MAX ? -1 : result;\n    return memo[board];\n}\n\nint find_min_step(string board, string hand) {\n    unordered_map<char, int> hand_map;\n    for (char c : hand) ++hand_map[c];\n    unordered_map<string, int> memo;\n    return find_min_step_helper(board, memo, hand_map);\n}\n```\n\n    \n    The algorithm uses a backtracking approach along with memoization. The base case for the recursion is when there is an empty board, in which case the minimum number of balls to clear the board is 0.\n\nThe function loops through the board to find sequences of the same color. For each sequence, it calculates the number of balls needed to reach at least 3 in a row. If the required number of balls are available in hand, it removes the required balls from hand and proceeds recursively with the rest of the board.\n\nAfter the recursive call, the removed balls are added back to the hand.\n\nThe memoization is used to store the results of subproblems based on the current state of the board.\n\nThe result is -1 if the balls in hand cannot clear the board, otherwise, the minimum number of balls required to clear the board is returned.\n    ", "python": "\n    ```python\nfrom collections import Counter\n\ndef find_min_step(board: str, hand: str) -> int:\n    def find_min_step_helper(board, memo, hand):\n        if not board:\n            return 0\n        if board in memo:\n            return memo[board]\n\n        result = float('inf')\n        i = 0\n        while i < len(board):\n            j = i\n            while j < len(board) and board[i] == board[j]:\n                j += 1            \n\n            color = board[i]\n            required = 3 - (j - i)\n            if hand[color] >= required:\n                hand[color] -= required\n                next_board = board[:i] + board[j:]\n                tmp = find_min_step_helper(next_board, memo, hand)\n                if tmp != -1:\n                    result = min(result, tmp + required)\n                hand[color] += required\n            i = j\n\n        memo[board] = -1 if result == float('inf') else result\n        return memo[board]\n\n    hand_count = Counter(hand)\n    memo = {}\n    return find_min_step_helper(board, memo, hand_count)\n```\n\n    \n    The algorithm uses a backtracking approach along with memoization. The base case for the recursion is when there is an empty board, in which case the minimum number of balls to clear the board is 0.\n\nThe function loops through the board to find sequences of the same color. For each sequence, it calculates the number of balls needed to reach at least 3 in a row. If the required number of balls are available in hand, it removes the required balls from hand and proceeds recursively with the rest of the board.\n\nAfter the recursive call, the removed balls are added back to the hand.\n\nThe memoization is used to store the results of subproblems based on the current state of the board.\n\nThe result is -1 if the balls in hand cannot clear the board, otherwise, the minimum number of balls required to clear the board is returned.\n    ", "javascript": "\n    ```javascript\nfunction findMinStep(board, hand) {\n    function findMinStepHelper(board, memo, hand) {\n        if (board.length === 0) return 0;\n        if (memo.has(board)) return memo.get(board);\n\n        let result = Infinity;\n        let i = 0;\n        while (i < board.length) {\n            let j = i;\n            while (j < board.length && board[i] === board[j]) j++;\n\n            let color = board[i];\n            let required = 3 - (j - i);\n            if (hand[color] >= required) {\n                hand[color] -= required;\n                let nextBoard = board.slice(0, i) + board.slice(j);\n                let tmp = findMinStepHelper(nextBoard, memo, hand);\n                if (tmp !== -1) result = Math.min(result, tmp + required);\n                hand[color] += required;\n            }\n            i = j;\n        }\n\n        let res = (result === Infinity) ? -1 : result;\n        memo.set(board, res);\n        return res;\n    }\n\n    let handMap = {};\n    for (let c of hand) handMap[c] = (handMap[c] || 0) + 1;\n\n    return findMinStepHelper(board, new Map(), handMap);\n}\n```\n\n    \n    The algorithm uses a backtracking approach along with memoization. The base case for the recursion is when there is an empty board, in which case the minimum number of balls to clear the board is 0.\n\nThe function loops through the board to find sequences of the same color. For each sequence, it calculates the number of balls needed to reach at least 3 in a row. If the required number of balls are available in hand, it removes the required balls from hand and proceeds recursively with the rest of the board.\n\nAfter the recursive call, the removed balls are added back to the hand.\n\nThe memoization is used to store the results of subproblems based on the current state of the board.\n\nThe result is -1 if the balls in hand cannot clear the board, otherwise, the minimum number of balls required to clear the board is returned.\n    "}
{"id": 494, "slug": "target-sum", "title": "Target Sum", "difficulty": "Medium", "content": "You are given an integer array `nums` and an integer `target`.\n\nYou want to build an **expression** out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate all the integers.\n\n*   For example, if `nums = [2, 1]`, you can add a `'+'` before `2` and a `'-'` before `1` and concatenate them to build the expression `\"+2-1 \"`.\n\nReturn the number of different **expressions** that you can build, which evaluates to `target`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,1,1,1\\], target = 3\n**Output:** 5\n**Explanation:** There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n\n**Example 2:**\n\n**Input:** nums = \\[1\\], target = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 20`\n*   `0 <= nums[i] <= 1000`\n*   `0 <= sum(nums[i]) <= 1000`\n*   `-1000 <= target <= 1000`", "java": "\n    ```java\npublic int findTargetSumWays(int[] nums, int target) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    if (sum < target || (sum + target) % 2 != 0) return 0;\n    int target_sum = (sum + target) / 2;\n    int[] dp = new int[target_sum + 1];\n    dp[0] = 1;\n    for (int num : nums) {\n        for (int j = target_sum; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[target_sum];\n}\n```\n\n    \n    The problem can be reduced to a subset sum problem by doing some simple math. First, calculate the sum of all numbers in the array. If the sum of integers is less than the target value or the total sum with target value is odd, there are no possible combinations.\n\nThe required subset sum is (sum + target) / 2. We will use dynamic programming to count the number of subsets with the target sum. Initialize a DP array of size `target_sum + 1` and set the first value to 1 because the empty subset adds up to 0.\n\nIterate through the given numbers and for each number, update the values in DP array by enumerating the subsets with the i-th number included as follows:\n\n1. If the current number is less than or equal to the target_sum, calculate the new value of the current subset by adding the value at a position shifted by the current number.\n\n2. Store the new value and the current number in the DP array.\n\nReturn the greater number of different target-sum expressions saved in the DP array.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nint findTargetSumWays(std::vector<int>& nums, int target) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    if (sum < target || (sum + target) % 2 != 0) return 0;\n    int target_sum = (sum + target) / 2;\n    std::vector<int> dp(target_sum + 1, 0);\n    dp[0] = 1;\n    for (int num : nums) {\n        for (int j = target_sum; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[target_sum];\n}\n```\n\n    \n    The problem can be reduced to a subset sum problem by doing some simple math. First, calculate the sum of all numbers in the array. If the sum of integers is less than the target value or the total sum with target value is odd, there are no possible combinations.\n\nThe required subset sum is (sum + target) / 2. We will use dynamic programming to count the number of subsets with the target sum. Initialize a DP array of size `target_sum + 1` and set the first value to 1 because the empty subset adds up to 0.\n\nIterate through the given numbers and for each number, update the values in DP array by enumerating the subsets with the i-th number included as follows:\n\n1. If the current number is less than or equal to the target_sum, calculate the new value of the current subset by adding the value at a position shifted by the current number.\n\n2. Store the new value and the current number in the DP array.\n\nReturn the greater number of different target-sum expressions saved in the DP array.\n    ", "python": "\n    ```python\ndef findTargetSumWays(nums, target):\n    total_sum = sum(nums)\n    if total_sum < target or (total_sum + target) % 2 != 0:\n        return 0\n    target_sum = (total_sum + target) // 2\n    dp = [0] * (target_sum + 1)\n    dp[0] = 1\n    for num in nums:\n        for j in range(target_sum, num - 1, -1):\n            dp[j] += dp[j - num]\n    return dp[target_sum]\n```\n\n    \n    The problem can be reduced to a subset sum problem by doing some simple math. First, calculate the sum of all numbers in the array. If the sum of integers is less than the target value or the total sum with target value is odd, there are no possible combinations.\n\nThe required subset sum is (sum + target) / 2. We will use dynamic programming to count the number of subsets with the target sum. Initialize a DP array of size `target_sum + 1` and set the first value to 1 because the empty subset adds up to 0.\n\nIterate through the given numbers and for each number, update the values in DP array by enumerating the subsets with the i-th number included as follows:\n\n1. If the current number is less than or equal to the target_sum, calculate the new value of the current subset by adding the value at a position shifted by the current number.\n\n2. Store the new value and the current number in the DP array.\n\nReturn the greater number of different target-sum expressions saved in the DP array.\n    ", "javascript": "\n    ```javascript\nfunction findTargetSumWays(nums, target) {\n    let sum = nums.reduce((a, b) => a + b);\n    if (sum < target || (sum + target) % 2 !== 0) return 0;\n    let target_sum = (sum + target) >> 1;\n    let dp = new Array(target_sum + 1).fill(0);\n    dp[0] = 1;\n    for (const num of nums) {\n        for (let j = target_sum; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[target_sum];\n}\n```\n\n    \n    The problem can be reduced to a subset sum problem by doing some simple math. First, calculate the sum of all numbers in the array. If the sum of integers is less than the target value or the total sum with target value is odd, there are no possible combinations.\n\nThe required subset sum is (sum + target) / 2. We will use dynamic programming to count the number of subsets with the target sum. Initialize a DP array of size `target_sum + 1` and set the first value to 1 because the empty subset adds up to 0.\n\nIterate through the given numbers and for each number, update the values in DP array by enumerating the subsets with the i-th number included as follows:\n\n1. If the current number is less than or equal to the target_sum, calculate the new value of the current subset by adding the value at a position shifted by the current number.\n\n2. Store the new value and the current number in the DP array.\n\nReturn the greater number of different target-sum expressions saved in the DP array.\n    "}
{"id": 514, "slug": "freedom-trail", "title": "Freedom Trail", "difficulty": "Hard", "content": "In the video game Fallout 4, the quest **\"Road to Freedom \"** requires players to reach a metal dial called the **\"Freedom Trail Ring \"** and use the dial to spell a specific keyword to open the door.\n\nGiven a string `ring` that represents the code engraved on the outer ring and another string `key` that represents the keyword that needs to be spelled, return _the minimum number of steps to spell all the characters in the keyword_.\n\nInitially, the first character of the ring is aligned at the `\"12:00 \"` direction. You should spell all the characters in `key` one by one by rotating `ring` clockwise or anticlockwise to make each character of the string key aligned at the `\"12:00 \"` direction and then by pressing the center button.\n\nAt the stage of rotating the ring to spell the key character `key[i]`:\n\n1.  You can rotate the ring clockwise or anticlockwise by one place, which counts as **one step**. The final purpose of the rotation is to align one of `ring`'s characters at the `\"12:00 \"` direction, where this character must equal `key[i]`.\n2.  If the character `key[i]` has been aligned at the `\"12:00 \"` direction, press the center button to spell, which also counts as **one step**. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.\n\n**Example 1:**\n\n**Input:** ring =  \"godding \", key =  \"gd \"\n**Output:** 4\n**Explanation:**\nFor the first key character 'g', since it is already in place, we just need 1 step to spell this character. \nFor the second key character 'd', we need to rotate the ring  \"godding \" anticlockwise by two steps to make it become  \"ddinggo \".\nAlso, we need 1 more step for spelling.\nSo the final output is 4.\n\n**Example 2:**\n\n**Input:** ring =  \"godding \", key =  \"godding \"\n**Output:** 13\n\n**Constraints:**\n\n*   `1 <= ring.length, key.length <= 100`\n*   `ring` and `key` consist of only lower case English letters.\n*   It is guaranteed that `key` could always be spelled by rotating `ring`.", "java": "\n    ```java\npublic int findRotateSteps(String ring, String key) {\n    int n = ring.length(), m = key.length();\n    int[][] dp = new int[m + 1][n];\n\n    for (int i = m - 1; i >= 0; --i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = Integer.MAX_VALUE;\n            for (int k = 0; k < n; ++k) {\n                if (ring.charAt(k) == key.charAt(i)) {\n                    int diff = Math.abs(j - k);\n                    int step = Math.min(diff, n - diff);\n                    dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}\n```\n\n    \n    The algorithm uses dynamic programming. Create a 2D table (\"dp\") with the dimensions of the length of the key + 1 as rows and the length of the ring as columns. The table represents the minimum number of steps required to reach each character in the key by aligning it to the 12:00 direction.\n\nThe main logic runs in reverse of the key string. For each character in the key, the outer ring positions are iterated and checked if the character in the ring matches the character in the key. The minimum steps to reach the matching character are calculated and updated in the \"dp\" table.\n\nFinally, the first element in the \"dp\" table would represent the minimum number of steps required to complete the whole key. The result is the sum of that value and the length of the key.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\nint findRotateSteps(std::string ring, std::string key) {\n    int n = ring.size(), m = key.size();\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n, 0));\n\n    for (int i = m - 1; i >= 0; --i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = INT_MAX;\n            for (int k = 0; k < n; ++k) {\n                if (ring[k] == key[i]) {\n                    int diff = abs(j - k);\n                    int step = std::min(diff, n - diff);\n                    dp[i][j] = std::min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}\n```\n\n    \n    The algorithm uses dynamic programming. Create a 2D table (\"dp\") with the dimensions of the length of the key + 1 as rows and the length of the ring as columns. The table represents the minimum number of steps required to reach each character in the key by aligning it to the 12:00 direction.\n\nThe main logic runs in reverse of the key string. For each character in the key, the outer ring positions are iterated and checked if the character in the ring matches the character in the key. The minimum steps to reach the matching character are calculated and updated in the \"dp\" table.\n\nFinally, the first element in the \"dp\" table would represent the minimum number of steps required to complete the whole key. The result is the sum of that value and the length of the key.\n    ", "python": "\n    ```python\ndef find_rotate_steps(ring: str, key: str) -> int:\n    n, m = len(ring), len(key)\n    dp = [[0] * n for _ in range(m + 1)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n):\n            dp[i][j] = float('inf')\n            for k in range(n):\n                if ring[k] == key[i]:\n                    diff = abs(j - k)\n                    step = min(diff, n - diff)\n                    dp[i][j] = min(dp[i][j], step + dp[i + 1][k])\n\n    return dp[0][0] + m\n```\n\n    \n    The algorithm uses dynamic programming. Create a 2D table (\"dp\") with the dimensions of the length of the key + 1 as rows and the length of the ring as columns. The table represents the minimum number of steps required to reach each character in the key by aligning it to the 12:00 direction.\n\nThe main logic runs in reverse of the key string. For each character in the key, the outer ring positions are iterated and checked if the character in the ring matches the character in the key. The minimum steps to reach the matching character are calculated and updated in the \"dp\" table.\n\nFinally, the first element in the \"dp\" table would represent the minimum number of steps required to complete the whole key. The result is the sum of that value and the length of the key.\n    ", "javascript": "\n    ```javascript\nfunction findRotateSteps(ring, key) {\n    const n = ring.length, m = key.length;\n    const dp = Array.from({ length: m + 1 }, () => new Array(n).fill(0));\n\n    for (let i = m - 1; i >= 0; --i) {\n        for (let j = 0; j < n; ++j) {\n            dp[i][j] = Infinity;\n            for (let k = 0; k < n; ++k) {\n                if (ring[k] === key[i]) {\n                    const diff = Math.abs(j - k);\n                    const step = Math.min(diff, n - diff);\n                    dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}\n```\n\n    \n    The algorithm uses dynamic programming. Create a 2D table (\"dp\") with the dimensions of the length of the key + 1 as rows and the length of the ring as columns. The table represents the minimum number of steps required to reach each character in the key by aligning it to the 12:00 direction.\n\nThe main logic runs in reverse of the key string. For each character in the key, the outer ring positions are iterated and checked if the character in the ring matches the character in the key. The minimum steps to reach the matching character are calculated and updated in the \"dp\" table.\n\nFinally, the first element in the \"dp\" table would represent the minimum number of steps required to complete the whole key. The result is the sum of that value and the length of the key.\n    "}
{"id": 516, "slug": "longest-palindromic-subsequence", "title": "Longest Palindromic Subsequence", "difficulty": "Medium", "content": "Given a string `s`, find _the longest palindromic **subsequence**'s length in_ `s`.\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n**Example 1:**\n\n**Input:** s =  \"bbbab \"\n**Output:** 4\n**Explanation:** One possible longest palindromic subsequence is  \"bbbb \".\n\n**Example 2:**\n\n**Input:** s =  \"cbbd \"\n**Output:** 2\n**Explanation:** One possible longest palindromic subsequence is  \"bb \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists only of lowercase English letters.", "java": "\n    ```java\npublic int longestPalindromeSubseq(String s) {\n    int n = s.length();\n    int[][] dp = new int[n][n];\n    \n    for (int i = n - 1; i >= 0; i--) {\n        dp[i][i] = 1;\n        for (int j = i + 1; j < n; j++) {\n            if (s.charAt(i) == s.charAt(j)) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the longest palindromic subsequence's length. It initializes a 2D table (dp) of size nxn, where n is the length of the string. The entries `dp[i][j]` represent the length of the longest palindromic subsequence in the string for the substring starting from index i and ending at index j.\n\nThe algorithm first fills the diagonal creating a single character palindrome. Then, it iterates through the string comparing the characters. When equal, the length of the longest palindromic subsequence increases by 2 plus the length of the longest palindrome found inside of these characters. If unequal, the longer subsequence length between the substrings not containing those characters is taken. \n\nFinally, the function returns the length of the longest palindromic subsequence found in the entire string (`dp[0][n-1]`).\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint longestPalindromeSubseq(string s) {\n    int n = s.size();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    for (int i = n - 1; i >= 0; i--) {\n        dp[i][i] = 1;\n        for (int j = i + 1; j < n; j++) {\n            if (s[i] == s[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the longest palindromic subsequence's length. It initializes a 2D table (dp) of size nxn, where n is the length of the string. The entries `dp[i][j]` represent the length of the longest palindromic subsequence in the string for the substring starting from index i and ending at index j.\n\nThe algorithm first fills the diagonal creating a single character palindrome. Then, it iterates through the string comparing the characters. When equal, the length of the longest palindromic subsequence increases by 2 plus the length of the longest palindrome found inside of these characters. If unequal, the longer subsequence length between the substrings not containing those characters is taken. \n\nFinally, the function returns the length of the longest palindromic subsequence found in the entire string (`dp[0][n-1]`).\n    ", "python": "\n    ```python\ndef longestPalindromeSubseq(s: str) -> int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n                \n    return dp[0][n - 1]\n```\n    \n    The algorithm uses dynamic programming to find the longest palindromic subsequence's length. It initializes a 2D table (dp) of size nxn, where n is the length of the string. The entries `dp[i][j]` represent the length of the longest palindromic subsequence in the string for the substring starting from index i and ending at index j.\n\nThe algorithm first fills the diagonal creating a single character palindrome. Then, it iterates through the string comparing the characters. When equal, the length of the longest palindromic subsequence increases by 2 plus the length of the longest palindrome found inside of these characters. If unequal, the longer subsequence length between the substrings not containing those characters is taken. \n\nFinally, the function returns the length of the longest palindromic subsequence found in the entire string (`dp[0][n-1]`).\n    ", "javascript": "\n    ```javascript\nfunction longestPalindromeSubseq(s) {\n    const n = s.length;\n    const dp = Array.from({ length: n }, () => Array(n).fill(0));\n\n    for (let i = n - 1; i >= 0; i--) {\n        dp[i][i] = 1;\n        for (let j = i + 1; j < n; j++) {\n            if (s[i] === s[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the longest palindromic subsequence's length. It initializes a 2D table (dp) of size nxn, where n is the length of the string. The entries `dp[i][j]` represent the length of the longest palindromic subsequence in the string for the substring starting from index i and ending at index j.\n\nThe algorithm first fills the diagonal creating a single character palindrome. Then, it iterates through the string comparing the characters. When equal, the length of the longest palindromic subsequence increases by 2 plus the length of the longest palindrome found inside of these characters. If unequal, the longer subsequence length between the substrings not containing those characters is taken. \n\nFinally, the function returns the length of the longest palindromic subsequence found in the entire string (`dp[0][n-1]`).\n    "}
{"id": 518, "slug": "coin-change-ii", "title": "Coin Change II", "difficulty": "Medium", "content": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the number of combinations that make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `0`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is **guaranteed** to fit into a signed **32-bit** integer.\n\n**Example 1:**\n\n**Input:** amount = 5, coins = \\[1,2,5\\]\n**Output:** 4\n**Explanation:** there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n\n**Example 2:**\n\n**Input:** amount = 3, coins = \\[2\\]\n**Output:** 0\n**Explanation:** the amount of 3 cannot be made up just with coins of 2.\n\n**Example 3:**\n\n**Input:** amount = 10, coins = \\[10\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= coins.length <= 300`\n*   `1 <= coins[i] <= 5000`\n*   All the values of `coins` are **unique**.\n*   `0 <= amount <= 5000`", "java": "\n    ```java\npublic int change(int amount, int[] coins) {\n    int[] dp = new int[amount + 1];\n    dp[0] = 1;\n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    return dp[amount];\n}\n```\n    \n    1. Initialize an array `dp` where `dp[i]` represents the number of combinations that make up the amount `i`. The length of the array is `amount + 1` to accommodate index 0. Set `dp[0]` to 1 as there is only one way to make up the amount 0 (by not picking any coins).\n2. Loop through each coin in the `coins` array.\n3. For each coin, iterate through the `dp` array, starting at the index equal to the coin value.\n4. In each iteration, increment the value of `dp[i]` by `dp[i - coin]`. This is because the number of combinations that can make up `i` is increased by the number of combinations that can make up `i - coin`.\n5. After iterating through all the coins and updating the `dp` array, return the value of `dp[amount]`, which represents the number of combinations that can make up the desired amount.\n    ", "c++": "\n    ```cpp\nint change(int amount, vector<int>& coins) {\n    vector<int> dp(amount + 1, 0);\n    dp[0] = 1;\n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    return dp[amount];\n}\n```\n    \n    1. Initialize an array `dp` where `dp[i]` represents the number of combinations that make up the amount `i`. The length of the array is `amount + 1` to accommodate index 0. Set `dp[0]` to 1 as there is only one way to make up the amount 0 (by not picking any coins).\n2. Loop through each coin in the `coins` array.\n3. For each coin, iterate through the `dp` array, starting at the index equal to the coin value.\n4. In each iteration, increment the value of `dp[i]` by `dp[i - coin]`. This is because the number of combinations that can make up `i` is increased by the number of combinations that can make up `i - coin`.\n5. After iterating through all the coins and updating the `dp` array, return the value of `dp[amount]`, which represents the number of combinations that can make up the desired amount.\n    ", "python": "\n    ```python\ndef change(amount, coins):\n    dp = [1] + [0] * amount\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    return dp[amount]\n```\n    \n    1. Initialize an array `dp` where `dp[i]` represents the number of combinations that make up the amount `i`. The length of the array is `amount + 1` to accommodate index 0. Set `dp[0]` to 1 as there is only one way to make up the amount 0 (by not picking any coins).\n2. Loop through each coin in the `coins` array.\n3. For each coin, iterate through the `dp` array, starting at the index equal to the coin value.\n4. In each iteration, increment the value of `dp[i]` by `dp[i - coin]`. This is because the number of combinations that can make up `i` is increased by the number of combinations that can make up `i - coin`.\n5. After iterating through all the coins and updating the `dp` array, return the value of `dp[amount]`, which represents the number of combinations that can make up the desired amount.\n    ", "javascript": "\n    ```javascript\nfunction change(amount, coins) {\n    let dp = new Array(amount + 1).fill(0);\n    dp[0] = 1;\n    for (let coin of coins) {\n        for (let i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    return dp[amount];\n}\n```\n    \n    1. Initialize an array `dp` where `dp[i]` represents the number of combinations that make up the amount `i`. The length of the array is `amount + 1` to accommodate index 0. Set `dp[0]` to 1 as there is only one way to make up the amount 0 (by not picking any coins).\n2. Loop through each coin in the `coins` array.\n3. For each coin, iterate through the `dp` array, starting at the index equal to the coin value.\n4. In each iteration, increment the value of `dp[i]` by `dp[i - coin]`. This is because the number of combinations that can make up `i` is increased by the number of combinations that can make up `i - coin`.\n5. After iterating through all the coins and updating the `dp` array, return the value of `dp[amount]`, which represents the number of combinations that can make up the desired amount.\n    "}
{"id": 526, "slug": "beautiful-arrangement", "title": "Beautiful Arrangement", "difficulty": "Medium", "content": "Suppose you have `n` integers labeled `1` through `n`. A permutation of those `n` integers `perm` (**1-indexed**) is considered a **beautiful arrangement** if for every `i` (`1 <= i <= n`), **either** of the following is true:\n\n*   `perm[i]` is divisible by `i`.\n*   `i` is divisible by `perm[i]`.\n\nGiven an integer `n`, return _the **number** of the **beautiful arrangements** that you can construct_.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** \nThe first beautiful arrangement is \\[1,2\\]:\n    - perm\\[1\\] = 1 is divisible by i = 1\n    - perm\\[2\\] = 2 is divisible by i = 2\nThe second beautiful arrangement is \\[2,1\\]:\n    - perm\\[1\\] = 2 is divisible by i = 1\n    - i = 2 is divisible by perm\\[2\\] = 1\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 15`", "java": "\n    ```java\nint countArrangement(int n) {\n    int[] res = new int[]{0};\n    boolean[] visited = new boolean[n+1];\n    helper(n, 1, visited, res);\n    return res[0];\n}\n\nvoid helper(int n, int idx, boolean[] visited, int[] res) {\n    if (idx > n) {\n        res[0]++;\n    }\n\n    for(int i=1; i<=n; i++){\n        if (!visited[i] && (idx % i == 0 || i % idx == 0)) {\n            visited[i] = true;\n            helper(n, idx+1, visited, res);\n            visited[i] = false;\n        }\n    }\n}\n```\n    \n    This problem can be solved using a backtracking algorithm. We can start by creating a helper function (a recursive function) that will iterate through all possibilities. The base case for the recursion is when the current index (idx) is greater than the given integer n. When this condition is met, increment the result (res) by 1.\n\nIn the helper function, iterate a loop for each integer i (1 <= i <= n). Check if i is not visited (visited[i] == false) and if i is divisible by idx or idx is divisible by i. If either of these conditions is true, mark i as visited and call the helper function recursively with the index incremented by 1. After the recursive call, unmark i as visited to backtrack to the previous state.\n\nInitially, pass an array or vector of visited flags, which are all initialized to false along with the integer n and index 1 to the helper function. The helper function will traverse all possibilities and return the result (res) as the final count of beautiful arrangements.\n    ", "c++": "\n    ```cpp\nint countArrangement(int n) {\n    int res=0;\n    vector<bool> visited(n+1,false); \n    helper(n,1,visited,res); \n    return res;\n}\n\nvoid helper(int n, int idx, vector<bool>& visited, int& res) {\n    if (idx > n) {\n        ++res;\n    }\n\n    for(int i=1; i<=n; i++){\n        if (!visited[i] && (idx % i == 0 || i % idx == 0)) { \n            visited[i] = true; \n            helper(n, idx+1, visited, res); \n            visited[i] = false; \n        }\n    }\n}\n```\n    \n    This problem can be solved using a backtracking algorithm. We can start by creating a helper function (a recursive function) that will iterate through all possibilities. The base case for the recursion is when the current index (idx) is greater than the given integer n. When this condition is met, increment the result (res) by 1.\n\nIn the helper function, iterate a loop for each integer i (1 <= i <= n). Check if i is not visited (visited[i] == false) and if i is divisible by idx or idx is divisible by i. If either of these conditions is true, mark i as visited and call the helper function recursively with the index incremented by 1. After the recursive call, unmark i as visited to backtrack to the previous state.\n\nInitially, pass an array or vector of visited flags, which are all initialized to false along with the integer n and index 1 to the helper function. The helper function will traverse all possibilities and return the result (res) as the final count of beautiful arrangements.\n    ", "python": "\n    ```python\ndef countArrangement(n: int) -> int:\n    def helper(idx: int, visited: List[bool], n: int) -> int:\n        if idx > n:\n            return 1\n\n        count = 0\n        for i in range(1, n+1):\n            if not visited[i] and (idx % i == 0 or i % idx == 0):\n                visited[i] = True\n                count += helper(idx+1, visited, n)\n                visited[i] = False\n\n        return count\n\n    visited = [False] * (n+1)\n    return helper(1, visited, n)\n```\n    \n    This problem can be solved using a backtracking algorithm. We can start by creating a helper function (a recursive function) that will iterate through all possibilities. The base case for the recursion is when the current index (idx) is greater than the given integer n. When this condition is met, increment the result (res) by 1.\n\nIn the helper function, iterate a loop for each integer i (1 <= i <= n). Check if i is not visited (visited[i] == false) and if i is divisible by idx or idx is divisible by i. If either of these conditions is true, mark i as visited and call the helper function recursively with the index incremented by 1. After the recursive call, unmark i as visited to backtrack to the previous state.\n\nInitially, pass an array or vector of visited flags, which are all initialized to false along with the integer n and index 1 to the helper function. The helper function will traverse all possibilities and return the result (res) as the final count of beautiful arrangements.\n    ", "javascript": "\n    ```javascript\nfunction countArrangement(n) {\n    let res=0;\n    let visited=Array(n+1).fill(false); \n    helper(n,1,visited); \n    return res;\n\n    function helper(n, idx, visited) {\n        if (idx > n) {\n            ++res;\n        }\n\n        for(let i=1; i<=n; i++){\n            if (!visited[i] && (idx % i === 0 || i % idx === 0)) { \n                visited[i] = true; \n                helper(n, idx+1, visited); \n                visited[i] = false; \n            }\n        }\n    }\n}\n```\n    \n    This problem can be solved using a backtracking algorithm. We can start by creating a helper function (a recursive function) that will iterate through all possibilities. The base case for the recursion is when the current index (idx) is greater than the given integer n. When this condition is met, increment the result (res) by 1.\n\nIn the helper function, iterate a loop for each integer i (1 <= i <= n). Check if i is not visited (visited[i] == false) and if i is divisible by idx or idx is divisible by i. If either of these conditions is true, mark i as visited and call the helper function recursively with the index incremented by 1. After the recursive call, unmark i as visited to backtrack to the previous state.\n\nInitially, pass an array or vector of visited flags, which are all initialized to false along with the integer n and index 1 to the helper function. The helper function will traverse all possibilities and return the result (res) as the final count of beautiful arrangements.\n    "}
{"id": 542, "slug": "01-matrix", "title": "01 Matrix", "difficulty": "Medium", "content": "Given an `m x n` binary matrix `mat`, return _the distance of the nearest_ `0` _for each cell_.\n\nThe distance between two adjacent cells is `1`.\n\n**Example 1:**\n\n**Input:** mat = \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n\n**Example 2:**\n\n**Input:** mat = \\[\\[0,0,0\\],\\[0,1,0\\],\\[1,1,1\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[0,1,0\\],\\[1,2,1\\]\\]\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 104`\n*   `1 <= m * n <= 104`\n*   `mat[i][j]` is either `0` or `1`.\n*   There is at least one `0` in `mat`.", "java": "\n    ```java\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic int[][] updateMatrix(int[][] mat) {\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][] distance = new int[m][n];\n    Queue<int[]> queue = new LinkedList<>();\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] == 0) {\n                distance[i][j] = 0;\n                queue.add(new int[]{i, j});\n            } else {\n                distance[i][j] = Integer.MAX_VALUE;\n            }\n        }\n    }\n\n    int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    while (!queue.isEmpty()) {\n        int[] current = queue.poll();\n        int x = current[0];\n        int y = current[1];\n\n        for (int[] dir : directions) {\n            int newX = x + dir[0];\n            int newY = y + dir[1];\n            if (newX >= 0 && newY >= 0 && newX < m && newY < n && distance[newX][newY] > distance[x][y] + 1) {\n                distance[newX][newY] = distance[x][y] + 1;\n                queue.add(new int[]{newX, newY});\n            }\n        }\n    }\n    return distance;\n}\n```\n\n    \n    1. Initialize an m x n matrix `distance` with 0 values and a queue.\n2. Iterate through the input matrix, setting the distance values to either 0 or infinity based on the original matrix value. For 0 values, push their coordinates to the queue.\n3. Define the 4 possible directions to move in the matrix.\n4. Use BFS (Breadth-First Search) to find the shortest distance to the nearest 0 for each cell:\n   a. Pop a cell (x, y) from the queue.\n   b. Iterate through each direction, checking if the new position is valid and the current distance is less than the current recorded position's distance.\n   c. If the new distance is shorter, update the distance and push the new position's coordinates to the queue.\n5. Return the `distance` matrix.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n    int m = mat.size();\n    int n = mat[0].size();\n    vector<vector<int>> ans(m, vector<int>(n, INT_MAX - 100000));\n    \n    queue<pair<int, int>> q;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] == 0) {\n                ans[i][j] = 0;\n                q.push({i, j});\n            }\n        }\n    }\n\n    vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n        \n        for (pair<int, int>& dir : dirs) {\n            int newX = x + dir.first;\n            int newY = y + dir.second;\n            if (newX >= 0 && newY >= 0 && newX < m && newY < n && ans[newX][newY] > ans[x][y] + 1) {\n                ans[newX][newY] = ans[x][y] + 1;\n                q.push({newX, newY});\n            }\n        }\n    }\n    return ans;\n}\n```\n\n    \n    1. Initialize an m x n matrix `distance` with 0 values and a queue.\n2. Iterate through the input matrix, setting the distance values to either 0 or infinity based on the original matrix value. For 0 values, push their coordinates to the queue.\n3. Define the 4 possible directions to move in the matrix.\n4. Use BFS (Breadth-First Search) to find the shortest distance to the nearest 0 for each cell:\n   a. Pop a cell (x, y) from the queue.\n   b. Iterate through each direction, checking if the new position is valid and the current distance is less than the current recorded position's distance.\n   c. If the new distance is shorter, update the distance and push the new position's coordinates to the queue.\n5. Return the `distance` matrix.\n    ", "python": "\n    ```python\nfrom collections import deque\n\ndef updateMatrix(mat):\n    m, n = len(mat), len(mat[0])\n    distance = [[0 if mat[i][j] == 0 else float('inf') for j in range(n)] for i in range(m)]\n    queue = deque([(i, j) for i in range(m) for j in range(n) if mat[i][j] == 0])\n\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            newX, newY = x + dx, y + dy\n            if 0 <= newX < m and 0 <= newY < n and distance[newX][newY] > distance[x][y] + 1:\n                distance[newX][newY] = distance[x][y] + 1\n                queue.append((newX, newY))\n\n    return distance\n```\n\n    \n    1. Initialize an m x n matrix `distance` with 0 values and a queue.\n2. Iterate through the input matrix, setting the distance values to either 0 or infinity based on the original matrix value. For 0 values, push their coordinates to the queue.\n3. Define the 4 possible directions to move in the matrix.\n4. Use BFS (Breadth-First Search) to find the shortest distance to the nearest 0 for each cell:\n   a. Pop a cell (x, y) from the queue.\n   b. Iterate through each direction, checking if the new position is valid and the current distance is less than the current recorded position's distance.\n   c. If the new distance is shorter, update the distance and push the new position's coordinates to the queue.\n5. Return the `distance` matrix.\n    ", "javascript": "\n    ```javascript\nfunction updateMatrix(mat) {\n    let m = mat.length;\n    let n = mat[0].length;\n    let distance = Array.from({ length: m }, () => Array.from({ length: n }, () => Infinity));\n    let queue = [];\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (mat[i][j] === 0) {\n                distance[i][j] = 0;\n                queue.push([i, j]);\n            }\n        }\n    }\n\n    let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n    while (queue.length) {\n        let [x, y] = queue.shift();\n        for (const [dx, dy] of directions) {\n            let newX = x + dx;\n            let newY = y + dy;\n            if (newX >= 0 && newY >= 0 && newX < m && newY < n && distance[newX][newY] > distance[x][y] + 1) {\n                distance[newX][newY] = distance[x][y] + 1;\n                queue.push([newX, newY]);\n            }\n        }\n    }\n    return distance;\n}\n```\n\n    \n    1. Initialize an m x n matrix `distance` with 0 values and a queue.\n2. Iterate through the input matrix, setting the distance values to either 0 or infinity based on the original matrix value. For 0 values, push their coordinates to the queue.\n3. Define the 4 possible directions to move in the matrix.\n4. Use BFS (Breadth-First Search) to find the shortest distance to the nearest 0 for each cell:\n   a. Pop a cell (x, y) from the queue.\n   b. Iterate through each direction, checking if the new position is valid and the current distance is less than the current recorded position's distance.\n   c. If the new distance is shorter, update the distance and push the new position's coordinates to the queue.\n5. Return the `distance` matrix.\n    "}
{"id": 546, "slug": "remove-boxes", "title": "Remove Boxes", "difficulty": "Hard", "content": "You are given several `boxes` with different colors represented by different positive numbers.\n\nYou may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of `k` boxes, `k >= 1`), remove them and get `k * k` points.\n\nReturn _the maximum points you can get_.\n\n**Example 1:**\n\n**Input:** boxes = \\[1,3,2,2,2,3,4,3,1\\]\n**Output:** 23\n**Explanation:**\n\\[1, 3, 2, 2, 2, 3, 4, 3, 1\\] \n----> \\[1, 3, 3, 4, 3, 1\\] (3\\*3=9 points) \n----> \\[1, 3, 3, 3, 1\\] (1\\*1=1 points) \n----> \\[1, 1\\] (3\\*3=9 points) \n----> \\[\\] (2\\*2=4 points)\n\n**Example 2:**\n\n**Input:** boxes = \\[1,1,1\\]\n**Output:** 9\n\n**Example 3:**\n\n**Input:** boxes = \\[1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= boxes.length <= 100`\n*   `1 <= boxes[i] <= 100`", "java": "\n    ```java\npublic int removeBoxes(int[] boxes) {\n    int[][][] dp = new int[100][100][100];\n    return dfs(boxes, dp, 0, boxes.length - 1, 0);\n}\n\nprivate int dfs(int[] boxes, int[][][] dp, int l, int r, int k) {\n    if (l > r) return 0;\n    if (dp[l][r][k] != 0) return dp[l][r][k];\n\n    while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n    dp[l][r][k] = (k + 1) * (k + 1) + dfs(boxes, dp, l, r - 1, 0);\n\n    for (int i = l; i < r; i++) {\n        if (boxes[i] == boxes[r]) {\n            dp[l][r][k] = Math.max(dp[l][r][k], dfs(boxes, dp, l, i, k + 1) + dfs(boxes, dp, i + 1, r - 1, 0));\n        }\n    }\n\n    return dp[l][r][k];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a 3D DP table where `dp[l][r][k]` will be the maximum points we can get for the boxes in the range `[l, r]`, where there are `k` boxes with the same color as `boxes[r]` to the right of `boxes[r]`. \n\nWe'll use a DFS approach to fill our DP table. \n1. First, we check whether our current range `l > r`, in which case we return 0.\n2. If `dp[l][r][k]` already has a non-zero value, we return `dp[l][r][k]`.\n3. Then, we remove all continuous boxes with the same color as `boxes[r]` on the right side of `boxes[r]` to calculate the initial value of `dp[l][r][k]`.\n4. We iterate from `l` to `r` and whenever we find a box with the same color as `boxes[r]`, we update `dp[l][r][k]` with the maximum of the current value and the sum of the result we get in the current split and the result that we have found for the next continuous split.\n\nFinally, we return the value in `dp[0][boxes.length - 1][0]`, which gives us the maximum points that can be obtained for the given input.\n    ", "c++": "\n    ```cpp\nint removeBoxes(vector<int>& boxes) {\n    int dp[100][100][100] = {0};\n    return dfs(boxes, dp, 0, boxes.size() - 1, 0);\n}\n\nint dfs(vector<int>& boxes, int dp[100][100][100], int l, int r, int k) {\n    if (l > r) return 0;\n    if (dp[l][r][k] != 0) return dp[l][r][k];\n\n    while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n    dp[l][r][k] = (k + 1) * (k + 1) + dfs(boxes, dp, l, r - 1, 0);\n\n    for (int i = l; i < r; i++) {\n        if (boxes[i] == boxes[r]) {\n            dp[l][r][k] = max(dp[l][r][k], dfs(boxes, dp, l, i, k + 1) + dfs(boxes, dp, i + 1, r - 1, 0));\n        }\n    }\n\n    return dp[l][r][k];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a 3D DP table where `dp[l][r][k]` will be the maximum points we can get for the boxes in the range `[l, r]`, where there are `k` boxes with the same color as `boxes[r]` to the right of `boxes[r]`. \n\nWe'll use a DFS approach to fill our DP table. \n1. First, we check whether our current range `l > r`, in which case we return 0.\n2. If `dp[l][r][k]` already has a non-zero value, we return `dp[l][r][k]`.\n3. Then, we remove all continuous boxes with the same color as `boxes[r]` on the right side of `boxes[r]` to calculate the initial value of `dp[l][r][k]`.\n4. We iterate from `l` to `r` and whenever we find a box with the same color as `boxes[r]`, we update `dp[l][r][k]` with the maximum of the current value and the sum of the result we get in the current split and the result that we have found for the next continuous split.\n\nFinally, we return the value in `dp[0][boxes.length - 1][0]`, which gives us the maximum points that can be obtained for the given input.\n    ", "python": "\n    ```python\ndef removeBoxes(boxes):\n    def dfs(l, r, k):\n        if l > r: return 0\n        if dp[l][r][k] != 0: return dp[l][r][k]\n\n        while r > l and boxes[r] == boxes[r - 1]:\n            r -= 1\n            k += 1\n            \n        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0)\n\n        for i in range(l, r):\n            if boxes[i] == boxes[r]:\n                dp[l][r][k] = max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0))\n                \n        return dp[l][r][k]\n\n    dp = [[[0] * 100 for _ in xrange(100)] for _ in xrange(100)]\n    return dfs(0, len(boxes) - 1, 0)\n```\n    \n    The problem can be solved using dynamic programming. We can define a 3D DP table where `dp[l][r][k]` will be the maximum points we can get for the boxes in the range `[l, r]`, where there are `k` boxes with the same color as `boxes[r]` to the right of `boxes[r]`. \n\nWe'll use a DFS approach to fill our DP table. \n1. First, we check whether our current range `l > r`, in which case we return 0.\n2. If `dp[l][r][k]` already has a non-zero value, we return `dp[l][r][k]`.\n3. Then, we remove all continuous boxes with the same color as `boxes[r]` on the right side of `boxes[r]` to calculate the initial value of `dp[l][r][k]`.\n4. We iterate from `l` to `r` and whenever we find a box with the same color as `boxes[r]`, we update `dp[l][r][k]` with the maximum of the current value and the sum of the result we get in the current split and the result that we have found for the next continuous split.\n\nFinally, we return the value in `dp[0][boxes.length - 1][0]`, which gives us the maximum points that can be obtained for the given input.\n    ", "javascript": "\n    ```javascript\nfunction removeBoxes(boxes) {\n    const dfs = (l, r, k) => {\n        if (l > r) return 0;\n        if (dp[l][r][k] !== 0) return dp[l][r][k];\n\n        while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0);\n\n        for (let i = l; i < r; i++) {\n            if (boxes[i] == boxes[r]) {\n                dp[l][r][k] = Math.max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0));\n            }\n        }\n\n        return dp[l][r][k];\n    };\n\n    let dp = Array.from({ length: 100 }, () => Array.from({ length: 100 }, () => Array(100).fill(0)));\n    return dfs(0, boxes.length - 1, 0);\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a 3D DP table where `dp[l][r][k]` will be the maximum points we can get for the boxes in the range `[l, r]`, where there are `k` boxes with the same color as `boxes[r]` to the right of `boxes[r]`. \n\nWe'll use a DFS approach to fill our DP table. \n1. First, we check whether our current range `l > r`, in which case we return 0.\n2. If `dp[l][r][k]` already has a non-zero value, we return `dp[l][r][k]`.\n3. Then, we remove all continuous boxes with the same color as `boxes[r]` on the right side of `boxes[r]` to calculate the initial value of `dp[l][r][k]`.\n4. We iterate from `l` to `r` and whenever we find a box with the same color as `boxes[r]`, we update `dp[l][r][k]` with the maximum of the current value and the sum of the result we get in the current split and the result that we have found for the next continuous split.\n\nFinally, we return the value in `dp[0][boxes.length - 1][0]`, which gives us the maximum points that can be obtained for the given input.\n    "}
{"id": 552, "slug": "student-attendance-record-ii", "title": "Student Attendance Record II", "difficulty": "Hard", "content": "An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n*   `'A'`: Absent.\n*   `'L'`: Late.\n*   `'P'`: Present.\n\nAny student is eligible for an attendance award if they meet **both** of the following criteria:\n\n*   The student was absent (`'A'`) for **strictly** fewer than 2 days **total**.\n*   The student was **never** late (`'L'`) for 3 or more **consecutive** days.\n\nGiven an integer `n`, return _the **number** of possible attendance records of length_ `n` _that make a student eligible for an attendance award. The answer may be very large, so return it **modulo**_ `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 8\n**Explanation:** There are 8 records with length 2 that are eligible for an award:\n \"PP \",  \"AP \",  \"PA \",  \"LP \",  \"PL \",  \"AL \",  \"LA \",  \"LL \"\nOnly  \"AA \" is not eligible because there are 2 absences (there need to be fewer than 2).\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 3\n\n**Example 3:**\n\n**Input:** n = 10101\n**Output:** 183236316\n\n**Constraints:**\n\n*   `1 <= n <= 105`", "java": "\n    ```java\npublic int checkRecord(int n) {\n    int M = 1000000007;\n    long[] dp = new long[6];  // {latent state 0, latent state 1, ..., latent state 5}\n    Arrays.fill(dp, 1);\n    while (n-- > 0) {\n        long[] next_dp = new long[6];\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return (int) ((dp[0] + dp[1] + dp[2] +\n                   dp[3] + dp[4] + dp[5]) % M);\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of eligible attendance records. We use a latent state representation consisting of 6 states to account for previous attendance occurrences:\n\n- latent state 0: no A or L\n- latent state 1: no A, 1 consecutive L\n- latent state 2: no A, 2 consecutive L\n- latent state 3: 1 A, no L\n- latent state 4: 1 A, 1 consecutive L\n- latent state 5: 1 A, 2 consecutive L\n\nIn each iteration, we update these latent states according to the previous states. After n iterations, the sum of all latent states represents the number of eligible attendance records.\n    ", "c++": "\n    ```cpp\nint checkRecord(int n) {\n    int M = 1000000007;\n    vector<long long> dp(6, 1);  // {latent state 0, latent state 1, ..., latent state 5}\n    while (n--) {\n        vector<long long> next_dp(6, 0);\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return (dp[0] + dp[1] + dp[2] + dp[3] + dp[4] + dp[5]) % M;\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of eligible attendance records. We use a latent state representation consisting of 6 states to account for previous attendance occurrences:\n\n- latent state 0: no A or L\n- latent state 1: no A, 1 consecutive L\n- latent state 2: no A, 2 consecutive L\n- latent state 3: 1 A, no L\n- latent state 4: 1 A, 1 consecutive L\n- latent state 5: 1 A, 2 consecutive L\n\nIn each iteration, we update these latent states according to the previous states. After n iterations, the sum of all latent states represents the number of eligible attendance records.\n    ", "python": "\n    ```python\ndef checkRecord(n: int) -> int:\n    M = 1000000007\n    dp = [1] * 6  # [latent state 0, latent state 1, ..., latent state 5]\n    while n:\n        next_dp = [0] * 6\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M\n        next_dp[1] = dp[0]\n        next_dp[2] = dp[1]\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M\n        next_dp[4] = dp[3]\n        next_dp[5] = dp[4]\n        dp = next_dp\n        n -= 1\n    return sum(dp) % M\n```\n\n    \n    The algorithm uses dynamic programming to count the number of eligible attendance records. We use a latent state representation consisting of 6 states to account for previous attendance occurrences:\n\n- latent state 0: no A or L\n- latent state 1: no A, 1 consecutive L\n- latent state 2: no A, 2 consecutive L\n- latent state 3: 1 A, no L\n- latent state 4: 1 A, 1 consecutive L\n- latent state 5: 1 A, 2 consecutive L\n\nIn each iteration, we update these latent states according to the previous states. After n iterations, the sum of all latent states represents the number of eligible attendance records.\n    ", "javascript": "\n    ```javascript\nfunction checkRecord(n) {\n    let M = 1000000007;\n    let dp = Array(6).fill(1);  // [latent state 0, latent state 1, ..., latent state 5]\n    while (n--) {\n        let next_dp = Array(6).fill(0);\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return dp.reduce((sum, val) => (sum + val) % M, 0);\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of eligible attendance records. We use a latent state representation consisting of 6 states to account for previous attendance occurrences:\n\n- latent state 0: no A or L\n- latent state 1: no A, 1 consecutive L\n- latent state 2: no A, 2 consecutive L\n- latent state 3: 1 A, no L\n- latent state 4: 1 A, 1 consecutive L\n- latent state 5: 1 A, 2 consecutive L\n\nIn each iteration, we update these latent states according to the previous states. After n iterations, the sum of all latent states represents the number of eligible attendance records.\n    "}
{"id": 553, "slug": "optimal-division", "title": "Optimal Division", "difficulty": "Medium", "content": "You are given an integer array `nums`. The adjacent integers in `nums` will perform the float division.\n\n*   For example, for `nums = [2,3,4]`, we will evaluate the expression `\"2/3/4 \"`.\n\nHowever, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum.\n\nReturn _the corresponding expression that has the maximum value in string format_.\n\n**Note:** your expression should not contain redundant parenthesis.\n\n**Example 1:**\n\n**Input:** nums = \\[1000,100,10,2\\]\n**Output:**  \"1000/(100/10/2) \"\n**Explanation:** 1000/(100/10/2) = 1000/((100/10)/2) = 200\nHowever, the bold parenthesis in  \"1000/(**(**100/10**)**/2) \" are redundant since they do not influence the operation priority.\nSo you should return  \"1000/(100/10/2) \".\nOther cases:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\n\n**Example 2:**\n\n**Input:** nums = \\[2,3,4\\]\n**Output:**  \"2/(3/4) \"\n**Explanation:** (2/(3/4)) = 8/3 = 2.667\nIt can be shown that after trying all possibilities, we cannot get an expression with evaluation greater than 2.667\n\n**Constraints:**\n\n*   `1 <= nums.length <= 10`\n*   `2 <= nums[i] <= 1000`\n*   There is only one optimal division for the given input.", "java": "\n    ```java\npublic String optimalDivision(int[] nums) {\n    int n = nums.length;\n    if (n == 1) return Integer.toString(nums[0]);\n    if (n == 2) return Integer.toString(nums[0]) + \"/\" + Integer.toString(nums[1]);\n    StringBuilder res = new StringBuilder(Integer.toString(nums[0]) + \"/(\");\n    for (int i = 1; i < n - 1; ++i) {\n        res.append(Integer.toString(nums[i])).append(\"/\");\n    }\n    res.append(Integer.toString(nums[n - 1])).append(\")\");\n    return res.toString();\n}\n```\n\n    \n    The key to maximizing the result of the division expression is to minimize the divisors by grouping them together in parentheses. Since we want the entire array of numbers divided by the smallest possible divisor, we essentially want to maximize the division by ensuring the numbers in the array are divided by each other in sequence, from left to right.\n\nThe algorithm goes as follows:\n1. If there's only one number, return that number.\n2. If there are two numbers, a and b, just return \"a/b\" as the division expression.\n3. For three or more numbers, create a string with the first number followed by \"/(\".\n4. Iterate through the rest of the numbers, adding each number to the string followed by a \"/\". Stop at the second-to-last number in the array.\n5. Add the very last number to the string followed by a closing parenthesis.\n6. Return the constructed string.\n\nThis way, we get the maximum value for the division operation.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string optimalDivision(std::vector<int>& nums) {\n    int n = nums.size();\n    if (n == 1) return std::to_string(nums[0]);\n    if (n == 2) return std::to_string(nums[0]) + \"/\" + std::to_string(nums[1]);\n    std::string res = std::to_string(nums[0]) + \"/(\";\n    for (int i = 1; i < n - 1; ++i) {\n        res += std::to_string(nums[i]) + \"/\";\n    }\n    res += std::to_string(nums[n - 1]) + \")\";\n    return res;\n}\n```\n\n    \n    The key to maximizing the result of the division expression is to minimize the divisors by grouping them together in parentheses. Since we want the entire array of numbers divided by the smallest possible divisor, we essentially want to maximize the division by ensuring the numbers in the array are divided by each other in sequence, from left to right.\n\nThe algorithm goes as follows:\n1. If there's only one number, return that number.\n2. If there are two numbers, a and b, just return \"a/b\" as the division expression.\n3. For three or more numbers, create a string with the first number followed by \"/(\".\n4. Iterate through the rest of the numbers, adding each number to the string followed by a \"/\". Stop at the second-to-last number in the array.\n5. Add the very last number to the string followed by a closing parenthesis.\n6. Return the constructed string.\n\nThis way, we get the maximum value for the division operation.\n    ", "python": "\n    ```python\ndef optimal_division(nums):\n    n = len(nums)\n    if n == 1:\n        return str(nums[0])\n    if n == 2:\n        return str(nums[0]) + '/' + str(nums[1])\n    res = str(nums[0]) + '/('\n    for i in range(1, n - 1):\n        res += str(nums[i]) + '/'\n    res += str(nums[n - 1]) + ')'\n    return res\n```\n\n    \n    The key to maximizing the result of the division expression is to minimize the divisors by grouping them together in parentheses. Since we want the entire array of numbers divided by the smallest possible divisor, we essentially want to maximize the division by ensuring the numbers in the array are divided by each other in sequence, from left to right.\n\nThe algorithm goes as follows:\n1. If there's only one number, return that number.\n2. If there are two numbers, a and b, just return \"a/b\" as the division expression.\n3. For three or more numbers, create a string with the first number followed by \"/(\".\n4. Iterate through the rest of the numbers, adding each number to the string followed by a \"/\". Stop at the second-to-last number in the array.\n5. Add the very last number to the string followed by a closing parenthesis.\n6. Return the constructed string.\n\nThis way, we get the maximum value for the division operation.\n    ", "javascript": "\n    ```javascript\nfunction optimalDivision(nums) {\n    const n = nums.length;\n    if (n === 1) return nums[0].toString();\n    if (n === 2) return nums[0].toString() + '/' + nums[1].toString();\n    let res = nums[0].toString() + '/(';\n    for (let i = 1; i < n - 1; ++i) {\n        res += nums[i].toString() + '/';\n    }\n    res += nums[n - 1].toString() + ')';\n    return res;\n}\n```\n\n    \n    The key to maximizing the result of the division expression is to minimize the divisors by grouping them together in parentheses. Since we want the entire array of numbers divided by the smallest possible divisor, we essentially want to maximize the division by ensuring the numbers in the array are divided by each other in sequence, from left to right.\n\nThe algorithm goes as follows:\n1. If there's only one number, return that number.\n2. If there are two numbers, a and b, just return \"a/b\" as the division expression.\n3. For three or more numbers, create a string with the first number followed by \"/(\".\n4. Iterate through the rest of the numbers, adding each number to the string followed by a \"/\". Stop at the second-to-last number in the array.\n5. Add the very last number to the string followed by a closing parenthesis.\n6. Return the constructed string.\n\nThis way, we get the maximum value for the division operation.\n    "}
{"id": 576, "slug": "out-of-boundary-paths", "title": "Out of Boundary Paths", "difficulty": "Medium", "content": "There is an `m x n` grid with a ball. The ball is initially at the position `[startRow, startColumn]`. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply **at most** `maxMove` moves to the ball.\n\nGiven the five integers `m`, `n`, `maxMove`, `startRow`, `startColumn`, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\n**Output:** 6\n\n**Example 2:**\n\n**Input:** m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1\n**Output:** 12\n\n**Constraints:**\n\n*   `1 <= m, n <= 50`\n*   `0 <= maxMove <= 50`\n*   `0 <= startRow < m`\n*   `0 <= startColumn < n`", "java": "\n    ```java\npublic int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n    int MOD = 1000000007;\n    int[][][] dp = new int[maxMove + 1][m][n];\n    int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    for (int k = 1; k <= maxMove; k++) {\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int[] move : moves) {\n                    int ni = i + move[0], nj = j + move[1];\n                    if (ni < 0 || ni >= m || nj < 0 || nj >= n) {\n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD;\n                    } else {\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    return dp[maxMove][startRow][startColumn];\n}\n```\n    \n    We use dynamic programming to accumulate the ways to move the ball up to the maximum allowed moves. The `dp` array has dimensions `maxMove + 1` by `m` by `n`, where `dp[k][i][j]` represents the number of ways the ball can reach position `(i, j)` in exactly `k` moves.\n\nWe loop through moves from `1` to `maxMove`, and then loop through each cell of the grid. For each cell, we check each possible move direction. If moving in that direction causes the ball to cross the grid boundary (i.e., the new coordinates are outside of the grid), we increment the number of ways to move in exactly `k` moves by `1`. If the new coordinates are inside the grid, we add the number of ways to move to the new position in exactly `k - 1` moves to our current ways. We do this modulo `10^9 + 7` to prevent integer overflow.\n\nFinally, we return the number of ways to move the ball out of the grid boundary in exactly `maxMove` moves, which is stored at `dp[maxMove][startRow][startColumn]`.\n    ", "c++": "\n    ```cpp\nint findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n    int MOD = 1e9 + 7;\n    vector<vector<vector<int>>> dp(maxMove + 1, vector<vector<int>>(m, vector<int>(n, 0)));\n    int moves[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    for (int k = 1; k <= maxMove; k++) {\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                for (auto move : moves) {\n                    int ni = i + move[0], nj = j + move[1];\n                    if (ni < 0 || ni >= m || nj < 0 || nj >= n) {\n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD;\n                    } else {\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    return dp[maxMove][startRow][startColumn];\n}\n```\n    \n    We use dynamic programming to accumulate the ways to move the ball up to the maximum allowed moves. The `dp` array has dimensions `maxMove + 1` by `m` by `n`, where `dp[k][i][j]` represents the number of ways the ball can reach position `(i, j)` in exactly `k` moves.\n\nWe loop through moves from `1` to `maxMove`, and then loop through each cell of the grid. For each cell, we check each possible move direction. If moving in that direction causes the ball to cross the grid boundary (i.e., the new coordinates are outside of the grid), we increment the number of ways to move in exactly `k` moves by `1`. If the new coordinates are inside the grid, we add the number of ways to move to the new position in exactly `k - 1` moves to our current ways. We do this modulo `10^9 + 7` to prevent integer overflow.\n\nFinally, we return the number of ways to move the ball out of the grid boundary in exactly `maxMove` moves, which is stored at `dp[maxMove][startRow][startColumn]`.\n    ", "python": "\n    ```python\ndef findPaths(m, n, maxMove, startRow, startColumn):               \n    MOD = 10**9 + 7                     \n    dp = [[[0]* n for _ in range(m)] for _ in range(maxMove + 1)]\n    moves = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    for k in range(1, maxMove + 1):                                \n        for i in range(m):                                         \n            for j in range(n):                                           \n                for move in moves:              \n                    ni, nj = i + move[0], j + move[1]\n                    if ni < 0 or ni >= m or nj < 0 or nj >= n:                                 \n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD          \n                    else:\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD\n\n    return dp[maxMove][startRow][startColumn]\n```\n    \n    We use dynamic programming to accumulate the ways to move the ball up to the maximum allowed moves. The `dp` array has dimensions `maxMove + 1` by `m` by `n`, where `dp[k][i][j]` represents the number of ways the ball can reach position `(i, j)` in exactly `k` moves.\n\nWe loop through moves from `1` to `maxMove`, and then loop through each cell of the grid. For each cell, we check each possible move direction. If moving in that direction causes the ball to cross the grid boundary (i.e., the new coordinates are outside of the grid), we increment the number of ways to move in exactly `k` moves by `1`. If the new coordinates are inside the grid, we add the number of ways to move to the new position in exactly `k - 1` moves to our current ways. We do this modulo `10^9 + 7` to prevent integer overflow.\n\nFinally, we return the number of ways to move the ball out of the grid boundary in exactly `maxMove` moves, which is stored at `dp[maxMove][startRow][startColumn]`.\n    ", "javascript": "\n    ```javascript\nfunction findPaths(m, n, maxMove, startRow, startColumn) {\n    const MOD = 1e9 + 7;\n    let dp = new Array(maxMove + 1).fill(0).map(() => new Array(m).fill(0).map(() => new Array(n).fill(0)));\n    let moves = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\n    for (let k = 1; k <= maxMove; k++) {\n        for (let i = 0; i < m; i++) {\n            for (let j = 0; j < n; j++) {\n                for (let move of moves) {\n                    let ni = i + move[0], nj = j + move[1];\n                    if (ni < 0 || ni >= m || nj < 0 || nj >= n) {\n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD;\n                    } else {\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    return dp[maxMove][startRow][startColumn];\n}\n```\n    \n    We use dynamic programming to accumulate the ways to move the ball up to the maximum allowed moves. The `dp` array has dimensions `maxMove + 1` by `m` by `n`, where `dp[k][i][j]` represents the number of ways the ball can reach position `(i, j)` in exactly `k` moves.\n\nWe loop through moves from `1` to `maxMove`, and then loop through each cell of the grid. For each cell, we check each possible move direction. If moving in that direction causes the ball to cross the grid boundary (i.e., the new coordinates are outside of the grid), we increment the number of ways to move in exactly `k` moves by `1`. If the new coordinates are inside the grid, we add the number of ways to move to the new position in exactly `k - 1` moves to our current ways. We do this modulo `10^9 + 7` to prevent integer overflow.\n\nFinally, we return the number of ways to move the ball out of the grid boundary in exactly `maxMove` moves, which is stored at `dp[maxMove][startRow][startColumn]`.\n    "}
{"id": 583, "slug": "delete-operation-for-two-strings", "title": "Delete Operation for Two Strings", "difficulty": "Medium", "content": "Given two strings `word1` and `word2`, return _the minimum number of **steps** required to make_ `word1` _and_ `word2` _the same_.\n\nIn one **step**, you can delete exactly one character in either string.\n\n**Example 1:**\n\n**Input:** word1 =  \"sea \", word2 =  \"eat \"\n**Output:** 2\n**Explanation:** You need one step to make  \"sea \" to  \"ea \" and another step to make  \"eat \" to  \"ea \".\n\n**Example 2:**\n\n**Input:** word1 =  \"leetcode \", word2 =  \"etco \"\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= word1.length, word2.length <= 500`\n*   `word1` and `word2` consist of only lowercase English letters.", "java": "\n    ```java\npublic int minDistance(String word1, String word2) {\n    int m = word1.length(), n = word2.length();\n    int[][] dp = new int[m+1][n+1];\n\n    for(int i = 0; i <= m; i++) {\n        for(int j = 0; j <= n; j++) {\n            if(i == 0 || j == 0)\n                dp[i][j] = i + j;\n            else if(word1.charAt(i-1) == word2.charAt(j-1))\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming (DP) to solve the problem. It first initializes a 2D DP array `dp` with dimensions `m+1` by `n+1` where `m` is the length of `word1` and `n` is the length of `word2`. The DP entry `dp[i][j]` represents the minimum number of steps required to make the prefixes `word1[0...i-1]` and `word2[0...j-1]` equal. \n\nThe algorithm then populates the DP table using the following rules:\n1. If either `i` or `j` is 0, then `dp[i][j] = i + j` since it needs to delete all characters from the other string.\n2. If `word1[i-1]` is the same as `word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`.\n3. Else, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])`, as we can either remove `word1[i-1]` or `word2[j-1]`.\n\nFinally, the algorithm returns the value `dp[m][n]` as it represents the minimum number of steps required to make the two input strings equal.\n    ", "c++": "\n    ```cpp\nint minDistance(std::string word1, std::string word2) {\n    int m = word1.length(), n = word2.length();\n    std::vector<std::vector<int>> dp(m+1, std::vector<int>(n+1, 0));\n    \n    for(int i = 0; i <= m; i++) {\n        for(int j = 0; j <= n; j++) {\n            if(i == 0 || j == 0)\n                dp[i][j] = i + j;\n            else if(word1[i-1] == word2[j-1])\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + std::min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    \n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming (DP) to solve the problem. It first initializes a 2D DP array `dp` with dimensions `m+1` by `n+1` where `m` is the length of `word1` and `n` is the length of `word2`. The DP entry `dp[i][j]` represents the minimum number of steps required to make the prefixes `word1[0...i-1]` and `word2[0...j-1]` equal. \n\nThe algorithm then populates the DP table using the following rules:\n1. If either `i` or `j` is 0, then `dp[i][j] = i + j` since it needs to delete all characters from the other string.\n2. If `word1[i-1]` is the same as `word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`.\n3. Else, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])`, as we can either remove `word1[i-1]` or `word2[j-1]`.\n\nFinally, the algorithm returns the value `dp[m][n]` as it represents the minimum number of steps required to make the two input strings equal.\n    ", "python": "\n    ```python\ndef minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                dp[i][j] = i + j\n            elif word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])\n\n    return dp[m][n]\n```\n    \n    The algorithm uses dynamic programming (DP) to solve the problem. It first initializes a 2D DP array `dp` with dimensions `m+1` by `n+1` where `m` is the length of `word1` and `n` is the length of `word2`. The DP entry `dp[i][j]` represents the minimum number of steps required to make the prefixes `word1[0...i-1]` and `word2[0...j-1]` equal. \n\nThe algorithm then populates the DP table using the following rules:\n1. If either `i` or `j` is 0, then `dp[i][j] = i + j` since it needs to delete all characters from the other string.\n2. If `word1[i-1]` is the same as `word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`.\n3. Else, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])`, as we can either remove `word1[i-1]` or `word2[j-1]`.\n\nFinally, the algorithm returns the value `dp[m][n]` as it represents the minimum number of steps required to make the two input strings equal.\n    ", "javascript": "\n    ```javascript\nfunction minDistance(word1, word2) {\n    let m = word1.length, n = word2.length;\n    let dp = new Array(m + 1).fill().map(() => new Array(n + 1).fill(0));\n\n    for(let i = 0; i <= m; i++) {\n        for(let j = 0; j <= n; j++) {\n            if(i === 0 || j === 0)\n                dp[i][j] = i + j;\n            else if(word1.charAt(i-1) === word2.charAt(j-1))\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming (DP) to solve the problem. It first initializes a 2D DP array `dp` with dimensions `m+1` by `n+1` where `m` is the length of `word1` and `n` is the length of `word2`. The DP entry `dp[i][j]` represents the minimum number of steps required to make the prefixes `word1[0...i-1]` and `word2[0...j-1]` equal. \n\nThe algorithm then populates the DP table using the following rules:\n1. If either `i` or `j` is 0, then `dp[i][j] = i + j` since it needs to delete all characters from the other string.\n2. If `word1[i-1]` is the same as `word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`.\n3. Else, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])`, as we can either remove `word1[i-1]` or `word2[j-1]`.\n\nFinally, the algorithm returns the value `dp[m][n]` as it represents the minimum number of steps required to make the two input strings equal.\n    "}
{"id": 600, "slug": "non-negative-integers-without-consecutive-ones", "title": "Non-negative Integers without Consecutive Ones", "difficulty": "Hard", "content": "Given a positive integer `n`, return the number of the integers in the range `[0, n]` whose binary representations **do not** contain consecutive ones.\n\n**Example 1:**\n\n**Input:** n = 5\n**Output:** 5\n**Explanation:**\nHere are the non-negative integers <= 5 with their corresponding binary representations:\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 2\n\n**Example 3:**\n\n**Input:** n = 2\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= n <= 109`", "java": "\n    ```java\npublic int findIntegers(int n) {\n    int[][] dp = new int[32][2];\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n\n    for (int i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    int ans = 0, prev_bit = 0;\n    for (int i = 30; i >= 0; i--) {\n        if ((n & (1 << i)) != 0) {\n            ans += dp[i][0];\n            if (prev_bit == 1) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition.\n    ", "c++": "\n    ```cpp\nint findIntegers(int n) {\n    int dp[32][2] = {0};\n    dp[0][0] = dp[0][1] = 1;\n\n    for (int i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    int ans = 0, prev_bit = 0;\n    for (int i = 30; i >= 0; i--) {\n        if (n & (1 << i)) {\n            ans += dp[i][0];\n            if (prev_bit) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition.\n    ", "python": "\n    ```python\ndef findIntegers(n: int) -> int:\n    dp = [[0, 0] for _ in range(32)]\n    dp[0][0], dp[0][1] = 1, 1\n\n    for i in range(1, 32):\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n        dp[i][1] = dp[i - 1][0]\n\n    ans = 0\n    prev_bit = 0\n    for i in range(30, -1, -1):\n        if n & (1 << i):\n            ans += dp[i][0]\n            if prev_bit:\n                break\n            prev_bit = 1\n        else:\n            prev_bit = 0\n\n    return ans + 1\n```\n\n    \n    The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition.\n    ", "javascript": "\n    ```javascript\nfunction findIntegers(n) {\n    let dp = new Array(32).fill(0).map(() => Array(2).fill(0));\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n\n    for (let i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    let ans = 0, prev_bit = 0;\n    for (let i = 30; i >= 0; i--) {\n        if (n & (1 << i)) {\n            ans += dp[i][0];\n            if (prev_bit === 1) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition.\n    "}
{"id": 629, "slug": "k-inverse-pairs-array", "title": "K Inverse Pairs Array", "difficulty": "Hard", "content": "For an integer array `nums`, an **inverse pair** is a pair of integers `[i, j]` where `0 <= i < j < nums.length` and `nums[i] > nums[j]`.\n\nGiven two integers n and k, return the number of different arrays consist of numbers from `1` to `n` such that there are exactly `k` **inverse pairs**. Since the answer can be huge, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 3, k = 0\n**Output:** 1\n**Explanation:** Only the array \\[1,2,3\\] which consists of numbers from 1 to 3 has exactly 0 inverse pairs.\n\n**Example 2:**\n\n**Input:** n = 3, k = 1\n**Output:** 2\n**Explanation:** The array \\[1,3,2\\] and \\[2,1,3\\] have exactly 1 inverse pair.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `0 <= k <= 1000`", "java": "\n    ```java\npublic int kInversePairs(int n, int k) {\n    int mod = 1000000007;\n    int[][] dp = new int[n + 1][k + 1];\n    for (int i = 1; i <= n; i++) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= k; j++) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a 2D array dp where `dp[i][j]` represents the number of arrays with `i` elements having `j` inverse pairs. We initialize `dp[i][0]` to 1 for all `i`.\n\nFor each `i` and `j`, we update the value of `dp[i][j]` using the following relation:\n\n`dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`\n\nIf there are enough elements (i.e., `j - i >= 0`) to form an inverse pair, we subtract the number of inverse pairs using `dp[i - 1][j - i]`. After updating the value, we ensure that the result stays within the given range by taking the modulo with 10^9 + 7.\n\nFinally, we return the value at `dp[n][k]`, which represents the number of arrays with `n` (1 to n) elements having exactly `k` inverse pairs. \n    ", "c++": "\n    ```cpp\nint kInversePairs(int n, int k) {\n    int mod = 1e9 + 7;\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\n    for (int i = 1; i <= n; ++i) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= k; ++j) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a 2D array dp where `dp[i][j]` represents the number of arrays with `i` elements having `j` inverse pairs. We initialize `dp[i][0]` to 1 for all `i`.\n\nFor each `i` and `j`, we update the value of `dp[i][j]` using the following relation:\n\n`dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`\n\nIf there are enough elements (i.e., `j - i >= 0`) to form an inverse pair, we subtract the number of inverse pairs using `dp[i - 1][j - i]`. After updating the value, we ensure that the result stays within the given range by taking the modulo with 10^9 + 7.\n\nFinally, we return the value at `dp[n][k]`, which represents the number of arrays with `n` (1 to n) elements having exactly `k` inverse pairs. \n    ", "python": "\n    ```python\ndef kInversePairs(n: int, k: int) -> int:\n    mod = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod\n            if j - i >= 0:\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod\n    return dp[n][k]\n```\n    \n    We use dynamic programming to solve this problem. We create a 2D array dp where `dp[i][j]` represents the number of arrays with `i` elements having `j` inverse pairs. We initialize `dp[i][0]` to 1 for all `i`.\n\nFor each `i` and `j`, we update the value of `dp[i][j]` using the following relation:\n\n`dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`\n\nIf there are enough elements (i.e., `j - i >= 0`) to form an inverse pair, we subtract the number of inverse pairs using `dp[i - 1][j - i]`. After updating the value, we ensure that the result stays within the given range by taking the modulo with 10^9 + 7.\n\nFinally, we return the value at `dp[n][k]`, which represents the number of arrays with `n` (1 to n) elements having exactly `k` inverse pairs. \n    ", "javascript": "\n    ```javascript\nfunction kInversePairs(n, k) {\n    const mod = 1e9 + 7;\n    const dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(0));\n    for (let i = 1; i <= n; ++i) {\n        dp[i][0] = 1;\n        for (let j = 1; j <= k; ++j) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a 2D array dp where `dp[i][j]` represents the number of arrays with `i` elements having `j` inverse pairs. We initialize `dp[i][0]` to 1 for all `i`.\n\nFor each `i` and `j`, we update the value of `dp[i][j]` using the following relation:\n\n`dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`\n\nIf there are enough elements (i.e., `j - i >= 0`) to form an inverse pair, we subtract the number of inverse pairs using `dp[i - 1][j - i]`. After updating the value, we ensure that the result stays within the given range by taking the modulo with 10^9 + 7.\n\nFinally, we return the value at `dp[n][k]`, which represents the number of arrays with `n` (1 to n) elements having exactly `k` inverse pairs. \n    "}
{"id": 638, "slug": "shopping-offers", "title": "Shopping Offers", "difficulty": "Medium", "content": "In LeetCode Store, there are `n` items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\n\nYou are given an integer array `price` where `price[i]` is the price of the `ith` item, and an integer array `needs` where `needs[i]` is the number of pieces of the `ith` item you want to buy.\n\nYou are also given an array `special` where `special[i]` is of size `n + 1` where `special[i][j]` is the number of pieces of the `jth` item in the `ith` offer and `special[i][n]` (i.e., the last integer in the array) is the price of the `ith` offer.\n\nReturn _the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers_. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.\n\n**Example 1:**\n\n**Input:** price = \\[2,5\\], special = \\[\\[3,0,5\\],\\[1,2,10\\]\\], needs = \\[3,2\\]\n**Output:** 14\n**Explanation:** There are two kinds of items, A and B. Their prices are $2 and $5 respectively. \nIn special offer 1, you can pay $5 for 3A and 0B\nIn special offer 2, you can pay $10 for 1A and 2B. \nYou need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\n\n**Example 2:**\n\n**Input:** price = \\[2,3,4\\], special = \\[\\[1,1,0,4\\],\\[2,2,1,9\\]\\], needs = \\[1,2,1\\]\n**Output:** 11\n**Explanation:** The price of A is $2, and $3 for B, $4 for C. \nYou may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \nYou need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \nYou cannot add more items, though only $9 for 2A ,2B and 1C.\n\n**Constraints:**\n\n*   `n == price.length == needs.length`\n*   `1 <= n <= 6`\n*   `0 <= price[i], needs[i] <= 10`\n*   `1 <= special.length <= 100`\n*   `special[i].length == n + 1`\n*   `0 <= special[i][j] <= 50`", "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\n    return shoppingOffersHelper(price, special, needs, 0);\n}\n\nprivate int shoppingOffersHelper(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int index) {\n    if (index == special.size()) {\n        int sum = 0;\n        for (int i = 0; i < needs.size(); ++i) {\n            sum += price.get(i) * needs.get(i);\n        }\n        return sum;\n    }\n\n    int no_offer = shoppingOffersHelper(price, special, needs, index + 1);\n    boolean can_apply_offer = true;\n    for (int i = 0; i < needs.size(); ++i) {\n        needs.set(i, needs.get(i) - special.get(index).get(i));\n        if (needs.get(i) < 0) can_apply_offer = false;\n    }\n\n    int with_offer = Integer.MAX_VALUE;\n    if (can_apply_offer) {\n        int offer_cost = special.get(index).get(needs.size()) + shoppingOffersHelper(price, special, needs, index);\n        with_offer = Math.min(no_offer, offer_cost);\n    }\n\n    for (int i = 0; i < needs.size(); ++i) {\n        needs.set(i, needs.get(i) + special.get(index).get(i));\n    }\n\n    return can_apply_offer ? with_offer : no_offer;\n}\n```\n\n    \n    The algorithm uses backtracking to solve the problem. We go through each special offer and recursively compute the cost of applying or not applying the offer. When no more offers are available, we compute the cost of buying the remaining items at their regular price.\n\nWe first define a helper function that takes the index of the current special offer as its argument:\n\n1. If the index equals the number of special offers, this means that we have checked all special offers, and we should calculate the cost of buying the remaining items at their regular price. We return the sum of the price multiplied by the required number of items for each item.\n\n2. Calculate the cost of not applying the current special offer by calling the helper function recursively with the next special offer.\n\n3. Check if we can apply the current special offer. To do this, we subtract the number of items in the special offer from the required number of items. If any value in the `needs` array becomes negative, this means that the current special offer does not satisfy the shopping requirements, and we cannot apply it.\n\n4. If the current special offer is applicable, we calculate the cost of applying it by adding the cost of the offer to the cost of applying the subsequent special offers. We then calculate the minimum cost between applying and not applying the current special offer.\n\n5. Update the `needs` array by adding the number of items in the special offer to the required number of items. This is necessary because we subtracted these values earlier when checking if we could apply the offer.\n\n6. If we can apply the current special offer, return the minimum cost between applying and not applying it. Otherwise, return the cost of not applying it.\n\nFinally, we call the helper function with the initial value of 0 to solve the problem from the first special offer.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint shoppingOffersHelper(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int index) {\n    if (index == special.size()) {\n        int sum = 0;\n        for (int i = 0; i < needs.size(); ++i) {\n            sum += price[i] * needs[i];\n        }\n        return sum;\n    }\n\n    int no_offer = shoppingOffersHelper(price, special, needs, index + 1);\n    bool can_apply_offer = true;\n    for (int i = 0; i < needs.size(); ++i) {\n        needs[i] -= special[index][i];\n        if (needs[i] < 0) can_apply_offer = false;\n    }\n\n    int with_offer = INT_MAX;\n    if (can_apply_offer) {\n        int offer_cost = special[index][needs.size()] + shoppingOffersHelper(price, special, needs, index);\n        with_offer = min(no_offer, offer_cost);\n    }\n\n    for (int i = 0; i < needs.size(); ++i) {\n        needs[i] += special[index][i];\n    }\n\n    return can_apply_offer ? with_offer : no_offer;\n}\n\nint shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\n    return shoppingOffersHelper(price, special, needs, 0);\n}\n```\n\n    \n    The algorithm uses backtracking to solve the problem. We go through each special offer and recursively compute the cost of applying or not applying the offer. When no more offers are available, we compute the cost of buying the remaining items at their regular price.\n\nWe first define a helper function that takes the index of the current special offer as its argument:\n\n1. If the index equals the number of special offers, this means that we have checked all special offers, and we should calculate the cost of buying the remaining items at their regular price. We return the sum of the price multiplied by the required number of items for each item.\n\n2. Calculate the cost of not applying the current special offer by calling the helper function recursively with the next special offer.\n\n3. Check if we can apply the current special offer. To do this, we subtract the number of items in the special offer from the required number of items. If any value in the `needs` array becomes negative, this means that the current special offer does not satisfy the shopping requirements, and we cannot apply it.\n\n4. If the current special offer is applicable, we calculate the cost of applying it by adding the cost of the offer to the cost of applying the subsequent special offers. We then calculate the minimum cost between applying and not applying the current special offer.\n\n5. Update the `needs` array by adding the number of items in the special offer to the required number of items. This is necessary because we subtracted these values earlier when checking if we could apply the offer.\n\n6. If we can apply the current special offer, return the minimum cost between applying and not applying it. Otherwise, return the cost of not applying it.\n\nFinally, we call the helper function with the initial value of 0 to solve the problem from the first special offer.\n    ", "python": "\n    ```python\nfrom typing import List\n\ndef shoppingOffers(price: List[int], special: List[List[int]], needs: List[int]) -> int:\n    def helper(index):\n        if index == len(special):\n            return sum(needs[i] * price[i] for i in range(len(needs)))\n\n        no_offer = helper(index + 1)\n        can_apply_offer = True\n        for i in range(len(needs)):\n            needs[i] -= special[index][i]\n            if needs[i] < 0:\n                can_apply_offer = False\n\n        with_offer = float('inf')\n        if can_apply_offer:\n            offer_cost = special[index][-1] + helper(index)\n            with_offer = min(no_offer, offer_cost)\n\n        for i in range(len(needs)):\n            needs[i] += special[index][i]\n        \n        return with_offer if can_apply_offer else no_offer\n\n    return helper(0)\n```\n\n    \n    The algorithm uses backtracking to solve the problem. We go through each special offer and recursively compute the cost of applying or not applying the offer. When no more offers are available, we compute the cost of buying the remaining items at their regular price.\n\nWe first define a helper function that takes the index of the current special offer as its argument:\n\n1. If the index equals the number of special offers, this means that we have checked all special offers, and we should calculate the cost of buying the remaining items at their regular price. We return the sum of the price multiplied by the required number of items for each item.\n\n2. Calculate the cost of not applying the current special offer by calling the helper function recursively with the next special offer.\n\n3. Check if we can apply the current special offer. To do this, we subtract the number of items in the special offer from the required number of items. If any value in the `needs` array becomes negative, this means that the current special offer does not satisfy the shopping requirements, and we cannot apply it.\n\n4. If the current special offer is applicable, we calculate the cost of applying it by adding the cost of the offer to the cost of applying the subsequent special offers. We then calculate the minimum cost between applying and not applying the current special offer.\n\n5. Update the `needs` array by adding the number of items in the special offer to the required number of items. This is necessary because we subtracted these values earlier when checking if we could apply the offer.\n\n6. If we can apply the current special offer, return the minimum cost between applying and not applying it. Otherwise, return the cost of not applying it.\n\nFinally, we call the helper function with the initial value of 0 to solve the problem from the first special offer.\n    ", "javascript": "\n    ```javascript\nfunction shoppingOffers(price, special, needs) {\n    function helper(index) {\n        if (index === special.length) {\n            return needs.reduce((sum, curr, i) => sum + curr * price[i], 0);\n        }\n\n        let no_offer = helper(index + 1);\n        let can_apply_offer = true;\n        for (let i = 0; i < needs.length; ++i) {\n            needs[i] -= special[index][i];\n            if (needs[i] < 0) can_apply_offer = false;\n        }\n\n        let with_offer = Infinity;\n        if (can_apply_offer) {\n            let offer_cost = special[index][needs.length] + helper(index);\n            with_offer = Math.min(no_offer, offer_cost);\n        }\n\n        for (let i = 0; i < needs.length; ++i) {\n            needs[i] += special[index][i];\n        }\n\n        return can_apply_offer ? with_offer : no_offer;\n    }\n\n    return helper(0);\n}\n```\n\n    \n    The algorithm uses backtracking to solve the problem. We go through each special offer and recursively compute the cost of applying or not applying the offer. When no more offers are available, we compute the cost of buying the remaining items at their regular price.\n\nWe first define a helper function that takes the index of the current special offer as its argument:\n\n1. If the index equals the number of special offers, this means that we have checked all special offers, and we should calculate the cost of buying the remaining items at their regular price. We return the sum of the price multiplied by the required number of items for each item.\n\n2. Calculate the cost of not applying the current special offer by calling the helper function recursively with the next special offer.\n\n3. Check if we can apply the current special offer. To do this, we subtract the number of items in the special offer from the required number of items. If any value in the `needs` array becomes negative, this means that the current special offer does not satisfy the shopping requirements, and we cannot apply it.\n\n4. If the current special offer is applicable, we calculate the cost of applying it by adding the cost of the offer to the cost of applying the subsequent special offers. We then calculate the minimum cost between applying and not applying the current special offer.\n\n5. Update the `needs` array by adding the number of items in the special offer to the required number of items. This is necessary because we subtracted these values earlier when checking if we could apply the offer.\n\n6. If we can apply the current special offer, return the minimum cost between applying and not applying it. Otherwise, return the cost of not applying it.\n\nFinally, we call the helper function with the initial value of 0 to solve the problem from the first special offer.\n    "}
{"id": 639, "slug": "decode-ways-ii", "title": "Decode Ways II", "difficulty": "Hard", "content": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\n**In addition** to the mapping above, an encoded message may contain the `'*'` character, which can represent any digit from `'1'` to `'9'` (`'0'` is excluded). For example, the encoded message `\"1* \"` may represent any of the encoded messages `\"11 \"`, `\"12 \"`, `\"13 \"`, `\"14 \"`, `\"15 \"`, `\"16 \"`, `\"17 \"`, `\"18 \"`, or `\"19 \"`. Decoding `\"1* \"` is equivalent to decoding **any** of the encoded messages it can represent.\n\nGiven a string `s` consisting of digits and `'*'` characters, return _the **number** of ways to **decode** it_.\n\nSince the answer may be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** s =  \"\\* \"\n**Output:** 9\n**Explanation:** The encoded message can represent any of the encoded messages  \"1 \",  \"2 \",  \"3 \",  \"4 \",  \"5 \",  \"6 \",  \"7 \",  \"8 \", or  \"9 \".\nEach of these can be decoded to the strings  \"A \",  \"B \",  \"C \",  \"D \",  \"E \",  \"F \",  \"G \",  \"H \", and  \"I \" respectively.\nHence, there are a total of 9 ways to decode  \"\\* \".\n\n**Example 2:**\n\n**Input:** s =  \"1\\* \"\n**Output:** 18\n**Explanation:** The encoded message can represent any of the encoded messages  \"11 \",  \"12 \",  \"13 \",  \"14 \",  \"15 \",  \"16 \",  \"17 \",  \"18 \", or  \"19 \".\nEach of these encoded messages have 2 ways to be decoded (e.g.  \"11 \" can be decoded to  \"AA \" or  \"K \").\nHence, there are a total of 9 \\* 2 = 18 ways to decode  \"1\\* \".\n\n**Example 3:**\n\n**Input:** s =  \"2\\* \"\n**Output:** 15\n**Explanation:** The encoded message can represent any of the encoded messages  \"21 \",  \"22 \",  \"23 \",  \"24 \",  \"25 \",  \"26 \",  \"27 \",  \"28 \", or  \"29 \".\n \"21 \",  \"22 \",  \"23 \",  \"24 \",  \"25 \", and  \"26 \" have 2 ways of being decoded, but  \"27 \",  \"28 \", and  \"29 \" only have 1 way.\nHence, there are a total of (6 \\* 2) + (3 \\* 1) = 12 + 3 = 15 ways to decode  \"2\\* \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is a digit or `'*'`.", "java": "\n    ```java\npublic int numDecodings(String s) {\n    final int MOD = 1_000_000_007;\n    int n = s.length();\n    long[] dp = new long[n + 1];\n    dp[0] = 1;\n    dp[1] = s.charAt(0) == '*' ? 9 : (s.charAt(0) == '0' ? 0 : 1);\n\n    for (int i = 2; i <= n; ++i) {\n        char c = s.charAt(i - 1);\n        char prevC = s.charAt(i - 2);\n\n        if (c == '*') {\n            dp[i] = 9 * dp[i - 1];\n            if (prevC == '1') dp[i] += 9 * dp[i - 2];\n            else if (prevC == '2') dp[i] += 6 * dp[i - 2];\n            else if (prevC == '*') dp[i] += 15 * dp[i - 2];\n        } else {\n            dp[i] = (c != '0') ? dp[i - 1] : 0;\n            int num = Integer.parseInt(s.substring(i - 2, i));\n            if (prevC == '1' || (prevC == '2' && num <= 26)) dp[i] += dp[i - 2];\n            else if (prevC == '*') dp[i] += (num <= 26 && num >= 10) ? 2 * dp[i - 2] : dp[i - 2];\n        }\n        dp[i] %= MOD;\n    }\n    return (int) dp[n];\n}\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to decode the string. The idea is to iterate over the characters of the string and, for each character `'c'`, calculate how many ways to decode the string up to the position of `'c'`.\n\nWe will use an array `dp`, where `dp[i]` holds the number of ways to decode the string up to position `i`. The base cases are `dp[0] = 1` and `dp[1]` is assigned depending on whether the first character is a star or not.\n\nIn each step, we will consider pairs of characters: the current character `'c'` and the previous character `'prevC'`. If `'c'` is a star, it can be replaced with any digit from '1' to '9', so we need to calculate how many ways we can decode each possibility. Similarly, we need to handle the case when `'c'` is not a star but `'prevC'` is.\n\nFinally, we update the number of ways to decode the string at each position, taking care of the modulo operation to avoid integer overflow issues.\n\nThe final answer will be the number of ways to decode the entire string, which is stored in `dp[n]`.\n    ", "c++": "\n    ```cpp\nint numDecodings(const std::string& s) {\n    const int MOD = 1e9 + 7;\n    int n = s.size();\n    std::vector<long long> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = s[0] == '*' ? 9 : (s[0] == '0' ? 0 : 1);\n\n    for (int i = 2; i <= n; ++i) {\n        if (s[i - 1] == '*') {\n            dp[i] = 9 * dp[i - 1];\n            if (s[i - 2] == '1') dp[i] += 9 * dp[i - 2];\n            else if (s[i - 2] == '2') dp[i] += 6 * dp[i - 2];\n            else if (s[i - 2] == '*') dp[i] += 15 * dp[i - 2];\n        } else {\n            dp[i] = (s[i - 1] != '0') ? dp[i - 1] : 0;\n            int num = std::stoi(s.substr(i - 2, 2));\n            if (s[i - 2] == '1' || (s[i - 2] == '2' && num <= 26)) dp[i] += dp[i - 2];\n            else if (s[i - 2] == '*') dp[i] += (num <= 26 && num >= 10) ? 2 * dp[i - 2] : dp[i - 2];\n        }\n        dp[i] %= MOD;\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to decode the string. The idea is to iterate over the characters of the string and, for each character `'c'`, calculate how many ways to decode the string up to the position of `'c'`.\n\nWe will use an array `dp`, where `dp[i]` holds the number of ways to decode the string up to position `i`. The base cases are `dp[0] = 1` and `dp[1]` is assigned depending on whether the first character is a star or not.\n\nIn each step, we will consider pairs of characters: the current character `'c'` and the previous character `'prevC'`. If `'c'` is a star, it can be replaced with any digit from '1' to '9', so we need to calculate how many ways we can decode each possibility. Similarly, we need to handle the case when `'c'` is not a star but `'prevC'` is.\n\nFinally, we update the number of ways to decode the string at each position, taking care of the modulo operation to avoid integer overflow issues.\n\nThe final answer will be the number of ways to decode the entire string, which is stored in `dp[n]`.\n    ", "python": "\n    ```python\ndef num_decodings(s: str) -> int:\n    MOD = 10**9 + 7\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 9 if s[0] == '*' else (0 if s[0] == '0' else 1)\n\n    for i in range(2, n + 1):\n        c, prev_c = s[i - 1], s[i - 2]\n        \n        if c == '*':\n            dp[i] = 9 * dp[i - 1]\n            if prev_c == '1': dp[i] += 9 * dp[i - 2]\n            elif prev_c == '2': dp[i] += 6 * dp[i - 2]\n            elif prev_c == '*': dp[i] += 15 * dp[i - 2]\n        else:\n            dp[i] = dp[i - 1] if c != '0' else 0\n            num = int(s[i - 2 : i])\n            if prev_c == '1' or (prev_c == '2' and num <= 26): dp[i] += dp[i - 2]\n            elif prev_c == '*': dp[i] += 2 * dp[i - 2] if 10 <= num <= 26 else dp[i - 2]\n\n        dp[i] %= MOD\n    return dp[n]\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to decode the string. The idea is to iterate over the characters of the string and, for each character `'c'`, calculate how many ways to decode the string up to the position of `'c'`.\n\nWe will use an array `dp`, where `dp[i]` holds the number of ways to decode the string up to position `i`. The base cases are `dp[0] = 1` and `dp[1]` is assigned depending on whether the first character is a star or not.\n\nIn each step, we will consider pairs of characters: the current character `'c'` and the previous character `'prevC'`. If `'c'` is a star, it can be replaced with any digit from '1' to '9', so we need to calculate how many ways we can decode each possibility. Similarly, we need to handle the case when `'c'` is not a star but `'prevC'` is.\n\nFinally, we update the number of ways to decode the string at each position, taking care of the modulo operation to avoid integer overflow issues.\n\nThe final answer will be the number of ways to decode the entire string, which is stored in `dp[n]`.\n    ", "javascript": "\n    ```javascript\nfunction numDecodings(s) {\n    const MOD = 1_000_000_007;\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = s[0] === '*' ? 9 : (s[0] === '0' ? 0 : 1);\n\n    for (let i = 2; i <= n; ++i) {\n        let c = s[i - 1];\n        let prevC = s[i - 2];\n\n        if (c === '*') {\n            dp[i] = 9 * dp[i - 1];\n            if (prevC === '1') dp[i] += 9 * dp[i - 2];\n            else if (prevC === '2') dp[i] += 6 * dp[i - 2];\n            else if (prevC === '*') dp[i] += 15 * dp[i - 2];\n        } else {\n            dp[i] = (c !== '0') ? dp[i - 1] : 0;\n            let num = parseInt(s.slice(i - 2, i));\n            if (prevC === '1' || (prevC === '2' && num <= 26)) dp[i] += dp[i - 2];\n            else if (prevC === '*') dp[i] += (num <= 26 && num >= 10) ? 2 * dp[i - 2] : dp[i - 2];\n        }\n        dp[i] %= MOD;\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to decode the string. The idea is to iterate over the characters of the string and, for each character `'c'`, calculate how many ways to decode the string up to the position of `'c'`.\n\nWe will use an array `dp`, where `dp[i]` holds the number of ways to decode the string up to position `i`. The base cases are `dp[0] = 1` and `dp[1]` is assigned depending on whether the first character is a star or not.\n\nIn each step, we will consider pairs of characters: the current character `'c'` and the previous character `'prevC'`. If `'c'` is a star, it can be replaced with any digit from '1' to '9', so we need to calculate how many ways we can decode each possibility. Similarly, we need to handle the case when `'c'` is not a star but `'prevC'` is.\n\nFinally, we update the number of ways to decode the string at each position, taking care of the modulo operation to avoid integer overflow issues.\n\nThe final answer will be the number of ways to decode the entire string, which is stored in `dp[n]`.\n    "}
{"id": 646, "slug": "maximum-length-of-pair-chain", "title": "Maximum Length of Pair Chain", "difficulty": "Medium", "content": "You are given an array of `n` pairs `pairs` where `pairs[i] = [lefti, righti]` and `lefti < righti`.\n\nA pair `p2 = [c, d]` **follows** a pair `p1 = [a, b]` if `b < c`. A **chain** of pairs can be formed in this fashion.\n\nReturn _the length longest chain which can be formed_.\n\nYou do not need to use up all the given intervals. You can select pairs in any order.\n\n**Example 1:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 2\n**Explanation:** The longest chain is \\[1,2\\] -> \\[3,4\\].\n\n**Example 2:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[7,8\\],\\[4,5\\]\\]\n**Output:** 3\n**Explanation:** The longest chain is \\[1,2\\] -> \\[4,5\\] -> \\[7,8\\].\n\n**Constraints:**\n\n*   `n == pairs.length`\n*   `1 <= n <= 1000`\n*   `-1000 <= lefti < righti <= 1000`", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int findLongestChain(int[][] pairs) {\n    Arrays.sort(pairs, Comparator.comparingInt(a -> a[1]));\n\n    int max_chain_length = 0, last_right = Integer.MIN_VALUE;\n    for (int[] pair : pairs) {\n        if (pair[0] > last_right) {\n            last_right = pair[1];\n            max_chain_length++;\n        }\n    }\n    \n    return max_chain_length;\n}\n```\n\n    \n    The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint findLongestChain(std::vector<std::vector<int>>& pairs) {\n    std::sort(pairs.begin(), pairs.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    int max_chain_length = 0, last_right = INT_MIN;\n    for (const auto& pair : pairs) {\n        if (pair[0] > last_right) {\n            last_right = pair[1];\n            max_chain_length++;\n        }\n    }\n    \n    return max_chain_length;\n}\n```\n\n    \n    The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n.\n    ", "python": "\n    ```python\ndef findLongestChain(pairs):\n    pairs.sort(key=lambda x: x[1])\n\n    max_chain_length = 0\n    last_right = float('-inf')\n    for pair in pairs:\n        if pair[0] > last_right:\n            last_right = pair[1]\n            max_chain_length += 1\n\n    return max_chain_length\n```\n\n    \n    The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n.\n    ", "javascript": "\n    ```javascript\nfunction findLongestChain(pairs) {\n    pairs.sort((a, b) => a[1] - b[1]);\n\n    let max_chain_length = 0, last_right = Number.MIN_SAFE_INTEGER;\n    for (const pair of pairs) {\n        if (pair[0] > last_right) {\n            last_right = pair[1];\n            max_chain_length++;\n        }\n    }\n\n    return max_chain_length;\n}\n```\n\n    \n    The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n.\n    "}
{"id": 647, "slug": "palindromic-substrings", "title": "Palindromic Substrings", "difficulty": "Medium", "content": "Given a string `s`, return _the number of **palindromic substrings** in it_.\n\nA string is a **palindrome** when it reads the same backward as forward.\n\nA **substring** is a contiguous sequence of characters within the string.\n\n**Example 1:**\n\n**Input:** s =  \"abc \"\n**Output:** 3\n**Explanation:** Three palindromic strings:  \"a \",  \"b \",  \"c \".\n\n**Example 2:**\n\n**Input:** s =  \"aaa \"\n**Output:** 6\n**Explanation:** Six palindromic strings:  \"a \",  \"a \",  \"a \",  \"aa \",  \"aa \",  \"aaa \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of lowercase English letters.", "java": "\n    ```java\npublic int countSubstrings(String s) {\n    int n = s.length(), count = 0;\n    for (int center = 0; center < 2 * n - 1; ++center) {\n        int left = center / 2;\n        int right = left + center % 2;\n        while (left >= 0 && right < n && s.charAt(left) == s.charAt(right)) {\n            ++count;\n            --left;\n            ++right;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is based on the idea of expanding a palindromic substring out from its center. There can be 2 * n - 1 possible centers for a string of length n. For each center, the algorithm initializes two pointers, left and right. Initially, left = center / 2, and right = left + center % 2. This ensures that both odd- and even-length palindromic substrings are covered. Then, for each center, the algorithm checks if characters at left and right are equal. If so, increment the count, move left pointer one position to the left, and right pointer one position to the right. The process continues until conditions are no longer satisfied, ensuring all palindromic substrings are taken into account. Finally, the count is returned as the answer.\n    ", "c++": "\n    ```cpp\nint countSubstrings(std::string s) {\n    int n = s.size(), count = 0;\n    for (int center = 0; center < 2 * n - 1; ++center) {\n        int left = center / 2;\n        int right = left + center % 2;\n        while (left >= 0 && right < n && s[left] == s[right]) {\n            ++count;\n            --left;\n            ++right;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is based on the idea of expanding a palindromic substring out from its center. There can be 2 * n - 1 possible centers for a string of length n. For each center, the algorithm initializes two pointers, left and right. Initially, left = center / 2, and right = left + center % 2. This ensures that both odd- and even-length palindromic substrings are covered. Then, for each center, the algorithm checks if characters at left and right are equal. If so, increment the count, move left pointer one position to the left, and right pointer one position to the right. The process continues until conditions are no longer satisfied, ensuring all palindromic substrings are taken into account. Finally, the count is returned as the answer.\n    ", "python": "\n    ```python\ndef countSubstrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for center in range(2 * n - 1):\n        left = center // 2\n        right = left + center % 2\n        while left >= 0 and right < n and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n    return count\n```\n    \n    The algorithm is based on the idea of expanding a palindromic substring out from its center. There can be 2 * n - 1 possible centers for a string of length n. For each center, the algorithm initializes two pointers, left and right. Initially, left = center / 2, and right = left + center % 2. This ensures that both odd- and even-length palindromic substrings are covered. Then, for each center, the algorithm checks if characters at left and right are equal. If so, increment the count, move left pointer one position to the left, and right pointer one position to the right. The process continues until conditions are no longer satisfied, ensuring all palindromic substrings are taken into account. Finally, the count is returned as the answer.\n    ", "javascript": "\n    ```javascript\nfunction countSubstrings(s) {\n    const n = s.length;\n    let count = 0;\n    for (let center = 0; center < 2 * n - 1; ++center) {\n        let left = Math.floor(center / 2);\n        let right = left + center % 2;\n        while (left >= 0 && right < n && s[left] === s[right]) {\n            ++count;\n            --left;\n            ++right;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is based on the idea of expanding a palindromic substring out from its center. There can be 2 * n - 1 possible centers for a string of length n. For each center, the algorithm initializes two pointers, left and right. Initially, left = center / 2, and right = left + center % 2. This ensures that both odd- and even-length palindromic substrings are covered. Then, for each center, the algorithm checks if characters at left and right are equal. If so, increment the count, move left pointer one position to the left, and right pointer one position to the right. The process continues until conditions are no longer satisfied, ensuring all palindromic substrings are taken into account. Finally, the count is returned as the answer.\n    "}
{"id": 650, "slug": "2-keys-keyboard", "title": "2 Keys Keyboard", "difficulty": "Medium", "content": "There is only one character `'A'` on the screen of a notepad. You can perform one of two operations on this notepad for each step:\n\n*   Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).\n*   Paste: You can paste the characters which are copied last time.\n\nGiven an integer `n`, return _the minimum number of operations to get the character_ `'A'` _exactly_ `n` _times on the screen_.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:** Initially, we have one character 'A'.\nIn step 1, we use Copy All operation.\nIn step 2, we use Paste operation to get 'AA'.\nIn step 3, we use Paste operation to get 'AAA'.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= n <= 1000`", "java": "\n    ```java\npublic int minSteps(int n) {\n    int result = 0;\n    for (int i = 2; i <= n; i++) {\n        while (n % i == 0) {\n            result += i;\n            n /= i;\n        }\n    }\n    return result;\n}\n```\n    \n    We need to find the minimum number of operations to get the character 'A' exactly n times on the screen. The operations are copying all (useful when having a large number of 'A's) and pasting.\n\nWe can think about this problem in terms of prime factorization. We are trying to break down n into the sum of various prime factors. The prime factors represent the number of operations needed at each step. \n\nIn our algorithm, we initialize the variable `result` to 0, which will store the minimum number of operations. We then start with i = 2 (smallest prime number) and iterate through all values less than or equal to n. Inside the loop, we check if n is divisible by i (i.e., n % i == 0). If yes, we add i to `result` and divide n by i. We keep doing this while n is divisible by i. Once n is no longer divisible by i, move on to the next value of i.\n\nAt the end of the algorithm, the `result` variable will contain the minimum number of operations to get n 'A's on the screen.\n    ", "c++": "\n    ```cpp\nint minSteps(int n) {\n    int result = 0;\n    for (int i = 2; i <= n; ++i) {\n        while (n % i == 0) {\n            result += i;\n            n /= i;\n        }\n    }\n    return result;\n}\n```\n    \n    We need to find the minimum number of operations to get the character 'A' exactly n times on the screen. The operations are copying all (useful when having a large number of 'A's) and pasting.\n\nWe can think about this problem in terms of prime factorization. We are trying to break down n into the sum of various prime factors. The prime factors represent the number of operations needed at each step. \n\nIn our algorithm, we initialize the variable `result` to 0, which will store the minimum number of operations. We then start with i = 2 (smallest prime number) and iterate through all values less than or equal to n. Inside the loop, we check if n is divisible by i (i.e., n % i == 0). If yes, we add i to `result` and divide n by i. We keep doing this while n is divisible by i. Once n is no longer divisible by i, move on to the next value of i.\n\nAt the end of the algorithm, the `result` variable will contain the minimum number of operations to get n 'A's on the screen.\n    ", "python": "\n    ```python\ndef min_steps(n):\n    result = 0\n    i = 2\n    while i <= n:\n        while n % i == 0:\n            result += i\n            n //= i\n        i += 1\n    return result\n```\n    \n    We need to find the minimum number of operations to get the character 'A' exactly n times on the screen. The operations are copying all (useful when having a large number of 'A's) and pasting.\n\nWe can think about this problem in terms of prime factorization. We are trying to break down n into the sum of various prime factors. The prime factors represent the number of operations needed at each step. \n\nIn our algorithm, we initialize the variable `result` to 0, which will store the minimum number of operations. We then start with i = 2 (smallest prime number) and iterate through all values less than or equal to n. Inside the loop, we check if n is divisible by i (i.e., n % i == 0). If yes, we add i to `result` and divide n by i. We keep doing this while n is divisible by i. Once n is no longer divisible by i, move on to the next value of i.\n\nAt the end of the algorithm, the `result` variable will contain the minimum number of operations to get n 'A's on the screen.\n    ", "javascript": "\n    ```javascript\nfunction minSteps(n) {\n    let result = 0;\n    for (let i = 2; i <= n; i++) {\n        while (n % i === 0) {\n            result += i;\n            n /= i;\n        }\n    }\n    return result;\n}\n```\n    \n    We need to find the minimum number of operations to get the character 'A' exactly n times on the screen. The operations are copying all (useful when having a large number of 'A's) and pasting.\n\nWe can think about this problem in terms of prime factorization. We are trying to break down n into the sum of various prime factors. The prime factors represent the number of operations needed at each step. \n\nIn our algorithm, we initialize the variable `result` to 0, which will store the minimum number of operations. We then start with i = 2 (smallest prime number) and iterate through all values less than or equal to n. Inside the loop, we check if n is divisible by i (i.e., n % i == 0). If yes, we add i to `result` and divide n by i. We keep doing this while n is divisible by i. Once n is no longer divisible by i, move on to the next value of i.\n\nAt the end of the algorithm, the `result` variable will contain the minimum number of operations to get n 'A's on the screen.\n    "}
{"id": 664, "slug": "strange-printer", "title": "Strange Printer", "difficulty": "Hard", "content": "There is a strange printer with the following two special properties:\n\n*   The printer can only print a sequence of **the same character** each time.\n*   At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\n\nGiven a string `s`, return _the minimum number of turns the printer needed to print it_.\n\n**Example 1:**\n\n**Input:** s =  \"aaabbb \"\n**Output:** 2\n**Explanation:** Print  \"aaa \" first and then print  \"bbb \".\n\n**Example 2:**\n\n**Input:** s =  \"aba \"\n**Output:** 2\n**Explanation:** Print  \"aaa \" first and then print  \"b \" from the second place of the string, which will cover the existing character 'a'.\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of lowercase English letters.", "java": "\n    ```java\nint strangePrinter(String s) {\n    int n = s.length();\n    if(n == 0) return 0;\n    int[][] dp = new int[n][n];\n    for(int i = 0; i < n; i++) dp[i][i] = 1;\n    for(int len = 1; len < n; len++) {\n        for(int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = dp[i+1][j] + 1;\n            for(int k = i + 1; k <= j; k++) {\n                if(s.charAt(i) == s.charAt(k)) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i+1][k-1] + dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n    \n    1. Initialize a DP table `dp` of size `n x n` where `n` is the length of the input string `s`.\n2. Fill the diagonal of the DP table with 1 since it takes one turn to print a single character.\n3. Iterate through subproblems of increasing length using a nested loop.\n4. For each subproblem, initialize `dp[i][j]` as `dp[i+1][j] + 1` assuming it takes one more turn to print the character at the current `i`.\n5. Loop through `k` from `i + 1` to `j`. If the character at `i` matches the character at `k`, update `dp[i][j]` by taking the minimum of its current value and the sum of turns for two non-overlapping subproblems `dp[i+1][k-1]` and `dp[k][j]`.\n6. The answer is stored at `dp[0][n-1]`.\n    ", "c++": "\n    ```cpp\nint strangePrinter(string s) {\n    int n = s.size();\n    if(n == 0) return 0;\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    for(int i = 0; i < n; i++) dp[i][i] = 1;\n    for(int len = 1; len < n; len++) {\n        for(int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = dp[i+1][j] + 1;\n            for(int k = i + 1; k <= j; k++) {\n                if(s[i] == s[k]) {\n                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n    \n    1. Initialize a DP table `dp` of size `n x n` where `n` is the length of the input string `s`.\n2. Fill the diagonal of the DP table with 1 since it takes one turn to print a single character.\n3. Iterate through subproblems of increasing length using a nested loop.\n4. For each subproblem, initialize `dp[i][j]` as `dp[i+1][j] + 1` assuming it takes one more turn to print the character at the current `i`.\n5. Loop through `k` from `i + 1` to `j`. If the character at `i` matches the character at `k`, update `dp[i][j]` by taking the minimum of its current value and the sum of turns for two non-overlapping subproblems `dp[i+1][k-1]` and `dp[k][j]`.\n6. The answer is stored at `dp[0][n-1]`.\n    ", "python": "\n    ```python\ndef strange_printer(s: str) -> int:\n    n = len(s)\n    if n == 0: return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = dp[i+1][j] + 1\n            for k in range(i + 1, j + 1):\n                if s[i] == s[k]:\n                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j])\n    return dp[0][n-1]\n```\n    \n    1. Initialize a DP table `dp` of size `n x n` where `n` is the length of the input string `s`.\n2. Fill the diagonal of the DP table with 1 since it takes one turn to print a single character.\n3. Iterate through subproblems of increasing length using a nested loop.\n4. For each subproblem, initialize `dp[i][j]` as `dp[i+1][j] + 1` assuming it takes one more turn to print the character at the current `i`.\n5. Loop through `k` from `i + 1` to `j`. If the character at `i` matches the character at `k`, update `dp[i][j]` by taking the minimum of its current value and the sum of turns for two non-overlapping subproblems `dp[i+1][k-1]` and `dp[k][j]`.\n6. The answer is stored at `dp[0][n-1]`.\n    ", "javascript": "\n    ```javascript\nfunction strangePrinter(s) {\n    let n = s.length;\n    if(n === 0) return 0;\n    const dp = Array.from({ length: n }, () => Array(n).fill(0));\n    for(let i = 0; i < n; i++) dp[i][i] = 1;\n    for(let len = 1; len < n; len++) {\n        for(let i = 0; i < n - len; i++) {\n            let j = i + len;\n            dp[i][j] = dp[i+1][j] + 1;\n            for(let k = i + 1; k <= j; k++) {\n                if(s.charAt(i) === s.charAt(k)) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i+1][k-1] + dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n    \n    1. Initialize a DP table `dp` of size `n x n` where `n` is the length of the input string `s`.\n2. Fill the diagonal of the DP table with 1 since it takes one turn to print a single character.\n3. Iterate through subproblems of increasing length using a nested loop.\n4. For each subproblem, initialize `dp[i][j]` as `dp[i+1][j] + 1` assuming it takes one more turn to print the character at the current `i`.\n5. Loop through `k` from `i + 1` to `j`. If the character at `i` matches the character at `k`, update `dp[i][j]` by taking the minimum of its current value and the sum of turns for two non-overlapping subproblems `dp[i+1][k-1]` and `dp[k][j]`.\n6. The answer is stored at `dp[0][n-1]`.\n    "}
{"id": 673, "slug": "number-of-longest-increasing-subsequence", "title": "Number of Longest Increasing Subsequence", "difficulty": "Medium", "content": "Given an integer array `nums`, return _the number of longest increasing subsequences._\n\n**Notice** that the sequence has to be **strictly** increasing.\n\n**Example 1:**\n\n**Input:** nums = \\[1,3,5,4,7\\]\n**Output:** 2\n**Explanation:** The two longest increasing subsequences are \\[1, 3, 4, 7\\] and \\[1, 3, 5, 7\\].\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\]\n**Output:** 5\n**Explanation:** The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2000`\n*   `-106 <= nums[i] <= 106`", "java": "\n    ```java\npublic int findNumberOfLIS(int[] nums) {\n    int n = nums.length, maxLength = 0, ans = 0;\n    int[] length = new int[n];\n    int[] count = new int[n];\n\n    for (int i = 0; i < n; ++i) {\n        length[i] = count[i] = 1;\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (length[i] == length[j] + 1) {\n                    count[i] += count[j];\n                } else if (length[i] < length[j] + 1) {\n                    length[i] = length[j] + 1;\n                    count[i] = count[j];\n                }\n            }\n        }\n        if (maxLength == length[i]) {\n            ans += count[i];\n        } else if (maxLength < length[i]) {\n            maxLength = length[i];\n            ans = count[i];\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm uses dynamic programming to find the number of longest increasing subsequences. We use two arrays, `length` and `count`. `length[i]` stores the length of the longest increasing subsequence ending at the index `i`, and `count[i]` stores the number of longest increasing subsequences ending at the index `i`.\n\n1. Initialize `maxLength` and `ans` to `0`.\n2. Initialize the `length` and `count` arrays to all have a value of `1`.\n3. Loop through the `nums` array using variable `i`.\n    a. Loop from `0` to `i - 1` using a variable `j`.\n        i. If `nums[i] > nums[j]`, update the values of `length[i]` and `count[i]` based on their current values and the values at index `j`. The rule for this is:\n            * If `length[i] == length[j] + 1`, increase `count[i]` by `count[j]`.\n            * If `length[i] < length[j] + 1`, update `length[i]` to `length[j] + 1` and update `count[i]` to `count[j]`.\n    b. If `maxLength` is equal to `length[i]`, increment `ans` by `count[i]`. If `maxLength` is less than `length[i]`, update `maxLength` to equal `length[i]` and update `ans` to equal `count[i]`.\n4. Return `ans` as the final result.\n\nThis algorithm has a time complexity of O(n^2) and a space complexity of O(n).\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nint findNumberOfLIS(std::vector<int>& nums) {\n    int n = nums.size(), maxLength = 0, ans = 0;\n    std::vector<int> length(n, 0), count(n, 0);\n\n    for (int i = 0; i < n; ++i) {\n        length[i] = count[i] = 1;\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (length[i] == length[j] + 1) {\n                    count[i] += count[j];\n                } else if (length[i] < length[j] + 1) {\n                    length[i] = length[j] + 1;\n                    count[i] = count[j];\n                }\n            }\n        }\n        if (maxLength == length[i]) {\n            ans += count[i];\n        } else if (maxLength < length[i]) {\n            maxLength = length[i];\n            ans = count[i];\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm uses dynamic programming to find the number of longest increasing subsequences. We use two arrays, `length` and `count`. `length[i]` stores the length of the longest increasing subsequence ending at the index `i`, and `count[i]` stores the number of longest increasing subsequences ending at the index `i`.\n\n1. Initialize `maxLength` and `ans` to `0`.\n2. Initialize the `length` and `count` arrays to all have a value of `1`.\n3. Loop through the `nums` array using variable `i`.\n    a. Loop from `0` to `i - 1` using a variable `j`.\n        i. If `nums[i] > nums[j]`, update the values of `length[i]` and `count[i]` based on their current values and the values at index `j`. The rule for this is:\n            * If `length[i] == length[j] + 1`, increase `count[i]` by `count[j]`.\n            * If `length[i] < length[j] + 1`, update `length[i]` to `length[j] + 1` and update `count[i]` to `count[j]`.\n    b. If `maxLength` is equal to `length[i]`, increment `ans` by `count[i]`. If `maxLength` is less than `length[i]`, update `maxLength` to equal `length[i]` and update `ans` to equal `count[i]`.\n4. Return `ans` as the final result.\n\nThis algorithm has a time complexity of O(n^2) and a space complexity of O(n).\n    ", "python": "\n    ```python\ndef findNumberOfLIS(nums):\n    n = len(nums)\n    maxLength = ans = 0\n    length = [1] * n\n    count = [1] * n\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                if length[i] == length[j] + 1:\n                    count[i] += count[j]\n                elif length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n                    count[i] = count[j]\n        if maxLength == length[i]:\n            ans += count[i]\n        elif maxLength < length[i]:\n            maxLength = length[i]\n            ans = count[i]\n\n    return ans\n```\n\n    \n    The algorithm uses dynamic programming to find the number of longest increasing subsequences. We use two arrays, `length` and `count`. `length[i]` stores the length of the longest increasing subsequence ending at the index `i`, and `count[i]` stores the number of longest increasing subsequences ending at the index `i`.\n\n1. Initialize `maxLength` and `ans` to `0`.\n2. Initialize the `length` and `count` arrays to all have a value of `1`.\n3. Loop through the `nums` array using variable `i`.\n    a. Loop from `0` to `i - 1` using a variable `j`.\n        i. If `nums[i] > nums[j]`, update the values of `length[i]` and `count[i]` based on their current values and the values at index `j`. The rule for this is:\n            * If `length[i] == length[j] + 1`, increase `count[i]` by `count[j]`.\n            * If `length[i] < length[j] + 1`, update `length[i]` to `length[j] + 1` and update `count[i]` to `count[j]`.\n    b. If `maxLength` is equal to `length[i]`, increment `ans` by `count[i]`. If `maxLength` is less than `length[i]`, update `maxLength` to equal `length[i]` and update `ans` to equal `count[i]`.\n4. Return `ans` as the final result.\n\nThis algorithm has a time complexity of O(n^2) and a space complexity of O(n).\n    ", "javascript": "\n    ```javascript\nfunction findNumberOfLIS(nums) {\n    const n = nums.length;\n    let maxLength = 0, ans = 0;\n    const length = new Array(n).fill(1);\n    const count = new Array(n).fill(1);\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (length[i] === length[j] + 1) {\n                    count[i] += count[j];\n                } else if (length[i] < length[j] + 1) {\n                    length[i] = length[j] + 1;\n                    count[i] = count[j];\n                }\n            }\n        }\n        if (maxLength === length[i]) {\n            ans += count[i];\n        } else if (maxLength < length[i]) {\n            maxLength = length[i];\n            ans = count[i];\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm uses dynamic programming to find the number of longest increasing subsequences. We use two arrays, `length` and `count`. `length[i]` stores the length of the longest increasing subsequence ending at the index `i`, and `count[i]` stores the number of longest increasing subsequences ending at the index `i`.\n\n1. Initialize `maxLength` and `ans` to `0`.\n2. Initialize the `length` and `count` arrays to all have a value of `1`.\n3. Loop through the `nums` array using variable `i`.\n    a. Loop from `0` to `i - 1` using a variable `j`.\n        i. If `nums[i] > nums[j]`, update the values of `length[i]` and `count[i]` based on their current values and the values at index `j`. The rule for this is:\n            * If `length[i] == length[j] + 1`, increase `count[i]` by `count[j]`.\n            * If `length[i] < length[j] + 1`, update `length[i]` to `length[j] + 1` and update `count[i]` to `count[j]`.\n    b. If `maxLength` is equal to `length[i]`, increment `ans` by `count[i]`. If `maxLength` is less than `length[i]`, update `maxLength` to equal `length[i]` and update `ans` to equal `count[i]`.\n4. Return `ans` as the final result.\n\nThis algorithm has a time complexity of O(n^2) and a space complexity of O(n).\n    "}
{"id": 678, "slug": "valid-parenthesis-string", "title": "Valid Parenthesis String", "difficulty": "Medium", "content": "Given a string `s` containing only three types of characters: `'('`, `')'` and `'*'`, return `true` _if_ `s` _is **valid**_.\n\nThe following rules define a **valid** string:\n\n*   Any left parenthesis `'('` must have a corresponding right parenthesis `')'`.\n*   Any right parenthesis `')'` must have a corresponding left parenthesis `'('`.\n*   Left parenthesis `'('` must go before the corresponding right parenthesis `')'`.\n*   `'*'` could be treated as a single right parenthesis `')'` or a single left parenthesis `'('` or an empty string `\" \"`.\n\n**Example 1:**\n\n**Input:** s = \"()\"\n**Output:** true\n\n**Example 2:**\n\n**Input:** s = \"(\\*)\"\n**Output:** true\n\n**Example 3:**\n\n**Input:** s = \"(\\*))\"\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s[i]` is `'('`, `')'` or `'*'`.", "java": "\n    ```java\npublic boolean checkValidString(String s) {\n    int left_balance = 0, right_balance = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        left_balance += (s.charAt(i) == '(' || s.charAt(i) == '*') ? 1 : -1;\n        right_balance += (s.charAt(s.length() - 1 - i) == ')' || s.charAt(s.length() - 1 - i) == '*') ? 1 : -1;\n\n        if (left_balance < 0 || right_balance < 0)\n            return false;\n    }\n\n    return true;\n}\n```\n\n    \n    The algorithm uses the greedy approach by keeping count of the possible balance of left and right parentheses with two variables `left_balance` and `right_balance`. \n\nWe iterate through the string in both forward and reverse direction looking at balance of the parentheses. The '*' character is treated as a left parenthesis when iterating forward, and as a right parenthesis when iterating in reverse. If at any point either balance is negative, we return false, as it is not a valid string.\n\nIf we successfully finish the iteration without returning false, it means the string is valid, and we return true.\n    ", "c++": "\n    ```cpp\nbool checkValidString(string s) {\n    int left_balance = 0, right_balance = 0;\n\n    for (int i = 0; i < s.size(); i++) {\n        left_balance += (s[i] == '(' || s[i] == '*') ? 1 : -1;\n        right_balance += (s[s.size() - 1 - i] == ')' || s[s.size() - 1 - i] == '*') ? 1 : -1;\n\n        if (left_balance < 0 || right_balance < 0)\n            return false;\n    }\n\n    return true;\n}\n```\n\n    \n    The algorithm uses the greedy approach by keeping count of the possible balance of left and right parentheses with two variables `left_balance` and `right_balance`. \n\nWe iterate through the string in both forward and reverse direction looking at balance of the parentheses. The '*' character is treated as a left parenthesis when iterating forward, and as a right parenthesis when iterating in reverse. If at any point either balance is negative, we return false, as it is not a valid string.\n\nIf we successfully finish the iteration without returning false, it means the string is valid, and we return true.\n    ", "python": "\n    ```python\ndef checkValidString(s: str) -> bool:\n    left_balance, right_balance = 0, 0\n\n    for i in range(len(s)):\n        left_balance += 1 if s[i] == '(' or s[i] == '*' else -1\n        right_balance += 1 if s[len(s) - 1 - i] == ')' or s[len(s) - 1 - i] == '*' else -1\n\n        if left_balance < 0 or right_balance < 0:\n            return False\n\n    return True\n```\n\n    \n    The algorithm uses the greedy approach by keeping count of the possible balance of left and right parentheses with two variables `left_balance` and `right_balance`. \n\nWe iterate through the string in both forward and reverse direction looking at balance of the parentheses. The '*' character is treated as a left parenthesis when iterating forward, and as a right parenthesis when iterating in reverse. If at any point either balance is negative, we return false, as it is not a valid string.\n\nIf we successfully finish the iteration without returning false, it means the string is valid, and we return true.\n    ", "javascript": "\n    ```javascript\nfunction checkValidString(s) {\n    let left_balance = 0, right_balance = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        left_balance += (s[i] === '(' || s[i] === '*') ? 1 : -1;\n        right_balance += (s[s.length - 1 - i] === ')' || s[s.length - 1 - i] === '*') ? 1 : -1;\n\n        if (left_balance < 0 || right_balance < 0)\n            return false;\n    }\n\n    return true;\n}\n```\n\n    \n    The algorithm uses the greedy approach by keeping count of the possible balance of left and right parentheses with two variables `left_balance` and `right_balance`. \n\nWe iterate through the string in both forward and reverse direction looking at balance of the parentheses. The '*' character is treated as a left parenthesis when iterating forward, and as a right parenthesis when iterating in reverse. If at any point either balance is negative, we return false, as it is not a valid string.\n\nIf we successfully finish the iteration without returning false, it means the string is valid, and we return true.\n    "}
{"id": 688, "slug": "knight-probability-in-chessboard", "title": "Knight Probability in Chessboard", "difficulty": "Medium", "content": "On an `n x n` chessboard, a knight starts at the cell `(row, column)` and attempts to make exactly `k` moves. The rows and columns are **0-indexed**, so the top-left cell is `(0, 0)`, and the bottom-right cell is `(n - 1, n - 1)`.\n\nA chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.\n\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\n\nThe knight continues moving until it has made exactly `k` moves or has moved off the chessboard.\n\nReturn _the probability that the knight remains on the board after it has stopped moving_.\n\n**Example 1:**\n\n**Input:** n = 3, k = 2, row = 0, column = 0\n**Output:** 0.06250\n**Explanation:** There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.\n\n**Example 2:**\n\n**Input:** n = 1, k = 0, row = 0, column = 0\n**Output:** 1.00000\n\n**Constraints:**\n\n*   `1 <= n <= 25`\n*   `0 <= k <= 100`\n*   `0 <= row, column <= n - 1`", "java": "\n    ```java\npublic double knightProbability(int n, int k, int row, int column) {\n    double[][][] memo = new double[n][n][k + 1];\n    for (double[][] m : memo)\n        for (double[] l : m)\n            Arrays.fill(l, -1.0);\n    return helper(n, k, row, column, memo);\n}\n\ndouble helper(int n, int k, int row, int column, double[][][] memo) {\n    if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\n    if (k == 0) return 1.0;\n    if (memo[row][column][k] >= 0) return memo[row][column][k];\n\n    double result = 0.0;\n    int[][] moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\n    for (int i = 0; i < 8; ++i)\n        result += helper(n, k - 1, row + moves[i][0], column + moves[i][1], memo) / 8;\n\n    memo[row][column][k] = result;\n    return result;\n}\n```\n    \n    The algorithm uses a depth-first search and memoization approach to find the probability that the knight remains on the board after k moves. It utilizes helper function, which receives parameters `n`, `k`, `row`, `column`, and `memo`.\n\nAt each step of the helper function, we check if the current position (row and column) is off the board. If it is, we return 0, as the knight is no longer on the board. If `k` equals 0, it means the knight has completed its moves and is still on the board, so we return 1. If the memo table has a valid value for the current position and moves remaining (k), we can return the memoized value to avoid redundant calculations.\n\nNext, we set a variable `result` to 0 and define an array of possible knight moves. We iterate through these moves and recursively call the helper function with the updated position (row + move[0], column + move[1]) and k - 1 moves remaining. We divide the result by 8 because the knight has 8 possible moves, and we need the average probability of staying on the board for each move. We store the result in the memo table and return it.\n\nWe call the helper function with the initial values for the given problem, and it returns the probability that the knight remains on the board after k moves.\n    ", "c++": "\n    ```cpp\ndouble knightProbability(int n, int k, int row, int column) {\n    vector<vector<vector<double>>> memo(n, vector<vector<double>>(n, vector<double>(k + 1, -1.0)));\n    return helper(n, k, row, column, memo);\n}\n\ndouble helper(int n, int k, int row, int column, vector<vector<vector<double>>>& memo) {\n    if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\n    if (k == 0) return 1.0;\n    if (memo[row][column][k] >= 0) return memo[row][column][k];\n    \n    double result = 0.0;\n    int moves[8][2] = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\n    for (int i = 0; i < 8; ++i)\n        result += helper(n, k - 1, row + moves[i][0], column + moves[i][1], memo) / 8;\n    \n    memo[row][column][k] = result;\n    return result;\n}\n```\n    \n    The algorithm uses a depth-first search and memoization approach to find the probability that the knight remains on the board after k moves. It utilizes helper function, which receives parameters `n`, `k`, `row`, `column`, and `memo`.\n\nAt each step of the helper function, we check if the current position (row and column) is off the board. If it is, we return 0, as the knight is no longer on the board. If `k` equals 0, it means the knight has completed its moves and is still on the board, so we return 1. If the memo table has a valid value for the current position and moves remaining (k), we can return the memoized value to avoid redundant calculations.\n\nNext, we set a variable `result` to 0 and define an array of possible knight moves. We iterate through these moves and recursively call the helper function with the updated position (row + move[0], column + move[1]) and k - 1 moves remaining. We divide the result by 8 because the knight has 8 possible moves, and we need the average probability of staying on the board for each move. We store the result in the memo table and return it.\n\nWe call the helper function with the initial values for the given problem, and it returns the probability that the knight remains on the board after k moves.\n    ", "python": "\n    ```python\ndef knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    memo = [[[-1.0 for _ in range(k + 1)] for _ in range(n)] for _ in range(n)]\n    return self.helper(n, k, row, column, memo)\n\ndef helper(self, n, k, row, column, memo):\n    if row < 0 or row >= n or column < 0 or column >= n:\n        return 0.0\n    if k == 0:\n        return 1.0\n    if memo[row][column][k] >= 0:\n        return memo[row][column][k]\n\n    result = 0.0\n    moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    for move in moves:\n        result += self.helper(n, k - 1, row + move[0], column + move[1], memo) / 8\n\n    memo[row][column][k] = result\n    return result\n```\n    \n    The algorithm uses a depth-first search and memoization approach to find the probability that the knight remains on the board after k moves. It utilizes helper function, which receives parameters `n`, `k`, `row`, `column`, and `memo`.\n\nAt each step of the helper function, we check if the current position (row and column) is off the board. If it is, we return 0, as the knight is no longer on the board. If `k` equals 0, it means the knight has completed its moves and is still on the board, so we return 1. If the memo table has a valid value for the current position and moves remaining (k), we can return the memoized value to avoid redundant calculations.\n\nNext, we set a variable `result` to 0 and define an array of possible knight moves. We iterate through these moves and recursively call the helper function with the updated position (row + move[0], column + move[1]) and k - 1 moves remaining. We divide the result by 8 because the knight has 8 possible moves, and we need the average probability of staying on the board for each move. We store the result in the memo table and return it.\n\nWe call the helper function with the initial values for the given problem, and it returns the probability that the knight remains on the board after k moves.\n    ", "javascript": "\n    ```javascript\nfunction knightProbability(n, k, row, column) {\n    let memo = new Array(n).fill().map(() => new Array(n).fill().map(() => new Array(k + 1).fill(-1)));\n    return helper(n, k, row, column, memo);\n}\n\nfunction helper(n, k, row, column, memo) {\n    if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\n    if (k === 0) return 1.0;\n    if (memo[row][column][k] >= 0) return memo[row][column][k];\n    \n    let result = 0.0;\n    let moves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];\n    for (let i = 0; i < 8; ++i)\n        result += helper(n, k - 1, row + moves[i][0], column + moves[i][1], memo) / 8;\n\n    memo[row][column][k] = result;\n    return result;\n}\n```\n    \n    The algorithm uses a depth-first search and memoization approach to find the probability that the knight remains on the board after k moves. It utilizes helper function, which receives parameters `n`, `k`, `row`, `column`, and `memo`.\n\nAt each step of the helper function, we check if the current position (row and column) is off the board. If it is, we return 0, as the knight is no longer on the board. If `k` equals 0, it means the knight has completed its moves and is still on the board, so we return 1. If the memo table has a valid value for the current position and moves remaining (k), we can return the memoized value to avoid redundant calculations.\n\nNext, we set a variable `result` to 0 and define an array of possible knight moves. We iterate through these moves and recursively call the helper function with the updated position (row + move[0], column + move[1]) and k - 1 moves remaining. We divide the result by 8 because the knight has 8 possible moves, and we need the average probability of staying on the board for each move. We store the result in the memo table and return it.\n\nWe call the helper function with the initial values for the given problem, and it returns the probability that the knight remains on the board after k moves.\n    "}
{"id": 689, "slug": "maximum-sum-of-3-non-overlapping-subarrays", "title": "Maximum Sum of 3 Non-Overlapping Subarrays", "difficulty": "Hard", "content": "Given an integer array `nums` and an integer `k`, find three non-overlapping subarrays of length `k` with maximum sum and return them.\n\nReturn the result as a list of indices representing the starting position of each interval (**0-indexed**). If there are multiple answers, return the lexicographically smallest one.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,1,2,6,7,5,1\\], k = 2\n**Output:** \\[0,3,5\\]\n**Explanation:** Subarrays \\[1, 2\\], \\[2, 6\\], \\[7, 5\\] correspond to the starting indices \\[0, 3, 5\\].\nWe could have also taken \\[2, 1\\], but an answer of \\[1, 3, 5\\] would be lexicographically larger.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,1,2,1,2,1,2,1\\], k = 2\n**Output:** \\[0,2,4\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i] < 216`\n*   `1 <= k <= floor(nums.length / 3)`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] max_sum_of_three_subarrays(int[] nums, int k) {\n    int n = nums.length;\n    int[] sums = new int[n - k + 1];\n    int[] left = new int[n], right = new int[n], ans = new int[3];\n    int acc_sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (int i = 1; i < n - k + 1; ++i) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (int i = n - k - 1; i >= 0; --i) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    int max_sum = 0;\n\n    for (int i = k; i < n - 2 * k + 1; ++i) {\n        int left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans = new int[] {left_idx, i, right_idx};\n        }\n    }\n\n    return ans;\n}\n```\n    \n    First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> max_sum_of_three_subarrays(std::vector<int> &nums, int k) {\n    int n = nums.size();\n    std::vector<int> sums(n - k + 1);\n    std::vector<int> left(n), right(n), ans(3);\n    int acc_sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (int i = 1; i < n - k + 1; ++i) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (int i = n - k - 1; i >= 0; --i) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    int max_sum = 0;\n\n    for (int i = k; i < n - 2 * k + 1; ++i) {\n        int left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans = {left_idx, i, right_idx};\n        }\n    }\n\n    return ans;\n}\n```\n    \n    First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum.\n    ", "python": "\n    ```python\ndef max_sum_of_three_subarrays(nums, k):\n    n = len(nums)\n    sums = [0] * (n - k + 1)\n    left, right = [0] * n, [0] * n\n\n    acc_sum = 0\n    for i in range(n):\n        acc_sum += nums[i]\n        if i >= k:\n            acc_sum -= nums[i - k]\n        if i >= k - 1:\n            sums[i - k + 1] = acc_sum\n\n    left[0] = 0\n    right[n - k] = n - k\n    for i in range(1, n - k + 1):\n        left[i] = i if sums[i] > sums[left[i - 1]] else left[i - 1]\n\n    for i in range(n - k - 1, -1, -1):\n        right[i] = i if sums[i] >= sums[right[i + 1]] else right[i + 1]\n\n    max_sum, ans = 0, [0] * 3\n    for i in range(k, n - 2 * k + 1):\n        left_idx, right_idx = left[i - k], right[i + k]\n        total_sum = sums[left_idx] + sums[i] + sums[right_idx]\n        if total_sum > max_sum:\n            max_sum = total_sum\n            ans = [left_idx, i, right_idx]\n\n    return ans\n```\n    \n    First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum.\n    ", "javascript": "\n    ```javascript\nfunction max_sum_of_three_subarrays(nums, k) {\n    const n = nums.length;\n    const sums = new Array(n - k + 1);\n    const left = new Array(n), right = new Array(n);\n    let acc_sum = 0;\n\n    for (let i = 0; i < n; i++) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (let i = 1; i < n - k + 1; i++) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (let i = n - k - 1; i >= 0; i--) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    let max_sum = 0;\n    const ans = [0, 0, 0];\n\n    for (let i = k; i < n - 2 * k + 1; i++) {\n        const left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans[0] = left_idx;\n            ans[1] = i;\n            ans[2] = right_idx;\n        }\n    }\n\n    return ans;\n}\n```\n    \n    First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum.\n    "}
{"id": 691, "slug": "stickers-to-spell-word", "title": "Stickers to Spell Word", "difficulty": "Hard", "content": "We are given `n` different types of `stickers`. Each sticker has a lowercase English word on it.\n\nYou would like to spell out the given string `target` by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker.\n\nReturn _the minimum number of stickers that you need to spell out_ `target`. If the task is impossible, return `-1`.\n\n**Note:** In all test cases, all words were chosen randomly from the `1000` most common US English words, and `target` was chosen as a concatenation of two random words.\n\n**Example 1:**\n\n**Input:** stickers = \\[ \"with \", \"example \", \"science \"\\], target =  \"thehat \"\n**Output:** 3\n**Explanation:**\nWe can use 2  \"with \" stickers, and 1  \"example \" sticker.\nAfter cutting and rearrange the letters of those stickers, we can form the target  \"thehat \".\nAlso, this is the minimum number of stickers necessary to form the target string.\n\n**Example 2:**\n\n**Input:** stickers = \\[ \"notice \", \"possible \"\\], target =  \"basicbasic \"\n**Output:** -1\nExplanation:\nWe cannot form the target  \"basicbasic \" from cutting letters from the given stickers.\n\n**Constraints:**\n\n*   `n == stickers.length`\n*   `1 <= n <= 50`\n*   `1 <= stickers[i].length <= 10`\n*   `1 <= target.length <= 15`\n*   `stickers[i]` and `target` consist of lowercase English letters.", "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int minStickers(String[] stickers, String target) {\n        Map<String, Integer> memo = new HashMap<>();\n        int[] targetCount = new int[26];\n        for (char c : target.toCharArray()) targetCount[c - 'a']++;\n        \n        for (String s : stickers) {\n            int[] stickerCount = new int[26];\n            StringBuilder sb = new StringBuilder();\n            for (char c : s.toCharArray()) {\n                if (targetCount[c - 'a'] == 0) continue;\n                stickerCount[c - 'a']++;\n            }\n            for (int i = 0; i < 26; ++i) {\n                sb.append(String.valueOf((char) ('a' + i)).repeat(stickerCount[i]));\n            }\n            memo.put(sb.toString(), 1);\n        }\n        \n        return dp(memo, targetCount, target);\n    }\n    \n    private int dp(Map<String, Integer> memo, int[] targetCount, String target) {\n        if (memo.containsKey(target)) return memo.get(target);\n        int[] counts = new int[26];\n        for (char c : target.toCharArray()) counts[c - 'a']++;\n        int ans = Integer.MAX_VALUE;\n        for (Map.Entry<String, Integer> kv : memo.entrySet()) {\n            boolean ok = true;\n            for (int i = 0; i < 26 && ok; ++i)\n                ok = counts[i] >= kv.getKey().charAt(i) - 'a';\n            if (!ok) continue;\n            ans = Math.min(ans, dp(memo, targetCount, target.substring(kv.getKey().length())) + kv.getValue());\n        }\n        memo.put(target, ans == Integer.MAX_VALUE ? -1 : ans);\n        return memo.get(target);\n    }\n}\n```\n    \n    The solution to the problem is recursive in nature, with memoization technique to optimize the solution further. The core idea is to calculate the frequency count for each character in the target string, and to iterate over each sticker and create a character frequency count for it while checking if the target string needs the characters present in that sticker. After creating the initial memo, we define a function `dp` that accepts the state of target and memo, and performs recursion to find the minimum count required to build the target.\n\nIn each step, we construct the frequency count needed for the remaining target and iterate through each possible remaining substring. If any substring can be formed with any subsequence of a sticker, the function calls itself recursively with the remaining characters and adds the count of that sticker. The answer is the minimum number of stickers required among all the possibilities. At the end, the base case is when the state is not present; it will return -1. It starts from the complete target and proceeds further solving the subproblems.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minStickers(vector<string>& stickers, string target) {\n    unordered_map<string, int> memo;\n    vector<int> target_count(26, 0);\n    for (char c : target) target_count[c - 'a']++;\n    \n    for (string& s : stickers) {\n        vector<int> sticker_count(26, 0);\n        int connection = 0;\n        for (char c : s) {\n            if (!target_count[c - 'a']) continue;\n            connection = 1;\n            sticker_count[c - 'a']++;\n        }\n        if (!connection) continue;\n        \n        string state = \"\";\n        for (int i = 0; i < 26; ++i)\n            state += string(sticker_count[i], 'a' + i);\n        memo[state] = 1;\n    }\n    \n    function<int(const string&)> dp = [&](const string& state) {\n        if (memo.count(state)) return memo[state];\n        vector<int> counts(26, 0);\n        for (char c : state) counts[c - 'a']++;\n        int ans = INT_MAX;\n        for (const auto& kv : memo) {\n            bool ok = true;\n            for (int i = 0; i < 26 && ok; ++i)\n                ok = counts[i] >= kv.first[i] - 'a';\n            if (!ok) continue;\n            ans = min(ans, dp(state.substr(kv.first.size())) + kv.second);\n        }\n        memo[state] = ans == INT_MAX ? -1 : ans;\n        return memo[state];\n    };\n    \n    string start = \"\";\n    for (int i = 0; i < 26; ++i)\n        start += string(target_count[i], 'a' + i);\n    return dp(start);\n}\n```\n    \n    The solution to the problem is recursive in nature, with memoization technique to optimize the solution further. The core idea is to calculate the frequency count for each character in the target string, and to iterate over each sticker and create a character frequency count for it while checking if the target string needs the characters present in that sticker. After creating the initial memo, we define a function `dp` that accepts the state of target and memo, and performs recursion to find the minimum count required to build the target.\n\nIn each step, we construct the frequency count needed for the remaining target and iterate through each possible remaining substring. If any substring can be formed with any subsequence of a sticker, the function calls itself recursively with the remaining characters and adds the count of that sticker. The answer is the minimum number of stickers required among all the possibilities. At the end, the base case is when the state is not present; it will return -1. It starts from the complete target and proceeds further solving the subproblems.\n    ", "python": "\n    ```python\nfrom collections import Counter\nfrom functools import lru_cache\n\ndef minStickers(stickers, target):\n    target_count = Counter(target)\n    memo = {}\n    \n    for s in stickers:\n        sticker_count = Counter(s)\n        state = ''.join(sticker_count & target_count)\n        memo[state] = 1\n    \n    @lru_cache(None)\n    def dp(state):\n        counts = Counter(state)\n        ans = float('inf')\n        for key, value in memo.items():\n            if any(counts[ch] < key.count(ch) for ch in state): continue\n            ans = min(ans, dp(state.translate(str.maketrans('', '', key))) + value)\n        return -1 if ans == float('inf') else ans\n    \n    return dp(target)\n```\n    \n    The solution to the problem is recursive in nature, with memoization technique to optimize the solution further. The core idea is to calculate the frequency count for each character in the target string, and to iterate over each sticker and create a character frequency count for it while checking if the target string needs the characters present in that sticker. After creating the initial memo, we define a function `dp` that accepts the state of target and memo, and performs recursion to find the minimum count required to build the target.\n\nIn each step, we construct the frequency count needed for the remaining target and iterate through each possible remaining substring. If any substring can be formed with any subsequence of a sticker, the function calls itself recursively with the remaining characters and adds the count of that sticker. The answer is the minimum number of stickers required among all the possibilities. At the end, the base case is when the state is not present; it will return -1. It starts from the complete target and proceeds further solving the subproblems.\n    ", "javascript": "\n    ```javascript\nfunction minStickers(stickers, target) {\n    let targetCount = new Array(26).fill(0);\n    let memo = new Map();\n    for (let c of target) targetCount[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    for (let s of stickers) {\n        let stickerCount = new Array(26).fill(0);\n        let state = \"\";\n        for (let c of s) {\n            if (!targetCount[c.charCodeAt(0) - 'a'.charCodeAt(0)]) continue;\n            stickerCount[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n        }\n        for (let i = 0; i < 26; ++i) {\n            state += String.fromCharCode('a'.charCodeAt(0) + i).repeat(stickerCount[i]);\n        }\n        memo.set(state, 1);\n    }\n    \n    return dp(memo, target);\n}\n\nfunction dp(memo, target) {\n    if (memo.has(target)) return memo.get(target);\n    let counts = new Array(26).fill(0);\n    for (let c of target) counts[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    let ans = Infinity;\n    for (let [key, value] of memo) {\n        let ok = true;\n        for (let i = 0; i < 26 && ok; ++i)\n            ok = counts[i] >= (key.match(new RegExp(String.fromCharCode('a'.charCodeAt(0) + i), 'g')) || []).length;\n        if (!ok) continue;\n        ans = Math.min(ans, dp(memo, target.substring(key.length)) + value);\n    }\n    memo.set(target, ans == Infinity ? -1 : ans);\n    return memo.get(target);\n}\n```\n    \n    The solution to the problem is recursive in nature, with memoization technique to optimize the solution further. The core idea is to calculate the frequency count for each character in the target string, and to iterate over each sticker and create a character frequency count for it while checking if the target string needs the characters present in that sticker. After creating the initial memo, we define a function `dp` that accepts the state of target and memo, and performs recursion to find the minimum count required to build the target.\n\nIn each step, we construct the frequency count needed for the remaining target and iterate through each possible remaining substring. If any substring can be formed with any subsequence of a sticker, the function calls itself recursively with the remaining characters and adds the count of that sticker. The answer is the minimum number of stickers required among all the possibilities. At the end, the base case is when the state is not present; it will return -1. It starts from the complete target and proceeds further solving the subproblems.\n    "}
{"id": 698, "slug": "partition-to-k-equal-sum-subsets", "title": "Partition to K Equal Sum Subsets", "difficulty": "Medium", "content": "Given an integer array `nums` and an integer `k`, return `true` if it is possible to divide this array into `k` non-empty subsets whose sums are all equal.\n\n**Example 1:**\n\n**Input:** nums = \\[4,3,2,3,5,2,1\\], k = 4\n**Output:** true\n**Explanation:** It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\], k = 3\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 16`\n*   `1 <= nums[i] <= 104`\n*   The frequency of each element is in the range `[1, 4]`.", "java": "\n    ```java\npublic boolean canPartitionKSubsets(int[] nums, int k) {\n  int sum = 0;\n  for (int num : nums) sum += num;\n  if (sum % k != 0) return false;\n  int target = sum / k;\n  boolean[] visited = new boolean[nums.length];\n  return dfs(nums, visited, 0, target, 0, k);\n}\n\nprivate boolean dfs(int[] nums, boolean[] visited, int start, int target, int curr_sum, int k) {\n  if (k == 1) return true;\n  if (curr_sum == target) return dfs(nums, visited, 0, target, 0, k - 1);\n  for (int i = start; i < nums.length; i++) {\n    if (!visited[i] && curr_sum + nums[i] <= target) {\n      visited[i] = true;\n      if (dfs(nums, visited, i + 1, target, curr_sum + nums[i], k)) return true;\n      visited[i] = false;\n    }\n  }\n  return false;\n}\n```\n    \n    The algorithm uses depth-first search (DFS) to find possible subsets that sum up to the target value. The target is calculated by dividing the total sum of the array by k. The DFS function takes the following parameters: nums (the array), visited (a boolean array to keep track of visited elements), start (starting index for the current subset), target (target sum), curr_sum (current sum of the current subset), and k (number of subsets).\n\nThe base case is when k == 1, which means we have successfully found k - 1 subsets and the remaining elements automatically form the last subset, so we return true. \n\nIf curr_sum equals target, we found a valid subset, and we continue the search with k - 1 subsets starting from the beginning of the array. \n\nThe algorithm iterates through the array elements, checks if the element has not been visited, and if adding the element to the curr_sum doesn't exceed the target. If both conditions are met, the element is marked as visited, and the DFS is called recursively with the updated curr_sum and starting index. If the recursive call returns true, we found a valid set of subsets and return true. Otherwise, we backtrack by marking the element as unvisited.\n\nIf the DFS function doesn't find a solution, it returns false, indicating that it's not possible to divide the array into k equal subsets.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <numeric>\n\nbool canPartitionKSubsets(std::vector<int>& nums, int k) {\n  int sum = std::accumulate(nums.begin(), nums.end(), 0);\n  if (sum % k != 0) return false;\n  int target = sum / k;\n  std::vector<bool> visited(nums.size(), false);\n  return dfs(nums, visited, 0, target, 0, k);\n}\n\nbool dfs(std::vector<int>& nums, std::vector<bool>& visited, int start, int target, int curr_sum, int k) {\n  if (k == 1) return true;\n  if (curr_sum == target) return dfs(nums, visited, 0, target, 0, k - 1);\n  for (int i = start; i < nums.size(); i++) {\n    if (!visited[i] && curr_sum + nums[i] <= target) {\n      visited[i] = true;\n      if (dfs(nums, visited, i + 1, target, curr_sum + nums[i], k)) return true;\n      visited[i] = false;\n    }\n  }\n  return false;\n}\n```\n    \n    The algorithm uses depth-first search (DFS) to find possible subsets that sum up to the target value. The target is calculated by dividing the total sum of the array by k. The DFS function takes the following parameters: nums (the array), visited (a boolean array to keep track of visited elements), start (starting index for the current subset), target (target sum), curr_sum (current sum of the current subset), and k (number of subsets).\n\nThe base case is when k == 1, which means we have successfully found k - 1 subsets and the remaining elements automatically form the last subset, so we return true. \n\nIf curr_sum equals target, we found a valid subset, and we continue the search with k - 1 subsets starting from the beginning of the array. \n\nThe algorithm iterates through the array elements, checks if the element has not been visited, and if adding the element to the curr_sum doesn't exceed the target. If both conditions are met, the element is marked as visited, and the DFS is called recursively with the updated curr_sum and starting index. If the recursive call returns true, we found a valid set of subsets and return true. Otherwise, we backtrack by marking the element as unvisited.\n\nIf the DFS function doesn't find a solution, it returns false, indicating that it's not possible to divide the array into k equal subsets.\n    ", "python": "\n    ```python\ndef canPartitionKSubsets(nums, k):\n    total_sum = sum(nums)\n    if total_sum % k != 0:\n        return False\n    target = total_sum // k\n    visited = [False] * len(nums)\n    return dfs(nums, visited, 0, target, 0, k)\n\ndef dfs(nums, visited, start, target, curr_sum, k):\n    if k == 1:\n        return True\n    if curr_sum == target:\n        return dfs(nums, visited, 0, target, 0, k - 1)\n    for i in range(start, len(nums)):\n        if not visited[i] and curr_sum + nums[i] <= target:\n            visited[i] = True\n            if dfs(nums, visited, i + 1, target, curr_sum + nums[i], k):\n                return True\n            visited[i] = False\n    return False\n```\n    \n    The algorithm uses depth-first search (DFS) to find possible subsets that sum up to the target value. The target is calculated by dividing the total sum of the array by k. The DFS function takes the following parameters: nums (the array), visited (a boolean array to keep track of visited elements), start (starting index for the current subset), target (target sum), curr_sum (current sum of the current subset), and k (number of subsets).\n\nThe base case is when k == 1, which means we have successfully found k - 1 subsets and the remaining elements automatically form the last subset, so we return true. \n\nIf curr_sum equals target, we found a valid subset, and we continue the search with k - 1 subsets starting from the beginning of the array. \n\nThe algorithm iterates through the array elements, checks if the element has not been visited, and if adding the element to the curr_sum doesn't exceed the target. If both conditions are met, the element is marked as visited, and the DFS is called recursively with the updated curr_sum and starting index. If the recursive call returns true, we found a valid set of subsets and return true. Otherwise, we backtrack by marking the element as unvisited.\n\nIf the DFS function doesn't find a solution, it returns false, indicating that it's not possible to divide the array into k equal subsets.\n    ", "javascript": "\n    ```javascript\nfunction canPartitionKSubsets(nums, k) {\n  let sum = nums.reduce((a, b) => a + b, 0);\n  if (sum % k !== 0) return false;\n  const target = sum / k;\n  const visited = new Array(nums.length).fill(false);\n  return dfs(nums, visited, 0, target, 0, k);\n}\n\nfunction dfs(nums, visited, start, target, currSum, k) {\n  if (k === 1) return true;\n  if (currSum === target) return dfs(nums, visited, 0, target, 0, k - 1);\n  for (let i = start; i < nums.length; i++) {\n    if (!visited[i] && currSum + nums[i] <= target) {\n      visited[i] = true;\n      if (dfs(nums, visited, i + 1, target, currSum + nums[i], k)) return true;\n      visited[i] = false;\n    }\n  }\n  return false;\n}\n```\n    \n    The algorithm uses depth-first search (DFS) to find possible subsets that sum up to the target value. The target is calculated by dividing the total sum of the array by k. The DFS function takes the following parameters: nums (the array), visited (a boolean array to keep track of visited elements), start (starting index for the current subset), target (target sum), curr_sum (current sum of the current subset), and k (number of subsets).\n\nThe base case is when k == 1, which means we have successfully found k - 1 subsets and the remaining elements automatically form the last subset, so we return true. \n\nIf curr_sum equals target, we found a valid subset, and we continue the search with k - 1 subsets starting from the beginning of the array. \n\nThe algorithm iterates through the array elements, checks if the element has not been visited, and if adding the element to the curr_sum doesn't exceed the target. If both conditions are met, the element is marked as visited, and the DFS is called recursively with the updated curr_sum and starting index. If the recursive call returns true, we found a valid set of subsets and return true. Otherwise, we backtrack by marking the element as unvisited.\n\nIf the DFS function doesn't find a solution, it returns false, indicating that it's not possible to divide the array into k equal subsets.\n    "}
{"id": 712, "slug": "minimum-ascii-delete-sum-for-two-strings", "title": "Minimum ASCII Delete Sum for Two Strings", "difficulty": "Medium", "content": "Given two strings `s1` and `s2`, return _the lowest **ASCII** sum of deleted characters to make two strings equal_.\n\n**Example 1:**\n\n**Input:** s1 =  \"sea \", s2 =  \"eat \"\n**Output:** 231\n**Explanation:** Deleting  \"s \" from  \"sea \" adds the ASCII value of  \"s \" (115) to the sum.\nDeleting  \"t \" from  \"eat \" adds 116 to the sum.\nAt the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\n\n**Example 2:**\n\n**Input:** s1 =  \"delete \", s2 =  \"leet \"\n**Output:** 403\n**Explanation:** Deleting  \"dee \" from  \"delete \" to turn the string into  \"let \",\nadds 100\\[d\\] + 101\\[e\\] + 101\\[e\\] to the sum.\nDeleting  \"e \" from  \"leet \" adds 101\\[e\\] to the sum.\nAt the end, both strings are equal to  \"let \", and the answer is 100+101+101+101 = 403.\nIf instead we turned both strings into  \"lee \" or  \"eet \", we would get answers of 433 or 417, which are higher.\n\n**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 1000`\n*   `s1` and `s2` consist of lowercase English letters.", "java": "\n    ```java\npublic int minimumDeleteSum(String s1, String s2) {\n    int[][] dp = new int[s1.length() + 1][s2.length() + 1];\n    for (int i = 1; i <= s1.length(); i++) {\n        dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);\n    }\n    for (int j = 1; j <= s2.length(); j++) {\n        dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);\n    }\n    for (int i = 1; i <= s1.length(); i++) {\n        for (int j = 1; j <= s2.length(); j++) {\n            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));\n            }\n        }\n    }\n    return dp[s1.length()][s2.length()];\n}\n```\n    \n    For this problem, we use dynamic programming. First, we create a 2D array `dp` to store the intermediate results. Each cell dp[i][j] in the `dp` array represents the lowest ASCII sum of deleted characters to make the first i characters of s1 and the first j characters of s2 equal.\n\nWe initialize the first column of the `dp` array to the ASCII sum of s1 characters and the first row to the ASCII sum of s2 characters. Then, we loop through the entire `dp` array, updating the values lexicographically. If the characters at the respective indexes of s1 and s2 are the same, we just copy the value of dp[i-1][j-1] to dp[i][j]. If they are different, we calculate the minimum between deleting the character from s1 (dp[i-1][j] + ASCII value of the character) and deleting the character from s2 (dp[i][j-1] + ASCII value of the character).\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the lowest ASCII sum needed to make s1 and s2 equal.\n    ", "c++": "\n    ```cpp\nint minimumDeleteSum(std::string s1, std::string s2) {\n    int dp[1001][1001] = {0};\n    for (int i = 1; i <= s1.size(); i++) {\n        dp[i][0] = dp[i - 1][0] + s1[i - 1];\n    }\n    for (int j = 1; j <= s2.size(); j++) {\n        dp[0][j] = dp[0][j - 1] + s2[j - 1];\n    }\n    for (int i = 1; i <= s1.size(); i++) {\n        for (int j = 1; j <= s2.size(); j++) {\n            if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = std::min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\n            }\n        }\n    }\n    return dp[s1.size()][s2.size()];\n}\n```\n    \n    For this problem, we use dynamic programming. First, we create a 2D array `dp` to store the intermediate results. Each cell dp[i][j] in the `dp` array represents the lowest ASCII sum of deleted characters to make the first i characters of s1 and the first j characters of s2 equal.\n\nWe initialize the first column of the `dp` array to the ASCII sum of s1 characters and the first row to the ASCII sum of s2 characters. Then, we loop through the entire `dp` array, updating the values lexicographically. If the characters at the respective indexes of s1 and s2 are the same, we just copy the value of dp[i-1][j-1] to dp[i][j]. If they are different, we calculate the minimum between deleting the character from s1 (dp[i-1][j] + ASCII value of the character) and deleting the character from s2 (dp[i][j-1] + ASCII value of the character).\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the lowest ASCII sum needed to make s1 and s2 equal.\n    ", "python": "\n    ```python\ndef minimumDeleteSum(s1: str, s2: str) -> int:\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    for i in range(1, len(s1) + 1):\n        dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n    for j in range(1, len(s2) + 1):\n        dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))\n    return dp[len(s1)][len(s2)]\n```\n    \n    For this problem, we use dynamic programming. First, we create a 2D array `dp` to store the intermediate results. Each cell dp[i][j] in the `dp` array represents the lowest ASCII sum of deleted characters to make the first i characters of s1 and the first j characters of s2 equal.\n\nWe initialize the first column of the `dp` array to the ASCII sum of s1 characters and the first row to the ASCII sum of s2 characters. Then, we loop through the entire `dp` array, updating the values lexicographically. If the characters at the respective indexes of s1 and s2 are the same, we just copy the value of dp[i-1][j-1] to dp[i][j]. If they are different, we calculate the minimum between deleting the character from s1 (dp[i-1][j] + ASCII value of the character) and deleting the character from s2 (dp[i][j-1] + ASCII value of the character).\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the lowest ASCII sum needed to make s1 and s2 equal.\n    ", "javascript": "\n    ```javascript\nfunction minimumDeleteSum(s1, s2) {\n    const dp = Array.from({ length: s1.length + 1 }, () => Array(s2.length + 1).fill(0));\n    for (let i = 1; i <= s1.length; i++) {\n        dp[i][0] = dp[i - 1][0] + s1.charCodeAt(i - 1);\n    }\n    for (let j = 1; j <= s2.length; j++) {\n        dp[0][j] = dp[0][j - 1] + s2.charCodeAt(j - 1);\n    }\n    for (let i = 1; i <= s1.length; i++) {\n        for (let j = 1; j <= s2.length; j++) {\n            if (s1.charAt(i - 1) === s2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j] + s1.charCodeAt(i - 1), dp[i][j - 1] + s2.charCodeAt(j - 1));\n            }\n        }\n    }\n    return dp[s1.length][s2.length];\n}\n```\n    \n    For this problem, we use dynamic programming. First, we create a 2D array `dp` to store the intermediate results. Each cell dp[i][j] in the `dp` array represents the lowest ASCII sum of deleted characters to make the first i characters of s1 and the first j characters of s2 equal.\n\nWe initialize the first column of the `dp` array to the ASCII sum of s1 characters and the first row to the ASCII sum of s2 characters. Then, we loop through the entire `dp` array, updating the values lexicographically. If the characters at the respective indexes of s1 and s2 are the same, we just copy the value of dp[i-1][j-1] to dp[i][j]. If they are different, we calculate the minimum between deleting the character from s1 (dp[i-1][j] + ASCII value of the character) and deleting the character from s2 (dp[i][j-1] + ASCII value of the character).\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the lowest ASCII sum needed to make s1 and s2 equal.\n    "}
{"id": 714, "slug": "best-time-to-buy-and-sell-stock-with-transaction-fee", "title": "Best Time to Buy and Sell Stock with Transaction Fee", "difficulty": "Medium", "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `fee` representing a transaction fee.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n**Example 1:**\n\n**Input:** prices = \\[1,3,2,8,4,9\\], fee = 2\n**Output:** 8\n**Explanation:** The maximum profit can be achieved by:\n- Buying at prices\\[0\\] = 1\n- Selling at prices\\[3\\] = 8\n- Buying at prices\\[4\\] = 4\n- Selling at prices\\[5\\] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n\n**Example 2:**\n\n**Input:** prices = \\[1,3,7,5,10,3\\], fee = 3\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= prices.length <= 5 * 104`\n*   `1 <= prices[i] < 5 * 104`\n*   `0 <= fee < 5 * 104`", "java": "\n    ```java\npublic int maxProfit(int[] prices, int fee) {\n    int cash = 0, hold = -prices[0];\n    for (int price : prices) {\n        int temp = cash;\n        cash = Math.max(cash, hold + price - fee);\n        hold = Math.max(hold, temp - price);\n    }\n    return cash;\n}\n```\n    \n    The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit.\n    ", "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices, int fee) {\n    int cash = 0, hold = -prices[0];\n    for (int price : prices) {\n        int temp = cash;\n        cash = max(cash, hold + price - fee);\n        hold = max(hold, temp - price);\n    }\n    return cash;\n}\n```\n    \n    The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit.\n    ", "python": "\n    ```python\ndef maxProfit(prices, fee):\n    cash, hold = 0, -prices[0]\n    for price in prices:\n        temp = cash\n        cash = max(cash, hold + price - fee)\n        hold = max(hold, temp - price)\n    return cash\n```\n    \n    The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit.\n    ", "javascript": "\n    ```javascript\nfunction maxProfit(prices, fee) {\n    let cash = 0, hold = -prices[0];\n    for (const price of prices) {\n        let temp = cash;\n        cash = Math.max(cash, hold + price - fee);\n        hold = Math.max(hold, temp - price);\n    }\n    return cash;\n}\n```\n    \n    The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit.\n    "}
{"id": 718, "slug": "maximum-length-of-repeated-subarray", "title": "Maximum Length of Repeated Subarray", "difficulty": "Medium", "content": "Given two integer arrays `nums1` and `nums2`, return _the maximum length of a subarray that appears in **both** arrays_.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,2,3,2,1\\], nums2 = \\[3,2,1,4,7\\]\n**Output:** 3\n**Explanation:** The repeated subarray with maximum length is \\[3,2,1\\].\n\n**Example 2:**\n\n**Input:** nums1 = \\[0,0,0,0,0\\], nums2 = \\[0,0,0,0,0\\]\n**Output:** 5\n**Explanation:** The repeated subarray with maximum length is \\[0,0,0,0,0\\].\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 100`", "java": "\n    ```java\npublic int findLength(int[] nums1, int[] nums2) {\n    int m = nums1.length;\n    int n = nums2.length;\n    int[][] dp = new int[m + 1][n + 1];\n    int maxLength = 0;\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if (nums1[i] == nums2[j]) {\n                dp[i][j] = dp[i + 1][j + 1] + 1;\n                maxLength = Math.max(maxLength, dp[i][j]);\n            }\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm uses dynamic programming to store the length of the common subarray ending at the current position for both arrays. For each element in the input arrays, it checks if the elements are equal. If they are, it updates the length of their common subarray by adding 1 to the length of the common subarray found in the next positions. Finally, the maximum length found is returned.\n\nNote that the outer loop iterates from the end to the beginning, avoiding the need to initialize values in the table with special cases (like initializing with the maximum length at the beginning of the loop). This makes the code shorter and easier to understand. Each step of the iteration compares elements in the two arrays and updates the maxLength, if necessary.\n    ", "c++": "\n    ```cpp\nint findLength(vector<int>& nums1, vector<int>& nums2) {\n    int m = nums1.size();\n    int n = nums2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    int maxLength = 0;\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if (nums1[i] == nums2[j]) {\n                dp[i][j] = dp[i + 1][j + 1] + 1;\n                maxLength = max(maxLength, dp[i][j]);\n            }\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm uses dynamic programming to store the length of the common subarray ending at the current position for both arrays. For each element in the input arrays, it checks if the elements are equal. If they are, it updates the length of their common subarray by adding 1 to the length of the common subarray found in the next positions. Finally, the maximum length found is returned.\n\nNote that the outer loop iterates from the end to the beginning, avoiding the need to initialize values in the table with special cases (like initializing with the maximum length at the beginning of the loop). This makes the code shorter and easier to understand. Each step of the iteration compares elements in the two arrays and updates the maxLength, if necessary.\n    ", "python": "\n    ```python\ndef findLength(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxLength = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if nums1[i] == nums2[j]:\n                dp[i][j] = dp[i + 1][j + 1] + 1\n                maxLength = max(maxLength, dp[i][j])\n\n    return maxLength\n```\n    \n    The algorithm uses dynamic programming to store the length of the common subarray ending at the current position for both arrays. For each element in the input arrays, it checks if the elements are equal. If they are, it updates the length of their common subarray by adding 1 to the length of the common subarray found in the next positions. Finally, the maximum length found is returned.\n\nNote that the outer loop iterates from the end to the beginning, avoiding the need to initialize values in the table with special cases (like initializing with the maximum length at the beginning of the loop). This makes the code shorter and easier to understand. Each step of the iteration compares elements in the two arrays and updates the maxLength, if necessary.\n    ", "javascript": "\n    ```javascript\nfunction findLength(nums1, nums2) {\n    const m = nums1.length;\n    const n = nums2.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    let maxLength = 0;\n\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            if (nums1[i] === nums2[j]) {\n                dp[i][j] = dp[i + 1][j + 1] + 1;\n                maxLength = Math.max(maxLength, dp[i][j]);\n            }\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm uses dynamic programming to store the length of the common subarray ending at the current position for both arrays. For each element in the input arrays, it checks if the elements are equal. If they are, it updates the length of their common subarray by adding 1 to the length of the common subarray found in the next positions. Finally, the maximum length found is returned.\n\nNote that the outer loop iterates from the end to the beginning, avoiding the need to initialize values in the table with special cases (like initializing with the maximum length at the beginning of the loop). This makes the code shorter and easier to understand. Each step of the iteration compares elements in the two arrays and updates the maxLength, if necessary.\n    "}
{"id": 730, "slug": "count-different-palindromic-subsequences", "title": "Count Different Palindromic Subsequences", "difficulty": "Hard", "content": "Given a string s, return _the number of different non-empty palindromic subsequences in_ `s`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA subsequence of a string is obtained by deleting zero or more characters from the string.\n\nA sequence is palindromic if it is equal to the sequence reversed.\n\nTwo sequences `a1, a2, ...` and `b1, b2, ...` are different if there is some `i` for which `ai != bi`.\n\n**Example 1:**\n\n**Input:** s =  \"bccb \"\n**Output:** 6\n**Explanation:** The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\nNote that 'bcb' is counted only once, even though it occurs twice.\n\n**Example 2:**\n\n**Input:** s =  \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba \"\n**Output:** 104860361\n**Explanation:** There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 109 + 7.\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` is either `'a'`, `'b'`, `'c'`, or `'d'`.", "java": "\n    ```java\npublic int countPalindromicSubsequences(String S) {\n    int n = S.length();\n    int mod = 1000000007;\n    int[][] dp = new int[4][n + 1];\n\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int c = S.charAt(i) - 'a';\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            if (dp[c][j] < 0) dp[c][j] += mod;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % mod;\n}\n```\n\n    \n    The algorithm uses dynamic programming. The state of `dp[i][j]` stores the number of different non-empty palindromic subsequences of `s` with characters from index `i` to `j - 1`, and only considering the character `s[i]`. Iterating over the string from the back, the algorithm checks the current character into its corresponding bucket, and updates the current bucket's values based on the previous state.\n\nThis algorithm has a time complexity of O(N^2), where N is the length of the string. The space complexity is O(N), as the algorithm only stores palindromic subsequences for each character from 'a' to 'd'.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nint countPalindromicSubsequences(string s) {\n    int n = s.length();\n    int MOD = 1000000007;\n    vector<vector<int>> dp(4, vector<int>(n + 1, 0));\n\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int c = s[i] - 'a';\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            dp[c][j] = (dp[c][j] + MOD) % MOD;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % MOD;\n}\n```\n\n    \n    The algorithm uses dynamic programming. The state of `dp[i][j]` stores the number of different non-empty palindromic subsequences of `s` with characters from index `i` to `j - 1`, and only considering the character `s[i]`. Iterating over the string from the back, the algorithm checks the current character into its corresponding bucket, and updates the current bucket's values based on the previous state.\n\nThis algorithm has a time complexity of O(N^2), where N is the length of the string. The space complexity is O(N), as the algorithm only stores palindromic subsequences for each character from 'a' to 'd'.\n    ", "python": "\n    ```python\ndef countPalindromicSubsequences(s: str) -> int:\n    n = len(s)\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(4)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n + 1):\n            c = ord(s[i]) - ord('a')\n            dp[c][j] = sum(dp[k][j - 1] for k in range(4)) - dp[c][i] + 2\n            dp[c][j] = (dp[c][j] + MOD) % MOD\n\n    return sum(dp[c][n] for c in range(4)) % MOD\n```\n\n    \n    The algorithm uses dynamic programming. The state of `dp[i][j]` stores the number of different non-empty palindromic subsequences of `s` with characters from index `i` to `j - 1`, and only considering the character `s[i]`. Iterating over the string from the back, the algorithm checks the current character into its corresponding bucket, and updates the current bucket's values based on the previous state.\n\nThis algorithm has a time complexity of O(N^2), where N is the length of the string. The space complexity is O(N), as the algorithm only stores palindromic subsequences for each character from 'a' to 'd'.\n    ", "javascript": "\n    ```javascript\nfunction countPalindromicSubsequences(s) {\n    const n = s.length;\n    const MOD = 1000000007;\n    const dp = Array.from({ length: 4 }, () => Array(n + 1).fill(0));\n\n    for (let i = n - 1; i >= 0; i--) {\n        for (let j = i + 1; j <= n; j++) {\n            const c = s.charCodeAt(i) - 97;\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            dp[c][j] = (dp[c][j] + MOD) % MOD;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % MOD;\n}\n```\n\n    \n    The algorithm uses dynamic programming. The state of `dp[i][j]` stores the number of different non-empty palindromic subsequences of `s` with characters from index `i` to `j - 1`, and only considering the character `s[i]`. Iterating over the string from the back, the algorithm checks the current character into its corresponding bucket, and updates the current bucket's values based on the previous state.\n\nThis algorithm has a time complexity of O(N^2), where N is the length of the string. The space complexity is O(N), as the algorithm only stores palindromic subsequences for each character from 'a' to 'd'.\n    "}
{"id": 740, "slug": "delete-and-earn", "title": "Delete and Earn", "difficulty": "Medium", "content": "You are given an integer array `nums`. You want to maximize the number of points you get by performing the following operation any number of times:\n\n*   Pick any `nums[i]` and delete it to earn `nums[i]` points. Afterwards, you must delete **every** element equal to `nums[i] - 1` and **every** element equal to `nums[i] + 1`.\n\nReturn _the **maximum number of points** you can earn by applying the above operation some number of times_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,4,2\\]\n**Output:** 6\n**Explanation:** You can perform the following operations:\n- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = \\[2\\].\n- Delete 2 to earn 2 points. nums = \\[\\].\nYou earn a total of 6 points.\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,3,3,3,4\\]\n**Output:** 9\n**Explanation:** You can perform the following operations:\n- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = \\[3,3\\].\n- Delete a 3 again to earn 3 points. nums = \\[3\\].\n- Delete a 3 once more to earn 3 points. nums = \\[\\].\nYou earn a total of 9 points.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i] <= 104`", "java": "\n    ```java\npublic int maxPoints(int[] nums) {\n    int[] dp = new int[100001];\n    int max_points = 0;\n    for (int num : nums) {\n        dp[num]++;\n    }\n    for (int i = 2; i < dp.length; i++) {\n        dp[i] = Math.max(dp[i - 1], dp[i - 2] + i * dp[i]);\n        max_points = Math.max(max_points, dp[i]);\n    }\n    return max_points;\n}\n```\n    \n    The algorithm uses dynamic programming to determine the maximum number of points earned from the input integer array. We create a `dp` array to store counts of integer occurrences in `nums`. We then iterate through the `dp` array, and for each index `i`, calculate the maximum number of points earned by choosing to either keep or skip the current value (represented by the index). The final answer (max points) is obtained from the last index of the `dp` array.\n    ", "c++": "\n    ```cpp\nint maxPoints(vector<int>& nums) {\n    vector<int> dp(100001, 0);\n    int max_points = 0;\n    for (int num : nums) {\n        dp[num]++;\n    }\n    for (int i = 2; i < dp.size(); i++) {\n        dp[i] = max(dp[i - 1], dp[i - 2] + i * dp[i]);\n        max_points = max(max_points, dp[i]);\n    }\n    return max_points;\n}\n```\n    \n    The algorithm uses dynamic programming to determine the maximum number of points earned from the input integer array. We create a `dp` array to store counts of integer occurrences in `nums`. We then iterate through the `dp` array, and for each index `i`, calculate the maximum number of points earned by choosing to either keep or skip the current value (represented by the index). The final answer (max points) is obtained from the last index of the `dp` array.\n    ", "python": "\n    ```python\ndef max_points(nums):\n    dp = [0] * 100001\n    max_points = 0\n    for num in nums:\n        dp[num] += 1\n    for i in range(2, len(dp)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + i * dp[i])\n        max_points = max(max_points, dp[i])\n    return max_points\n```\n    \n    The algorithm uses dynamic programming to determine the maximum number of points earned from the input integer array. We create a `dp` array to store counts of integer occurrences in `nums`. We then iterate through the `dp` array, and for each index `i`, calculate the maximum number of points earned by choosing to either keep or skip the current value (represented by the index). The final answer (max points) is obtained from the last index of the `dp` array.\n    ", "javascript": "\n    ```javascript\nfunction maxPoints(nums) {\n    const dp = new Array(100001).fill(0);\n    let max_points = 0;\n    for (let num of nums) {\n        dp[num]++;\n    }\n    for (let i = 2; i < dp.length; i++) {\n        dp[i] = Math.max(dp[i - 1], dp[i - 2] + i * dp[i]);\n        max_points = Math.max(max_points, dp[i]);\n    }\n    return max_points;\n}\n```\n    \n    The algorithm uses dynamic programming to determine the maximum number of points earned from the input integer array. We create a `dp` array to store counts of integer occurrences in `nums`. We then iterate through the `dp` array, and for each index `i`, calculate the maximum number of points earned by choosing to either keep or skip the current value (represented by the index). The final answer (max points) is obtained from the last index of the `dp` array.\n    "}
{"id": 741, "slug": "cherry-pickup", "title": "Cherry Pickup", "difficulty": "Hard", "content": "You are given an `n x n` `grid` representing a field of cherries, each cell is one of three possible integers.\n\n*   `0` means the cell is empty, so you can pass through,\n*   `1` means the cell contains a cherry that you can pick up and pass through, or\n*   `-1` means the cell contains a thorn that blocks your way.\n\nReturn _the maximum number of cherries you can collect by following the rules below_:\n\n*   Starting at the position `(0, 0)` and reaching `(n - 1, n - 1)` by moving right or down through valid path cells (cells with value `0` or `1`).\n*   After reaching `(n - 1, n - 1)`, returning to `(0, 0)` by moving left or up through valid path cells.\n*   When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell `0`.\n*   If there is no valid path between `(0, 0)` and `(n - 1, n - 1)`, then no cherries can be collected.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,-1\\],\\[1,0,-1\\],\\[1,1,1\\]\\]\n**Output:** 5\n**Explanation:** The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes \\[\\[0,1,-1\\],\\[0,0,-1\\],\\[0,0,0\\]\\].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,-1\\],\\[1,-1,1\\],\\[-1,1,1\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 50`\n*   `grid[i][j]` is `-1`, `0`, or `1`.\n*   `grid[0][0] != -1`\n*   `grid[n - 1][n - 1] != -1`", "java": "\n    ```java\npublic int cherryPickup(int[][] grid) {\n    int N = grid.length;\n    int[][][] dp = new int[N][N][N];\n    for (int[][] layer: dp)\n        for (int[] row: layer)\n            Arrays.fill(row, Integer.MIN_VALUE);\n\n    return Math.max(0, dp(0, 0, 0, grid, dp));\n}\n\npublic int dp(int r1, int c1, int c2, int[][] grid, int[][][] memo) {\n    int r2 = r1 + c1 - c2;\n    if (r1 == grid.length || r2 == grid.length || c1 == grid.length || c2 == grid.length ||\n            grid[r1][c1] == -1 || grid[r2][c2] == -1) {\n        return Integer.MIN_VALUE;\n    } else if (r1 == grid.length - 1 && c1 == grid.length - 1) {\n        return grid[r1][c1];\n    } else if (memo[r1][c1][c2] != Integer.MIN_VALUE) {\n        return memo[r1][c1][c2];\n    } else {\n        memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2 ? grid[r2][c2] : 0);\n        int tempMax = Math.max(Math.max(dp(r1+1, c1, c2+1, grid, memo), dp(r1, c1+1, c2+1, grid, memo)),\n                        Math.max(dp(r1+1, c1, c2, grid, memo), dp(r1, c1+1, c2, grid, memo)));\n        memo[r1][c1][c2] += tempMax;\n    }\n    return memo[r1][c1][c2];\n}\n```\n\n    \n    The algorithm is based on Dynamic Programming. The main idea is to traverse the grid twice - first from (0, 0) to (n-1, n-1) and then back to (0, 0) - using two different paths.\n\nWe use memoization to store values of the cherries collected at each step to avoid recomputations. The dp function takes three variables (r1, c1, and c2) as inputs, where r1 and c1 represent the row and column of the first path, and c2 represents the column of the second path. We then calculate the row of the second path (r2) using the formula r2 = r1 + c1 - c2.\n\nThe function checks the base cases for invalid inputs or if cherries collected are already calculated (memoized), then it returns the memoized value.\n\nThe main algorithm calculates the cherries for the current step by adding the cherries in the current cell r1 and c1, and if the paths are different, it adds cherries of r2 and c2 too. After that, it computes the maximum cherries from four possible ways to move (right, down) for both paths and adds it to the memoized table.\n\nFinally, the algorithm returns memo[r1][c1][c2] as the maximum cherries collected.\n\nAt the end, the function returns the maximum cherries collected between (0, 0) and (n-1, n-1) using two different paths, making sure it's not negative.\n    ", "c++": "\n    ```cpp\nint helper(vector<vector<int>>& grid, vector<vector<vector<int>>>& memo, int r1, int c1, int r2) {\n    int c2 = r1 + c1 - r2;\n    if (r1 == grid.size() || r2 == grid.size() || c1 == grid.size() || c2 == grid.size() ||\n        grid[r1][c1] == -1 || grid[r2][c2] == -1) {\n        return INT_MIN;\n    } else if (r1 == grid.size() - 1 && c1 == grid.size() - 1) {\n        return grid[r1][c1];\n    } else if (memo[r1][c1][r2] != INT_MIN) {\n        return memo[r1][c1][r2];\n    } else {\n        memo[r1][c1][r2] = grid[r1][c1] + (r1 != r2 ? grid[r2][c2] : 0);\n        int max_cherries = max(max(helper(grid, memo, r1 + 1, c1, r2 + 1), helper(grid, memo, r1, c1 + 1, r2 + 1)),\n                               max(helper(grid, memo, r1 + 1, c1, r2), helper(grid, memo, r1, c1 + 1, r2)));\n        memo[r1][c1][r2] += max_cherries;\n    }\n    return memo[r1][c1][r2];\n}\n\nint cherryPickup(vector<vector<int>>& grid) {\n    int n = grid.size();\n    vector<vector<vector<int>>> memo(n, vector<vector<int>>(n, vector<int>(n, INT_MIN)));\n    return max(0, helper(grid, memo, 0, 0, 0));\n}\n```\n\n    \n    The algorithm is based on Dynamic Programming. The main idea is to traverse the grid twice - first from (0, 0) to (n-1, n-1) and then back to (0, 0) - using two different paths.\n\nWe use memoization to store values of the cherries collected at each step to avoid recomputations. The dp function takes three variables (r1, c1, and c2) as inputs, where r1 and c1 represent the row and column of the first path, and c2 represents the column of the second path. We then calculate the row of the second path (r2) using the formula r2 = r1 + c1 - c2.\n\nThe function checks the base cases for invalid inputs or if cherries collected are already calculated (memoized), then it returns the memoized value.\n\nThe main algorithm calculates the cherries for the current step by adding the cherries in the current cell r1 and c1, and if the paths are different, it adds cherries of r2 and c2 too. After that, it computes the maximum cherries from four possible ways to move (right, down) for both paths and adds it to the memoized table.\n\nFinally, the algorithm returns memo[r1][c1][c2] as the maximum cherries collected.\n\nAt the end, the function returns the maximum cherries collected between (0, 0) and (n-1, n-1) using two different paths, making sure it's not negative.\n    ", "python": "\n    ```python\ndef cherryPickup(self, grid: List[List[int]]) -> int:\n    def dp(r1, c1, c2):\n        r2 = r1 + c1 - c2\n        if (r1 == len(grid) or r2 == len(grid) or c1 == len(grid) or c2 == len(grid) or\n            grid[r1][c1] == -1 or grid[r2][c2] == -1):\n            return float('-inf')\n        elif r1 == len(grid) - 1 and c1 == len(grid) - 1:\n            return grid[r1][c1]\n        elif memo[r1][c1][c2] != float('-inf'):\n            return memo[r1][c1][c2]\n        else:\n            memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2) * grid[r2][c2]\n            max_cherries = max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1),\n                               dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2))\n            memo[r1][c1][c2] += max_cherries\n        \n        return memo[r1][c1][c2]\n    \n    N = len(grid)\n    memo = [[[float('-inf')] * N for _1 in range(N)] for _2 in range(N)]\n    return max(0, dp(0, 0, 0))\n```\n\n    \n    The algorithm is based on Dynamic Programming. The main idea is to traverse the grid twice - first from (0, 0) to (n-1, n-1) and then back to (0, 0) - using two different paths.\n\nWe use memoization to store values of the cherries collected at each step to avoid recomputations. The dp function takes three variables (r1, c1, and c2) as inputs, where r1 and c1 represent the row and column of the first path, and c2 represents the column of the second path. We then calculate the row of the second path (r2) using the formula r2 = r1 + c1 - c2.\n\nThe function checks the base cases for invalid inputs or if cherries collected are already calculated (memoized), then it returns the memoized value.\n\nThe main algorithm calculates the cherries for the current step by adding the cherries in the current cell r1 and c1, and if the paths are different, it adds cherries of r2 and c2 too. After that, it computes the maximum cherries from four possible ways to move (right, down) for both paths and adds it to the memoized table.\n\nFinally, the algorithm returns memo[r1][c1][c2] as the maximum cherries collected.\n\nAt the end, the function returns the maximum cherries collected between (0, 0) and (n-1, n-1) using two different paths, making sure it's not negative.\n    ", "javascript": "\n    ```javascript\nvar cherryPickup = function(grid) {\n    const N = grid.length;\n    const memo = new Array(N).fill(0).map(() => new Array(N).fill(0).map(() => new Array(N).fill(Number.MIN_SAFE_INTEGER)));\n\n    function dp(r1, c1, c2) {\n        const r2 = r1 + c1 - c2;\n        if (r1 === N || r2 === N || c1 === N || c2 === N || grid[r1][c1] === -1 || grid[r2][c2] === -1) {\n            return Number.MIN_SAFE_INTEGER;\n        } else if (r1 === N - 1 && c1 === N - 1) {\n            return grid[r1][c1];\n        } else if (memo[r1][c1][c2] !== Number.MIN_SAFE_INTEGER) {\n            return memo[r1][c1][c2];\n        } else {\n            memo[r1][c1][c2] = grid[r1][c1] + (r1 !== r2 ? grid[r2][c2] : 0);\n            const tempMax = Math.max(Math.max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1)),\n                            Math.max(dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2)));\n            memo[r1][c1][c2] += tempMax;\n        }\n        return memo[r1][c1][c2];\n    }\n\n    return Math.max(0, dp(0, 0, 0));\n};\n```\n\n    \n    The algorithm is based on Dynamic Programming. The main idea is to traverse the grid twice - first from (0, 0) to (n-1, n-1) and then back to (0, 0) - using two different paths.\n\nWe use memoization to store values of the cherries collected at each step to avoid recomputations. The dp function takes three variables (r1, c1, and c2) as inputs, where r1 and c1 represent the row and column of the first path, and c2 represents the column of the second path. We then calculate the row of the second path (r2) using the formula r2 = r1 + c1 - c2.\n\nThe function checks the base cases for invalid inputs or if cherries collected are already calculated (memoized), then it returns the memoized value.\n\nThe main algorithm calculates the cherries for the current step by adding the cherries in the current cell r1 and c1, and if the paths are different, it adds cherries of r2 and c2 too. After that, it computes the maximum cherries from four possible ways to move (right, down) for both paths and adds it to the memoized table.\n\nFinally, the algorithm returns memo[r1][c1][c2] as the maximum cherries collected.\n\nAt the end, the function returns the maximum cherries collected between (0, 0) and (n-1, n-1) using two different paths, making sure it's not negative.\n    "}
{"id": 746, "slug": "min-cost-climbing-stairs", "title": "Min Cost Climbing Stairs", "difficulty": "Easy", "content": "You are given an integer array `cost` where `cost[i]` is the cost of `ith` step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\nYou can either start from the step with index `0`, or the step with index `1`.\n\nReturn _the minimum cost to reach the top of the floor_.\n\n**Example 1:**\n\n**Input:** cost = \\[10,15,20\\]\n**Output:** 15\n**Explanation:** You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n**Example 2:**\n\n**Input:** cost = \\[1,100,1,1,1,100,1,1,100,1\\]\n**Output:** 6\n**Explanation:** You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.\n\n**Constraints:**\n\n*   `2 <= cost.length <= 1000`\n*   `0 <= cost[i] <= 999`", "java": "\n    ```java\nimport java.util.HashMap;\n\nclass WordFilter {\n    private HashMap<String, Integer> dict;\n    \n    public WordFilter(String[] words) {\n        dict = new HashMap<>();\n        for (int i = 0; i < words.length; i++) {\n            for (int j = 0; j <= words[i].length(); j++) {\n                dict.put(words[i].substring(0, j) + \"#\" + words[i].substring(j), i);\n            }\n        }\n    }\n    \n    public int f(String prefix, String suffix) {\n        Integer result = dict.get(prefix + \"#\" + suffix);\n        return result == null ? -1 : result;\n    }\n}\n```\n\n    \n    1. We create a hash table called `dict`.\n2. For every word in the given `words` list, we iterate through each character position in the word.\n3. For each position, we create a new string that combines the word's prefix (characters before the position) and suffix (characters after the position), with a '#' as a separator. This new string is added to the `dict` hash table with the corresponding index of the word in the list as its value.\n4. When the `f` function is called with a given prefix and suffix, we search for the combined string (prefix + '#' + suffix) in the `dict`. If it exists, we return the index value stored for that string, otherwise we return -1.\n    ", "c++": "\n    ```cpp\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nclass WordFilter {\n    unordered_map<string, int> dict;\npublic:\n    WordFilter(vector<string>& words) {\n        for (int i = 0; i < words.size(); ++i) {\n            for (int j = 0; j <= words[i].size(); ++j) {\n                dict[words[i].substr(0, j) + \"#\" + words[i].substr(j)] = i;\n            }\n        }\n    }\n\n    int f(string prefix, string suffix) {\n        auto it = dict.find(prefix + \"#\" + suffix);\n        if (it == dict.end()) {\n            return -1;\n        }\n        return it->second;\n    }\n};\n```\n\n    \n    1. We create a hash table called `dict`.\n2. For every word in the given `words` list, we iterate through each character position in the word.\n3. For each position, we create a new string that combines the word's prefix (characters before the position) and suffix (characters after the position), with a '#' as a separator. This new string is added to the `dict` hash table with the corresponding index of the word in the list as its value.\n4. When the `f` function is called with a given prefix and suffix, we search for the combined string (prefix + '#' + suffix) in the `dict`. If it exists, we return the index value stored for that string, otherwise we return -1.\n    ", "python": "\n    ```python\nclass WordFilter:\n\n    def __init__(self, words):\n        self.dict = {}\n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                self.dict[word[:j] + \"#\" + word[j:]] = i\n\n    def f(self, prefix, suffix):\n        return self.dict.get(prefix + \"#\" + suffix, -1)\n```\n\n    \n    1. We create a hash table called `dict`.\n2. For every word in the given `words` list, we iterate through each character position in the word.\n3. For each position, we create a new string that combines the word's prefix (characters before the position) and suffix (characters after the position), with a '#' as a separator. This new string is added to the `dict` hash table with the corresponding index of the word in the list as its value.\n4. When the `f` function is called with a given prefix and suffix, we search for the combined string (prefix + '#' + suffix) in the `dict`. If it exists, we return the index value stored for that string, otherwise we return -1.\n    ", "javascript": "\n    ```javascript\nclass WordFilter {\n    constructor(words) {\n        this.dict = {};\n        for (let i = 0; i < words.length; i++) {\n            for (let j = 0; j <= words[i].length; j++) {\n                this.dict[words[i].slice(0, j) + \"#\" + words[i].slice(j)] = i;\n            }\n        }\n    }\n\n    f(prefix, suffix) {\n        if (this.dict.hasOwnProperty(prefix + \"#\" + suffix)) {\n            return this.dict[prefix + \"#\" + suffix];\n        }\n        return -1;\n    }\n}\n```\n\n    \n    1. We create a hash table called `dict`.\n2. For every word in the given `words` list, we iterate through each character position in the word.\n3. For each position, we create a new string that combines the word's prefix (characters before the position) and suffix (characters after the position), with a '#' as a separator. This new string is added to the `dict` hash table with the corresponding index of the word in the list as its value.\n4. When the `f` function is called with a given prefix and suffix, we search for the combined string (prefix + '#' + suffix) in the `dict`. If it exists, we return the index value stored for that string, otherwise we return -1.\n    "}
{"id": 750, "slug": "number-of-corner-rectangles", "title": "Number Of Corner Rectangles", "difficulty": "Medium", "content": "Given an `m x n` integer matrix `grid` where each entry is only `0` or `1`, return _the number of **corner rectangles**_.\n\nA **corner rectangle** is four distinct `1`'s on the grid that forms an axis-aligned rectangle. Note that only the corners need to have the value `1`. Also, all four `1`'s used must be distinct.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,0,0,1,0\\],\\[0,0,1,0,1\\],\\[0,0,0,1,0\\],\\[1,0,1,0,1\\]\\]\n**Output:** 1\n**Explanation:** There is only one corner rectangle, with corners grid\\[1\\]\\[2\\], grid\\[1\\]\\[4\\], grid\\[3\\]\\[2\\], grid\\[3\\]\\[4\\].\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\]\n**Output:** 9\n**Explanation:** There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1,1\\]\\]\n**Output:** 0\n**Explanation:** Rectangles must have four distinct corners.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `grid[i][j]` is either `0` or `1`.\n*   The number of `1`'s in the grid is in the range `[1, 6000]`.", "java": "\n    ```java\npublic int countCornerRectangles(int[][] grid) {\n    int count = 0;\n    int m = grid.length;\n    int n = grid[0].length;\n    \n    for (int i = 0; i < m - 1; i++) {\n        for (int j = 0; j < n - 1; j++) {\n            if (grid[i][j] == 1) {\n                for (int k = i + 1; k < m; k++) {\n                    for (int l = j + 1; l < n; l++) {\n                        if (grid[k][l] == 1 && grid[i][l] == 1 && grid[k][j] == 1) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through each element of the grid, starting from the top-left corner to the bottom-right corner. For each element with value 1, it checks for another 1 in the same row but at a later column (forming a top corner of the rectangle) and another 1 in the same column but at a later row (forming a left corner of the rectangle). Then, it checks if the intersection point of these two corners (the bottom-right corner of the rectangle) is also 1. If all these conditions are met, it means a corner rectangle is formed, and the count is incremented. The final result is returned after iterating through all possible combinations.\n\nTime complexity: O(m^2 * n^2), where m and n are the dimensions of the grid\nSpace complexity: O(1)\n    ", "c++": "\n    ```cpp\nint countCornerRectangles(vector<vector<int>>& grid) {\n    int count = 0;\n    int m = grid.size();\n    int n = grid[0].size();\n    \n    for (int i = 0; i < m - 1; i++) {\n        for (int j = 0; j < n - 1; j++) {\n            if (grid[i][j] == 1) {\n                for (int k = i + 1; k < m; k++) {\n                    for (int l = j + 1; l < n; l++) {\n                        if (grid[k][l] == 1 && grid[i][l] == 1 && grid[k][j] == 1) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through each element of the grid, starting from the top-left corner to the bottom-right corner. For each element with value 1, it checks for another 1 in the same row but at a later column (forming a top corner of the rectangle) and another 1 in the same column but at a later row (forming a left corner of the rectangle). Then, it checks if the intersection point of these two corners (the bottom-right corner of the rectangle) is also 1. If all these conditions are met, it means a corner rectangle is formed, and the count is incremented. The final result is returned after iterating through all possible combinations.\n\nTime complexity: O(m^2 * n^2), where m and n are the dimensions of the grid\nSpace complexity: O(1)\n    ", "python": "\n    ```python\ndef countCornerRectangles(grid):\n    count = 0\n    m = len(grid)\n    n = len(grid[0])\n    \n    for i in range(m - 1):\n        for j in range(n - 1):\n            if grid[i][j] == 1:\n                for k in range(i + 1, m):\n                    for l in range(j + 1, n):\n                        if grid[k][l] == 1 and grid[i][l] == 1 and grid[k][j] == 1:\n                            count += 1\n    return count\n```\n    \n    The algorithm iterates through each element of the grid, starting from the top-left corner to the bottom-right corner. For each element with value 1, it checks for another 1 in the same row but at a later column (forming a top corner of the rectangle) and another 1 in the same column but at a later row (forming a left corner of the rectangle). Then, it checks if the intersection point of these two corners (the bottom-right corner of the rectangle) is also 1. If all these conditions are met, it means a corner rectangle is formed, and the count is incremented. The final result is returned after iterating through all possible combinations.\n\nTime complexity: O(m^2 * n^2), where m and n are the dimensions of the grid\nSpace complexity: O(1)\n    ", "javascript": "\n    ```javascript\nfunction countCornerRectangles(grid) {\n    let count = 0;\n    let m = grid.length;\n    let n = grid[0].length;\n    \n    for (let i = 0; i < m - 1; i++) {\n        for (let j = 0; j < n - 1; j++) {\n            if (grid[i][j] === 1) {\n                for (let k = i + 1; k < m; k++) {\n                    for (let l = j + 1; l < n; l++) {\n                        if (grid[k][l] === 1 && grid[i][l] === 1 && grid[k][j] === 1) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through each element of the grid, starting from the top-left corner to the bottom-right corner. For each element with value 1, it checks for another 1 in the same row but at a later column (forming a top corner of the rectangle) and another 1 in the same column but at a later row (forming a left corner of the rectangle). Then, it checks if the intersection point of these two corners (the bottom-right corner of the rectangle) is also 1. If all these conditions are met, it means a corner rectangle is formed, and the count is incremented. The final result is returned after iterating through all possible combinations.\n\nTime complexity: O(m^2 * n^2), where m and n are the dimensions of the grid\nSpace complexity: O(1)\n    "}
{"id": 764, "slug": "largest-plus-sign", "title": "Largest Plus Sign", "difficulty": "Medium", "content": "You are given an integer `n`. You have an `n x n` binary grid `grid` with all values initially `1`'s except for some indices given in the array `mines`. The `ith` element of the array `mines` is defined as `mines[i] = [xi, yi]` where `grid[xi][yi] == 0`.\n\nReturn _the order of the largest **axis-aligned** plus sign of_ 1_'s contained in_ `grid`. If there is none, return `0`.\n\nAn **axis-aligned plus sign** of `1`'s of order `k` has some center `grid[r][c] == 1` along with four arms of length `k - 1` going up, down, left, and right, and made of `1`'s. Note that there could be `0`'s or `1`'s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for `1`'s.\n\n**Example 1:**\n\n**Input:** n = 5, mines = \\[\\[4,2\\]\\]\n**Output:** 2\n**Explanation:** In the above grid, the largest plus sign can only be of order 2. One of them is shown.\n\n**Example 2:**\n\n**Input:** n = 1, mines = \\[\\[0,0\\]\\]\n**Output:** 0\n**Explanation:** There is no plus sign, so return 0.\n\n**Constraints:**\n\n*   `1 <= n <= 500`\n*   `1 <= mines.length <= 5000`\n*   `0 <= xi, yi < n`\n*   All the pairs `(xi, yi)` are **unique**.", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val,List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n}\n\npublic List<List<Integer>> levelOrder(Node root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<Node> toVisit = new LinkedList<>();\n    toVisit.offer(root);\n\n    while (!toVisit.isEmpty()) {\n        int size = toVisit.size();\n        List<Integer> level = new ArrayList<>();\n\n        for (int i = 0; i < size; i++) {\n            Node currentNode = toVisit.poll();\n            level.add(currentNode.val);\n\n            for (Node child : currentNode.children) {\n                toVisit.offer(child);\n            }\n        }\n        result.add(level);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a Breadth-First Search (BFS) traversal approach to traverse the n-ary tree level-by-level. A queue is used to keep track of nodes to visit at each level. The process starts by adding the root node to the queue. Then, while the queue is not empty, it continues to process nodes from the queue. For each node, we remove it from the queue, add its value to the current level, and add its children to the queue. This process continues for all nodes at the current level, and then the level is added to the result list. The algorithm continues until there are no more nodes in the queue.\n\nIn each language, the function first initializes an empty result list and a queue, adds the root node to the queue (if it is not null), and then traverses the tree using the BFS method described, adding the values of the nodes to the result list as it goes.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nusing std::vector;\nusing std::queue;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n\nvector<vector<int>> levelOrder(Node* root) {\n    vector<vector<int>> result;\n    if (root == nullptr) return result;\n\n    queue<Node*> toVisit;\n    toVisit.push(root);\n\n    while (!toVisit.empty()) {\n        int size = toVisit.size();\n        vector<int> level;\n\n        for (int i = 0; i < size; i++) {\n            Node* currentNode = toVisit.front();\n            toVisit.pop();\n            level.push_back(currentNode->val);\n\n            for (Node* child : currentNode->children) {\n                toVisit.push(child);\n            }\n        }\n        result.push_back(level);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a Breadth-First Search (BFS) traversal approach to traverse the n-ary tree level-by-level. A queue is used to keep track of nodes to visit at each level. The process starts by adding the root node to the queue. Then, while the queue is not empty, it continues to process nodes from the queue. For each node, we remove it from the queue, add its value to the current level, and add its children to the queue. This process continues for all nodes at the current level, and then the level is added to the result list. The algorithm continues until there are no more nodes in the queue.\n\nIn each language, the function first initializes an empty result list and a queue, adds the root node to the queue (if it is not null), and then traverses the tree using the BFS method described, adding the values of the nodes to the result list as it goes.\n    ", "python": "\n    ```python\nfrom collections import deque\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef levelOrder(root):\n    result = []\n\n    if not root:\n        return result\n\n    toVisit = deque([root])\n\n    while toVisit:\n        size = len(toVisit)\n        level = []\n\n        for _ in range(size):\n            currentNode = toVisit.popleft()\n            level.append(currentNode.val)\n\n            for child in currentNode.children:\n                toVisit.append(child)\n\n        result.append(level)\n\n    return result\n```\n    \n    The algorithm uses a Breadth-First Search (BFS) traversal approach to traverse the n-ary tree level-by-level. A queue is used to keep track of nodes to visit at each level. The process starts by adding the root node to the queue. Then, while the queue is not empty, it continues to process nodes from the queue. For each node, we remove it from the queue, add its value to the current level, and add its children to the queue. This process continues for all nodes at the current level, and then the level is added to the result list. The algorithm continues until there are no more nodes in the queue.\n\nIn each language, the function first initializes an empty result list and a queue, adds the root node to the queue (if it is not null), and then traverses the tree using the BFS method described, adding the values of the nodes to the result list as it goes.\n    ", "javascript": "\n    ```javascript\nclass Node {\n    constructor(val, children) {\n        this.val = val;\n        this.children = children;\n    }\n}\n\nfunction levelOrder(root) {\n    const result = [];\n    if (!root) return result;\n\n    const toVisit = [root];\n\n    while (toVisit.length > 0) {\n        const size = toVisit.length;\n        const level = [];\n\n        for (let i = 0; i < size; i++) {\n            const currentNode = toVisit.shift();\n            level.push(currentNode.val);\n\n            for (const child of currentNode.children) {\n                toVisit.push(child);\n            }\n        }\n        result.push(level);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a Breadth-First Search (BFS) traversal approach to traverse the n-ary tree level-by-level. A queue is used to keep track of nodes to visit at each level. The process starts by adding the root node to the queue. Then, while the queue is not empty, it continues to process nodes from the queue. For each node, we remove it from the queue, add its value to the current level, and add its children to the queue. This process continues for all nodes at the current level, and then the level is added to the result list. The algorithm continues until there are no more nodes in the queue.\n\nIn each language, the function first initializes an empty result list and a queue, adds the root node to the queue (if it is not null), and then traverses the tree using the BFS method described, adding the values of the nodes to the result list as it goes.\n    "}
{"id": 787, "slug": "cheapest-flights-within-k-stops", "title": "Cheapest Flights Within K Stops", "difficulty": "Medium", "content": "There are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there is a flight from city `fromi` to city `toi` with cost `pricei`.\n\nYou are also given three integers `src`, `dst`, and `k`, return _**the cheapest price** from_ `src` _to_ `dst` _with at most_ `k` _stops._ If there is no such route, return `-1`.\n\n**Example 1:**\n\n**Input:** n = 4, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[2,0,100\\],\\[1,3,600\\],\\[2,3,200\\]\\], src = 0, dst = 3, k = 1\n**Output:** 700\n**Explanation:**\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities \\[0,1,2,3\\] is cheaper but is invalid because it uses 2 stops.\n\n**Example 2:**\n\n**Input:** n = 3, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[0,2,500\\]\\], src = 0, dst = 2, k = 1\n**Output:** 200\n**Explanation:**\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n\n**Example 3:**\n\n**Input:** n = 3, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[0,2,500\\]\\], src = 0, dst = 2, k = 0\n**Output:** 500\n**Explanation:**\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `0 <= flights.length <= (n * (n - 1) / 2)`\n*   `flights[i].length == 3`\n*   `0 <= fromi, toi < n`\n*   `fromi != toi`\n*   `1 <= pricei <= 104`\n*   There will not be any multiple flights between two cities.\n*   `0 <= src, dst, k < n`\n*   `src != dst`", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int slidingPuzzle(int[][] board) {\n        int m = 2, n = 3;\n        String target = \"123450\";\n        String start = \"\";\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                start += board[i][j];\n            }\n        }\n        int[][] dirs = {{1, 3}, {0, 2, 4}, {1, 5}, {0, 4}, {1, 3, 5}, {2, 4}};\n        Queue<String> q = new LinkedList<>(Arrays.asList(A));\n        int res = 0;\n        Set<String> visited = new HashSet<>(q);\n        while (!q.isEmpty()) {\n            for (int k = q.size(); k > 0; --k) {\n                String cur = q.poll();\n                if (cur.equals(target)) return res;\n                int zero_idx = cur.indexOf('0');\n                for (int dir : dirs[zero_idx]) {\n                    String neighbor = cur;\n                    neighbor = neighbor.substring(0, zero_idx) + neighbor.charAt(dir) + neighbor.substring(zero_idx + 1);\n                    neighbor = neighbor.substring(0, dir) + '0' + neighbor.substring(dir+1);\n                    if (!visited.contains(neighbor)) {\n                        visited.add(neighbor);\n                        q.add(neighbor);\n                    }\n                }\n            }\n            ++res;\n        }\n        return -1;\n    }\n}\n```\n    \n    The algorithm can be explained as follows:\n\n1. Convert the board 2D array into a string.\n2. Initialize the target state, the visiting queue starting from the given board state, and a set containing visited states.\n3. Create a directions array that represents the possible moves of the \"0\" tile for each of its positions.\n4. Iterate through the visiting queue until it is empty, incrementing the move counter with each iteration.\n5. For each visiting state, find the index of the \"0\" tile.\n6. For each possible move of the \"0\" tile from its current index, swap it with the adjacent tile given by the directions array.\n7. Check if the new state is the target state. If it is, return the current move counter value.\n8. Otherwise, if the new state has not been visited, mark it as visited and add it to the visiting queue.\n9. When the visiting queue is empty, if there was no target state found, return -1 as solving the puzzle is impossible.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nint slidingPuzzle(vector<vector<int>>& board) {\n    int m = 2, n = 3;\n    string target = \"123450\";\n    string start = \"\";\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            start += to_string(board[i][j]);\n    vector<vector<int>> dirs{{1, 3}, {0, 2, 4}, {1, 5}, {0, 4}, {1, 3, 5}, {2, 4}};\n    queue<string> q{{start}};\n    int res = 0;\n    unordered_set<string> visited{start};\n    while (!q.empty()) {\n        for (int k = q.size(); k > 0; --k) {\n            string cur = q.front(); q.pop();\n            if (cur == target) return res;\n            int zero_idx = cur.find(\"0\");\n            for (int dir : dirs[zero_idx]) {\n                string neighbor = cur;\n                swap(neighbor[zero_idx], neighbor[dir]);\n                if (!visited.count(neighbor)) {\n                    visited.insert(neighbor);\n                    q.push(neighbor);\n                }\n            }\n        }\n        ++res;\n    }\n    return -1;\n}\n```\n    \n    The algorithm can be explained as follows:\n\n1. Convert the board 2D array into a string.\n2. Initialize the target state, the visiting queue starting from the given board state, and a set containing visited states.\n3. Create a directions array that represents the possible moves of the \"0\" tile for each of its positions.\n4. Iterate through the visiting queue until it is empty, incrementing the move counter with each iteration.\n5. For each visiting state, find the index of the \"0\" tile.\n6. For each possible move of the \"0\" tile from its current index, swap it with the adjacent tile given by the directions array.\n7. Check if the new state is the target state. If it is, return the current move counter value.\n8. Otherwise, if the new state has not been visited, mark it as visited and add it to the visiting queue.\n9. When the visiting queue is empty, if there was no target state found, return -1 as solving the puzzle is impossible.\n    ", "python": "\n    ```python\nfrom collections import deque\n\ndef slidingPuzzle(board):\n    m, n = 2, 3\n    target = \"123450\"\n    start = \"\".join(str(num) for row in board for num in row)\n    dirs = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]]\n    q = deque([start])\n    res = 0\n    visited = {start}\n    while q:\n        for _ in range(len(q)):\n            cur = q.popleft()\n            if cur == target:\n                return res\n            zero_idx = cur.index(\"0\")\n            for dir in dirs[zero_idx]:\n                neighbor = list(cur)\n                neighbor[zero_idx], neighbor[dir] = neighbor[dir], neighbor[zero_idx]\n                neighbor = \"\".join(neighbor)\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    q.append(neighbor)\n        res += 1\n    return -1\n```\n    \n    The algorithm can be explained as follows:\n\n1. Convert the board 2D array into a string.\n2. Initialize the target state, the visiting queue starting from the given board state, and a set containing visited states.\n3. Create a directions array that represents the possible moves of the \"0\" tile for each of its positions.\n4. Iterate through the visiting queue until it is empty, incrementing the move counter with each iteration.\n5. For each visiting state, find the index of the \"0\" tile.\n6. For each possible move of the \"0\" tile from its current index, swap it with the adjacent tile given by the directions array.\n7. Check if the new state is the target state. If it is, return the current move counter value.\n8. Otherwise, if the new state has not been visited, mark it as visited and add it to the visiting queue.\n9. When the visiting queue is empty, if there was no target state found, return -1 as solving the puzzle is impossible.\n    ", "javascript": "\n    ```javascript\nfunction slidingPuzzle(board) {\n    const m = 2, n = 3;\n    const target = \"123450\";\n    let start = \"\";\n    for (const row of board) {\n        for (const num of row) {\n            start += num;\n        }\n    }\n    const dirs = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]];\n    const q = [start];\n    let res = 0;\n    const visited = new Set(q);\n    while (q.length > 0) {\n        for (let k = q.length; k > 0; --k) {\n            const cur = q.shift();\n            if (cur === target) return res;\n            const zero_idx = cur.indexOf('0');\n            for (const dir of dirs[zero_idx]) {\n                let neighbor = cur.slice(0, zero_idx) + cur[dir] + cur.slice(zero_idx + 1);\n                neighbor = neighbor.slice(0, dir) + '0' + neighbor.slice(dir + 1);\n                if (!visited.has(neighbor)) {\n                    visited.add(neighbor);\n                    q.push(neighbor);\n                }\n            }\n        }\n        ++res;\n    }\n    return -1;\n}\n```\n    \n    The algorithm can be explained as follows:\n\n1. Convert the board 2D array into a string.\n2. Initialize the target state, the visiting queue starting from the given board state, and a set containing visited states.\n3. Create a directions array that represents the possible moves of the \"0\" tile for each of its positions.\n4. Iterate through the visiting queue until it is empty, incrementing the move counter with each iteration.\n5. For each visiting state, find the index of the \"0\" tile.\n6. For each possible move of the \"0\" tile from its current index, swap it with the adjacent tile given by the directions array.\n7. Check if the new state is the target state. If it is, return the current move counter value.\n8. Otherwise, if the new state has not been visited, mark it as visited and add it to the visiting queue.\n9. When the visiting queue is empty, if there was no target state found, return -1 as solving the puzzle is impossible.\n    "}
{"id": 790, "slug": "domino-and-tromino-tiling", "title": "Domino and Tromino Tiling", "difficulty": "Medium", "content": "You have two types of tiles: a `2 x 1` domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return _the number of ways to tile an_ `2 x n` _board_. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 5\n**Explanation:** The five different ways are show above.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 1000`", "java": "\n    ```java\npublic boolean isIdealPermutation(int[] nums) {\n    for (int i = 0; i < nums.length; ++i) {\n        if (Math.abs(nums[i] - i) > 1) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n    \n    For the given question, we need to check if the number of global inversions is equal to the number of local inversions in the permutation. To do that, we can check if the absolute difference between the number at each index (`nums[i]`) and the index itself (`i`) is greater than 1. If it is, then it means the number of global inversions is not equal to the number of local inversions, and we can return false. If the loop completes without finding such a difference, we return true, which means the number of global inversions is equal to the number of local inversions.\n    ", "c++": "\n    ```cpp\nbool isIdealPermutation(vector<int>& nums) {\n    for (int i = 0; i < nums.size(); ++i) {\n        if (abs(nums[i] - i) > 1) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n    \n    For the given question, we need to check if the number of global inversions is equal to the number of local inversions in the permutation. To do that, we can check if the absolute difference between the number at each index (`nums[i]`) and the index itself (`i`) is greater than 1. If it is, then it means the number of global inversions is not equal to the number of local inversions, and we can return false. If the loop completes without finding such a difference, we return true, which means the number of global inversions is equal to the number of local inversions.\n    ", "python": "\n    ```python\ndef is_ideal_permutation(nums):\n    for i, num in enumerate(nums):\n        if abs(num - i) > 1:\n            return False\n    return True\n```\n\n    \n    For the given question, we need to check if the number of global inversions is equal to the number of local inversions in the permutation. To do that, we can check if the absolute difference between the number at each index (`nums[i]`) and the index itself (`i`) is greater than 1. If it is, then it means the number of global inversions is not equal to the number of local inversions, and we can return false. If the loop completes without finding such a difference, we return true, which means the number of global inversions is equal to the number of local inversions.\n    ", "javascript": "\n    ```javascript\nfunction isIdealPermutation(nums) {\n    for (let i = 0; i < nums.length; ++i) {\n        if (Math.abs(nums[i] - i) > 1) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n    \n    For the given question, we need to check if the number of global inversions is equal to the number of local inversions in the permutation. To do that, we can check if the absolute difference between the number at each index (`nums[i]`) and the index itself (`i`) is greater than 1. If it is, then it means the number of global inversions is not equal to the number of local inversions, and we can return false. If the loop completes without finding such a difference, we return true, which means the number of global inversions is equal to the number of local inversions.\n    "}
{"id": 792, "slug": "number-of-matching-subsequences", "title": "Number of Matching Subsequences", "difficulty": "Medium", "content": "Given a string `s` and an array of strings `words`, return _the number of_ `words[i]` _that is a subsequence of_ `s`.\n\nA **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n*   For example, `\"ace \"` is a subsequence of `\"abcde \"`.\n\n**Example 1:**\n\n**Input:** s =  \"abcde \", words = \\[ \"a \", \"bb \", \"acd \", \"ace \"\\]\n**Output:** 3\n**Explanation:** There are three strings in words that are a subsequence of s:  \"a \",  \"acd \",  \"ace \".\n\n**Example 2:**\n\n**Input:** s =  \"dsahjpjauf \", words = \\[ \"ahjpjau \", \"ja \", \"ahbwzgqnuk \", \"tnmlanowax \"\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `1 <= words.length <= 5000`\n*   `1 <= words[i].length <= 50`\n*   `s` and `words[i]` consist of only lowercase English letters.", "java": "\n    ```java\npublic int search(int[] nums, int target) {\n    int left = 0;\n    int right = nums.length - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return -1;\n}\n```\n\n    \n    The algorithm used in all four implementations is a Binary Search, which has a runtime complexity of O(log n). The binary search algorithm essentially divides the given sorted array in half with every iteration until the target value is found or the boundaries collapse.\n\n1. Set left and right boundaries to the first and last indices of the nums array.\n2. While the left boundary is less than or equal to the right boundary, perform the following steps:\n   1. Calculate the mid index by taking the average of the left and right boundaries (making sure to account for integer division in Python).\n   2. If the mid element matches the target, return the mid index.\n   3. If the mid element is less than the target, update the left boundary to mid + 1.\n   4. If the mid element is greater than the target, update the right boundary to mid - 1.\n3. If the while loop ends and the target is not found, return -1.\n    ", "c++": "\n    ```cpp\nint search(vector<int>& nums, int target) {\n    int left = 0;\n    int right = nums.size() - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return -1;\n}\n```\n\n    \n    The algorithm used in all four implementations is a Binary Search, which has a runtime complexity of O(log n). The binary search algorithm essentially divides the given sorted array in half with every iteration until the target value is found or the boundaries collapse.\n\n1. Set left and right boundaries to the first and last indices of the nums array.\n2. While the left boundary is less than or equal to the right boundary, perform the following steps:\n   1. Calculate the mid index by taking the average of the left and right boundaries (making sure to account for integer division in Python).\n   2. If the mid element matches the target, return the mid index.\n   3. If the mid element is less than the target, update the left boundary to mid + 1.\n   4. If the mid element is greater than the target, update the right boundary to mid - 1.\n3. If the while loop ends and the target is not found, return -1.\n    ", "python": "\n    ```python\ndef search(nums, target):\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n```\n\n    \n    The algorithm used in all four implementations is a Binary Search, which has a runtime complexity of O(log n). The binary search algorithm essentially divides the given sorted array in half with every iteration until the target value is found or the boundaries collapse.\n\n1. Set left and right boundaries to the first and last indices of the nums array.\n2. While the left boundary is less than or equal to the right boundary, perform the following steps:\n   1. Calculate the mid index by taking the average of the left and right boundaries (making sure to account for integer division in Python).\n   2. If the mid element matches the target, return the mid index.\n   3. If the mid element is less than the target, update the left boundary to mid + 1.\n   4. If the mid element is greater than the target, update the right boundary to mid - 1.\n3. If the while loop ends and the target is not found, return -1.\n    ", "javascript": "\n    ```javascript\nfunction search(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n\n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return -1;\n}\n```\n\n    \n    The algorithm used in all four implementations is a Binary Search, which has a runtime complexity of O(log n). The binary search algorithm essentially divides the given sorted array in half with every iteration until the target value is found or the boundaries collapse.\n\n1. Set left and right boundaries to the first and last indices of the nums array.\n2. While the left boundary is less than or equal to the right boundary, perform the following steps:\n   1. Calculate the mid index by taking the average of the left and right boundaries (making sure to account for integer division in Python).\n   2. If the mid element matches the target, return the mid index.\n   3. If the mid element is less than the target, update the left boundary to mid + 1.\n   4. If the mid element is greater than the target, update the right boundary to mid - 1.\n3. If the while loop ends and the target is not found, return -1.\n    "}
{"id": 799, "slug": "champagne-tower", "title": "Champagne Tower", "difficulty": "Medium", "content": "We stack glasses in a pyramid, where the **first** row has `1` glass, the **second** row has `2` glasses, and so on until the 100th row. Each glass holds one cup of champagne.\n\nThen, some champagne is poured into the first glass at the top. When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it. When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on. (A glass at the bottom row has its excess champagne fall on the floor.)\n\nFor example, after one cup of champagne is poured, the top most glass is full. After two cups of champagne are poured, the two glasses on the second row are half full. After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now. After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.\n\nNow after pouring some non-negative integer cups of champagne, return how full the `jth` glass in the `ith` row is (both `i` and `j` are 0-indexed.)\n\n**Example 1:**\n\n**Input:** poured = 1, query\\_row = 1, query\\_glass = 1\n**Output:** 0.00000\n**Explanation:** We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.\n\n**Example 2:**\n\n**Input:** poured = 2, query\\_row = 1, query\\_glass = 1\n**Output:** 0.50000\n**Explanation:** We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.\n\n**Example 3:**\n\n**Input:** poured = 100000009, query\\_row = 33, query\\_glass = 17\n**Output:** 1.00000\n\n**Constraints:**\n\n*   `0 <= poured <= 109`\n*   `0 <= query_glass <= query_row < 100`", "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    Integer minDiff = Integer.MAX_VALUE;\n    TreeNode prev = null;\n\n    public int minDiffInBST(TreeNode root) {\n        inOrderTraversal(root);\n        return minDiff;\n    }\n\n    private void inOrderTraversal(TreeNode node) {\n        if (node == null) return;\n        inOrderTraversal(node.left);\n        if (prev != null) {\n            minDiff = Math.min(minDiff, node.val - prev.val);\n        }\n        prev = node;\n        inOrderTraversal(node.right);\n    }\n}\n```\n\n    \n    The key to solving this problem is to realize that an inorder traversal of a Binary Search Tree would give a sorted list of values. We can perform an inorder traversal of the BST, updating the minimum difference as we traverse. We only need to consider adjacent nodes in-order, so we just need a `prev` variable to track the previous node visited. This way, we'll have an O(n) time and O(1) space complexity.\n    ", "c++": "\n    ```cpp\n#include <limits>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nclass Solution {\n    int minDiff = std::numeric_limits<int>::max();\n    TreeNode* prev = nullptr;\n\npublic:\n    int minDiffInBST(TreeNode* root) {\n        inOrderTraversal(root);\n        return minDiff;\n    }\n\n    void inOrderTraversal(TreeNode *node) {\n        if (!node) return;\n        inOrderTraversal(node->left);\n        if (prev) {\n            minDiff = std::min(minDiff, node->val - prev->val);\n        }\n        prev = node;\n        inOrderTraversal(node->right);\n    }\n};\n```\n\n    \n    The key to solving this problem is to realize that an inorder traversal of a Binary Search Tree would give a sorted list of values. We can perform an inorder traversal of the BST, updating the minimum difference as we traverse. We only need to consider adjacent nodes in-order, so we just need a `prev` variable to track the previous node visited. This way, we'll have an O(n) time and O(1) space complexity.\n    ", "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def __init__(self):\n        self.min_diff = float(\"inf\")\n        self.prev = None\n\n    def minDiffInBST(self, root: TreeNode) -> int:\n        self.in_order_traversal(root)\n        return self.min_diff\n\n    def in_order_traversal(self, node: TreeNode) -> None:\n        if not node: return\n        self.in_order_traversal(node.left)\n        if self.prev:\n            self.min_diff = min(self.min_diff, node.val - self.prev.val)\n        self.prev = node\n        self.in_order_traversal(node.right)\n```\n\n    \n    The key to solving this problem is to realize that an inorder traversal of a Binary Search Tree would give a sorted list of values. We can perform an inorder traversal of the BST, updating the minimum difference as we traverse. We only need to consider adjacent nodes in-order, so we just need a `prev` variable to track the previous node visited. This way, we'll have an O(n) time and O(1) space complexity.\n    ", "javascript": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    constructor() {\n        this.minDiff = Infinity;\n        this.prev = null;\n    }\n\n    minDiffInBST(root) {\n        this.inOrderTraversal(root);\n        return this.minDiff;\n    }\n\n    inOrderTraversal(node) {\n        if (!node) return;\n        this.inOrderTraversal(node.left);\n        if (this.prev) {\n            this.minDiff = Math.min(this.minDiff, node.val - this.prev.val);\n        }\n        this.prev = node;\n        this.inOrderTraversal(node.right);\n    }\n}\n```\n\n    \n    The key to solving this problem is to realize that an inorder traversal of a Binary Search Tree would give a sorted list of values. We can perform an inorder traversal of the BST, updating the minimum difference as we traverse. We only need to consider adjacent nodes in-order, so we just need a `prev` variable to track the previous node visited. This way, we'll have an O(n) time and O(1) space complexity.\n    "}
{"id": 801, "slug": "minimum-swaps-to-make-sequences-increasing", "title": "Minimum Swaps To Make Sequences Increasing", "difficulty": "Hard", "content": "You are given two integer arrays of the same length `nums1` and `nums2`. In one operation, you are allowed to swap `nums1[i]` with `nums2[i]`.\n\n*   For example, if `nums1 = [1,2,3,8]`, and `nums2 = [5,6,7,4]`, you can swap the element at `i = 3` to obtain `nums1 = [1,2,3,4]` and `nums2 = [5,6,7,8]`.\n\nReturn _the minimum number of needed operations to make_ `nums1` _and_ `nums2` _**strictly increasing**_. The test cases are generated so that the given input always makes it possible.\n\nAn array `arr` is **strictly increasing** if and only if `arr[0] < arr[1] < arr[2] < ... < arr[arr.length - 1]`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,3,5,4\\], nums2 = \\[1,2,3,7\\]\n**Output:** 1\n**Explanation:** \nSwap nums1\\[3\\] and nums2\\[3\\]. Then the sequences are:\nnums1 = \\[1, 3, 5, 7\\] and nums2 = \\[1, 2, 3, 4\\]\nwhich are both strictly increasing.\n\n**Example 2:**\n\n**Input:** nums1 = \\[0,3,5,8,9\\], nums2 = \\[2,1,4,6,9\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `2 <= nums1.length <= 105`\n*   `nums2.length == nums1.length`\n*   `0 <= nums1[i], nums2[i] <= 2 * 105`", "java": "\n    ```java\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic boolean isBipartite(int[][] graph) {\n    int[] colors = new int[graph.length];\n    for(int i = 0; i < graph.length; i++){\n        if(colors[i] != 0) continue;\n        colors[i] = 1;\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(i);\n        while(!queue.isEmpty()){\n            int node = queue.poll();\n            for(int neighbor : graph[node]){\n                if(colors[neighbor] == 0){\n                    colors[neighbor] = -colors[node];\n                    queue.offer(neighbor);\n                } else if(colors[neighbor] == colors[node]){\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    We can approach this problem as graph traversal. First, we initialize a colors array of size n, filling it with 0. We can think of 0 as \"not visited\" and use 1 and -1 as the two different colors for the nodes.\n\nFor each uncolored node, we assign color 1 to it and put it into a queue. Then, we use Breadth First Search (BFS) by dequeuing a node, checking its neighbors, and performing the following - if a neighbor is uncolored (0), assign it the opposite color of the current node and enqueue it. If the neighbor's color is the same as the current node, return false, as the graph is not bipartite. Repeat this process until the queue is empty. If the loop ends without finding conflict, return true, since the graph is bipartite.\n\nThis algorithm works because a bipartite graph can be colored in such a way that no adjacent nodes have the same color. Using BFS ensures that we check all connected components of the graph (as there can be several disjoint subsets in the graph).\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nbool isBipartite(std::vector<std::vector<int>>& graph) {\n    std::vector<int> colors(graph.size(), 0);\n    for(int i = 0; i < graph.size(); i++){\n        if(colors[i] != 0) continue;\n        colors[i] = 1;\n        std::queue<int> q;\n        q.push(i);\n        while(!q.empty()){\n            int node = q.front(); q.pop();\n            for(int neighbor : graph[node]){\n                if(colors[neighbor] == 0){\n                    colors[neighbor] = -colors[node];\n                    q.push(neighbor);\n                } else if(colors[neighbor] == colors[node]){\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    We can approach this problem as graph traversal. First, we initialize a colors array of size n, filling it with 0. We can think of 0 as \"not visited\" and use 1 and -1 as the two different colors for the nodes.\n\nFor each uncolored node, we assign color 1 to it and put it into a queue. Then, we use Breadth First Search (BFS) by dequeuing a node, checking its neighbors, and performing the following - if a neighbor is uncolored (0), assign it the opposite color of the current node and enqueue it. If the neighbor's color is the same as the current node, return false, as the graph is not bipartite. Repeat this process until the queue is empty. If the loop ends without finding conflict, return true, since the graph is bipartite.\n\nThis algorithm works because a bipartite graph can be colored in such a way that no adjacent nodes have the same color. Using BFS ensures that we check all connected components of the graph (as there can be several disjoint subsets in the graph).\n    ", "python": "\n    ```python\nfrom collections import deque\n\ndef isBipartite(graph):\n    colors = [0] * len(graph)\n    for i in range(len(graph)):\n        if colors[i] != 0:\n            continue\n        colors[i] = 1\n        queue = deque([i])\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if colors[neighbor] == 0:\n                    colors[neighbor] = -colors[node]\n                    queue.append(neighbor)\n                elif colors[neighbor] == colors[node]:\n                    return False\n    return True\n```\n\n    \n    We can approach this problem as graph traversal. First, we initialize a colors array of size n, filling it with 0. We can think of 0 as \"not visited\" and use 1 and -1 as the two different colors for the nodes.\n\nFor each uncolored node, we assign color 1 to it and put it into a queue. Then, we use Breadth First Search (BFS) by dequeuing a node, checking its neighbors, and performing the following - if a neighbor is uncolored (0), assign it the opposite color of the current node and enqueue it. If the neighbor's color is the same as the current node, return false, as the graph is not bipartite. Repeat this process until the queue is empty. If the loop ends without finding conflict, return true, since the graph is bipartite.\n\nThis algorithm works because a bipartite graph can be colored in such a way that no adjacent nodes have the same color. Using BFS ensures that we check all connected components of the graph (as there can be several disjoint subsets in the graph).\n    ", "javascript": "\n    ```javascript\nfunction isBipartite(graph) {\n    const colors = new Array(graph.length).fill(0);\n    for(let i = 0; i < graph.length; i++){\n        if(colors[i] !== 0) continue;\n        colors[i] = 1;\n        const queue = [i];\n        while(queue.length){\n            const node = queue.shift();\n            for(const neighbor of graph[node]){\n                if(colors[neighbor] === 0){\n                    colors[neighbor] = -colors[node];\n                    queue.push(neighbor);\n                } else if(colors[neighbor] === colors[node]){\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    We can approach this problem as graph traversal. First, we initialize a colors array of size n, filling it with 0. We can think of 0 as \"not visited\" and use 1 and -1 as the two different colors for the nodes.\n\nFor each uncolored node, we assign color 1 to it and put it into a queue. Then, we use Breadth First Search (BFS) by dequeuing a node, checking its neighbors, and performing the following - if a neighbor is uncolored (0), assign it the opposite color of the current node and enqueue it. If the neighbor's color is the same as the current node, return false, as the graph is not bipartite. Repeat this process until the queue is empty. If the loop ends without finding conflict, return true, since the graph is bipartite.\n\nThis algorithm works because a bipartite graph can be colored in such a way that no adjacent nodes have the same color. Using BFS ensures that we check all connected components of the graph (as there can be several disjoint subsets in the graph).\n    "}
{"id": 805, "slug": "split-array-with-same-average", "title": "Split Array With Same Average", "difficulty": "Hard", "content": "You are given an integer array `nums`.\n\nYou should move each element of `nums` into one of the two arrays `A` and `B` such that `A` and `B` are non-empty, and `average(A) == average(B)`.\n\nReturn `true` if it is possible to achieve that and `false` otherwise.\n\n**Note** that for an array `arr`, `average(arr)` is the sum of all the elements of `arr` over the length of `arr`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7,8\\]\n**Output:** true\n**Explanation:** We can split the array into \\[1,4,5,8\\] and \\[2,3,6,7\\], and both of them have an average of 4.5.\n\n**Example 2:**\n\n**Input:** nums = \\[3,1\\]\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= nums.length <= 30`\n*   `0 <= nums[i] <= 104`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic class Solution {\n    public boolean escapeGhosts(int[][] ghosts, int[] target) {\n        int maxDist = Math.abs(target[0]) + Math.abs(target[1]);\n        for (int[] ghost : ghosts) {\n            int ghostDist = Math.abs(ghost[0] - target[0]) + Math.abs(ghost[1] - target[1]);\n            if (ghostDist <= maxDist) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n    \n    The PAC-MAN's shortest path to the target is moving diagonally, so it takes |xtarget| + |ytarget| steps to reach the target. The algorithm calculates this optimal distance to the target and checks whether it is smaller than the distance from every ghost to the target. If the PAC-MAN can reach the target with fewer moves than any ghost, it is possible to escape. Otherwise, if any ghost is closer to the target than PAC-MAN, it is impossible to reach the target before being caught.\n\nThe algorithm is based on the Manhattan distance, which calculates the sum of the absolute differences of the coordinates. Using Manhattan distance ensures that we are only considering the minimum number of moves required to reach the target, disregarding any possible extra moves taken during the game.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nbool escapeGhosts(std::vector<std::vector<int>>& ghosts, std::vector<int>& target) {\n    int max_dist = std::abs(target[0]) + std::abs(target[1]);\n    for (const auto& ghost : ghosts) {\n        int ghost_dist = std::abs(ghost[0] - target[0]) + std::abs(ghost[1] - target[1]);\n        if (ghost_dist <= max_dist) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n    \n    The PAC-MAN's shortest path to the target is moving diagonally, so it takes |xtarget| + |ytarget| steps to reach the target. The algorithm calculates this optimal distance to the target and checks whether it is smaller than the distance from every ghost to the target. If the PAC-MAN can reach the target with fewer moves than any ghost, it is possible to escape. Otherwise, if any ghost is closer to the target than PAC-MAN, it is impossible to reach the target before being caught.\n\nThe algorithm is based on the Manhattan distance, which calculates the sum of the absolute differences of the coordinates. Using Manhattan distance ensures that we are only considering the minimum number of moves required to reach the target, disregarding any possible extra moves taken during the game.\n    ", "python": "\n    ```python\nfrom typing import List\n\ndef escape_ghosts(ghosts: List[List[int]], target: List[int]) -> bool:\n    max_dist = abs(target[0]) + abs(target[1])\n    for ghost in ghosts:\n        ghost_dist = abs(ghost[0] - target[0]) + abs(ghost[1] - target[1])\n        if ghost_dist <= max_dist:\n            return False\n    return True\n```\n\n    \n    The PAC-MAN's shortest path to the target is moving diagonally, so it takes |xtarget| + |ytarget| steps to reach the target. The algorithm calculates this optimal distance to the target and checks whether it is smaller than the distance from every ghost to the target. If the PAC-MAN can reach the target with fewer moves than any ghost, it is possible to escape. Otherwise, if any ghost is closer to the target than PAC-MAN, it is impossible to reach the target before being caught.\n\nThe algorithm is based on the Manhattan distance, which calculates the sum of the absolute differences of the coordinates. Using Manhattan distance ensures that we are only considering the minimum number of moves required to reach the target, disregarding any possible extra moves taken during the game.\n    ", "javascript": "\n    ```javascript\nfunction escapeGhosts(ghosts, target) {\n    let maxDist = Math.abs(target[0]) + Math.abs(target[1]);\n    for (let ghost of ghosts) {\n        let ghostDist = Math.abs(ghost[0] - target[0]) + Math.abs(ghost[1] - target[1]);\n        if (ghostDist <= maxDist) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n    \n    The PAC-MAN's shortest path to the target is moving diagonally, so it takes |xtarget| + |ytarget| steps to reach the target. The algorithm calculates this optimal distance to the target and checks whether it is smaller than the distance from every ghost to the target. If the PAC-MAN can reach the target with fewer moves than any ghost, it is possible to escape. Otherwise, if any ghost is closer to the target than PAC-MAN, it is impossible to reach the target before being caught.\n\nThe algorithm is based on the Manhattan distance, which calculates the sum of the absolute differences of the coordinates. Using Manhattan distance ensures that we are only considering the minimum number of moves required to reach the target, disregarding any possible extra moves taken during the game.\n    "}
{"id": 808, "slug": "soup-servings", "title": "Soup Servings", "difficulty": "Medium", "content": "There are two types of soup: **type A** and **type B**. Initially, we have `n` ml of each type of soup. There are four kinds of operations:\n\n1.  Serve `100` ml of **soup A** and `0` ml of **soup B**,\n2.  Serve `75` ml of **soup A** and `25` ml of **soup B**,\n3.  Serve `50` ml of **soup A** and `50` ml of **soup B**, and\n4.  Serve `25` ml of **soup A** and `75` ml of **soup B**.\n\nWhen we serve some soup, we give it to someone, and we no longer have it. Each turn, we will choose from the four operations with an equal probability `0.25`. If the remaining volume of soup is not enough to complete the operation, we will serve as much as possible. We stop once we no longer have some quantity of both types of soup.\n\n**Note** that we do not have an operation where all `100` ml's of **soup B** are used first.\n\nReturn _the probability that **soup A** will be empty first, plus half the probability that **A** and **B** become empty at the same time_. Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** n = 50\n**Output:** 0.62500\n**Explanation:** If we choose the first two operations, A will become empty first.\nFor the third operation, A and B will become empty at the same time.\nFor the fourth operation, B will become empty first.\nSo the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 \\* (1 + 1 + 0.5 + 0) = 0.625.\n\n**Example 2:**\n\n**Input:** n = 100\n**Output:** 0.71875\n\n**Constraints:**\n\n*   `0 <= n <= 109`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic int numMatchingSubseq(String s, String[] words) {\n    ArrayList<Integer>[] positions = new ArrayList[26];\n\n    for (int i = 0; i < s.length(); ++i) {\n        int index = s.charAt(i) - 'a';\n        if (positions[index] == null) {\n            positions[index] = new ArrayList<>();\n        }\n        positions[index].add(i);\n    }\n\n    int count = 0;\n\n    for (String word : words) {\n        int index = -1;\n        boolean isSubsequence = true;\n\n        for (char c : word.toCharArray()) {\n            var list = positions[c - 'a'];\n            if (list == null || list.size() == 0) {\n                isSubsequence = false;\n                break;\n            }\n            int pos = -1;\n            for (int num : list) {\n                if (num > index) {\n                    pos = num;\n                    break;\n                }\n            }\n            if (pos == -1) {\n                isSubsequence = false;\n                break;\n            } else {\n                list.remove((Integer) pos);\n                index = pos;\n            }\n        }\n\n        if (isSubsequence) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```\n    \n    For each character in string s, we save its position in an array (positions) which maps characters to their positions. Specifically, we use one array for each character ('a'-'z').\n\nNow for each word in words array, we traverse its characters one by one. We check if there is a position for each character greater than the last checked position. If we are successful in finding such positions for every character in the word, we increase the count.\n\nWe do this using the positions array, which has sorted positions of each character.\n\nWe use the 'upper_bound' function in C++ and 'bisect_left' function in Python to find the smallest number greater than a given number in a sorted list of numbers. In Java and JavaScript, we use a loop to search for the number manually.\n\nFinally, we return the count.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint numMatchingSubseq(const std::string& s, const std::vector<std::string>& words) {\n    std::vector<std::vector<int>> positions(26);\n\n    for (int i = 0; i < s.size(); ++i) {\n        positions[s[i] - 'a'].push_back(i);\n    }\n\n    int count = 0;\n\n    for (const auto& word : words) {\n        int index = -1;\n        bool isSubsequence = true;\n\n        for (const char& c : word) {\n            auto it = std::upper_bound(positions[c - 'a'].begin(), positions[c - 'a'].end(), index);\n            if (it == positions[c - 'a'].end()) {\n                isSubsequence = false;\n                break;\n            }\n            index = *it;\n        }\n\n        if (isSubsequence) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n```\n    \n    For each character in string s, we save its position in an array (positions) which maps characters to their positions. Specifically, we use one array for each character ('a'-'z').\n\nNow for each word in words array, we traverse its characters one by one. We check if there is a position for each character greater than the last checked position. If we are successful in finding such positions for every character in the word, we increase the count.\n\nWe do this using the positions array, which has sorted positions of each character.\n\nWe use the 'upper_bound' function in C++ and 'bisect_left' function in Python to find the smallest number greater than a given number in a sorted list of numbers. In Java and JavaScript, we use a loop to search for the number manually.\n\nFinally, we return the count.\n    ", "python": "\n    ```python\nfrom bisect import bisect_left\nfrom collections import defaultdict\n\ndef numMatchingSubseq(s, words):\n    positions = defaultdict(list)\n\n    for i, c in enumerate(s):\n        positions[c].append(i)\n\n    count = 0\n\n    for word in words:\n        index = -1\n        isSubsequence = True\n\n        for c in word:\n            position_list = positions.get(c, [])\n            i = bisect_left(position_list, index + 1)\n            if (i == len(position_list)):\n                isSubsequence = False\n                break\n            index = position_list[i]\n\n        if isSubsequence:\n            count += 1\n\n    return count\n```\n    \n    For each character in string s, we save its position in an array (positions) which maps characters to their positions. Specifically, we use one array for each character ('a'-'z').\n\nNow for each word in words array, we traverse its characters one by one. We check if there is a position for each character greater than the last checked position. If we are successful in finding such positions for every character in the word, we increase the count.\n\nWe do this using the positions array, which has sorted positions of each character.\n\nWe use the 'upper_bound' function in C++ and 'bisect_left' function in Python to find the smallest number greater than a given number in a sorted list of numbers. In Java and JavaScript, we use a loop to search for the number manually.\n\nFinally, we return the count.\n    ", "javascript": "\n    ```javascript\nfunction numMatchingSubseq(s, words) {\n    const positions = Array.from({ length: 26 }, () => []);\n\n    for (let i = 0; i < s.length; ++i) {\n        positions[s.charCodeAt(i) - 'a'.charCodeAt(0)].push(i);\n    }\n\n    let count = 0;\n\n    words.forEach(word => {\n        let index = -1;\n        let isSubsequence = true;\n\n        for (let i = 0; i < word.length; i++) {\n            const c = word.charCodeAt(i) - 'a'.charCodeAt(0);\n            const pos = positions[c].find(el => el > index);\n            if (pos === undefined) {\n                isSubsequence = false;\n                break;\n            }\n            index = pos;\n        }\n\n        if (isSubsequence) {\n            count++;\n        }\n    });\n\n    return count;\n}\n```\n    \n    For each character in string s, we save its position in an array (positions) which maps characters to their positions. Specifically, we use one array for each character ('a'-'z').\n\nNow for each word in words array, we traverse its characters one by one. We check if there is a position for each character greater than the last checked position. If we are successful in finding such positions for every character in the word, we increase the count.\n\nWe do this using the positions array, which has sorted positions of each character.\n\nWe use the 'upper_bound' function in C++ and 'bisect_left' function in Python to find the smallest number greater than a given number in a sorted list of numbers. In Java and JavaScript, we use a loop to search for the number manually.\n\nFinally, we return the count.\n    "}
{"id": 813, "slug": "largest-sum-of-averages", "title": "Largest Sum of Averages", "difficulty": "Medium", "content": "You are given an integer array `nums` and an integer `k`. You can partition the array into **at most** `k` non-empty adjacent subarrays. The **score** of a partition is the sum of the averages of each subarray.\n\nNote that the partition must use every integer in `nums`, and that the score is not necessarily an integer.\n\nReturn _the maximum **score** you can achieve of all the possible partitions_. Answers within `10-6` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** nums = \\[9,1,2,3,9\\], k = 3\n**Output:** 20.00000\n**Explanation:** \nThe best choice is to partition nums into \\[9\\], \\[1, 2, 3\\], \\[9\\]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.\nWe could have also partitioned nums into \\[9, 1\\], \\[2\\], \\[3, 9\\], for example.\nThat partition would lead to a score of 5 + 2 + 6 = 13, which is worse.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7\\], k = 4\n**Output:** 20.50000\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 104`\n*   `1 <= k <= nums.length`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> allPathsSourceTarget(int[][] graph) {\n    List<List<Integer>> result = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    DFS(graph, result, path, 0);\n    return result;\n}\n\nprivate void DFS(int[][] graph, List<List<Integer>> result, List<Integer> path, int currentNode) {\n    path.add(currentNode);\n    if (currentNode == graph.length - 1) {\n        result.add(new ArrayList<>(path));\n    } else {\n        for (int neighbor : graph[currentNode]) {\n            DFS(graph, result, path, neighbor);\n        }\n    }\n    path.remove(path.size() - 1);\n}\n```\n    \n    This algorithm uses a Depth First Search (DFS) approach to traverse through the directed acyclic graph. \n\n1. Create a recursive helper function called DFS, which takes the current node, path, graph, and result as parameters.\n2. Add the current node to the path list.\n3. Check if the current node is the target node (n-1).\n   - If yes, then add the path to the result list.\n4. If the current node is not the target, traverse through each of its neighbors by calling the DFS function recursively.\n5. Pop off the current node from the path to backtrack to the previous node.\n6. The main function calls the DFS function with node 0 as the starting point, and it returns the result list containing all possible paths.\n\nThe time complexity of this algorithm is O(2^N * N) as in the worst case, we will iterate through all the paths from the starting node to the target node. The space complexity is also O(2^N * N) because of the storage required for the result list.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvoid DFS(vector<vector<int>>& graph, vector<vector<int>>& result, vector<int>& path, int currentNode) {\n    path.push_back(currentNode);\n    if (currentNode == graph.size()-1) {\n        result.push_back(path);\n    } else {\n        for (int neighbor : graph[currentNode]) {\n            DFS(graph, result, path, neighbor);\n        }\n    }\n    path.pop_back();\n}\n\nvector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {\n    vector<vector<int>> result;\n    vector<int> path;\n    DFS(graph, result, path, 0);\n    return result;\n}\n```\n    \n    This algorithm uses a Depth First Search (DFS) approach to traverse through the directed acyclic graph. \n\n1. Create a recursive helper function called DFS, which takes the current node, path, graph, and result as parameters.\n2. Add the current node to the path list.\n3. Check if the current node is the target node (n-1).\n   - If yes, then add the path to the result list.\n4. If the current node is not the target, traverse through each of its neighbors by calling the DFS function recursively.\n5. Pop off the current node from the path to backtrack to the previous node.\n6. The main function calls the DFS function with node 0 as the starting point, and it returns the result list containing all possible paths.\n\nThe time complexity of this algorithm is O(2^N * N) as in the worst case, we will iterate through all the paths from the starting node to the target node. The space complexity is also O(2^N * N) because of the storage required for the result list.\n    ", "python": "\n    ```python\nfrom typing import List\n\ndef allPathsSourceTarget(graph: List[List[int]]) -> List[List[int]]:\n    def DFS(currentNode, path):\n        path.append(currentNode)\n        if currentNode == len(graph) - 1:\n            result.append(path[:])\n        else:\n            for neighbor in graph[currentNode]:\n                DFS(neighbor, path)\n        path.pop()\n\n    result = []\n    DFS(0, [])\n    return result\n```\n    \n    This algorithm uses a Depth First Search (DFS) approach to traverse through the directed acyclic graph. \n\n1. Create a recursive helper function called DFS, which takes the current node, path, graph, and result as parameters.\n2. Add the current node to the path list.\n3. Check if the current node is the target node (n-1).\n   - If yes, then add the path to the result list.\n4. If the current node is not the target, traverse through each of its neighbors by calling the DFS function recursively.\n5. Pop off the current node from the path to backtrack to the previous node.\n6. The main function calls the DFS function with node 0 as the starting point, and it returns the result list containing all possible paths.\n\nThe time complexity of this algorithm is O(2^N * N) as in the worst case, we will iterate through all the paths from the starting node to the target node. The space complexity is also O(2^N * N) because of the storage required for the result list.\n    ", "javascript": "\n    ```javascript\nfunction allPathsSourceTarget(graph) {\n    const result = [];\n    const path = [];\n    DFS(graph, result, path, 0);\n    return result;\n}\n\nfunction DFS(graph, result, path, currentNode) {\n    path.push(currentNode);\n    if (currentNode === graph.length - 1) {\n        result.push(path.slice());\n    } else {\n        for (const neighbor of graph[currentNode]) {\n            DFS(graph, result, path, neighbor);\n        }\n    }\n    path.pop();\n}\n```\n    \n    This algorithm uses a Depth First Search (DFS) approach to traverse through the directed acyclic graph. \n\n1. Create a recursive helper function called DFS, which takes the current node, path, graph, and result as parameters.\n2. Add the current node to the path list.\n3. Check if the current node is the target node (n-1).\n   - If yes, then add the path to the result list.\n4. If the current node is not the target, traverse through each of its neighbors by calling the DFS function recursively.\n5. Pop off the current node from the path to backtrack to the previous node.\n6. The main function calls the DFS function with node 0 as the starting point, and it returns the result list containing all possible paths.\n\nThe time complexity of this algorithm is O(2^N * N) as in the worst case, we will iterate through all the paths from the starting node to the target node. The space complexity is also O(2^N * N) because of the storage required for the result list.\n    "}
{"id": 823, "slug": "binary-trees-with-factors", "title": "Binary Trees With Factors", "difficulty": "Medium", "content": "Given an array of unique integers, `arr`, where each integer `arr[i]` is strictly greater than `1`.\n\nWe make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.\n\nReturn _the number of binary trees we can make_. The answer may be too large so return the answer **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** arr = \\[2,4\\]\n**Output:** 3\n**Explanation:** We can make these trees: `[2], [4], [4, 2, 2]`\n\n**Example 2:**\n\n**Input:** arr = \\[2,4,5,10\\]\n**Output:** 7\n**Explanation:** We can make these trees: `[2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2]`.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 1000`\n*   `2 <= arr[i] <= 109`\n*   All the values of `arr` are **unique**.", "java": "\n    ```java\npublic boolean isPossibleToSplit(int[] nums) {\n    int n = nums.length;\n    int total_sum = 0;\n    for (int num : nums) {\n        total_sum += num;\n    }\n\n    if (total_sum % n != 0) return false;\n\n    int target_sum = total_sum * (n / 2) / n;\n    boolean[][] dp = new boolean[n / 2 + 1][target_sum + 1];\n    dp[0][0] = true;\n\n    for (int num : nums) {\n        for (int count = n / 2; count >= 1; --count) {\n            for (int sum = target_sum; sum >= num; --sum) {\n                dp[count][sum] = dp[count][sum] || dp[count - 1][sum - num];\n            }\n        }\n        if (dp[n / 2][target_sum]) return true;\n    }\n\n    return false;\n}\n```\n\n    \n    The algorithm uses a dynamic programming approach to solve the problem. We calculate the total sum of the nums array and check if it can be divided evenly into two parts. If the sum is not divisible by the length of the array, then it is impossible to create two arrays with equal average.\n\nNext, we create a 2D boolean dp table with dimensions `(n / 2 + 1)` by `(target_sum + 1)`. The table represents whether it's possible to create a subset with a given count of elements and a given sum. Initially, we set `dp[0][0]` to True as it represents an empty subset.\n\nWe iterate through each element in the nums array, and for each element, we check all combinations of remaining count and sum values. If we find any subset of required size and target_sum in dp table, we return True.\n\nOnce all iterations are completed and no required subsets are found, we return False, meaning it's not possible to create two arrays with equal average.\n    ", "c++": "\n    ```cpp\nbool isPossibleToSplit(const vector<int>& nums) {\n    int n = nums.size();\n    int total_sum = accumulate(nums.begin(), nums.end(), 0);\n    \n    if (total_sum % n != 0) return false;\n\n    int target_sum = total_sum * (n / 2) / n;\n    vector<vector<bool>> dp(n / 2 + 1, vector<bool>(target_sum + 1, false));\n    dp[0][0] = true;\n\n    for (int num : nums) {\n        for (int count = n / 2; count >= 1; --count) {\n            for (int sum = target_sum; sum >= num; --sum) {\n                dp[count][sum] = dp[count][sum] || dp[count - 1][sum - num];\n            }\n        }\n        if (dp[n / 2][target_sum]) return true;\n    }\n\n    return false;\n}\n```\n\n    \n    The algorithm uses a dynamic programming approach to solve the problem. We calculate the total sum of the nums array and check if it can be divided evenly into two parts. If the sum is not divisible by the length of the array, then it is impossible to create two arrays with equal average.\n\nNext, we create a 2D boolean dp table with dimensions `(n / 2 + 1)` by `(target_sum + 1)`. The table represents whether it's possible to create a subset with a given count of elements and a given sum. Initially, we set `dp[0][0]` to True as it represents an empty subset.\n\nWe iterate through each element in the nums array, and for each element, we check all combinations of remaining count and sum values. If we find any subset of required size and target_sum in dp table, we return True.\n\nOnce all iterations are completed and no required subsets are found, we return False, meaning it's not possible to create two arrays with equal average.\n    ", "python": "\n    ```python\ndef isPossibleToSplit(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n\n    if total_sum % n != 0:\n        return False\n\n    target_sum = total_sum * (n // 2) // n\n    dp = [[False] * (target_sum + 1) for _ in range(n // 2 + 1)]\n    dp[0][0] = True\n\n    for num in nums:\n        for count in range(n // 2, 0, -1):\n            for sum_ in range(target_sum, num - 1, -1):\n                dp[count][sum_] = dp[count][sum_] or dp[count - 1][sum_ - num]\n\n        if dp[n // 2][target_sum]:\n            return True\n\n    return False\n```\n\n    \n    The algorithm uses a dynamic programming approach to solve the problem. We calculate the total sum of the nums array and check if it can be divided evenly into two parts. If the sum is not divisible by the length of the array, then it is impossible to create two arrays with equal average.\n\nNext, we create a 2D boolean dp table with dimensions `(n / 2 + 1)` by `(target_sum + 1)`. The table represents whether it's possible to create a subset with a given count of elements and a given sum. Initially, we set `dp[0][0]` to True as it represents an empty subset.\n\nWe iterate through each element in the nums array, and for each element, we check all combinations of remaining count and sum values. If we find any subset of required size and target_sum in dp table, we return True.\n\nOnce all iterations are completed and no required subsets are found, we return False, meaning it's not possible to create two arrays with equal average.\n    ", "javascript": "\n    ```javascript\nfunction isPossibleToSplit(nums) {\n    const n = nums.length;\n    const total_sum = nums.reduce((a, b) => a + b, 0);\n\n    if (total_sum % n !== 0) return false;\n\n    const target_sum = (total_sum * (n / 2)) / n;\n    const dp = Array.from(Array(n / 2 + 1), () => Array(target_sum + 1).fill(false));\n    dp[0][0] = true;\n\n    for (const num of nums) {\n        for (let count = n / 2; count >= 1; --count) {\n            for (let sum = target_sum; sum >= num; --sum) {\n                dp[count][sum] = dp[count][sum] || dp[count - 1][sum - num];\n            }\n        }\n        if (dp[n / 2][target_sum]) return true;\n    }\n\n    return false;\n}\n```\n\n    \n    The algorithm uses a dynamic programming approach to solve the problem. We calculate the total sum of the nums array and check if it can be divided evenly into two parts. If the sum is not divisible by the length of the array, then it is impossible to create two arrays with equal average.\n\nNext, we create a 2D boolean dp table with dimensions `(n / 2 + 1)` by `(target_sum + 1)`. The table represents whether it's possible to create a subset with a given count of elements and a given sum. Initially, we set `dp[0][0]` to True as it represents an empty subset.\n\nWe iterate through each element in the nums array, and for each element, we check all combinations of remaining count and sum values. If we find any subset of required size and target_sum in dp table, we return True.\n\nOnce all iterations are completed and no required subsets are found, we return False, meaning it's not possible to create two arrays with equal average.\n    "}
{"id": 828, "slug": "count-unique-characters-of-all-substrings-of-a-given-string", "title": "Count Unique Characters of All Substrings of a Given String", "difficulty": "Hard", "content": "Let's define a function `countUniqueChars(s)` that returns the number of unique characters on `s`.\n\n*   For example, calling `countUniqueChars(s)` if `s = \"LEETCODE \"` then `\"L \"`, `\"T \"`, `\"C \"`, `\"O \"`, `\"D \"` are the unique characters since they appear only once in `s`, therefore `countUniqueChars(s) = 5`.\n\nGiven a string `s`, return the sum of `countUniqueChars(t)` where `t` is a substring of `s`. The test cases are generated such that the answer fits in a 32-bit integer.\n\nNotice that some substrings can be repeated so in this case you have to count the repeated ones too.\n\n**Example 1:**\n\n**Input:** s =  \"ABC \"\n**Output:** 10\n**Explanation:** All possible substrings are:  \"A \", \"B \", \"C \", \"AB \", \"BC \" and  \"ABC \".\nEvery substring is composed with only unique letters.\nSum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10\n\n**Example 2:**\n\n**Input:** s =  \"ABA \"\n**Output:** 8\n**Explanation:** The same as example 1, except `countUniqueChars`( \"ABA \") = 1.\n\n**Example 3:**\n\n**Input:** s =  \"LEETCODE \"\n**Output:** 92\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of uppercase English letters only.", "java": "\n    ```java\npublic boolean xorGame(int[] nums) {\n    int xorSum = 0;\n    for (int num : nums) {\n        xorSum ^= num;\n    }\n    return xorSum == 0 || nums.length % 2 == 0;\n}\n```\n    \n    The algorithm first calculates the bitwise XOR of all elements in the array. Then, it checks if the XOR of all elements is zero or if the total number of elements in the array is even.\n\nIf the bitwise XOR of all elements is zero, Alice wins because the game condition is already satisfied and it is her turn. If the total number of elements in the array is even, Alice wins because she can always force a situation where the bitwise XOR of the remaining elements is non-zero when it is Bob's turn to play. In all other cases, Alice will lose, and the function returns false.\n    ", "c++": "\n    ```cpp\nbool xorGame(const std::vector<int>& nums) {\n    int xorSum = 0;\n    for (int num : nums) {\n        xorSum ^= num;\n    }\n    return xorSum == 0 || nums.size() % 2 == 0;\n}\n```\n    \n    The algorithm first calculates the bitwise XOR of all elements in the array. Then, it checks if the XOR of all elements is zero or if the total number of elements in the array is even.\n\nIf the bitwise XOR of all elements is zero, Alice wins because the game condition is already satisfied and it is her turn. If the total number of elements in the array is even, Alice wins because she can always force a situation where the bitwise XOR of the remaining elements is non-zero when it is Bob's turn to play. In all other cases, Alice will lose, and the function returns false.\n    ", "python": "\n    ```python\ndef xor_game(nums: List[int]) -> bool:\n    xor_sum = 0\n    for num in nums:\n        xor_sum ^= num\n    return xor_sum == 0 or len(nums) % 2 == 0\n```\n    \n    The algorithm first calculates the bitwise XOR of all elements in the array. Then, it checks if the XOR of all elements is zero or if the total number of elements in the array is even.\n\nIf the bitwise XOR of all elements is zero, Alice wins because the game condition is already satisfied and it is her turn. If the total number of elements in the array is even, Alice wins because she can always force a situation where the bitwise XOR of the remaining elements is non-zero when it is Bob's turn to play. In all other cases, Alice will lose, and the function returns false.\n    ", "javascript": "\n    ```javascript\nfunction xorGame(nums) {\n    let xorSum = 0;\n    for (let num of nums) {\n        xorSum ^= num;\n    }\n    return xorSum === 0 || nums.length % 2 === 0;\n}\n```\n    \n    The algorithm first calculates the bitwise XOR of all elements in the array. Then, it checks if the XOR of all elements is zero or if the total number of elements in the array is even.\n\nIf the bitwise XOR of all elements is zero, Alice wins because the game condition is already satisfied and it is her turn. If the total number of elements in the array is even, Alice wins because she can always force a situation where the bitwise XOR of the remaining elements is non-zero when it is Bob's turn to play. In all other cases, Alice will lose, and the function returns false.\n    "}
{"id": 834, "slug": "sum-of-distances-in-tree", "title": "Sum of Distances in Tree", "difficulty": "Hard", "content": "There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given the integer `n` and the array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nReturn an array `answer` of length `n` where `answer[i]` is the sum of the distances between the `ith` node in the tree and all other nodes.\n\n**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\],\\[2,5\\]\\]\n**Output:** \\[8,12,6,10,10,10\\]\n**Explanation:** The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer\\[0\\] = 8, and so on.\n\n**Example 2:**\n\n**Input:** n = 1, edges = \\[\\]\n**Output:** \\[0\\]\n\n**Example 3:**\n\n**Input:** n = 2, edges = \\[\\[1,0\\]\\]\n**Output:** \\[1,1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 3 * 104`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   The given input represents a valid tree.", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> ambiguousCoordinates(String s) {\n    int n = s.length();\n    List<String> res = new ArrayList<>();\n    \n    for (int i = 2; i < n - 1; i++) {\n        List<String> first = generateNumber(s.substring(1, i));\n        List<String> second = generateNumber(s.substring(i, n - 1));\n        \n        for (String f : first) {\n            for (String sec : second) {\n                res.add(\"(\" + f + \", \" + sec + \")\");\n            }\n        }\n    }\n    return res;\n}\n\nprivate List<String> generateNumber(String s) {\n    int n = s.length();\n    List<String> res = new ArrayList<>();\n    \n    if (n == 0 || (n > 1 && s.charAt(0) == '0' && s.charAt(n - 1) == '0')) return res;\n    if (n > 1 && s.charAt(0) == '0') {\n        res.add(\"0.\" + s.substring(1));\n        return res;\n    }\n    res.add(s);\n    if (n == 1 || s.charAt(n - 1) == '0') return res;\n    \n    for (int i = 1; i < n; i++) {\n        res.add(s.substring(0, i) + \".\" + s.substring(i));\n    }\n    return res;\n}\n```\n\n    \n    1. Iterate over the string except the first and the last characters to create pairs of valid numbers.\n2. In the `generateNumber()` function, handle four cases:\n    a. If the length of the string is 0 or both the first and last characters are '0', then return an empty list.\n    b. If the first character is '0', return a list with the number having a decimal point after the first character.\n    c. If the last character is '0' or the string has only one digit, return a list with only the given string as the number.\n    d. Otherwise, create numbers by placing a decimal point at every valid position between digits of the string.\n3. Combine all valid pairs of numbers and return the final answer in the format of a list of strings.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> ambiguousCoordinates(std::string s) {\n    int n = s.size();\n    std::vector<std::string> res;\n    \n    for (int i = 2; i < n - 1; ++i) {\n        auto first = generateNumber(s.substr(1, i - 1));\n        auto second = generateNumber(s.substr(i, n - 1 - i));\n        \n        for (const auto& f : first) {\n            for (const auto& sec : second) {\n                res.push_back(\"(\" + f + \", \" + sec + \")\");\n            }\n        }\n    }\n    return res;\n}\n\nstd::vector<std::string> generateNumber(const std::string& s) {\n    int n = s.size();\n    std::vector<std::string> res;\n    \n    if (n == 0 || (n > 1 && s[0] == '0' && s[n - 1] == '0')) return res;\n    if (n > 1 && s[0] == '0') {\n        res.push_back(\"0.\" + s.substr(1));\n        return res;\n    }\n    res.push_back(s);\n    if (n == 1 || s[n - 1] == '0') return res;\n    \n    for (int i = 1; i < n; ++i) {\n        res.push_back(s.substr(0, i) + \".\" + s.substr(i));\n    }\n    return res;\n}\n```\n\n    \n    1. Iterate over the string except the first and the last characters to create pairs of valid numbers.\n2. In the `generateNumber()` function, handle four cases:\n    a. If the length of the string is 0 or both the first and last characters are '0', then return an empty list.\n    b. If the first character is '0', return a list with the number having a decimal point after the first character.\n    c. If the last character is '0' or the string has only one digit, return a list with only the given string as the number.\n    d. Otherwise, create numbers by placing a decimal point at every valid position between digits of the string.\n3. Combine all valid pairs of numbers and return the final answer in the format of a list of strings.\n    ", "python": "\n    ```python\ndef ambiguousCoordinates(s):\n    def generateNumber(s):\n        if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):\n            return []\n        if len(s) > 1 and s[0] == '0':\n            return [\"0.\" + s[1:]]\n        res = [s]\n        if len(s) == 1 or s[-1] == '0':\n            return res\n        for i in range(1, len(s)):\n            res.append(s[:i] + \".\" + s[i:])\n        return res\n\n    n = len(s)\n    res = []\n    \n    for i in range(2, n - 1):\n        first = generateNumber(s[1:i])\n        second = generateNumber(s[i:n - 1])\n        \n        for f in first:\n            for sec in second:\n                res.append(\"(\" + f + \", \" + sec + \")\")\n    \n    return res\n```\n\n    \n    1. Iterate over the string except the first and the last characters to create pairs of valid numbers.\n2. In the `generateNumber()` function, handle four cases:\n    a. If the length of the string is 0 or both the first and last characters are '0', then return an empty list.\n    b. If the first character is '0', return a list with the number having a decimal point after the first character.\n    c. If the last character is '0' or the string has only one digit, return a list with only the given string as the number.\n    d. Otherwise, create numbers by placing a decimal point at every valid position between digits of the string.\n3. Combine all valid pairs of numbers and return the final answer in the format of a list of strings.\n    ", "javascript": "\n    ```javascript\nfunction ambiguousCoordinates(s) {\n    function generateNumber(s) {\n        if (s.length === 0 || (s.length > 1 && s[0] === '0' && s[s.length - 1] === '0')) {\n            return [];\n        }\n        if (s.length > 1 && s[0] === '0') {\n            return [\"0.\" + s.slice(1)];\n        }\n        let res = [s];\n        if (s.length === 1 || s[s.length - 1] === '0') {\n            return res;\n        }\n        for (let i = 1; i < s.length; i++) {\n            res.push(s.slice(0, i) + \".\" + s.slice(i));\n        }\n        return res;\n    }\n    \n    let n = s.length;\n    let res = [];\n    \n    for (let i = 2; i < n - 1; i++) {\n        let first = generateNumber(s.slice(1, i));\n        let second = generateNumber(s.slice(i, n - 1));\n        \n        for (let f of first) {\n            for (let sec of second) {\n                res.push(\"(\" + f + \", \" + sec + \")\");\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    1. Iterate over the string except the first and the last characters to create pairs of valid numbers.\n2. In the `generateNumber()` function, handle four cases:\n    a. If the length of the string is 0 or both the first and last characters are '0', then return an empty list.\n    b. If the first character is '0', return a list with the number having a decimal point after the first character.\n    c. If the last character is '0' or the string has only one digit, return a list with only the given string as the number.\n    d. Otherwise, create numbers by placing a decimal point at every valid position between digits of the string.\n3. Combine all valid pairs of numbers and return the final answer in the format of a list of strings.\n    "}
{"id": 837, "slug": "new-21-game", "title": "New 21 Game", "difficulty": "Medium", "content": "Alice plays the following game, loosely based on the card game **\"21 \"**.\n\nAlice starts with `0` points and draws numbers while she has less than `k` points. During each draw, she gains an integer number of points randomly from the range `[1, maxPts]`, where `maxPts` is an integer. Each draw is independent and the outcomes have equal probabilities.\n\nAlice stops drawing numbers when she gets `k` **or more points**.\n\nReturn the probability that Alice has `n` or fewer points.\n\nAnswers within `10-5` of the actual answer are considered accepted.\n\n**Example 1:**\n\n**Input:** n = 10, k = 1, maxPts = 10\n**Output:** 1.00000\n**Explanation:** Alice gets a single card, then stops.\n\n**Example 2:**\n\n**Input:** n = 6, k = 1, maxPts = 10\n**Output:** 0.60000\n**Explanation:** Alice gets a single card, then stops.\nIn 6 out of 10 possibilities, she is at or below 6 points.\n\n**Example 3:**\n\n**Input:** n = 21, k = 17, maxPts = 10\n**Output:** 0.73278\n\n**Constraints:**\n\n*   `0 <= k <= n <= 104`\n*   `1 <= maxPts <= 104`", "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic String mostCommonWord(String paragraph, String[] banned) {\n    String lowerPara = paragraph.toLowerCase();\n    String[] words = lowerPara.split(\"\\\\W+\");\n    Map<String, Integer> wordCount = new HashMap<>();\n    Set<String> bannedSet = new HashSet<>();\n    \n    for (String ban : banned) {\n        bannedSet.add(ban.toLowerCase());\n    }\n    \n    for (String word : words) {\n        if (!bannedSet.contains(word)) {\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n        }\n    }\n    \n    return wordCount.entrySet().stream()\n            .max(Map.Entry.comparingByValue())\n            .orElseThrow()\n            .getKey();\n}\n```\n\n    \n    First, convert the given `paragraph` to lowercase and split it into words. Then, create a `wordCount` map to store each word and their corresponding frequency count. Ignore punctuations by checking if the character is an alphabet or not. \n\nCreate a set of lowercase banned words (`bannedSet`) and iterate through the original list of words. For any word, not in the bannedSet, update or increment its frequency count in the wordCount map.\n\nFinally, iterate through the `wordCount` map to find the word with the highest frequency count and return it as the result.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <cctype>\n\nstd::string mostCommonWord(std::string paragraph, std::vector<std::string>& banned) {\n    std::unordered_map<std::string, int> wordCount;\n    std::string currentWord;\n    for (char c : paragraph) {\n        if (isalpha(c)) {\n            currentWord.push_back(tolower(c));\n        } else if (!currentWord.empty()) {\n            wordCount[currentWord]++;\n            currentWord.clear();\n        }\n    }\n\n    if (!currentWord.empty()) {\n        wordCount[currentWord]++;\n    }\n\n    for (std::string &ban : banned) {\n        transform(ban.begin(), ban.end(), ban.begin(), ::tolower);\n        wordCount[ban] = 0;\n    }\n\n    return std::max_element(wordCount.begin(), wordCount.end(), [](const auto &a, const auto &b) {\n        return a.second < b.second;\n    })->first;\n}\n```\n\n    \n    First, convert the given `paragraph` to lowercase and split it into words. Then, create a `wordCount` map to store each word and their corresponding frequency count. Ignore punctuations by checking if the character is an alphabet or not. \n\nCreate a set of lowercase banned words (`bannedSet`) and iterate through the original list of words. For any word, not in the bannedSet, update or increment its frequency count in the wordCount map.\n\nFinally, iterate through the `wordCount` map to find the word with the highest frequency count and return it as the result.\n    ", "python": "\n    ```python\ndef mostCommonWord(paragraph: str, banned: List[str]):\n    word_count = {}\n    banned_set = {ban.lower() for ban in banned}\n\n    for word in paragraph.lower().split():\n        cleaned_word = ''.join(c for c in word if c.isalpha())\n        if cleaned_word not in banned_set:\n            word_count[cleaned_word] = word_count.get(cleaned_word, 0) + 1\n\n    return max(word_count, key=word_count.get)\n```\n\n    \n    First, convert the given `paragraph` to lowercase and split it into words. Then, create a `wordCount` map to store each word and their corresponding frequency count. Ignore punctuations by checking if the character is an alphabet or not. \n\nCreate a set of lowercase banned words (`bannedSet`) and iterate through the original list of words. For any word, not in the bannedSet, update or increment its frequency count in the wordCount map.\n\nFinally, iterate through the `wordCount` map to find the word with the highest frequency count and return it as the result.\n    ", "javascript": "\n    ```javascript\nfunction mostCommonWord(paragraph, banned) {\n    const wordCount = new Map();\n    const bannedSet = new Set(banned.map(x => x.toLowerCase()));\n    const words = paragraph.toLowerCase().split(/\\W+/);\n\n    words.forEach(word => {\n        if (!bannedSet.has(word)) {\n            wordCount.set(word, (wordCount.get(word) || 0) + 1);\n        }\n    });\n    \n    let maxCount = -1;\n    let result = '';\n    wordCount.forEach((count, word) => {\n        if (count > maxCount) {\n            maxCount = count;\n            result = word;\n        }\n    });\n    \n    return result;\n}\n```\n\n    \n    First, convert the given `paragraph` to lowercase and split it into words. Then, create a `wordCount` map to store each word and their corresponding frequency count. Ignore punctuations by checking if the character is an alphabet or not. \n\nCreate a set of lowercase banned words (`bannedSet`) and iterate through the original list of words. For any word, not in the bannedSet, update or increment its frequency count in the wordCount map.\n\nFinally, iterate through the `wordCount` map to find the word with the highest frequency count and return it as the result.\n    "}
{"id": 838, "slug": "push-dominoes", "title": "Push Dominoes", "difficulty": "Medium", "content": "There are `n` dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.\n\nAfter each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\n\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\n\nFor the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\n\nYou are given a string `dominoes` representing the initial state where:\n\n*   `dominoes[i] = 'L'`, if the `ith` domino has been pushed to the left,\n*   `dominoes[i] = 'R'`, if the `ith` domino has been pushed to the right, and\n*   `dominoes[i] = '.'`, if the `ith` domino has not been pushed.\n\nReturn _a string representing the final state_.\n\n**Example 1:**\n\n**Input:** dominoes =  \"RR.L \"\n**Output:**  \"RR.L \"\n**Explanation:** The first domino expends no additional force on the second domino.\n\n**Example 2:**\n\n**Input:** dominoes =  \".L.R...LR..L.. \"\n**Output:**  \"LL.RR.LLRRLL.. \"\n\n**Constraints:**\n\n*   `n == dominoes.length`\n*   `1 <= n <= 105`\n*   `dominoes[i]` is either `'L'`, `'R'`, or `'.'`.", "java": "\n    ```java\npublic String pushDominoes(String dominoes) {\n    int n = dominoes.length();\n    int[] forces = new int[n];\n\n    int force = 0;\n    for (int i = 0; i < n; ++i) {\n        if (dominoes.charAt(i) == 'R') force = n;\n        else if (dominoes.charAt(i) == 'L') force = 0;\n        else force = Math.max(force - 1, 0);\n        forces[i] += force;\n    }\n\n    force = 0;\n    for (int i = n - 1; i >= 0; --i) {\n        if (dominoes.charAt(i) == 'L') force = n;\n        else if (dominoes.charAt(i) == 'R') force = 0;\n        else force = Math.max(force - 1, 0);\n        forces[i] -= force;\n    }\n\n    StringBuilder result = new StringBuilder();\n    for (int f : forces) {\n        if (f > 0) result.append('R');\n        else if (f < 0) result.append('L');\n        else result.append('.');\n    }\n\n    return result.toString();\n}\n```\n\n    \n    We will use two-pass mechanism:\n1. Pass from left to right - calculate the force exerted by 'R' dominoes to 'L' dominoes.\n2. Pass from right to left - calculate the force exerted by 'L' dominoes to 'R' dominoes and subtract it from the previous force (from pass 1)\n3. Use the final force information to output the final state of dominoes:\n    - if force > 0, it's 'R'\n    - if force < 0, it's 'L'\n    - if force == 0, it's '.'\n    ", "c++": "\n    ```cpp\nstring pushDominoes(string dominoes) {\n    int n = dominoes.size();\n    vector<int> forces(n, 0);\n    \n    int force = 0;\n    for (int i = 0; i < n; ++i) {\n        if (dominoes[i] == 'R') force = n;\n        else if (dominoes[i] == 'L') force = 0;\n        else force = max(force - 1, 0);\n        forces[i] += force;\n    }\n    \n    force = 0;\n    for (int i = n - 1; i >= 0; --i) {\n        if (dominoes[i] == 'L') force = n;\n        else if (dominoes[i] == 'R') force = 0;\n        else force = max(force - 1, 0);\n        forces[i] -= force;\n    }\n    \n    string result = \"\";\n    for (int force : forces) {\n        if (force > 0) result += 'R';\n        else if (force < 0) result += 'L';\n        else result += '.';\n    }\n    \n    return result;\n}\n```\n\n    \n    We will use two-pass mechanism:\n1. Pass from left to right - calculate the force exerted by 'R' dominoes to 'L' dominoes.\n2. Pass from right to left - calculate the force exerted by 'L' dominoes to 'R' dominoes and subtract it from the previous force (from pass 1)\n3. Use the final force information to output the final state of dominoes:\n    - if force > 0, it's 'R'\n    - if force < 0, it's 'L'\n    - if force == 0, it's '.'\n    ", "python": "\n    ```python\ndef pushDominoes(dominoes: str) -> str:\n    n = len(dominoes)\n    forces = [0] * n\n    \n    force = 0\n    for i in range(n):\n        if dominoes[i] == 'R':\n            force = n\n        elif dominoes[i] == 'L':\n            force = 0\n        else:\n            force = max(force - 1, 0)\n        forces[i] += force\n    \n    force = 0\n    for i in range(n - 1, -1, -1):\n        if dominoes[i] == 'L':\n            force = n\n        elif dominoes[i] == 'R':\n            force = 0\n        else:\n            force = max(force - 1, 0)\n        forces[i] -= force\n    \n    return \"\".join(['R' if f > 0 else 'L' if f < 0 else '.' for f in forces])\n```\n\n    \n    We will use two-pass mechanism:\n1. Pass from left to right - calculate the force exerted by 'R' dominoes to 'L' dominoes.\n2. Pass from right to left - calculate the force exerted by 'L' dominoes to 'R' dominoes and subtract it from the previous force (from pass 1)\n3. Use the final force information to output the final state of dominoes:\n    - if force > 0, it's 'R'\n    - if force < 0, it's 'L'\n    - if force == 0, it's '.'\n    ", "javascript": "\n    ```javascript\nfunction pushDominoes(dominoes) {\n    const n = dominoes.length;\n    const forces = new Array(n).fill(0);\n\n    let force = 0;\n    for (let i = 0; i < n; ++i) {\n        if (dominoes[i] === 'R') force = n;\n        else if (dominoes[i] === 'L') force = 0;\n        else force = Math.max(force - 1, 0);\n        forces[i] += force;\n    }\n\n    force = 0;\n    for (let i = n - 1; i >= 0; --i) {\n        if (dominoes[i] === 'L') force = n;\n        else if (dominoes[i] === 'R') force = 0;\n        else force = Math.max(force - 1, 0);\n        forces[i] -= force;\n    }\n\n    return forces.map(f => f > 0 ? 'R' : f < 0 ? 'L' : '.').join('');\n}\n```\n\n    \n    We will use two-pass mechanism:\n1. Pass from left to right - calculate the force exerted by 'R' dominoes to 'L' dominoes.\n2. Pass from right to left - calculate the force exerted by 'L' dominoes to 'R' dominoes and subtract it from the previous force (from pass 1)\n3. Use the final force information to output the final state of dominoes:\n    - if force > 0, it's 'R'\n    - if force < 0, it's 'L'\n    - if force == 0, it's '.'\n    "}
{"id": 871, "slug": "minimum-number-of-refueling-stops", "title": "Minimum Number of Refueling Stops", "difficulty": "Hard", "content": "A car travels from a starting position to a destination which is `target` miles east of the starting position.\n\nThere are gas stations along the way. The gas stations are represented as an array `stations` where `stations[i] = [positioni, fueli]` indicates that the `ith` gas station is `positioni` miles east of the starting position and has `fueli` liters of gas.\n\nThe car starts with an infinite tank of gas, which initially has `startFuel` liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\n\nReturn _the minimum number of refueling stops the car must make in order to reach its destination_. If it cannot reach the destination, return `-1`.\n\nNote that if the car reaches a gas station with `0` fuel left, the car can still refuel there. If the car reaches the destination with `0` fuel left, it is still considered to have arrived.\n\n**Example 1:**\n\n**Input:** target = 1, startFuel = 1, stations = \\[\\]\n**Output:** 0\n**Explanation:** We can reach the target without refueling.\n\n**Example 2:**\n\n**Input:** target = 100, startFuel = 1, stations = \\[\\[10,100\\]\\]\n**Output:** -1\n**Explanation:** We can not reach the target (or even the first gas station).\n\n**Example 3:**\n\n**Input:** target = 100, startFuel = 10, stations = \\[\\[10,60\\],\\[20,30\\],\\[30,30\\],\\[60,40\\]\\]\n**Output:** 2\n**Explanation:** We start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2.\n\n**Constraints:**\n\n*   `1 <= target, startFuel <= 109`\n*   `0 <= stations.length <= 500`\n*   `1 <= positioni < positioni+1 < target`\n*   `1 <= fueli < 109`", "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Stack;\n\npublic boolean canVisitAllRooms(List<List<Integer>> rooms) {\n    HashSet<Integer> visited = new HashSet<>();\n    Stack<Integer> stack = new Stack<>();\n    stack.push(0);\n\n    while (!stack.isEmpty()) {\n        int currentRoom = stack.pop();\n\n        visited.add(currentRoom);\n\n        for (int key : rooms.get(currentRoom)) {\n            if (!visited.contains(key)) {\n                stack.push(key);\n            }\n        }\n    }\n\n    return visited.size() == rooms.size();\n}\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n\nbool canVisitAllRooms(const std::vector<std::vector<int>>& rooms) {\n    std::unordered_set<int> visited;\n    std::vector<int> stack = {0};\n\n    while (!stack.empty()) {\n        int currentRoom = stack.back();\n        stack.pop_back();\n\n        visited.insert(currentRoom);\n\n        for (int key : rooms[currentRoom]) {\n            if (!visited.count(key)) {\n                stack.push_back(key);\n            }\n        }\n    }\n\n    return visited.size() == rooms.size();\n}\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    ", "python": "\n    ```python\ndef can_visit_all_rooms(rooms):\n    visited = set()\n    stack = [0]\n\n    while stack:\n        current_room = stack.pop()\n\n        visited.add(current_room)\n\n        for key in rooms[current_room]:\n            if key not in visited:\n                stack.append(key)\n\n    return len(visited) == len(rooms)\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    ", "javascript": "\n    ```javascript\nfunction canVisitAllRooms(rooms) {\n    const visited = new Set();\n    const stack = [0];\n\n    while (stack.length > 0) {\n        const currentRoom = stack.pop();\n\n        visited.add(currentRoom);\n\n        for (const key of rooms[currentRoom]) {\n            if (!visited.has(key)) {\n                stack.push(key);\n            }\n        }\n    }\n\n    return visited.size === rooms.length;\n}\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    "}
{"id": 873, "slug": "length-of-longest-fibonacci-subsequence", "title": "Length of Longest Fibonacci Subsequence", "difficulty": "Medium", "content": "A sequence `x1, x2, ..., xn` is _Fibonacci-like_ if:\n\n*   `n >= 3`\n*   `xi + xi+1 == xi+2` for all `i + 2 <= n`\n\nGiven a **strictly increasing** array `arr` of positive integers forming a sequence, return _the **length** of the longest Fibonacci-like subsequence of_ `arr`. If one does not exist, return `0`.\n\nA **subsequence** is derived from another sequence `arr` by deleting any number of elements (including none) from `arr`, without changing the order of the remaining elements. For example, `[3, 5, 8]` is a subsequence of `[3, 4, 5, 6, 7, 8]`.\n\n**Example 1:**\n\n**Input:** arr = \\[1,2,3,4,5,6,7,8\\]\n**Output:** 5\n**Explanation:** The longest subsequence that is fibonacci-like: \\[1,2,3,5,8\\].\n\n**Example 2:**\n\n**Input:** arr = \\[1,3,7,11,12,14,18\\]\n**Output:** 3\n**Explanation**: The longest subsequence that is fibonacci-like: \\[1,11,12\\], \\[3,11,14\\] or \\[7,11,18\\].\n\n**Constraints:**\n\n*   `3 <= arr.length <= 1000`\n*   `1 <= arr[i] < arr[i + 1] <= 109`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\nclass Solution {\n    private int match(String a, String b) {\n        int matches = 0;\n        for (int i = 0; i < 6; ++i)\n            if (a.charAt(i) == b.charAt(i)) matches++;\n        return matches;\n    }\n\n    public void findSecretWord(String[] wordlist, Master master) {\n        List<String> words = new ArrayList<>();\n        for (String word : wordlist) words.add(word);\n        Random rand = new Random();\n\n        for (int i = 0, matchCnt = 0; i < 10 && matchCnt < 6; ++i) {\n            String guess = words.get(rand.nextInt(words.size()));\n            matchCnt = master.guess(guess);\n            List<String> candidates = new ArrayList<>();\n            for (String word : words)\n                if (match(word, guess) == matchCnt)\n                    candidates.add(word);\n            words = candidates;\n        }\n    }\n}\n```\n    \n    1. Define a `match` function to calculate the number of exact matches between two strings.\n2. For 10 iterations or until the secret word is guessed:\n  a. Randomly select a word (`guess`) from the `wordlist`.\n  b. Call `Master.guess` with the `guess`, and store the number of exact matches in `match_cnt`.\n  c. If the `match_cnt` equals 6 (i.e., the word is guessed), terminate the loop.\n  d. Filter the `wordlist` to keep only those words that have the same number of exact matches with the `guess` as `match_cnt`.\n3. Complete the loop and return.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint match(const std::string& a, const std::string& b) {\n    int matches = 0;\n    for (int i = 0; i < 6; ++i)\n        if (a[i] == b[i]) matches++;\n    return matches;\n}\n\nvoid findSecretWord(std::vector<std::string>& wordlist, Master& master) {\n    int n = word_list.size();\n    for (int i = 0, match_cnt=0; i < 10 && match_cnt < 6; ++i) {\n        std::string guess = wordlist[rand() %n];\n        match_cnt = master.guess(guess);\n        std::vector<std::string> candidates;\n        for (const std::string& word : wordlist)\n            if (match(word, guess) == match_cnt)\n                candidates.push_back(word);\n        wordlist = candidates;\n        n = wordlist.size();\n    }\n}\n```\n    \n    1. Define a `match` function to calculate the number of exact matches between two strings.\n2. For 10 iterations or until the secret word is guessed:\n  a. Randomly select a word (`guess`) from the `wordlist`.\n  b. Call `Master.guess` with the `guess`, and store the number of exact matches in `match_cnt`.\n  c. If the `match_cnt` equals 6 (i.e., the word is guessed), terminate the loop.\n  d. Filter the `wordlist` to keep only those words that have the same number of exact matches with the `guess` as `match_cnt`.\n3. Complete the loop and return.\n    ", "python": "\n    ```python\nimport random\n\ndef match(a, b):\n    return sum(a[i] == b[i] for i in range(6))\n\ndef find_secret_word(wordlist, master):\n    for _ in range(10):\n        guess = random.choice(wordlist)\n        match_cnt = master.guess(guess)\n        if match_cnt == 6:\n            return\n        wordlist = [word for word in wordlist if match(word, guess) == match_cnt]\n```\n    \n    1. Define a `match` function to calculate the number of exact matches between two strings.\n2. For 10 iterations or until the secret word is guessed:\n  a. Randomly select a word (`guess`) from the `wordlist`.\n  b. Call `Master.guess` with the `guess`, and store the number of exact matches in `match_cnt`.\n  c. If the `match_cnt` equals 6 (i.e., the word is guessed), terminate the loop.\n  d. Filter the `wordlist` to keep only those words that have the same number of exact matches with the `guess` as `match_cnt`.\n3. Complete the loop and return.\n    ", "javascript": "\n    ```javascript\nfunction match(a, b) {\n    let matches = 0;\n    for (let i = 0; i < 6; ++i)\n        if (a[i] == b[i]) matches++;\n    return matches;\n}\n\nfunction findSecretWord(wordlist, master) {\n    let n = wordlist.length;\n    for (let i = 0, matchCnt = 0; i < 10 && matchCnt < 6; ++i) {\n        let guess = wordlist[Math.floor(Math.random() * n)];\n        matchCnt = master.guess(guess);\n        let candidates = [];\n        for (const word of wordlist)\n            if (match(word, guess) == matchCnt)\n                candidates.push(word);\n        wordlist = candidates;\n        n = wordlist.length;\n    }\n}\n```\n    \n    1. Define a `match` function to calculate the number of exact matches between two strings.\n2. For 10 iterations or until the secret word is guessed:\n  a. Randomly select a word (`guess`) from the `wordlist`.\n  b. Call `Master.guess` with the `guess`, and store the number of exact matches in `match_cnt`.\n  c. If the `match_cnt` equals 6 (i.e., the word is guessed), terminate the loop.\n  d. Filter the `wordlist` to keep only those words that have the same number of exact matches with the `guess` as `match_cnt`.\n3. Complete the loop and return.\n    "}
{"id": 877, "slug": "stone-game", "title": "Stone Game", "difficulty": "Medium", "content": "Alice and Bob play a game with piles of stones. There are an **even** number of piles arranged in a row, and each pile has a **positive** integer number of stones `piles[i]`.\n\nThe objective of the game is to end with the most stones. The **total** number of stones across all the piles is **odd**, so there are no ties.\n\nAlice and Bob take turns, with **Alice starting first**. Each turn, a player takes the entire pile of stones either from the **beginning** or from the **end** of the row. This continues until there are no more piles left, at which point the person with the **most stones wins**.\n\nAssuming Alice and Bob play optimally, return `true` _if Alice wins the game, or_ `false` _if Bob wins_.\n\n**Example 1:**\n\n**Input:** piles = \\[5,3,4,5\\]\n**Output:** true\n**Explanation:** \nAlice starts first, and can only take the first 5 or the last 5.\nSay she takes the first 5, so that the row becomes \\[3, 4, 5\\].\nIf Bob takes 3, then the board is \\[4, 5\\], and Alice takes 5 to win with 10 points.\nIf Bob takes the last 5, then the board is \\[3, 4\\], and Alice takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alice, so we return true.\n\n**Example 2:**\n\n**Input:** piles = \\[3,7,2,3\\]\n**Output:** true\n\n**Constraints:**\n\n*   `2 <= piles.length <= 500`\n*   `piles.length` is **even**.\n*   `1 <= piles[i] <= 500`\n*   `sum(piles[i])` is **odd**.", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int shortestPathLength(int[][] graph) {\n        int n = graph.length;\n        Queue<int[]> q = new LinkedList<>();\n        \n        for(int i = 0; i < n; i++) {\n            q.add(new int[]{i, 1 << i});\n        }\n        int steps = -1;\n        boolean[][] visited = new boolean[n][1 << n];\n        \n        while(!q.isEmpty()) {\n            steps++;\n            int size = q.size();\n            \n            for(int k = 0; k < size; k++) {\n                int[] curr = q.poll();\n                int currNode = curr[0];\n                int currVisits = curr[1];\n\n                if(Integer.bitCount(currVisits) == n) return steps;\n                \n                for(int nextNode: graph[currNode]) {\n                    int nextVisits = currVisits | (1 << nextNode);\n                    \n                    if(!visited[nextNode][nextVisits]) {\n                        visited[nextNode][nextVisits] = true;\n                        q.add(new int[]{nextNode, nextVisits});\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n}\n```\n\n    \n    We will solve this problem using Breadth-First Search (BFS) algorithm with some modifications to account for visited nodes and edges. The basic idea is to start from every node, explore adjacent nodes in each step, and keep track of visited nodes and edges.\n\nFor each node, we will maintain a bitmask representing the visited nodes so far. We will create a queue data structure that will store the node along with its bitmask. Initially, push all nodes to the queue, each having only their own bit set in their bitmask.\n\nNow, we perform the BFS algorithm. For the nodes in the current level of the queue, we retrieve the node and its bitmask. If the total number of set bits (1's) in the bitmask equals the total number of nodes (`n`), we return the current iteration counter as the shortest path length.\n\nOtherwise, for each adjacent node, find the updated bitmask after visiting this neighbor by performing a bitwise OR operation with the current bitmask. If the updated bitmask for the neighbor hasn't been visited before, mark it as visited, and enqueue the neighbor with updated bitmask.\n\nRepeat this process until the queue is empty or we find the shortest path length. If the queue becomes empty, return -1 as the result.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\nint shortestPathLength(vector<vector<int>>& graph) {\n    int n = graph.size();\n    queue<pair<int, bitset<12>>> q;\n    \n    for(int i = 0; i < n; i++) {\n        q.push({i, 1 << i});\n    }\n    int steps = -1;\n    vector<vector<bool>> visited(n, vector<bool>(1 << n));\n    \n    while(!q.empty()) {\n        steps++;\n        int size = q.size();\n        \n        for(int k = 0; k < size; k++) {\n            int currNode = q.front().first;\n            bitset<12> currVisits = q.front().second;\n            q.pop();\n            \n            if(currVisits.count() == n) return steps;\n            \n            for(int nextNode: graph[currNode]) {\n                bitset<12> nextVisits = currVisits;\n                nextVisits.set(nextNode);\n                \n                if(!visited[nextNode][nextVisits.to_ulong()]) {\n                    visited[nextNode][nextVisits.to_ulong()] = true;\n                    q.push({nextNode, nextVisits});\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n```\n\n    \n    We will solve this problem using Breadth-First Search (BFS) algorithm with some modifications to account for visited nodes and edges. The basic idea is to start from every node, explore adjacent nodes in each step, and keep track of visited nodes and edges.\n\nFor each node, we will maintain a bitmask representing the visited nodes so far. We will create a queue data structure that will store the node along with its bitmask. Initially, push all nodes to the queue, each having only their own bit set in their bitmask.\n\nNow, we perform the BFS algorithm. For the nodes in the current level of the queue, we retrieve the node and its bitmask. If the total number of set bits (1's) in the bitmask equals the total number of nodes (`n`), we return the current iteration counter as the shortest path length.\n\nOtherwise, for each adjacent node, find the updated bitmask after visiting this neighbor by performing a bitwise OR operation with the current bitmask. If the updated bitmask for the neighbor hasn't been visited before, mark it as visited, and enqueue the neighbor with updated bitmask.\n\nRepeat this process until the queue is empty or we find the shortest path length. If the queue becomes empty, return -1 as the result.\n    ", "python": "\n    ```python\nfrom collections import deque, defaultdict\n\ndef shortestPathLength(graph):\n    n = len(graph)\n    q = deque()\n    \n    for i in range(n):\n        q.append((i, 1 << i))\n    steps = -1\n    visited = {i: set() for i in range(n)}\n    \n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            currNode, currVisits = q.popleft()\n            \n            if bin(currVisits).count('1') == n:\n                return steps\n\n            for nextNode in graph[currNode]:\n                nextVisits = currVisits | (1 << nextNode)\n\n                if nextVisits not in visited[nextNode]:\n                    visited[nextNode].add(nextVisits)\n                    q.append((nextNode, nextVisits))\n\n    return -1\n```\n\n    \n    We will solve this problem using Breadth-First Search (BFS) algorithm with some modifications to account for visited nodes and edges. The basic idea is to start from every node, explore adjacent nodes in each step, and keep track of visited nodes and edges.\n\nFor each node, we will maintain a bitmask representing the visited nodes so far. We will create a queue data structure that will store the node along with its bitmask. Initially, push all nodes to the queue, each having only their own bit set in their bitmask.\n\nNow, we perform the BFS algorithm. For the nodes in the current level of the queue, we retrieve the node and its bitmask. If the total number of set bits (1's) in the bitmask equals the total number of nodes (`n`), we return the current iteration counter as the shortest path length.\n\nOtherwise, for each adjacent node, find the updated bitmask after visiting this neighbor by performing a bitwise OR operation with the current bitmask. If the updated bitmask for the neighbor hasn't been visited before, mark it as visited, and enqueue the neighbor with updated bitmask.\n\nRepeat this process until the queue is empty or we find the shortest path length. If the queue becomes empty, return -1 as the result.\n    ", "javascript": "\n    ```javascript\nfunction shortestPathLength(graph) {\n    const n = graph.length;\n    const q = [];\n    \n    for(let i = 0; i < n; i++) {\n        q.push([i, 1 << i]);\n    }\n    let steps = -1;\n    const visited = Array.from({length: n}, () => Array(1 << n).fill(false));\n    \n    while(q.length > 0) {\n        steps++;\n        const size = q.length;\n        \n        for(let k = 0; k < size; k++) {\n            const [currNode, currVisits] = q.shift();\n\n            if(currVisits.toString(2).split('').filter(v => v === '1').length === n) return steps;\n            \n            for(const nextNode of graph[currNode]) {\n                const nextVisits = currVisits | (1 << nextNode);\n                \n                if(!visited[nextNode][nextVisits]) {\n                    visited[nextNode][nextVisits] = true;\n                    q.push([nextNode, nextVisits]);\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n```\n\n    \n    We will solve this problem using Breadth-First Search (BFS) algorithm with some modifications to account for visited nodes and edges. The basic idea is to start from every node, explore adjacent nodes in each step, and keep track of visited nodes and edges.\n\nFor each node, we will maintain a bitmask representing the visited nodes so far. We will create a queue data structure that will store the node along with its bitmask. Initially, push all nodes to the queue, each having only their own bit set in their bitmask.\n\nNow, we perform the BFS algorithm. For the nodes in the current level of the queue, we retrieve the node and its bitmask. If the total number of set bits (1's) in the bitmask equals the total number of nodes (`n`), we return the current iteration counter as the shortest path length.\n\nOtherwise, for each adjacent node, find the updated bitmask after visiting this neighbor by performing a bitwise OR operation with the current bitmask. If the updated bitmask for the neighbor hasn't been visited before, mark it as visited, and enqueue the neighbor with updated bitmask.\n\nRepeat this process until the queue is empty or we find the shortest path length. If the queue becomes empty, return -1 as the result.\n    "}
{"id": 879, "slug": "profitable-schemes", "title": "Profitable Schemes", "difficulty": "Hard", "content": "There is a group of `n` members, and a list of various crimes they could commit. The `ith` crime generates a `profit[i]` and requires `group[i]` members to participate in it. If a member participates in one crime, that member can't participate in another crime.\n\nLet's call a **profitable scheme** any subset of these crimes that generates at least `minProfit` profit, and the total number of members participating in that subset of crimes is at most `n`.\n\nReturn the number of schemes that can be chosen. Since the answer may be very large, **return it modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 5, minProfit = 3, group = \\[2,2\\], profit = \\[2,3\\]\n**Output:** 2\n**Explanation:** To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1.\nIn total, there are 2 schemes.\n\n**Example 2:**\n\n**Input:** n = 10, minProfit = 5, group = \\[2,3,5\\], profit = \\[6,7,8\\]\n**Output:** 7\n**Explanation:** To make a profit of at least 5, the group could commit any crimes, as long as they commit one.\nThere are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).\n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `0 <= minProfit <= 100`\n*   `1 <= group.length <= 100`\n*   `1 <= group[i] <= 100`\n*   `profit.length == group.length`\n*   `0 <= profit[i] <= 100`", "java": "\n    ```java\npublic int maxDistToClosest(int[] seats) {\n    int maxDist = 0, lastPerson = -1;\n    for (int i = 0; i < seats.length; ++i) {\n        if (seats[i] == 1) {\n            maxDist = lastPerson < 0 ? i : Math.max(maxDist, (i - lastPerson) / 2);\n            lastPerson = i;\n        }\n    }\n    return Math.max(maxDist, seats.length - 1 - lastPerson);\n}\n```\n    \n    First, initialize `max_dist` to store the maximum distance encountered and `last_person` to store the index of the last person found in the array. Iterate through the array of `seats`, for each person encountered (seats[i] == 1), calculate the distance between the current index and the last person, divide it by 2, and update `max_dist` with the maximum of its current value, the distance calculated or the index (i) if it's the first person found. Update the last person index to the current index (i). Once the iteration is complete, return the maximum of `max_dist` and the distance between the last person and the end of the array.\n    ", "c++": "\n    ```cpp\nint maxDistToClosest(vector<int>& seats) {\n    int max_dist = 0, last_person = -1;\n    for (int i = 0; i < seats.size(); ++i) {\n        if (seats[i] == 1) {\n            max_dist = last_person < 0 ? i : max(max_dist, (i - last_person) / 2);\n            last_person = i;\n        }\n    }\n    return max(max_dist, (int)(seats.size() - 1 - last_person));\n}\n```\n    \n    First, initialize `max_dist` to store the maximum distance encountered and `last_person` to store the index of the last person found in the array. Iterate through the array of `seats`, for each person encountered (seats[i] == 1), calculate the distance between the current index and the last person, divide it by 2, and update `max_dist` with the maximum of its current value, the distance calculated or the index (i) if it's the first person found. Update the last person index to the current index (i). Once the iteration is complete, return the maximum of `max_dist` and the distance between the last person and the end of the array.\n    ", "python": "\n    ```python\ndef max_dist_to_closest(seats):\n    max_dist = 0\n    last_person = -1\n    for i, seat in enumerate(seats):\n        if seat == 1:\n            max_dist = i if last_person < 0 else max(max_dist, (i - last_person) // 2)\n            last_person = i\n    return max(max_dist, len(seats) - 1 - last_person)\n```\n    \n    First, initialize `max_dist` to store the maximum distance encountered and `last_person` to store the index of the last person found in the array. Iterate through the array of `seats`, for each person encountered (seats[i] == 1), calculate the distance between the current index and the last person, divide it by 2, and update `max_dist` with the maximum of its current value, the distance calculated or the index (i) if it's the first person found. Update the last person index to the current index (i). Once the iteration is complete, return the maximum of `max_dist` and the distance between the last person and the end of the array.\n    ", "javascript": "\n    ```javascript\nfunction maxDistToClosest(seats) {\n    let maxDist = 0, lastPerson = -1;\n    for (let i = 0; i < seats.length; ++i) {\n        if (seats[i] == 1) {\n            maxDist = lastPerson < 0 ? i : Math.max(maxDist, ((i - lastPerson) / 2) | 0);\n            lastPerson = i;\n        }\n    }\n    return Math.max(maxDist, seats.length - 1 - lastPerson);\n}\n```\n    \n    First, initialize `max_dist` to store the maximum distance encountered and `last_person` to store the index of the last person found in the array. Iterate through the array of `seats`, for each person encountered (seats[i] == 1), calculate the distance between the current index and the last person, divide it by 2, and update `max_dist` with the maximum of its current value, the distance calculated or the index (i) if it's the first person found. Update the last person index to the current index (i). Once the iteration is complete, return the maximum of `max_dist` and the distance between the last person and the end of the array.\n    "}
{"id": 887, "slug": "super-egg-drop", "title": "Super Egg Drop", "difficulty": "Hard", "content": "You are given `k` identical eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n\nYou know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor **higher** than `f` will **break**, and any egg dropped **at or below** floor `f` will **not break**.\n\nEach move, you may take an unbroken egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may **reuse** it in future moves.\n\nReturn _the **minimum number of moves** that you need to determine **with certainty** what the value of_ `f` is.\n\n**Example 1:**\n\n**Input:** k = 1, n = 2\n**Output:** 2\n**Explanation:** \nDrop the egg from floor 1. If it breaks, we know that f = 0.\nOtherwise, drop the egg from floor 2. If it breaks, we know that f = 1.\nIf it does not break, then we know f = 2.\nHence, we need at minimum 2 moves to determine with certainty what the value of f is.\n\n**Example 2:**\n\n**Input:** k = 2, n = 6\n**Output:** 3\n\n**Example 3:**\n\n**Input:** k = 3, n = 14\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= k <= 100`\n*   `1 <= n <= 104`", "java": "\n    ```java\nimport java.util.PriorityQueue;\nimport java.util.Arrays;\n\npublic double mincostToHireWorkers(int[] quality, int[] wage, int K) {\n    int N = quality.length;\n    double[][] workers = new double[N][2];\n    for (int i = 0; i < N; ++i)\n        workers[i] = new double[] {(double) wage[i] / quality[i], (double) quality[i]};\n\n    Arrays.sort(workers, (a, b) -> Double.compare(a[0], b[0]));\n\n    double ans = 1e60;\n    int sumq = 0;\n    PriorityQueue<Integer> pool = new PriorityQueue<>((a, b) -> -Integer.compare(a, b));\n    for (double[] worker: workers) {\n        pool.offer((int) worker[1]);\n        sumq += worker[1];\n\n        if (pool.size() > K)\n            sumq -= pool.poll();\n\n        if (pool.size() == K)\n            ans = Math.min(ans, worker[0] * sumq);\n    }\n\n    return ans;\n}\n```\n    \n    We represent each worker as a pair of `(wage / quality, quality)`. We sort these workers based on the wage-to-quality ratio, making it easier to track the cost of hiring each worker. The algorithm maintains a priority queue, which is initially empty. The total quality sum starts at 0. \n\nWe iterate through the sorted workers, for each worker:\n1. Add their quality value to the max heap and increment the total quality sum.\n2. If max heap size is greater than `k`, we subtract the largest quality value from the sum and pop it from the max heap.\n3. If max heap size equals `k`, we update the result with the minimum of the current result and the product of the total quality sum and the current worker's wage-to-quality ratio.\n\nFinally, we return the lowest cost.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n\ndouble mincostToHireWorkers(std::vector<int>& quality, std::vector<int>& wage, int k) {\n    std::vector<std::pair<double, int>> workers;\n    for (int i = 0; i < quality.size(); i++) {\n        workers.emplace_back((double)wage[i] / quality[i], quality[i]);\n    }\n    std::sort(workers.begin(), workers.end());\n    \n    int sum_quality = 0;\n    double result = 1e60;\n    std::priority_queue<int> pq;\n    \n    for (auto [ratio, q] : workers) {\n        sum_quality += q;\n        pq.push(q);\n        \n        if (pq.size() > k) {\n            sum_quality -= pq.top();\n            pq.pop();\n        }\n        \n        if (pq.size() == k) {\n            result = std::min(result, ratio * sum_quality);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    We represent each worker as a pair of `(wage / quality, quality)`. We sort these workers based on the wage-to-quality ratio, making it easier to track the cost of hiring each worker. The algorithm maintains a priority queue, which is initially empty. The total quality sum starts at 0. \n\nWe iterate through the sorted workers, for each worker:\n1. Add their quality value to the max heap and increment the total quality sum.\n2. If max heap size is greater than `k`, we subtract the largest quality value from the sum and pop it from the max heap.\n3. If max heap size equals `k`, we update the result with the minimum of the current result and the product of the total quality sum and the current worker's wage-to-quality ratio.\n\nFinally, we return the lowest cost.\n    ", "python": "\n    ```python\nimport heapq\n\ndef mincost_to_hire_workers(quality, wage, k):\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    max_heap = []\n    result = float(\"inf\")\n\n    for ratio, q in workers:\n        heapq.heappush(max_heap, -q)\n        total_quality += q\n\n        if len(max_heap) > k:\n            total_quality += heapq.heappop(max_heap)\n\n        if len(max_heap) == k:\n            result = min(result, total_quality * ratio)\n\n    return result\n```\n    \n    We represent each worker as a pair of `(wage / quality, quality)`. We sort these workers based on the wage-to-quality ratio, making it easier to track the cost of hiring each worker. The algorithm maintains a priority queue, which is initially empty. The total quality sum starts at 0. \n\nWe iterate through the sorted workers, for each worker:\n1. Add their quality value to the max heap and increment the total quality sum.\n2. If max heap size is greater than `k`, we subtract the largest quality value from the sum and pop it from the max heap.\n3. If max heap size equals `k`, we update the result with the minimum of the current result and the product of the total quality sum and the current worker's wage-to-quality ratio.\n\nFinally, we return the lowest cost.\n    ", "javascript": "\n    ```javascript\nfunction mincostToHireWorkers(quality, wage, K) {\n    const workers = Array.from({length: quality.length}, (_, i) => [\n        wage[i] / quality[i], quality[i],\n    ]).sort((a, b) => a[0] - b[0]);\n\n    let sumQuality = 0;\n    const maxHeap = new MaxHeap(comparator);\n\n    let result = Infinity;\n    for (const [ratio, q] of workers) {\n        maxHeap.add(q);\n        sumQuality += q;\n\n        if (maxHeap.size() > K) {\n            sumQuality -= maxHeap.pop();\n        }\n\n        if (maxHeap.size() === K) {\n            result = Math.min(result, ratio * sumQuality);\n        }\n    }\n\n    return result;\n}\n\nclass MaxHeap {\n    constructor(comparator) {\n        this._heap = [];\n        this._comparator = comparator;\n    }\n\n    add(value) {\n        this._heap.push(value);\n        this.bubbleUp(this.size() - 1);\n    }\n\n    pop() {\n        if (this.isEmpty()) return undefined;\n\n        this.swap(0, this.size() - 1);\n        const result = this._heap.pop();\n        this.bubbleDown(0);\n        return result;\n    }\n\n    size() {\n        return this._heap.length;\n    }\n\n    isEmpty() {\n        return this._heap.length === 0;\n    }\n\n    bubbleUp(index) {\n        const parent = this.parent(index);\n        if (parent >= 0 && this._compare(parent, index)) {\n            this.swap(parent, index);\n            this.bubbleUp(parent);\n        }\n    }\n\n    bubbleDown(index) {\n        const largest = this.maxChildIndex(index);\n        if (largest !== -1 && this._compare(index, largest)) {\n            this.swap(index, largest);\n            this.bubbleDown(largest);\n        }\n    }\n\n    parent(index) {\n        return index <= 0 ? -1 : Math.floor((index - 1) / 2);\n    }\n\n    maxChildIndex(index) {\n        const left = index * 2 + 1;\n        const right = index * 2 + 2;\n        if (left >= this.size()) return -1;\n\n        if (right >= this.size()) return left;\n\n        return this._compare(left, right) ? right : left;\n    }\n\n    swap(i, j) {\n        [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];\n    }\n\n    _compare(i, j) {\n        return this._comparator(this._heap[i], this._heap[j]);\n    }\n}\n\nfunction comparator(a, b) {\n    return a < b;\n}\n```\n    \n    We represent each worker as a pair of `(wage / quality, quality)`. We sort these workers based on the wage-to-quality ratio, making it easier to track the cost of hiring each worker. The algorithm maintains a priority queue, which is initially empty. The total quality sum starts at 0. \n\nWe iterate through the sorted workers, for each worker:\n1. Add their quality value to the max heap and increment the total quality sum.\n2. If max heap size is greater than `k`, we subtract the largest quality value from the sum and pop it from the max heap.\n3. If max heap size equals `k`, we update the result with the minimum of the current result and the product of the total quality sum and the current worker's wage-to-quality ratio.\n\nFinally, we return the lowest cost.\n    "}
{"id": 894, "slug": "all-possible-full-binary-trees", "title": "All Possible Full Binary Trees", "difficulty": "Medium", "content": "Given an integer `n`, return _a list of all possible **full binary trees** with_ `n` _nodes_. Each node of each tree in the answer must have `Node.val == 0`.\n\nEach element of the answer is the root node of one possible tree. You may return the final list of trees in **any order**.\n\nA **full binary tree** is a binary tree where each node has exactly `0` or `2` children.\n\n**Example 1:**\n\n**Input:** n = 7\n**Output:** \\[\\[0,0,0,null,null,0,0,null,null,0,0\\],\\[0,0,0,null,null,0,0,0,0\\],\\[0,0,0,0,0,0,0\\],\\[0,0,0,0,0,null,null,null,null,0,0\\],\\[0,0,0,0,0,null,null,0,0\\]\\]\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** \\[\\[0,0,0\\]\\]\n\n**Constraints:**\n\n*   `1 <= n <= 20`", "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Random;\n\nclass Solution {\n    HashMap<Integer, Integer> blacklistMap;\n    int reducedN;\n    Random rand = new Random();\n\n    public Solution(int n, int[] blacklist) {\n        blacklistMap = new HashMap<>();\n        for (int b : blacklist) {\n            if (b < n) {\n                blacklistMap.put(b, -1);\n            }\n        }\n        reducedN = n - blacklistMap.size();\n\n        for (int b : blacklist) {\n            if (b >= reducedN) continue;\n            while (blacklistMap.containsKey(--n)) {}\n            blacklistMap.put(b, n);\n        }\n    }\n\n    public int pick() {\n        int randomInt = rand.nextInt(reducedN);\n        return blacklistMap.getOrDefault(randomInt, randomInt);\n    }\n}\n```\n    \n    The main idea of the algorithm is to create a mapping from each blacklisted value to a legal value, while searching for legal values with decreasing indices.\n\n1. Start by placing each blacklisted number less than `n` in a mapping, `blacklist_map`, with a value of `-1`.\n2. Calculate the reduced number of possible values, `reduced_n`, as the total range `n` minus the size of the `blacklist_map`.\n3. Iterate through the blacklist again, but this time check if each blacklisted number is less than `reduced_n`. If it is not, there is no need to find a legal value.\n4. When searching for a legal value, decrement `n` until we find a value that is not in the `blacklist_map`. Then, replace the blacklisted number in the map with this legal value.\n5. Finally, we can implement the random pick function to choose a value in the range `[0, reduced_n - 1]`. If the random pick corresponds to a blacklisted value in the `blacklist_map`, return the mapped legal value. If it is not a blacklisted value, return the pick directly. \n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n#include <random>\n\nclass Solution {\npublic:\n    std::unordered_map<int, int> blacklist_map;\n    int reduced_n;\n\n    Solution(int n, std::vector<int>& blacklist) {\n        for (int b : blacklist) {\n            if (b < n) {\n                blacklist_map[b] = -1;\n            }\n        }\n        reduced_n = n - blacklist_map.size();\n\n        for (int b : blacklist) {\n            if (b >= reduced_n) continue;\n            while (blacklist_map.count(--n)) {}\n            blacklist_map[b] = n;\n        } \n    }\n\n    int pick() {\n        int random_int = rand() % reduced_n;\n        if (blacklist_map.count(random_int)) {\n            return blacklist_map[random_int];\n        }\n        return random_int;\n    }\n};\n```\n    \n    The main idea of the algorithm is to create a mapping from each blacklisted value to a legal value, while searching for legal values with decreasing indices.\n\n1. Start by placing each blacklisted number less than `n` in a mapping, `blacklist_map`, with a value of `-1`.\n2. Calculate the reduced number of possible values, `reduced_n`, as the total range `n` minus the size of the `blacklist_map`.\n3. Iterate through the blacklist again, but this time check if each blacklisted number is less than `reduced_n`. If it is not, there is no need to find a legal value.\n4. When searching for a legal value, decrement `n` until we find a value that is not in the `blacklist_map`. Then, replace the blacklisted number in the map with this legal value.\n5. Finally, we can implement the random pick function to choose a value in the range `[0, reduced_n - 1]`. If the random pick corresponds to a blacklisted value in the `blacklist_map`, return the mapped legal value. If it is not a blacklisted value, return the pick directly. \n    ", "python": "\n    ```python\nimport random\n\nclass Solution:\n\n    def __init__(self, n: int, blacklist: List[int]):\n        self.blacklist_map = {}\n        self.reduced_n = n - len(blacklist)\n\n        for b in blacklist:\n            if b < n:\n                self.blacklist_map[b] = -1\n\n        for b in blacklist:\n            if b >= self.reduced_n:\n                continue\n            while n - 1 in self.blacklist_map:\n                n -= 1\n            self.blacklist_map[b] = n - 1\n            n -= 1\n\n    def pick(self) -> int:\n        random_int = random.randint(0, self.reduced_n - 1)\n        return self.blacklist_map.get(random_int, random_int)\n```\n    \n    The main idea of the algorithm is to create a mapping from each blacklisted value to a legal value, while searching for legal values with decreasing indices.\n\n1. Start by placing each blacklisted number less than `n` in a mapping, `blacklist_map`, with a value of `-1`.\n2. Calculate the reduced number of possible values, `reduced_n`, as the total range `n` minus the size of the `blacklist_map`.\n3. Iterate through the blacklist again, but this time check if each blacklisted number is less than `reduced_n`. If it is not, there is no need to find a legal value.\n4. When searching for a legal value, decrement `n` until we find a value that is not in the `blacklist_map`. Then, replace the blacklisted number in the map with this legal value.\n5. Finally, we can implement the random pick function to choose a value in the range `[0, reduced_n - 1]`. If the random pick corresponds to a blacklisted value in the `blacklist_map`, return the mapped legal value. If it is not a blacklisted value, return the pick directly. \n    ", "javascript": "\n    ```javascript\nclass Solution {\n    constructor(n, blacklist) {\n        this.blacklistMap = new Map();\n        this.reducedN = n - blacklist.length;\n        \n        for (let b of blacklist) {\n            if (b < n) {\n                this.blacklistMap.set(b, -1);\n            }\n        }\n\n        for (let b of blacklist) {\n            if (b >= this.reducedN) continue;\n            while (this.blacklistMap.has(--n)) {}\n            this.blacklistMap.set(b, n);\n        }\n    }\n\n    pick() {\n        const randomInt = Math.floor(Math.random() * this.reducedN);\n        return this.blacklistMap.has(randomInt) ? this.blacklistMap.get(randomInt) : randomInt;\n    }\n}\n```\n    \n    The main idea of the algorithm is to create a mapping from each blacklisted value to a legal value, while searching for legal values with decreasing indices.\n\n1. Start by placing each blacklisted number less than `n` in a mapping, `blacklist_map`, with a value of `-1`.\n2. Calculate the reduced number of possible values, `reduced_n`, as the total range `n` minus the size of the `blacklist_map`.\n3. Iterate through the blacklist again, but this time check if each blacklisted number is less than `reduced_n`. If it is not, there is no need to find a legal value.\n4. When searching for a legal value, decrement `n` until we find a value that is not in the `blacklist_map`. Then, replace the blacklisted number in the map with this legal value.\n5. Finally, we can implement the random pick function to choose a value in the range `[0, reduced_n - 1]`. If the random pick corresponds to a blacklisted value in the `blacklist_map`, return the mapped legal value. If it is not a blacklisted value, return the pick directly. \n    "}
{"id": 898, "slug": "bitwise-ors-of-subarrays", "title": "Bitwise ORs of Subarrays", "difficulty": "Medium", "content": "Given an integer array `arr`, return _the number of distinct bitwise ORs of all the non-empty subarrays of_ `arr`.\n\nThe bitwise OR of a subarray is the bitwise OR of each integer in the subarray. The bitwise OR of a subarray of one integer is that integer.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\n**Example 1:**\n\n**Input:** arr = \\[0\\]\n**Output:** 1\n**Explanation:** There is only one possible result: 0.\n\n**Example 2:**\n\n**Input:** arr = \\[1,1,2\\]\n**Output:** 3\n**Explanation:** The possible subarrays are \\[1\\], \\[1\\], \\[2\\], \\[1, 1\\], \\[1, 2\\], \\[1, 1, 2\\].\nThese yield the results 1, 1, 2, 1, 3, 3.\nThere are 3 unique values, so the answer is 3.\n\n**Example 3:**\n\n**Input:** arr = \\[1,2,4\\]\n**Output:** 6\n**Explanation:** The possible results are 1, 2, 3, 4, 6, and 7.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 5 * 104`\n*   `0 <= arr[i] <= 109`", "java": "\n    ```java\npublic int[][] transpose(int[][] matrix) {\n    int rows = matrix.length;\n    int cols = matrix[0].length;\n    int[][] result = new int[cols][rows];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm for finding the transpose of a matrix involves first creating an empty matrix with the number of rows and columns swapped. Then, iterate through each element of the input matrix and copy its value to the corresponding reversed row and column index in the new matrix. By switching the row and column indices while copying elements, we effectively flip the matrix over its main diagonal.\n    ", "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nvector<vector<int>> transpose(vector<vector<int>>& matrix) {\n    int rows = matrix.size();\n    int cols = matrix[0].size();\n    vector<vector<int>> result(cols, vector<int>(rows));\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm for finding the transpose of a matrix involves first creating an empty matrix with the number of rows and columns swapped. Then, iterate through each element of the input matrix and copy its value to the corresponding reversed row and column index in the new matrix. By switching the row and column indices while copying elements, we effectively flip the matrix over its main diagonal.\n    ", "python": "\n    ```python\ndef transpose(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    result = [[0] * rows for _ in range(cols)]\n    for i in range(rows):\n        for j in range(cols):\n            result[j][i] = matrix[i][j]\n    return result\n```\n    \n    The algorithm for finding the transpose of a matrix involves first creating an empty matrix with the number of rows and columns swapped. Then, iterate through each element of the input matrix and copy its value to the corresponding reversed row and column index in the new matrix. By switching the row and column indices while copying elements, we effectively flip the matrix over its main diagonal.\n    ", "javascript": "\n    ```javascript\nfunction transpose(matrix) {\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    const result = Array.from({ length: cols }, () => Array(rows));\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm for finding the transpose of a matrix involves first creating an empty matrix with the number of rows and columns swapped. Then, iterate through each element of the input matrix and copy its value to the corresponding reversed row and column index in the new matrix. By switching the row and column indices while copying elements, we effectively flip the matrix over its main diagonal.\n    "}
{"id": 902, "slug": "numbers-at-most-n-given-digit-set", "title": "Numbers At Most N Given Digit Set", "difficulty": "Hard", "content": "Given an array of `digits` which is sorted in **non-decreasing** order. You can write numbers using each `digits[i]` as many times as we want. For example, if `digits = ['1','3','5']`, we may write numbers such as `'13'`, `'551'`, and `'1351315'`.\n\nReturn _the number of positive integers that can be generated_ that are less than or equal to a given integer `n`.\n\n**Example 1:**\n\n**Input:** digits = \\[ \"1 \", \"3 \", \"5 \", \"7 \"\\], n = 100\n**Output:** 20\n**Explanation:** \nThe 20 numbers that can be written are:\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n\n**Example 2:**\n\n**Input:** digits = \\[ \"1 \", \"4 \", \"9 \"\\], n = 1000000000\n**Output:** 29523\n**Explanation:** \nWe can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,\n81 four digit numbers, 243 five digit numbers, 729 six digit numbers,\n2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.\nIn total, this is 29523 integers that can be written using the digits array.\n\n**Example 3:**\n\n**Input:** digits = \\[ \"7 \"\\], n = 8\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= digits.length <= 9`\n*   `digits[i].length == 1`\n*   `digits[i]` is a digit from `'1'` to `'9'`.\n*   All the values in `digits` are **unique**.\n*   `digits` is sorted in **non-decreasing** order.\n*   `1 <= n <= 109`", "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int minRefuelStops(int target, int startFuel, int[][] stations) {\n    int i = 0, stops = 0, curFuel = startFuel;\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n    while (curFuel < target) {\n        while (i < stations.length && stations[i][0] <= curFuel) {\n            pq.offer(stations[i][1]);\n            i++;\n        }\n        if (pq.isEmpty()) return -1;\n        curFuel += pq.poll();\n        stops++;\n    }\n    return stops;\n}\n```\n\n    \n    1. Initialize a variable `stops` to store the number of refueling stops made, `curFuel` to save the current fuel, and a max heap (priority queue) `pq` to store the gas station capacities encountered along the way.\n2. While `curFuel` is not sufficient to reach the target, perform the following steps:\n   a. Loop through the gas stations that can be reached from the current fuel, add their fuel capacity to the priority queue, and increment the station index.\n   b. If the priority queue is empty, it means no gas station can be reached, so return -1.\n   c. Add the maximum fuel capacity from the priority queue (the top value) to the `curFuel` and remove it from the priority queue.\n   d. Increment the `stops` variable.\n3. When the loop ends and the car has enough `curFuel` to reach the target, return the number of `stops`.\n    ", "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\n    int i = 0, stops = 0, curFuel = startFuel;\n    priority_queue<int> pq;\n    while (curFuel < target) {\n        while (i < stations.size() && stations[i][0] <= curFuel) {\n            pq.push(stations[i][1]);\n            i++;\n        }\n        if (pq.empty()) return -1;\n        curFuel += pq.top();\n        pq.pop();\n        stops++;\n    }\n    return stops;\n}\n```\n\n    \n    1. Initialize a variable `stops` to store the number of refueling stops made, `curFuel` to save the current fuel, and a max heap (priority queue) `pq` to store the gas station capacities encountered along the way.\n2. While `curFuel` is not sufficient to reach the target, perform the following steps:\n   a. Loop through the gas stations that can be reached from the current fuel, add their fuel capacity to the priority queue, and increment the station index.\n   b. If the priority queue is empty, it means no gas station can be reached, so return -1.\n   c. Add the maximum fuel capacity from the priority queue (the top value) to the `curFuel` and remove it from the priority queue.\n   d. Increment the `stops` variable.\n3. When the loop ends and the car has enough `curFuel` to reach the target, return the number of `stops`.\n    ", "python": "\n    ```python\nimport heapq\n\ndef minRefuelStops(target: int, startFuel: int, stations: List[List[int]]) -> int:\n    i, stops, curFuel = 0, 0, startFuel\n    pq = []\n    while curFuel < target:\n        while i < len(stations) and stations[i][0] <= curFuel:\n            heapq.heappush(pq, -stations[i][1])\n            i += 1\n        if not pq: return -1\n        curFuel += -heapq.heappop(pq)\n        stops += 1\n    return stops\n```\n\n    \n    1. Initialize a variable `stops` to store the number of refueling stops made, `curFuel` to save the current fuel, and a max heap (priority queue) `pq` to store the gas station capacities encountered along the way.\n2. While `curFuel` is not sufficient to reach the target, perform the following steps:\n   a. Loop through the gas stations that can be reached from the current fuel, add their fuel capacity to the priority queue, and increment the station index.\n   b. If the priority queue is empty, it means no gas station can be reached, so return -1.\n   c. Add the maximum fuel capacity from the priority queue (the top value) to the `curFuel` and remove it from the priority queue.\n   d. Increment the `stops` variable.\n3. When the loop ends and the car has enough `curFuel` to reach the target, return the number of `stops`.\n    ", "javascript": "\n    ```javascript\nfunction minRefuelStops(target, startFuel, stations) {\n    let i = 0, stops = 0, curFuel = startFuel;\n    let pq = new PriorityQueue((a, b) => b - a);\n    while (curFuel < target) {\n        while (i < stations.length && stations[i][0] <= curFuel) {\n            pq.offer(stations[i][1]);\n            i++;\n        }\n        if (pq.isEmpty()) return -1;\n        curFuel += pq.poll();\n        stops++;\n    }\n    return stops;\n}\n\nclass PriorityQueue {\n    constructor(comparator) {\n        this._heap = [];\n        this._comparator = comparator || ((a, b) => a - b);\n    }\n    size() {\n        return this._heap.length;\n    }\n    isEmpty() {\n        return this.size() == 0;\n    }\n    peek() {\n        return this._heap[0];\n    }\n    offer(value) {\n        this._heap.push(value);\n        this._siftUp();\n    }\n    poll() {\n        const head = this.peek();\n        this._heap[0] = this._heap.pop();\n        this._siftDown();\n        return head;\n    }\n    _parent(idx) {\n        return Math.floor((idx - 1) / 2);\n    }\n    _left(idx) {\n        return idx * 2 + 1;\n    }\n    _right(idx) {\n        return idx * 2 + 2;\n    }\n    _siftUp() {\n        let node = this.size() - 1;\n\n        while (node > 0 && this._comparator(this._heap[node], this._heap[this._parent(node)]) < 0) {\n            [this._heap[node], this._heap[this._parent(node)]] = [this._heap[this._parent(node)], this._heap[node]];\n            node = this._parent(node);\n        }\n    }\n    _siftDown() {\n        let node = 0;\n        while ((this._left(node) < this.size() && this._comparator(this._heap[this._left(node)], this._heap[node]) < 0) ||\n            (this._right(node) < this.size() && this._comparator(this._heap[this._right(node)], this._heap[node]) < 0)) {\n                \n            let minChild = this._left(node);\n            if (this._right(node) < this.size() && this._comparator(this._heap[this._right(node)], this._heap[this._left(node)]) < 0) {\n                minChild = this._right(node);\n            }\n\n            [this._heap[node], this._heap[minChild]] = [this._heap[minChild], this._heap[node]];\n            node = minChild;\n        }\n    }\n}\n```\n\n    \n    1. Initialize a variable `stops` to store the number of refueling stops made, `curFuel` to save the current fuel, and a max heap (priority queue) `pq` to store the gas station capacities encountered along the way.\n2. While `curFuel` is not sufficient to reach the target, perform the following steps:\n   a. Loop through the gas stations that can be reached from the current fuel, add their fuel capacity to the priority queue, and increment the station index.\n   b. If the priority queue is empty, it means no gas station can be reached, so return -1.\n   c. Add the maximum fuel capacity from the priority queue (the top value) to the `curFuel` and remove it from the priority queue.\n   d. Increment the `stops` variable.\n3. When the loop ends and the car has enough `curFuel` to reach the target, return the number of `stops`.\n    "}
{"id": 903, "slug": "valid-permutations-for-di-sequence", "title": "Valid Permutations for DI Sequence", "difficulty": "Hard", "content": "You are given a string `s` of length `n` where `s[i]` is either:\n\n*   `'D'` means decreasing, or\n*   `'I'` means increasing.\n\nA permutation `perm` of `n + 1` integers of all the integers in the range `[0, n]` is called a **valid permutation** if for all valid `i`:\n\n*   If `s[i] == 'D'`, then `perm[i] > perm[i + 1]`, and\n*   If `s[i] == 'I'`, then `perm[i] < perm[i + 1]`.\n\nReturn _the number of **valid permutations**_ `perm`. Since the answer may be large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** s =  \"DID \"\n**Output:** 5\n**Explanation:** The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)\n\n**Example 2:**\n\n**Input:** s =  \"D \"\n**Output:** 1\n\n**Constraints:**\n\n*   `n == s.length`\n*   `1 <= n <= 200`\n*   `s[i]` is either `'I'` or `'D'`.", "java": "\n    ```java\npublic int rand7(); // Given API\n\npublic int rand10() {\n    int result;\n    do {\n        result = (rand7() - 1) * 7 + rand7();\n    } while (result > 40);\n    return result % 10 + 1;\n}\n```\n    \n    The algorithm is based on generating a uniform random integer in the range of [1, 49] using the given rand7() API by the following formula:\n\n`result = (rand7() - 1) * 7 + rand7()`\n\nSince rand7() generates a number between 1 and 7, `(rand7() - 1) * 7` generates multiples of 7 ranging from 0 to 42. By adding another rand7(), we fill in the gaps to create a uniformly random number between 1 and 49.\n\nHowever, we need to generate a number in the range of [1, 10]. To do this, we can discard any numbers greater than 40 (since 40 is the largest multiple of 10 within the generated range) and use the modulo operator to convert the range from [1, 40] to [1, 10].\n\n`result % 10 + 1`\n\nWe repeat the process in a loop until we get a number in the range of [1, 40], following which we apply the modulo operator and return the final result. This ensures a uniform distribution of random integers in the [1, 10] range.\n    ", "c++": "\n    ```cpp\nint rand7(); // Given API\n\nint rand10() {\n    int result;\n    do {\n        result = (rand7() - 1) * 7 + rand7();\n    } while (result > 40);\n    return result % 10 + 1;\n}\n```\n    \n    The algorithm is based on generating a uniform random integer in the range of [1, 49] using the given rand7() API by the following formula:\n\n`result = (rand7() - 1) * 7 + rand7()`\n\nSince rand7() generates a number between 1 and 7, `(rand7() - 1) * 7` generates multiples of 7 ranging from 0 to 42. By adding another rand7(), we fill in the gaps to create a uniformly random number between 1 and 49.\n\nHowever, we need to generate a number in the range of [1, 10]. To do this, we can discard any numbers greater than 40 (since 40 is the largest multiple of 10 within the generated range) and use the modulo operator to convert the range from [1, 40] to [1, 10].\n\n`result % 10 + 1`\n\nWe repeat the process in a loop until we get a number in the range of [1, 40], following which we apply the modulo operator and return the final result. This ensures a uniform distribution of random integers in the [1, 10] range.\n    ", "python": "\n    ```python\ndef rand7(): # Given API\n    pass\n\ndef rand10():\n    result = 41\n    while result > 40:\n        result = (rand7() - 1) * 7 + rand7()\n    return result % 10 + 1\n```\n    \n    The algorithm is based on generating a uniform random integer in the range of [1, 49] using the given rand7() API by the following formula:\n\n`result = (rand7() - 1) * 7 + rand7()`\n\nSince rand7() generates a number between 1 and 7, `(rand7() - 1) * 7` generates multiples of 7 ranging from 0 to 42. By adding another rand7(), we fill in the gaps to create a uniformly random number between 1 and 49.\n\nHowever, we need to generate a number in the range of [1, 10]. To do this, we can discard any numbers greater than 40 (since 40 is the largest multiple of 10 within the generated range) and use the modulo operator to convert the range from [1, 40] to [1, 10].\n\n`result % 10 + 1`\n\nWe repeat the process in a loop until we get a number in the range of [1, 40], following which we apply the modulo operator and return the final result. This ensures a uniform distribution of random integers in the [1, 10] range.\n    ", "javascript": "\n    ```javascript\nfunction rand7() {} // Given API\n\nfunction rand10() {\n    let result;\n    do {\n        result = (rand7() - 1) * 7 + rand7();\n    } while (result > 40);\n    return result % 10 + 1;\n}\n```\n    \n    The algorithm is based on generating a uniform random integer in the range of [1, 49] using the given rand7() API by the following formula:\n\n`result = (rand7() - 1) * 7 + rand7()`\n\nSince rand7() generates a number between 1 and 7, `(rand7() - 1) * 7` generates multiples of 7 ranging from 0 to 42. By adding another rand7(), we fill in the gaps to create a uniformly random number between 1 and 49.\n\nHowever, we need to generate a number in the range of [1, 10]. To do this, we can discard any numbers greater than 40 (since 40 is the largest multiple of 10 within the generated range) and use the modulo operator to convert the range from [1, 40] to [1, 10].\n\n`result % 10 + 1`\n\nWe repeat the process in a loop until we get a number in the range of [1, 40], following which we apply the modulo operator and return the final result. This ensures a uniform distribution of random integers in the [1, 10] range.\n    "}
{"id": 907, "slug": "sum-of-subarray-minimums", "title": "Sum of Subarray Minimums", "difficulty": "Medium", "content": "Given an array of integers arr, find the sum of `min(b)`, where `b` ranges over every (contiguous) subarray of `arr`. Since the answer may be large, return the answer **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** arr = \\[3,1,2,4\\]\n**Output:** 17\n**Explanation:** \nSubarrays are \\[3\\], \\[1\\], \\[2\\], \\[4\\], \\[3,1\\], \\[1,2\\], \\[2,4\\], \\[3,1,2\\], \\[1,2,4\\], \\[3,1,2,4\\]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.\n\n**Example 2:**\n\n**Input:** arr = \\[11,81,94,43,3\\]\n**Output:** 444\n\n**Constraints:**\n\n*   `1 <= arr.length <= 3 * 104`\n*   `1 <= arr[i] <= 3 * 104`", "java": "\n    ```java\npublic int minEatingSpeed(int[] piles, int h) {\n    int left = 1, right = 1;\n    for (int pile : piles)\n        right = Math.max(right, pile);\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        int totalHours = 0;\n        for (int pile : piles)\n            totalHours += (pile + mid - 1) / mid;\n        if (totalHours > h)\n            left = mid + 1;\n        else\n            right = mid;\n    }\n    return left;\n}\n```\n    \n    The problem can be solved using binary search. We start with the lowest possible value of k (eating speed) as 1 and the highest possible value as the maximum value in the piles array. We calculate the mid value and the total hours it would take Koko to eat all bananas at the current mid eating speed. If the total hours is more than h, we increase the left boundary, otherwise we decrease the right boundary. We continue the process until left and right meet, and at this point, we have found the minimum integer k such that Koko can eat all the bananas within h hours.\n    ", "c++": "\n    ```cpp\nint minEatingSpeed(vector<int>& piles, int h) {\n    int left = 1, right = *max_element(piles.begin(), piles.end());\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        int totalHours = 0;\n        for (int pile : piles)\n            totalHours += (pile + mid - 1) / mid;\n        if (totalHours > h)\n            left = mid + 1;\n        else\n            right = mid;\n    }\n    return left;\n}\n```\n    \n    The problem can be solved using binary search. We start with the lowest possible value of k (eating speed) as 1 and the highest possible value as the maximum value in the piles array. We calculate the mid value and the total hours it would take Koko to eat all bananas at the current mid eating speed. If the total hours is more than h, we increase the left boundary, otherwise we decrease the right boundary. We continue the process until left and right meet, and at this point, we have found the minimum integer k such that Koko can eat all the bananas within h hours.\n    ", "python": "\n    ```python\ndef minEatingSpeed(piles, h):\n    left, right = 1, max(piles)\n    while left < right:\n        mid = left + (right - left) // 2\n        totalHours = sum((pile + mid - 1) // mid for pile in piles)\n        if totalHours > h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n```\n    \n    The problem can be solved using binary search. We start with the lowest possible value of k (eating speed) as 1 and the highest possible value as the maximum value in the piles array. We calculate the mid value and the total hours it would take Koko to eat all bananas at the current mid eating speed. If the total hours is more than h, we increase the left boundary, otherwise we decrease the right boundary. We continue the process until left and right meet, and at this point, we have found the minimum integer k such that Koko can eat all the bananas within h hours.\n    ", "javascript": "\n    ```javascript\nfunction minEatingSpeed(piles, h) {\n  let left = 1, right = Math.max(...piles);\n  while (left < right) {\n    let mid = left + Math.floor((right - left) / 2);\n    let totalHours = 0;\n    for (let pile of piles)\n      totalHours += Math.ceil(pile / mid);\n    if (totalHours > h)\n      left = mid + 1;\n    else\n      right = mid;\n  }\n  return left;\n}\n```\n    \n    The problem can be solved using binary search. We start with the lowest possible value of k (eating speed) as 1 and the highest possible value as the maximum value in the piles array. We calculate the mid value and the total hours it would take Koko to eat all bananas at the current mid eating speed. If the total hours is more than h, we increase the left boundary, otherwise we decrease the right boundary. We continue the process until left and right meet, and at this point, we have found the minimum integer k such that Koko can eat all the bananas within h hours.\n    "}
{"id": 913, "slug": "cat-and-mouse", "title": "Cat and Mouse", "difficulty": "Hard", "content": "A game on an **undirected** graph is played by two players, Mouse and Cat, who alternate turns.\n\nThe graph is given as follows: `graph[a]` is a list of all nodes `b` such that `ab` is an edge of the graph.\n\nThe mouse starts at node `1` and goes first, the cat starts at node `2` and goes second, and there is a hole at node `0`.\n\nDuring each player's turn, they **must** travel along one edge of the graph that meets where they are. For example, if the Mouse is at node 1, it **must** travel to any node in `graph[1]`.\n\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0.)\n\nThen, the game can end in three ways:\n\n*   If ever the Cat occupies the same node as the Mouse, the Cat wins.\n*   If ever the Mouse reaches the Hole, the Mouse wins.\n*   If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.\n\nGiven a `graph`, and assuming both players play optimally, return\n\n*   `1` if the mouse wins the game,\n*   `2` if the cat wins the game, or\n*   `0` if the game is a draw.\n\n**Example 1:**\n\n**Input:** graph = \\[\\[2,5\\],\\[3\\],\\[0,4,5\\],\\[1,4,5\\],\\[2,3\\],\\[0,2,3\\]\\]\n**Output:** 0\n\n**Example 2:**\n\n**Input:** graph = \\[\\[1,3\\],\\[0\\],\\[3\\],\\[0,2\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `3 <= graph.length <= 50`\n*   `1 <= graph[i].length < graph.length`\n*   `0 <= graph[i][j] < graph.length`\n*   `graph[i][j] != i`\n*   `graph[i]` is unique.\n*   The mouse and the cat can always move.", "java": "\n    ```java\nimport java.util.Random;\n\nclass Solution {\n    private int[][] grid;\n    private int zeroCount;\n    private final Random rng = new Random();\n\n    public Solution(int m, int n) {\n        this.grid = new int[m][n];\n        this.zeroCount = m * n;\n    }\n\n    public int[] pick() {\n        int index = rng.nextInt(zeroCount);\n\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 0) {\n                    if (index == 0) {\n                        grid[i][j] = 1;\n                        zeroCount--;\n                        return new int[]{i, j};\n                    }\n                    index--;\n                }\n            }\n        }\n        return new int[]{-1, -1};  // Should not happen\n    }\n}\n```\n    \n    The algorithm initializes an m x n grid with all 0s and keeps track of the count of 0s (`_zero_count`). When the `pick()` function is called, it generates a random number between 0 and `zero_count - 1`. Then, it iterates over the grid elements, skipping the 1s. When it encounters a 0, it checks if the random index equals 0. If so, it flips the value to 1, decrements the zero count, and returns the current index. Otherwise, it decrements the random index value. This process ensures that each unfilled index has an equal chance of being picked.\n\nThe code is language-specific due to the random number generation mechanism and the classes/constructors used. However, the core algorithm remains the same across all languages. The time complexity is O(mn) as the function iterates through the entire grid. The space complexity is O(mn), as it stores the matrix. The usage of the built-in random function is minimized as it is called only once for each pick operation.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <random>\n\nclass Solution {\npublic:\n    Solution(int m, int n) : _grid(m, std::vector<int>(n, 0)), _zero_count(m * n), _rng(std::random_device{}()) {}\n\n    std::pair<int, int> pick() {\n        std::uniform_int_distribution<int> dist(0, _zero_count - 1);\n        int index = dist(_rng);\n\n        for (int i = 0; i < _grid.size(); ++i) {\n            for (int j = 0; j < _grid[0].size(); ++j) {\n                if (_grid[i][j] == 0) {\n                    if (index == 0) {\n                        _grid[i][j] = 1;\n                        --_zero_count;\n                        return {i, j};\n                    }\n                    --index;\n                }\n            }\n        }\n        return {-1, -1};  // Should not happen\n    }\n\nprivate:\n    std::vector<std::vector<int>> _grid;\n    int _zero_count;\n    std::mt19937 _rng;\n};\n```\n    \n    The algorithm initializes an m x n grid with all 0s and keeps track of the count of 0s (`_zero_count`). When the `pick()` function is called, it generates a random number between 0 and `zero_count - 1`. Then, it iterates over the grid elements, skipping the 1s. When it encounters a 0, it checks if the random index equals 0. If so, it flips the value to 1, decrements the zero count, and returns the current index. Otherwise, it decrements the random index value. This process ensures that each unfilled index has an equal chance of being picked.\n\nThe code is language-specific due to the random number generation mechanism and the classes/constructors used. However, the core algorithm remains the same across all languages. The time complexity is O(mn) as the function iterates through the entire grid. The space complexity is O(mn), as it stores the matrix. The usage of the built-in random function is minimized as it is called only once for each pick operation.\n    ", "python": "\n    ```python\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.grid = [[0] * n for _ in range(m)]\n        self.zero_count = m * n\n\n    def pick(self):\n        index = random.randrange(self.zero_count)\n\n        for i, row in enumerate(self.grid):\n            for j, cell in enumerate(row):\n                if cell == 0:\n                    if index == 0:\n                        self.grid[i][j] = 1\n                        self.zero_count -= 1\n                        return (i, j)\n                    index -= 1\n        return (-1, -1)  # Should not happen\n```\n    \n    The algorithm initializes an m x n grid with all 0s and keeps track of the count of 0s (`_zero_count`). When the `pick()` function is called, it generates a random number between 0 and `zero_count - 1`. Then, it iterates over the grid elements, skipping the 1s. When it encounters a 0, it checks if the random index equals 0. If so, it flips the value to 1, decrements the zero count, and returns the current index. Otherwise, it decrements the random index value. This process ensures that each unfilled index has an equal chance of being picked.\n\nThe code is language-specific due to the random number generation mechanism and the classes/constructors used. However, the core algorithm remains the same across all languages. The time complexity is O(mn) as the function iterates through the entire grid. The space complexity is O(mn), as it stores the matrix. The usage of the built-in random function is minimized as it is called only once for each pick operation.\n    ", "javascript": "\n    ```javascript\nclass Solution {\n    constructor(m, n) {\n        this.grid = new Array(m).fill(0).map(() => new Array(n).fill(0));\n        this.zeroCount = m * n;\n    }\n\n    pick() {\n        let index = Math.floor(Math.random() * this.zeroCount);\n\n        for (let i = 0; i < this.grid.length; i++) {\n            for (let j = 0; j < this.grid[0].length; j++) {\n                if (this.grid[i][j] === 0) {\n                    if (index === 0) {\n                        this.grid[i][j] = 1;\n                        this.zeroCount--;\n                        return [i, j];\n                    }\n                    index--;\n                }\n            }\n        }\n        return [-1, -1];  // Should not happen\n    }\n}\n```\n    \n    The algorithm initializes an m x n grid with all 0s and keeps track of the count of 0s (`_zero_count`). When the `pick()` function is called, it generates a random number between 0 and `zero_count - 1`. Then, it iterates over the grid elements, skipping the 1s. When it encounters a 0, it checks if the random index equals 0. If so, it flips the value to 1, decrements the zero count, and returns the current index. Otherwise, it decrements the random index value. This process ensures that each unfilled index has an equal chance of being picked.\n\nThe code is language-specific due to the random number generation mechanism and the classes/constructors used. However, the core algorithm remains the same across all languages. The time complexity is O(mn) as the function iterates through the entire grid. The space complexity is O(mn), as it stores the matrix. The usage of the built-in random function is minimized as it is called only once for each pick operation.\n    "}
{"id": 918, "slug": "maximum-sum-circular-subarray", "title": "Maximum Sum Circular Subarray", "difficulty": "Medium", "content": "Given a **circular integer array** `nums` of length `n`, return _the maximum possible sum of a non-empty **subarray** of_ `nums`.\n\nA **circular array** means the end of the array connects to the beginning of the array. Formally, the next element of `nums[i]` is `nums[(i + 1) % n]` and the previous element of `nums[i]` is `nums[(i - 1 + n) % n]`.\n\nA **subarray** may only include each element of the fixed buffer `nums` at most once. Formally, for a subarray `nums[i], nums[i + 1], ..., nums[j]`, there does not exist `i <= k1`, `k2 <= j` with `k1 % n == k2 % n`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,-2,3,-2\\]\n**Output:** 3\n**Explanation:** Subarray \\[3\\] has maximum sum 3.\n\n**Example 2:**\n\n**Input:** nums = \\[5,-3,5\\]\n**Output:** 10\n**Explanation:** Subarray \\[5,5\\] has maximum sum 5 + 5 = 10.\n\n**Example 3:**\n\n**Input:** nums = \\[-3,-2,-3\\]\n**Output:** -2\n**Explanation:** Subarray \\[-2\\] has maximum sum -2.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 3 * 104`\n*   `-3 * 104 <= nums[i] <= 3 * 104`", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int reachableNodes(int[][] edges, int maxMoves, int n) {\n        List<List<int[]>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1], cnt = edge[2];\n            graph.get(u).add(new int[]{v, cnt + 1});\n            graph.get(v).add(new int[]{u, cnt + 1});\n        }\n\n        Set<Integer> visited = new HashSet<>();\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\n        pq.offer(new int[]{maxMoves, 0});\n\n        while (!pq.isEmpty()) {\n            int[] top = pq.poll();\n            int moves_left = top[0];\n            int node = top[1];\n\n            if (visited.contains(node)) continue;\n            visited.add(node);\n\n            for (int[] neighbor : graph.get(node)) {\n                int next_node = neighbor[0];\n                int moves_needed = neighbor[1];\n                int moves_left_after = moves_left - moves_needed;\n\n                if (!visited.contains(next_node) && moves_left_after > 0) {\n                    pq.offer(new int[]{moves_left_after, next_node});\n                }\n            }\n        }\n\n        return visited.size();\n    }\n}\n```\n\n    \n    The problem can be solved using Dijkstra's algorithm.\n\n1. First, convert the given graph into an adjacency list (graph) so that it stores the adjacent nodes and the edge weights between them.\n2. Initialize a set (visited) for storing the visited nodes.\n3. Initialize a max-heap priority queue (pq), with the initial maximum moves left and the starting node (0) as a tuple.\n4. Run a while loop until the priority queue is empty:\n   a. Pop the top element from the queue which has the maximum moves left and the corresponding node.\n   b. Check if the node is already visited. If yes, continue to the next element in the queue.\n   c. If the node is not visited, add it to the visited set.\n   d. Loop through each neighbor of the current node:\n      i. Calculate moves_left_after: moves left after reaching the neighbor node.\n      ii. If the neighbor node is not visited and the moves_left_after is greater than 0, push it into the priority queue.\n5. Return the size of the visited set.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\n\nint reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {\n    vector<vector<pair<int, int>>> graph(n);\n    for (const auto& edge : edges) {\n        int u = edge[0], v = edge[1], cnt = edge[2];\n        graph[u].emplace_back(v, cnt + 1);\n        graph[v].emplace_back(u, cnt + 1);\n    }\n\n    unordered_set<int> visited;\n    priority_queue<pair<int, int>> pq;\n    pq.emplace(maxMoves, 0);\n\n    while (!pq.empty()) {\n        int moves_left = pq.top().first;\n        int node = pq.top().second;\n        pq.pop();\n\n        if (visited.count(node)) continue;\n        visited.insert(node);\n\n        for (const auto& neighbor : graph[node]) {\n            int next_node = neighbor.first;\n            int moves_needed = neighbor.second;\n            int moves_left_after = moves_left - moves_needed;\n\n            if (!visited.count(next_node) && moves_left_after > 0) {\n                pq.emplace(moves_left_after, next_node);\n            }\n        }\n    }\n\n    return visited.size();\n}\n```\n\n    \n    The problem can be solved using Dijkstra's algorithm.\n\n1. First, convert the given graph into an adjacency list (graph) so that it stores the adjacent nodes and the edge weights between them.\n2. Initialize a set (visited) for storing the visited nodes.\n3. Initialize a max-heap priority queue (pq), with the initial maximum moves left and the starting node (0) as a tuple.\n4. Run a while loop until the priority queue is empty:\n   a. Pop the top element from the queue which has the maximum moves left and the corresponding node.\n   b. Check if the node is already visited. If yes, continue to the next element in the queue.\n   c. If the node is not visited, add it to the visited set.\n   d. Loop through each neighbor of the current node:\n      i. Calculate moves_left_after: moves left after reaching the neighbor node.\n      ii. If the neighbor node is not visited and the moves_left_after is greater than 0, push it into the priority queue.\n5. Return the size of the visited set.\n    ", "python": "\n    ```python\nfrom heapq import heappush, heappop\n\ndef reachableNodes(edges, maxMoves, n):\n    graph = [[] for _ in range(n)]\n    for u, v, cnt in edges:\n        graph[u].append((v, cnt + 1))\n        graph[v].append((u, cnt + 1))\n\n    visited = set()\n    pq = [(-maxMoves, 0)]\n\n    while pq:\n        moves_left, node = heappop(pq)\n\n        if node in visited:\n            continue\n        visited.add(node)\n\n        for next_node, moves_needed in graph[node]:\n            moves_left_after = moves_left - moves_needed\n            if next_node not in visited and moves_left_after > 0:\n                heappush(pq, (moves_left_after, next_node))\n\n    return len(visited)\n```\n\n    \n    The problem can be solved using Dijkstra's algorithm.\n\n1. First, convert the given graph into an adjacency list (graph) so that it stores the adjacent nodes and the edge weights between them.\n2. Initialize a set (visited) for storing the visited nodes.\n3. Initialize a max-heap priority queue (pq), with the initial maximum moves left and the starting node (0) as a tuple.\n4. Run a while loop until the priority queue is empty:\n   a. Pop the top element from the queue which has the maximum moves left and the corresponding node.\n   b. Check if the node is already visited. If yes, continue to the next element in the queue.\n   c. If the node is not visited, add it to the visited set.\n   d. Loop through each neighbor of the current node:\n      i. Calculate moves_left_after: moves left after reaching the neighbor node.\n      ii. If the neighbor node is not visited and the moves_left_after is greater than 0, push it into the priority queue.\n5. Return the size of the visited set.\n    ", "javascript": "\n    ```javascript\nfunction reachableNodes(edges, maxMoves, n) {\n    const graph = Array.from({length: n}, () => []);\n    for (const edge of edges) {\n        const [u, v, cnt] = edge;\n        graph[u].push([v, cnt + 1]);\n        graph[v].push([u, cnt + 1]);\n    }\n\n    const visited = new Set();\n    const pq = [[maxMoves, 0]];\n\n    while (pq.length) {\n        const [moves_left, node] = pq.pop();\n\n        if (visited.has(node)) continue;\n        visited.add(node);\n\n        for (const neighbor of graph[node]) {\n            const [next_node, moves_needed] = neighbor;\n            const moves_left_after = moves_left - moves_needed;\n\n            if (!visited.has(next_node) && moves_left_after > 0) {\n                pq.push([moves_left_after, next_node]);\n                pq.sort((a, b) => b[0] - a[0]);\n            }\n        }\n    }\n\n    return visited.size;\n}\n```\n\n    \n    The problem can be solved using Dijkstra's algorithm.\n\n1. First, convert the given graph into an adjacency list (graph) so that it stores the adjacent nodes and the edge weights between them.\n2. Initialize a set (visited) for storing the visited nodes.\n3. Initialize a max-heap priority queue (pq), with the initial maximum moves left and the starting node (0) as a tuple.\n4. Run a while loop until the priority queue is empty:\n   a. Pop the top element from the queue which has the maximum moves left and the corresponding node.\n   b. Check if the node is already visited. If yes, continue to the next element in the queue.\n   c. If the node is not visited, add it to the visited set.\n   d. Loop through each neighbor of the current node:\n      i. Calculate moves_left_after: moves left after reaching the neighbor node.\n      ii. If the neighbor node is not visited and the moves_left_after is greater than 0, push it into the priority queue.\n5. Return the size of the visited set.\n    "}
{"id": 920, "slug": "number-of-music-playlists", "title": "Number of Music Playlists", "difficulty": "Hard", "content": "Your music player contains `n` different songs. You want to listen to `goal` songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that:\n\n*   Every song is played **at least once**.\n*   A song can only be played again only if `k` other songs have been played.\n\nGiven `n`, `goal`, and `k`, return _the number of possible playlists that you can create_. Since the answer can be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 3, goal = 3, k = 1\n**Output:** 6\n**Explanation:** There are 6 possible playlists: \\[1, 2, 3\\], \\[1, 3, 2\\], \\[2, 1, 3\\], \\[2, 3, 1\\], \\[3, 1, 2\\], and \\[3, 2, 1\\].\n\n**Example 2:**\n\n**Input:** n = 2, goal = 3, k = 0\n**Output:** 6\n**Explanation:** There are 6 possible playlists: \\[1, 1, 2\\], \\[1, 2, 1\\], \\[2, 1, 1\\], \\[2, 2, 1\\], \\[2, 1, 2\\], and \\[1, 2, 2\\].\n\n**Example 3:**\n\n**Input:** n = 2, goal = 3, k = 1\n**Output:** 2\n**Explanation:** There are 2 possible playlists: \\[1, 2, 1\\] and \\[2, 1, 2\\].\n\n**Constraints:**\n\n*   `0 <= k < n <= goal <= 100`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<String> uncommonFromSentences(String s1, String s2) {\n    Map<String, Integer> wordCount = new HashMap<>();\n    for (String word : (s1 + \" \" + s2).split(\" \")) {\n        wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n    }\n\n    List<String> result = new ArrayList<>();\n    for (Map.Entry<String, Integer> entry : wordCount.entrySet()) {\n        if (entry.getValue() == 1) {\n            result.add(entry.getKey());\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Create a hash map called `word_count` to store the word count of each word.\n2. Concatenate `s1` and `s2` separated by a space and split the string into words.\n3. Iterate through each word and update the value in the `wordCount` hash map.\n4. Create a list (Java: ArrayList, Python: list, JavaScript: array) called `result`.\n5. Iterate through each key-value pair in `wordCount`, and if the value is 1, push the key (the word) into `result`.\n6. Return `result`.\n\nThe time complexity of the algorithm is O(N) where N is the number of words in both sentences. The space complexity is also O(N) for storing the hash map and the result list.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n\nstd::vector<std::string> uncommonFromSentences(std::string s1, std::string s2) {\n    std::unordered_map<std::string, int> word_count;\n    std::istringstream is(s1 + ' ' + s2);\n    std::string word;\n\n    while (is >> word) {\n        word_count[word]++;\n    }\n\n    std::vector<std::string> result;\n    for (const auto &pair : word_count) {\n        if (pair.second == 1) {\n            result.push_back(pair.first);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Create a hash map called `word_count` to store the word count of each word.\n2. Concatenate `s1` and `s2` separated by a space and split the string into words.\n3. Iterate through each word and update the value in the `wordCount` hash map.\n4. Create a list (Java: ArrayList, Python: list, JavaScript: array) called `result`.\n5. Iterate through each key-value pair in `wordCount`, and if the value is 1, push the key (the word) into `result`.\n6. Return `result`.\n\nThe time complexity of the algorithm is O(N) where N is the number of words in both sentences. The space complexity is also O(N) for storing the hash map and the result list.\n    ", "python": "\n    ```python\ndef uncommon_from_sentences(s1, s2):\n    word_count = {}\n    for word in (s1 + \" \" + s2).split():\n        word_count[word] = word_count.get(word, 0) + 1\n\n    return [key for key, val in word_count.items() if val == 1]\n```\n    \n    The algorithm works as follows:\n\n1. Create a hash map called `word_count` to store the word count of each word.\n2. Concatenate `s1` and `s2` separated by a space and split the string into words.\n3. Iterate through each word and update the value in the `wordCount` hash map.\n4. Create a list (Java: ArrayList, Python: list, JavaScript: array) called `result`.\n5. Iterate through each key-value pair in `wordCount`, and if the value is 1, push the key (the word) into `result`.\n6. Return `result`.\n\nThe time complexity of the algorithm is O(N) where N is the number of words in both sentences. The space complexity is also O(N) for storing the hash map and the result list.\n    ", "javascript": "\n    ```javascript\nfunction uncommonFromSentences(s1, s2) {\n    const wordCount = new Map();\n    const words = (s1 + \" \" + s2).split(\" \");\n    \n    for (const word of words) {\n        wordCount.set(word, (wordCount.get(word) || 0) + 1);\n    }\n\n    const result = [];\n    for (const [key, value] of wordCount.entries()) {\n        if (value === 1) {\n            result.push(key);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Create a hash map called `word_count` to store the word count of each word.\n2. Concatenate `s1` and `s2` separated by a space and split the string into words.\n3. Iterate through each word and update the value in the `wordCount` hash map.\n4. Create a list (Java: ArrayList, Python: list, JavaScript: array) called `result`.\n5. Iterate through each key-value pair in `wordCount`, and if the value is 1, push the key (the word) into `result`.\n6. Return `result`.\n\nThe time complexity of the algorithm is O(N) where N is the number of words in both sentences. The space complexity is also O(N) for storing the hash map and the result list.\n    "}
{"id": 926, "slug": "flip-string-to-monotone-increasing", "title": "Flip String to Monotone Increasing", "difficulty": "Medium", "content": "A binary string is monotone increasing if it consists of some number of `0`'s (possibly none), followed by some number of `1`'s (also possibly none).\n\nYou are given a binary string `s`. You can flip `s[i]` changing it from `0` to `1` or from `1` to `0`.\n\nReturn _the minimum number of flips to make_ `s` _monotone increasing_.\n\n**Example 1:**\n\n**Input:** s =  \"00110 \"\n**Output:** 1\n**Explanation:** We flip the last digit to get 00111.\n\n**Example 2:**\n\n**Input:** s =  \"010110 \"\n**Output:** 2\n**Explanation:** We flip to get 011111, or alternatively 000111.\n\n**Example 3:**\n\n**Input:** s =  \"00011000 \"\n**Output:** 2\n**Explanation:** We flip to get 00000000.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'0'` or `'1'`.", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<String> findAndReplacePatterns(String[] words, String pattern) {\n    List<String> result = new ArrayList<>();\n    for (String word : words) {\n        if (word.length() != pattern.length()) continue;\n\n        Map<Character, Character> w2p = new HashMap<>();\n        Map<Character, Character> p2w = new HashMap<>();\n        boolean matches = true;\n        for (int i = 0; i < word.length(); ++i) {\n            char cWord = word.charAt(i);\n            char cPattern = pattern.charAt(i);\n\n            if (!w2p.containsKey(cWord)) w2p.put(cWord, cPattern);\n            if (!p2w.containsKey(cPattern)) p2w.put(cPattern, cWord);\n\n            if (w2p.get(cWord) != cPattern || p2w.get(cPattern) != cWord) {\n                matches = false;\n                break;\n            }\n        }\n        if (matches) result.add(word);\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize an empty list (or vector) `result` to store the words that match the pattern.\n2. Iterate through the given list of words.\n   a. If the current word has a different length than the pattern, skip it as it will not match.\n   b. Create two maps (hashmaps or dictionaries) called `w2p` and `p2w` to store the current word-to-pattern and pattern-to-word character mappings.\n   c. Iterate through the characters of the current word and the pattern at the same time.\n      i. If the current character in the word is not in `w2p`, add it with the corresponding character in the pattern.\n      ii. If the current character in the pattern is not in `p2w`, add it with the corresponding character in the word.\n      iii. If the current character mappings do not match, set `matches` to false and break the loop.\n   d. If `matches` is true, add the current word to `result`.\n3. Return `result`.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<std::string> findAndReplacePatterns(std::vector<std::string>& words, std::string pattern) {\n    std::vector<std::string> result;\n    for (const std::string& word : words) {\n        if (word.size() != pattern.size()) continue;\n\n        std::unordered_map<char, char> w2p;\n        std::unordered_map<char, char> p2w;\n        bool matches = true;\n        for (size_t i = 0; i < word.size(); ++i) {\n            char cWord = word[i];\n            char cPattern = pattern[i];\n\n            if (!w2p.count(cWord)) w2p[cWord] = cPattern;\n            if (!p2w.count(cPattern)) p2w[cPattern] = cWord;\n\n            if (w2p[cWord] != cPattern || p2w[cPattern] != cWord) {\n                matches = false;\n                break;\n            }\n        }\n        if (matches) result.push_back(word);\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize an empty list (or vector) `result` to store the words that match the pattern.\n2. Iterate through the given list of words.\n   a. If the current word has a different length than the pattern, skip it as it will not match.\n   b. Create two maps (hashmaps or dictionaries) called `w2p` and `p2w` to store the current word-to-pattern and pattern-to-word character mappings.\n   c. Iterate through the characters of the current word and the pattern at the same time.\n      i. If the current character in the word is not in `w2p`, add it with the corresponding character in the pattern.\n      ii. If the current character in the pattern is not in `p2w`, add it with the corresponding character in the word.\n      iii. If the current character mappings do not match, set `matches` to false and break the loop.\n   d. If `matches` is true, add the current word to `result`.\n3. Return `result`.\n    ", "python": "\n    ```python\ndef find_and_replace_patterns(words, pattern):\n    result = []\n    for word in words:\n        if len(word) != len(pattern): continue\n\n        w2p = {}\n        p2w = {}\n        matches = True\n        for cWord, cPattern in zip(word, pattern):\n            if cWord not in w2p: w2p[cWord] = cPattern\n            if cPattern not in p2w: p2w[cPattern] = cWord\n\n            if w2p[cWord] != cPattern or p2w[cPattern] != cWord:\n                matches = False\n                break\n\n        if matches: result.append(word)\n    return result\n```\n\n    \n    1. Initialize an empty list (or vector) `result` to store the words that match the pattern.\n2. Iterate through the given list of words.\n   a. If the current word has a different length than the pattern, skip it as it will not match.\n   b. Create two maps (hashmaps or dictionaries) called `w2p` and `p2w` to store the current word-to-pattern and pattern-to-word character mappings.\n   c. Iterate through the characters of the current word and the pattern at the same time.\n      i. If the current character in the word is not in `w2p`, add it with the corresponding character in the pattern.\n      ii. If the current character in the pattern is not in `p2w`, add it with the corresponding character in the word.\n      iii. If the current character mappings do not match, set `matches` to false and break the loop.\n   d. If `matches` is true, add the current word to `result`.\n3. Return `result`.\n    ", "javascript": "\n    ```javascript\nfunction findAndReplacePatterns(words, pattern) {\n    const result = [];\n    for (const word of words) {\n        if (word.length !== pattern.length) continue;\n\n        const w2p = new Map();\n        const p2w = new Map();\n        let matches = true;\n        for (let i = 0; i < word.length; ++i) {\n            const cWord = word[i];\n            const cPattern = pattern[i];\n\n            if (!w2p.has(cWord)) w2p.set(cWord, cPattern);\n            if (!p2w.has(cPattern)) p2w.set(cPattern, cWord);\n\n            if (w2p.get(cWord) !== cPattern || p2w.get(cPattern) !== cWord) {\n                matches = false;\n                break;\n            }\n        }\n        if (matches) result.push(word);\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize an empty list (or vector) `result` to store the words that match the pattern.\n2. Iterate through the given list of words.\n   a. If the current word has a different length than the pattern, skip it as it will not match.\n   b. Create two maps (hashmaps or dictionaries) called `w2p` and `p2w` to store the current word-to-pattern and pattern-to-word character mappings.\n   c. Iterate through the characters of the current word and the pattern at the same time.\n      i. If the current character in the word is not in `w2p`, add it with the corresponding character in the pattern.\n      ii. If the current character in the pattern is not in `p2w`, add it with the corresponding character in the word.\n      iii. If the current character mappings do not match, set `matches` to false and break the loop.\n   d. If `matches` is true, add the current word to `result`.\n3. Return `result`.\n    "}
{"id": 931, "slug": "minimum-falling-path-sum", "title": "Minimum Falling Path Sum", "difficulty": "Medium", "content": "Given an `n x n` array of integers `matrix`, return _the **minimum sum** of any **falling path** through_ `matrix`.\n\nA **falling path** starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position `(row, col)` will be `(row + 1, col - 1)`, `(row + 1, col)`, or `(row + 1, col + 1)`.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[2,1,3\\],\\[6,5,4\\],\\[7,8,9\\]\\]\n**Output:** 13\n**Explanation:** There are two falling paths with a minimum sum as shown.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[-19,57\\],\\[-40,-5\\]\\]\n**Output:** -59\n**Explanation:** The falling path with a minimum sum is shown.\n\n**Constraints:**\n\n*   `n == matrix.length == matrix[i].length`\n*   `1 <= n <= 100`\n*   `-100 <= matrix[i][j] <= 100`", "java": "\n    ```java\nimport java.util.*;\n\nclass FreqStack {\n    private Map<Integer, Integer> freq;\n    private Map<Integer, Stack<Integer>> group;\n\n    public FreqStack() {\n        freq = new HashMap<>();\n        group = new TreeMap<>(Collections.reverseOrder());\n    }\n\n    public void push(int x) {\n        int f = freq.getOrDefault(x, 0) + 1;\n        freq.put(x, f);\n        group.computeIfAbsent(f, k -> new Stack<>()).push(x);\n    }\n\n    public int pop() {\n        int x = group.get(group.keySet().iterator().next()).pop();\n        int f = freq.get(x) - 1;\n        freq.put(x, f);\n        \n        if (group.get(f + 1).empty()) {\n            group.remove(f + 1);\n        }\n        \n        return x;\n    }\n}\n```\n\n    \n    The algorithm maintains two dictionaries (HashMap in Java, unordered_map in C++, Map in JavaScript, and defaultdict in Python): `freq` and `group`.\n\n- `freq` maps elements to their frequencies.\n- `group` maps frequencies to elements with this frequency.\n\nWhen `push` is called, we increase the frequency of the element and add it to the corresponding frequency group.\n\nWhen `pop` is called, we find the group with the highest frequency (using `rbegin()` in C++, `keySet().iterator().next()` in Java, `max()` in Python, and `Math.max()` in JavaScript). We remove the element from the highest frequency group and decrease the frequency in the `freq` dictionary. If the group is empty after removing the element, we delete it from the `group` dictionary.\n\nThe time complexities for both `push` and `pop` operations are O(log N) due to the use of balanced trees under the hood in TreeMap (Java), map (C++) or getting the maximum from the keys in Map (JavaScript), and defaultdict (Python).\n    ", "c++": "\n    ```cpp\n#include <unordered_map>\n#include <map>\n#include <stack>\n\nclass FreqStack {\n    std::unordered_map<int, int> freq;\n    std::map<int, std::stack<int>> group;\n\npublic:\n    FreqStack() {}\n\n    void push(int x) {\n        int f = ++freq[x];\n        group[f].push(x);\n    }\n\n    int pop() {\n        auto& st = group.rbegin()->second;\n        int x = st.top();\n        st.pop();\n        if (st.empty()) {\n            group.erase(group.rbegin()->first);\n        }\n        --freq[x];\n        return x;\n    }\n};\n```\n\n    \n    The algorithm maintains two dictionaries (HashMap in Java, unordered_map in C++, Map in JavaScript, and defaultdict in Python): `freq` and `group`.\n\n- `freq` maps elements to their frequencies.\n- `group` maps frequencies to elements with this frequency.\n\nWhen `push` is called, we increase the frequency of the element and add it to the corresponding frequency group.\n\nWhen `pop` is called, we find the group with the highest frequency (using `rbegin()` in C++, `keySet().iterator().next()` in Java, `max()` in Python, and `Math.max()` in JavaScript). We remove the element from the highest frequency group and decrease the frequency in the `freq` dictionary. If the group is empty after removing the element, we delete it from the `group` dictionary.\n\nThe time complexities for both `push` and `pop` operations are O(log N) due to the use of balanced trees under the hood in TreeMap (Java), map (C++) or getting the maximum from the keys in Map (JavaScript), and defaultdict (Python).\n    ", "python": "\n    ```python\nfrom collections import defaultdict, deque\n\nclass FreqStack:\n    def __init__(self):\n        self.freq = defaultdict(int)\n        self.group = defaultdict(list)\n\n    def push(self, x: int):\n        freq = self.freq[x] = self.freq[x] + 1\n        self.group[freq].append(x)\n\n    def pop(self) -> int:\n        max_freq = max(self.group)\n        x = self.group[max_freq].pop()\n        self.freq[x] -= 1\n        if not self.group[max_freq]:\n            del self.group[max_freq]\n        return x\n```\n\n    \n    The algorithm maintains two dictionaries (HashMap in Java, unordered_map in C++, Map in JavaScript, and defaultdict in Python): `freq` and `group`.\n\n- `freq` maps elements to their frequencies.\n- `group` maps frequencies to elements with this frequency.\n\nWhen `push` is called, we increase the frequency of the element and add it to the corresponding frequency group.\n\nWhen `pop` is called, we find the group with the highest frequency (using `rbegin()` in C++, `keySet().iterator().next()` in Java, `max()` in Python, and `Math.max()` in JavaScript). We remove the element from the highest frequency group and decrease the frequency in the `freq` dictionary. If the group is empty after removing the element, we delete it from the `group` dictionary.\n\nThe time complexities for both `push` and `pop` operations are O(log N) due to the use of balanced trees under the hood in TreeMap (Java), map (C++) or getting the maximum from the keys in Map (JavaScript), and defaultdict (Python).\n    ", "javascript": "\n    ```javascript\nclass FreqStack {\n    constructor() {\n        this.freq = new Map();\n        this.group = new Map();\n    }\n\n    push(x) {\n        let f = (this.freq.get(x) || 0) + 1;\n        this.freq.set(x, f);\n        let stack = this.group.get(f) || [];\n        stack.push(x);\n        this.group.set(f, stack);\n    }\n\n    pop() {\n        let maxFreq = Math.max(...this.group.keys());\n        let stack = this.group.get(maxFreq);\n        let x = stack.pop();\n        this.freq.set(x, this.freq.get(x) - 1);\n        if (stack.length === 0) {\n            this.group.delete(maxFreq);\n        } else {\n            this.group.set(maxFreq, stack);\n        }\n        return x;\n    }\n}\n```\n\n    \n    The algorithm maintains two dictionaries (HashMap in Java, unordered_map in C++, Map in JavaScript, and defaultdict in Python): `freq` and `group`.\n\n- `freq` maps elements to their frequencies.\n- `group` maps frequencies to elements with this frequency.\n\nWhen `push` is called, we increase the frequency of the element and add it to the corresponding frequency group.\n\nWhen `pop` is called, we find the group with the highest frequency (using `rbegin()` in C++, `keySet().iterator().next()` in Java, `max()` in Python, and `Math.max()` in JavaScript). We remove the element from the highest frequency group and decrease the frequency in the `freq` dictionary. If the group is empty after removing the element, we delete it from the `group` dictionary.\n\nThe time complexities for both `push` and `pop` operations are O(log N) due to the use of balanced trees under the hood in TreeMap (Java), map (C++) or getting the maximum from the keys in Map (JavaScript), and defaultdict (Python).\n    "}
{"id": 935, "slug": "knight-dialer", "title": "Knight Dialer", "difficulty": "Medium", "content": "The chess knight has a **unique movement**, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an **L**). The possible movements of chess knight are shown in this diagaram:\n\nA chess knight can move as indicated in the chess diagram below:\n\nWe have a chess knight and a phone pad as shown below, the knight **can only stand on a numeric cell** (i.e. blue cell).\n\nGiven an integer `n`, return how many distinct phone numbers of length `n` we can dial.\n\nYou are allowed to place the knight **on any numeric cell** initially and then you should perform `n - 1` jumps to dial a number of length `n`. All jumps should be **valid** knight jumps.\n\nAs the answer may be very large, **return the answer modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** 10\n**Explanation:** We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 20\n**Explanation:** All the valid number we can dial are \\[04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94\\]\n\n**Example 3:**\n\n**Input:** n = 3131\n**Output:** 136006598\n**Explanation:** Please take care of the mod.\n\n**Constraints:**\n\n*   `1 <= n <= 5000`", "java": "\n    ```java\npublic String lexSmallestString(String s, int k) {\n    String res = s;\n    for (int i = 0; i < k; i++) {\n        String tmp = s.substring(i) + s.substring(0, i);\n        if (tmp.compareTo(res) < 0) {\n            res = tmp;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm for this problem is quite simple. We can iterate through the first `k` characters of the input string `s`. In each iteration, we generate a new string by moving the substring consisting of the first `i` characters to the end of the string. Then, we compare the new string with the current result. If the new string is lexicographically smaller, we update the result. After iterating through all `k` possibilities, we return the lexicographically smallest string we've found. \n    ", "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring lex_smallest_string(string s, int k) {\n    string res = s;\n    for (int i = 0; i < k; ++i) {\n        string tmp = s.substr(i) + s.substr(0, i);\n        if (tmp < res) res = tmp;\n    }\n    return res;\n}\n```\n    \n    The algorithm for this problem is quite simple. We can iterate through the first `k` characters of the input string `s`. In each iteration, we generate a new string by moving the substring consisting of the first `i` characters to the end of the string. Then, we compare the new string with the current result. If the new string is lexicographically smaller, we update the result. After iterating through all `k` possibilities, we return the lexicographically smallest string we've found. \n    ", "python": "\n    ```python\ndef lex_smallest_string(s, k):\n    res = s\n    for i in range(k):\n        tmp = s[i:] + s[:i]\n        if tmp < res:\n            res = tmp\n    return res\n```\n    \n    The algorithm for this problem is quite simple. We can iterate through the first `k` characters of the input string `s`. In each iteration, we generate a new string by moving the substring consisting of the first `i` characters to the end of the string. Then, we compare the new string with the current result. If the new string is lexicographically smaller, we update the result. After iterating through all `k` possibilities, we return the lexicographically smallest string we've found. \n    ", "javascript": "\n    ```javascript\nfunction lexSmallestString(s, k) {\n    let res = s;\n    for (let i = 0; i < k; i++) {\n        let tmp = s.slice(i) + s.slice(0, i);\n        if (tmp < res) {\n            res = tmp;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm for this problem is quite simple. We can iterate through the first `k` characters of the input string `s`. In each iteration, we generate a new string by moving the substring consisting of the first `i` characters to the end of the string. Then, we compare the new string with the current result. If the new string is lexicographically smaller, we update the result. After iterating through all `k` possibilities, we return the lexicographically smallest string we've found. \n    "}
{"id": 940, "slug": "distinct-subsequences-ii", "title": "Distinct Subsequences II", "difficulty": "Hard", "content": "Given a string s, return _the number of **distinct non-empty subsequences** of_ `s`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not.\n\n**Example 1:**\n\n**Input:** s =  \"abc \"\n**Output:** 7\n**Explanation:** The 7 distinct subsequences are  \"a \",  \"b \",  \"c \",  \"ab \",  \"ac \",  \"bc \", and  \"abc \".\n\n**Example 2:**\n\n**Input:** s =  \"aba \"\n**Output:** 6\n**Explanation:** The 6 distinct subsequences are  \"a \",  \"b \",  \"ab \",  \"aa \",  \"ba \", and  \"aba \".\n\n**Example 3:**\n\n**Input:** s =  \"aaa \"\n**Output:** 3\n**Explanation:** The 3 distinct subsequences are  \"a \",  \"aa \" and  \"aaa \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase English letters.", "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int totalFruit(int[] fruits) {\n    int left = 0, right = 0, max_count = 0, n = fruits.length;\n    HashMap<Integer, Integer> count = new HashMap<>();\n\n    while (right < n) {\n        count.put(fruits[right], count.getOrDefault(fruits[right], 0) + 1);\n        while (count.size() > 2) {\n            count.put(fruits[left], count.get(fruits[left]) - 1);\n            if (count.get(fruits[left]) == 0) {\n                count.remove(fruits[left]);\n            }\n            left++;\n        }\n        max_count = Math.max(max_count, right - left + 1);\n        right++;\n    }\n    return max_count;\n}\n```\n    \n    The algorithm uses a sliding window approach where two pointers \"left\" and \"right\" traverse through the `fruits` array while maintaining a frequency \"count\" hashmap (or map in JavaScript) to count the occurrences of different fruits in the current window.\n\n1. First, initialize `left`, `right`, and `max_count` to 0, and an empty hashmap for `count`.\n2. Perform a while loop where the condition is `right < length of fruits`.\n3. Update the hashmap `count` with the fruit at the right index, incrementing the count by 1.\n4. If the hashmap size is greater than 2, it means more than two types of fruits are in the current window, so we need to remove the leftmost fruit from the hashmap and increment the left pointer.\n5. Calculate the maximum collected fruit count (`max_count`) by getting the max of the current `max_count` and the number of fruits in the current window (i.e., `right - left + 1`).\n6. Increment the right pointer to move the window.\n7. When the while loop finishes, return the `max_count`.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint totalFruit(vector<int>& fruits) {\n    int left = 0, right = 0, max_count = 0, n = fruits.size();\n    unordered_map<int, int> count;\n\n    while (right < n) {\n        count[fruits[right]]++;\n        while (count.size() > 2) {\n            count[fruits[left]]--;\n            if (count[fruits[left]] == 0) {\n                count.erase(fruits[left]);\n            }\n            left++;\n        }\n        max_count = max(max_count, right - left + 1);\n        right++;\n    }\n    return max_count;\n}\n```\n    \n    The algorithm uses a sliding window approach where two pointers \"left\" and \"right\" traverse through the `fruits` array while maintaining a frequency \"count\" hashmap (or map in JavaScript) to count the occurrences of different fruits in the current window.\n\n1. First, initialize `left`, `right`, and `max_count` to 0, and an empty hashmap for `count`.\n2. Perform a while loop where the condition is `right < length of fruits`.\n3. Update the hashmap `count` with the fruit at the right index, incrementing the count by 1.\n4. If the hashmap size is greater than 2, it means more than two types of fruits are in the current window, so we need to remove the leftmost fruit from the hashmap and increment the left pointer.\n5. Calculate the maximum collected fruit count (`max_count`) by getting the max of the current `max_count` and the number of fruits in the current window (i.e., `right - left + 1`).\n6. Increment the right pointer to move the window.\n7. When the while loop finishes, return the `max_count`.\n    ", "python": "\n    ```python\ndef totalFruit(fruits):\n    left, right, max_count = 0, 0, 0\n    count = {}\n\n    while right < len(fruits):\n        count[fruits[right]] = count.get(fruits[right], 0) + 1\n        while len(count) > 2:\n            count[fruits[left]] -= 1\n            if count[fruits[left]] == 0:\n                del count[fruits[left]]\n            left += 1\n        max_count = max(max_count, right - left + 1)\n        right += 1\n\n    return max_count\n```\n    \n    The algorithm uses a sliding window approach where two pointers \"left\" and \"right\" traverse through the `fruits` array while maintaining a frequency \"count\" hashmap (or map in JavaScript) to count the occurrences of different fruits in the current window.\n\n1. First, initialize `left`, `right`, and `max_count` to 0, and an empty hashmap for `count`.\n2. Perform a while loop where the condition is `right < length of fruits`.\n3. Update the hashmap `count` with the fruit at the right index, incrementing the count by 1.\n4. If the hashmap size is greater than 2, it means more than two types of fruits are in the current window, so we need to remove the leftmost fruit from the hashmap and increment the left pointer.\n5. Calculate the maximum collected fruit count (`max_count`) by getting the max of the current `max_count` and the number of fruits in the current window (i.e., `right - left + 1`).\n6. Increment the right pointer to move the window.\n7. When the while loop finishes, return the `max_count`.\n    ", "javascript": "\n    ```javascript\nfunction totalFruit(fruits) {\n    let left = 0, right = 0, max_count = 0;\n    const count = new Map();\n\n    while (right < fruits.length) {\n        count.set(fruits[right], (count.get(fruits[right]) || 0) + 1);\n        while (count.size > 2) {\n            count.set(fruits[left], count.get(fruits[left]) - 1);\n            if (count.get(fruits[left]) === 0) {\n                count.delete(fruits[left]);\n            }\n            left++;\n        }\n        max_count = Math.max(max_count, right - left + 1);\n        right++;\n    }\n    return max_count;\n}\n```\n    \n    The algorithm uses a sliding window approach where two pointers \"left\" and \"right\" traverse through the `fruits` array while maintaining a frequency \"count\" hashmap (or map in JavaScript) to count the occurrences of different fruits in the current window.\n\n1. First, initialize `left`, `right`, and `max_count` to 0, and an empty hashmap for `count`.\n2. Perform a while loop where the condition is `right < length of fruits`.\n3. Update the hashmap `count` with the fruit at the right index, incrementing the count by 1.\n4. If the hashmap size is greater than 2, it means more than two types of fruits are in the current window, so we need to remove the leftmost fruit from the hashmap and increment the left pointer.\n5. Calculate the maximum collected fruit count (`max_count`) by getting the max of the current `max_count` and the number of fruits in the current window (i.e., `right - left + 1`).\n6. Increment the right pointer to move the window.\n7. When the while loop finishes, return the `max_count`.\n    "}
{"id": 943, "slug": "find-the-shortest-superstring", "title": "Find the Shortest Superstring", "difficulty": "Hard", "content": "Given an array of strings `words`, return _the smallest string that contains each string in_ `words` _as a substring_. If there are multiple valid strings of the smallest length, return **any of them**.\n\nYou may assume that no string in `words` is a substring of another string in `words`.\n\n**Example 1:**\n\n**Input:** words = \\[ \"alex \", \"loves \", \"leetcode \"\\]\n**Output:**  \"alexlovesleetcode \"\n**Explanation:** All permutations of  \"alex \", \"loves \", \"leetcode \" would also be accepted.\n\n**Example 2:**\n\n**Input:** words = \\[ \"catg \", \"ctaagt \", \"gcta \", \"ttca \", \"atgcatc \"\\]\n**Output:**  \"gctaagttcatgcatc \"\n\n**Constraints:**\n\n*   `1 <= words.length <= 12`\n*   `1 <= words[i].length <= 20`\n*   `words[i]` consists of lowercase English letters.\n*   All the strings of `words` are **unique**.", "java": "\n    ```java\npublic int sumOfMins(int[] arr) {\n    int mod = (int)1e9 + 7;\n    int n = arr.length;\n    int[] left = new int[n], right = new int[n];\n    Stack<Integer> st = new Stack<>();\n\n    for (int i = 0; i < n; i++) {\n        while (!st.isEmpty() && arr[st.peek()] > arr[i]) {\n            st.pop();\n        }\n        left[i] = st.isEmpty() ? -1 : st.peek();\n        st.push(i);\n    }\n\n    st.clear();\n    for (int i = n - 1; i >= 0; i--) {\n        while (!st.isEmpty() && arr[st.peek()] > arr[i]) {\n            st.pop();\n        }\n        right[i] = st.isEmpty() ? n : st.peek();\n        st.push(i);\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        ans = (int)((ans + (long)arr[i] * (i - left[i]) * (right[i] - i)) % mod);\n    }\n    return ans;\n}\n```\n    \n    To find the sum of minimum elements in all subarrays, we first find two auxiliary arrays, 'left' and 'right', which store the index of the closest smaller element for each element in the input array from left and right respectively.\n\nWe then iterate over the array and for each element, we find the product of the element, its distance to the previous smaller element (stored in 'left') and its distance to the next smaller element (stored in 'right'). The sum of these products for all elements in the array gives us the sum of minimums in all subarrays.\n\nFinally, we return the total sum of minimums modulo 10^9 + 7.\n    ", "c++": "\n    ```cpp\nint sumOfMins(vector<int>& arr) {\n    int mod = 1e9 + 7;\n    int n = arr.size();\n    vector<int> left(n), right(n);\n    stack<int> st;\n\n    for (int i = 0; i < n; i++) {\n        while (!st.empty() && arr[st.top()] > arr[i]) {\n            st.pop();\n        }\n        left[i] = st.empty() ? -1 : st.top();\n        st.push(i);\n    }\n\n    while (!st.empty()) st.pop();\n    for (int i = n - 1; i >= 0; i--) {\n        while (!st.empty() && arr[st.top()] > arr[i]) {\n            st.pop();\n        }\n        right[i] = st.empty() ? n : st.top();\n        st.push(i);\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        ans = (ans + arr[i] * (i - left[i]) * (right[i] - i)) % mod;\n    }\n    return ans;\n}\n```\n    \n    To find the sum of minimum elements in all subarrays, we first find two auxiliary arrays, 'left' and 'right', which store the index of the closest smaller element for each element in the input array from left and right respectively.\n\nWe then iterate over the array and for each element, we find the product of the element, its distance to the previous smaller element (stored in 'left') and its distance to the next smaller element (stored in 'right'). The sum of these products for all elements in the array gives us the sum of minimums in all subarrays.\n\nFinally, we return the total sum of minimums modulo 10^9 + 7.\n    ", "python": "\n    ```python\ndef sum_of_mins(arr):\n    mod = 10**9 + 7\n    n = len(arr)\n    left, right = [0] * n, [0] * n\n    st = []\n\n    for i in range(n):\n        while st and arr[st[-1]] > arr[i]:\n            st.pop()\n        left[i] = st[-1] if st else -1\n        st.append(i)\n\n    st.clear()\n    for i in range(n - 1, -1, -1):\n        while st and arr[st[-1]] > arr[i]:\n            st.pop()\n        right[i] = st[-1] if st else n\n        st.append(i)\n\n    ans = 0\n    for i in range(n):\n        ans = (ans + arr[i] * (i - left[i]) * (right[i] - i)) % mod\n    return ans\n```\n    \n    To find the sum of minimum elements in all subarrays, we first find two auxiliary arrays, 'left' and 'right', which store the index of the closest smaller element for each element in the input array from left and right respectively.\n\nWe then iterate over the array and for each element, we find the product of the element, its distance to the previous smaller element (stored in 'left') and its distance to the next smaller element (stored in 'right'). The sum of these products for all elements in the array gives us the sum of minimums in all subarrays.\n\nFinally, we return the total sum of minimums modulo 10^9 + 7.\n    ", "javascript": "\n    ```javascript\nfunction sumOfMins(arr) {\n    let mod = 1e9 + 7;\n    let n = arr.length;\n    let left = new Array(n), right = new Array(n);\n    let st = [];\n\n    for (let i = 0; i < n; i++) {\n        while (st.length && arr[st[st.length - 1]] > arr[i]) {\n            st.pop();\n        }\n        left[i] = st.length === 0 ? -1 : st[st.length - 1];\n        st.push(i);\n    }\n\n    st = [];\n    for (let i = n - 1; i >= 0; i--) {\n        while (st.length && arr[st[st.length - 1]] > arr[i]) {\n            st.pop();\n        }\n        right[i] = st.length === 0 ? n : st[st.length - 1];\n        st.push(i);\n    }\n\n    let ans = 0;\n    for (let i = 0; i < n; i++) {\n        ans = (ans + arr[i] * (i - left[i]) * (right[i] - i)) % mod;\n    }\n    return ans;\n}\n```\n    \n    To find the sum of minimum elements in all subarrays, we first find two auxiliary arrays, 'left' and 'right', which store the index of the closest smaller element for each element in the input array from left and right respectively.\n\nWe then iterate over the array and for each element, we find the product of the element, its distance to the previous smaller element (stored in 'left') and its distance to the next smaller element (stored in 'right'). The sum of these products for all elements in the array gives us the sum of minimums in all subarrays.\n\nFinally, we return the total sum of minimums modulo 10^9 + 7.\n    "}
{"id": 956, "slug": "tallest-billboard", "title": "Tallest Billboard", "difficulty": "Hard", "content": "You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.\n\nYou are given a collection of `rods` that can be welded together. For example, if you have rods of lengths `1`, `2`, and `3`, you can weld them together to make a support of length `6`.\n\nReturn _the largest possible height of your billboard installation_. If you cannot support the billboard, return `0`.\n\n**Example 1:**\n\n**Input:** rods = \\[1,2,3,6\\]\n**Output:** 6\n**Explanation:** We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.\n\n**Example 2:**\n\n**Input:** rods = \\[1,2,3,4,5,6\\]\n**Output:** 10\n**Explanation:** We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.\n\n**Example 3:**\n\n**Input:** rods = \\[1,2\\]\n**Output:** 0\n**Explanation:** The billboard cannot be supported, so we return 0.\n\n**Constraints:**\n\n*   `1 <= rods.length <= 20`\n*   `1 <= rods[i] <= 1000`\n*   `sum(rods[i]) <= 5000`", "java": "\n    ```java\npublic int numMusicPlaylists(int n, int goal, int k) {\n    long MOD = 1000000007;\n    long[][] dp = new long[goal + 1][n + 1];\n    dp[0][0] = 1;\n    for (int i = 1; i <= goal; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j - 1] * (n - (j - 1)) % MOD + dp[i - 1][j] * Math.max(0, j - k) % MOD) % MOD;\n        }\n    }\n    return (int) dp[goal][n];\n}\n```\n    \n    Here, we use a Dynamic Programming approach to solve the problem. We first create a 2D array dp where dp[i][j] represents the number of playlists of length i formed using j different songs. We initialize dp[0][0] to 1.\n\nThen, we loop through each cell of the dp array from length 1 to goal and from song 1 to n. For each cell, we do the following:\n1. Add a new song to the playlist. The number of ways to do this is (n - (j - 1)).\n2. Add an existing song to the playlist, with the condition that the song is not played in the last k positions. The number of ways to do this is max(0, j - k).\n\nWe add both of these to update the value of dp[i][j] and calculate the result modulo 109 + 7. Eventually, we return the value in dp[goal][n] which is the number of possible playlists of length goal formed using n different songs.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#define MOD 1000000007\n\nint numMusicPlaylists(int n, int goal, int k) {\n    std::vector<std::vector<long long>> dp(goal + 1, std::vector<long long>(n + 1, 0));\n    dp[0][0] = 1;\n    for (int i = 1; i <= goal; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = ((dp[i - 1][j - 1] * (n - (j - 1))) % MOD + (dp[i - 1][j] * std::max(0, j - k)) % MOD) % MOD;\n        }\n    }\n    return dp[goal][n];\n}\n```\n    \n    Here, we use a Dynamic Programming approach to solve the problem. We first create a 2D array dp where dp[i][j] represents the number of playlists of length i formed using j different songs. We initialize dp[0][0] to 1.\n\nThen, we loop through each cell of the dp array from length 1 to goal and from song 1 to n. For each cell, we do the following:\n1. Add a new song to the playlist. The number of ways to do this is (n - (j - 1)).\n2. Add an existing song to the playlist, with the condition that the song is not played in the last k positions. The number of ways to do this is max(0, j - k).\n\nWe add both of these to update the value of dp[i][j] and calculate the result modulo 109 + 7. Eventually, we return the value in dp[goal][n] which is the number of possible playlists of length goal formed using n different songs.\n    ", "python": "\n    ```python\ndef numMusicPlaylists(n, goal, k):\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(goal + 1)]\n    dp[0][0] = 1\n    for i in range(1, goal + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j - 1] * (n - (j - 1)) % MOD + dp[i - 1][j] * max(0, j - k) % MOD) % MOD\n    return dp[goal][n]\n```\n    \n    Here, we use a Dynamic Programming approach to solve the problem. We first create a 2D array dp where dp[i][j] represents the number of playlists of length i formed using j different songs. We initialize dp[0][0] to 1.\n\nThen, we loop through each cell of the dp array from length 1 to goal and from song 1 to n. For each cell, we do the following:\n1. Add a new song to the playlist. The number of ways to do this is (n - (j - 1)).\n2. Add an existing song to the playlist, with the condition that the song is not played in the last k positions. The number of ways to do this is max(0, j - k).\n\nWe add both of these to update the value of dp[i][j] and calculate the result modulo 109 + 7. Eventually, we return the value in dp[goal][n] which is the number of possible playlists of length goal formed using n different songs.\n    ", "javascript": "\n    ```javascript\nfunction numMusicPlaylists(n, goal, k) {\n    const MOD = 1_000_000_007;\n    const dp = Array.from({ length: goal + 1 }, () => Array.from({ length: n + 1 }, () => 0));\n    dp[0][0] = 1;\n    for (let i = 1; i <= goal; i++) {\n        for (let j = 1; j <= n; j++) {\n            dp[i][j] = ((dp[i - 1][j - 1] * (n - (j - 1))) % MOD + (dp[i - 1][j] * Math.max(0, j - k)) % MOD) % MOD;\n        }\n    }\n    return dp[goal][n];\n}\n```\n    \n    Here, we use a Dynamic Programming approach to solve the problem. We first create a 2D array dp where dp[i][j] represents the number of playlists of length i formed using j different songs. We initialize dp[0][0] to 1.\n\nThen, we loop through each cell of the dp array from length 1 to goal and from song 1 to n. For each cell, we do the following:\n1. Add a new song to the playlist. The number of ways to do this is (n - (j - 1)).\n2. Add an existing song to the playlist, with the condition that the song is not played in the last k positions. The number of ways to do this is max(0, j - k).\n\nWe add both of these to update the value of dp[i][j] and calculate the result modulo 109 + 7. Eventually, we return the value in dp[goal][n] which is the number of possible playlists of length goal formed using n different songs.\n    "}
{"id": 960, "slug": "delete-columns-to-make-sorted-iii", "title": "Delete Columns to Make Sorted III", "difficulty": "Hard", "content": "You are given an array of `n` strings `strs`, all of the same length.\n\nWe may choose any deletion indices, and we delete all the characters in those indices for each string.\n\nFor example, if we have `strs = [ \"abcdef \", \"uvwxyz \"]` and deletion indices `{0, 2, 3}`, then the final array after deletions is `[ \"bef \", \"vyz \"]`.\n\nSuppose we chose a set of deletion indices `answer` such that after deletions, the final array has **every string (row) in lexicographic** order. (i.e., `(strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1])`, and `(strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1])`, and so on). Return _the minimum possible value of_ `answer.length`.\n\n**Example 1:**\n\n**Input:** strs = \\[ \"babca \", \"bbazb \"\\]\n**Output:** 3\n**Explanation:** After deleting columns 0, 1, and 4, the final array is strs = \\[ \"bc \",  \"az \"\\].\nBoth these rows are individually in lexicographic order (ie. strs\\[0\\]\\[0\\] <= strs\\[0\\]\\[1\\] and strs\\[1\\]\\[0\\] <= strs\\[1\\]\\[1\\]).\nNote that strs\\[0\\] > strs\\[1\\] - the array strs is not necessarily in lexicographic order.\n\n**Example 2:**\n\n**Input:** strs = \\[ \"edcba \"\\]\n**Output:** 4\n**Explanation:** If we delete less than 4 columns, the only row will not be lexicographically sorted.\n\n**Example 3:**\n\n**Input:** strs = \\[ \"ghi \", \"def \", \"abc \"\\]\n**Output:** 0\n**Explanation:** All rows are already lexicographically sorted.\n\n**Constraints:**\n\n*   `n == strs.length`\n*   `1 <= n <= 100`\n*   `1 <= strs[i].length <= 100`\n*   `strs[i]` consists of lowercase English letters.", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int n = graph.length;\n        Arrays.sort(initial);\n        \n        Set<Integer> malware = new HashSet<>();\n        for (int i : initial) {\n            malware.add(i);\n        }\n        \n        int minNode = initial[0], minSpread = n + 1;\n        for (int node : initial) {\n            Queue<Integer> q = new LinkedList<>();\n            boolean[] visited = new boolean[n];\n            \n            for (int otherNode : initial) {\n                if (node != otherNode) {\n                    q.offer(otherNode);\n                    visited[otherNode] = true;\n                }\n            }\n\n            while (!q.isEmpty()) {\n                int cur = q.poll();\n                for (int next = 0; next < n; ++next) {\n                    if (graph[cur][next] == 1 && !visited[next] && !malware.contains(next)) {\n                        visited[next] = true;\n                        q.offer(next);\n                    }\n                }\n            }\n            \n            int spread = 0;\n            for (boolean v : visited) {\n                spread += v ? 1 : 0;\n            }\n\n            if (spread < minSpread) {\n                minNode = node;\n                minSpread = spread;\n            }\n        }\n        \n        return minNode;\n    }\n}\n```\n\n    \n    The algorithm starts by sorting the node indices of the initial malware-infected nodes in ascending order. Then, it initializes a set called `malware` for efficient look-up of malware-infected nodes. We also initialize variables to store the node index that, when removed, minimizes the number of infected nodes (i.e., `minNode`) and the minimum number of infected nodes across all node removals (i.e., `minSpread`). Next, we iterate through each malware-infected node and simulate the spread of malware after removing the node from the initial set of infected nodes. During each iteration/simulation, we maintain a queue (FIFO) `q` that stores the currently traversed nodes and a `visited` array to keep track of previously traversed nodes. While there are still nodes to traverse, we dequeue a node `cur` from `q` and enqueue all unvisited, non-infected neighboring nodes. After the traversal, we calculate the total number of infected nodes (`spread`) and update `minNode` accordingly. Finally, we return `minNode` as the node that, if removed, would minimize M(initial).\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n#include <queue>\n\nint minMalwareSpread(std::vector<std::vector<int>>& graph, std::vector<int>& initial) {\n    int n = graph.size();\n    std::sort(initial.begin(), initial.end());\n    \n    std::unordered_set<int> malware(initial.begin(), initial.end());\n    \n    int minNode = initial[0], minSpread = n + 1;\n    for (int node : initial) {\n        std::queue<int> q;\n        std::vector<bool> visited(n, false);\n        \n        for (int otherNode : initial) {\n            if (node != otherNode) {\n                q.push(otherNode);\n                visited[otherNode] = true;\n            }\n        }\n\n        while (!q.empty()) {\n            int cur = q.front(); q.pop();\n            for (int next = 0; next < n; ++next) {\n                if (graph[cur][next] == 1 && !visited[next] && !malware.count(next)) {\n                    visited[next] = true;\n                    q.push(next);\n                }\n            }\n        }\n        \n        int spread = 0;\n        for (bool v : visited) {\n            spread += v;\n        }\n\n        if (spread < minSpread) {\n            minNode = node;\n            minSpread = spread;\n        }\n    }\n    \n    return minNode;\n}\n```\n\n    \n    The algorithm starts by sorting the node indices of the initial malware-infected nodes in ascending order. Then, it initializes a set called `malware` for efficient look-up of malware-infected nodes. We also initialize variables to store the node index that, when removed, minimizes the number of infected nodes (i.e., `minNode`) and the minimum number of infected nodes across all node removals (i.e., `minSpread`). Next, we iterate through each malware-infected node and simulate the spread of malware after removing the node from the initial set of infected nodes. During each iteration/simulation, we maintain a queue (FIFO) `q` that stores the currently traversed nodes and a `visited` array to keep track of previously traversed nodes. While there are still nodes to traverse, we dequeue a node `cur` from `q` and enqueue all unvisited, non-infected neighboring nodes. After the traversal, we calculate the total number of infected nodes (`spread`) and update `minNode` accordingly. Finally, we return `minNode` as the node that, if removed, would minimize M(initial).\n    ", "python": "\n    ```python\nfrom collections import deque\n\ndef minMalwareSpread(graph, initial):\n    n = len(graph)\n    initial.sort()\n    \n    malware = set(initial)\n    \n    minNode = initial[0]\n    minSpread = n + 1\n\n    for node in initial:\n        q = deque(otherNode for otherNode in initial if node != otherNode)\n        visited = [node != otherNode and otherNode in malware for otherNode in range(n)]\n        \n        while q:\n            cur = q.popleft()\n            for next, isConnected in enumerate(graph[cur]):\n                if isConnected and not visited[next] and next not in malware:\n                    visited[next] = True\n                    q.append(next)\n        \n        spread = sum(visited)\n        \n        if spread < minSpread:\n            minNode = node\n            minSpread = spread\n    \n    return minNode\n```\n\n    \n    The algorithm starts by sorting the node indices of the initial malware-infected nodes in ascending order. Then, it initializes a set called `malware` for efficient look-up of malware-infected nodes. We also initialize variables to store the node index that, when removed, minimizes the number of infected nodes (i.e., `minNode`) and the minimum number of infected nodes across all node removals (i.e., `minSpread`). Next, we iterate through each malware-infected node and simulate the spread of malware after removing the node from the initial set of infected nodes. During each iteration/simulation, we maintain a queue (FIFO) `q` that stores the currently traversed nodes and a `visited` array to keep track of previously traversed nodes. While there are still nodes to traverse, we dequeue a node `cur` from `q` and enqueue all unvisited, non-infected neighboring nodes. After the traversal, we calculate the total number of infected nodes (`spread`) and update `minNode` accordingly. Finally, we return `minNode` as the node that, if removed, would minimize M(initial).\n    ", "javascript": "\n    ```javascript\nfunction minMalwareSpread(graph, initial) {\n    const n = graph.length;\n    initial.sort((a, b) => a - b);\n    \n    const malware = new Set(initial);\n    \n    let minNode = initial[0];\n    let minSpread = n + 1;\n\n    for (const node of initial) {\n        const q = [];\n        const visited = new Array(n).fill(false);\n\n        for (const otherNode of initial) {\n            if (node !== otherNode) {\n                q.push(otherNode);\n                visited[otherNode] = true;\n            }\n        }\n\n        while (q.length) {\n            const cur = q.shift();\n            for (let next = 0; next < n; ++next) {\n                if (graph[cur][next] === 1 && !visited[next] && !malware.has(next)) {\n                    visited[next] = true;\n                    q.push(next);\n                }\n            }\n        }\n        \n        const spread = visited.reduce((acc, v) => acc + (v ? 1 : 0), 0);\n\n        if (spread < minSpread) {\n            minNode = node;\n            minSpread = spread;\n        }\n    }\n    \n    return minNode;\n}\n```\n\n    \n    The algorithm starts by sorting the node indices of the initial malware-infected nodes in ascending order. Then, it initializes a set called `malware` for efficient look-up of malware-infected nodes. We also initialize variables to store the node index that, when removed, minimizes the number of infected nodes (i.e., `minNode`) and the minimum number of infected nodes across all node removals (i.e., `minSpread`). Next, we iterate through each malware-infected node and simulate the spread of malware after removing the node from the initial set of infected nodes. During each iteration/simulation, we maintain a queue (FIFO) `q` that stores the currently traversed nodes and a `visited` array to keep track of previously traversed nodes. While there are still nodes to traverse, we dequeue a node `cur` from `q` and enqueue all unvisited, non-infected neighboring nodes. After the traversal, we calculate the total number of infected nodes (`spread`) and update `minNode` accordingly. Finally, we return `minNode` as the node that, if removed, would minimize M(initial).\n    "}
{"id": 964, "slug": "least-operators-to-express-number", "title": "Least Operators to Express Number", "difficulty": "Hard", "content": "Given a single positive integer `x`, we will write an expression of the form `x (op1) x (op2) x (op3) x ...` where each operator `op1`, `op2`, etc. is either addition, subtraction, multiplication, or division (`+`, `-`, `*`, or `/)`. For example, with `x = 3`, we might write `3 * 3 / 3 + 3 - 3` which is a value of 3.\n\nWhen writing such an expression, we adhere to the following conventions:\n\n*   The division operator (`/`) returns rational numbers.\n*   There are no parentheses placed anywhere.\n*   We use the usual order of operations: multiplication and division happen before addition and subtraction.\n*   It is not allowed to use the unary negation operator (`-`). For example, \"`x - x` \" is a valid expression as it only uses subtraction, but \"`-x + x` \" is not because it uses negation.\n\nWe would like to write an expression with the least number of operators such that the expression equals the given `target`. Return the least number of operators used.\n\n**Example 1:**\n\n**Input:** x = 3, target = 19\n**Output:** 5\n**Explanation:** 3 \\* 3 + 3 \\* 3 + 3 / 3.\nThe expression contains 5 operations.\n\n**Example 2:**\n\n**Input:** x = 5, target = 501\n**Output:** 8\n**Explanation:** 5 \\* 5 \\* 5 \\* 5 - 5 \\* 5 \\* 5 + 5 / 5.\nThe expression contains 8 operations.\n\n**Example 3:**\n\n**Input:** x = 100, target = 100000000\n**Output:** 3\n**Explanation:** 100 \\* 100 \\* 100 \\* 100.\nThe expression contains 3 operations.\n\n**Constraints:**\n\n*   `2 <= x <= 100`\n*   `1 <= target <= 2 * 108`", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int n = graph.length, res = 0, minSize = Integer.MAX_VALUE;\n        int[] color = new int[n];\n        Arrays.fill(color, -1);\n        int colors = 0;\n\n        for (int i = 0; i < n; ++i) {\n            if (color[i] == -1) {\n                Queue<Integer> q = new LinkedList<>();\n                q.offer(i);\n                color[i] = colors;\n\n                while (!q.isEmpty()) {\n                    int t = q.poll();\n                    for (int j = 0; j < n; ++j) {\n                        if (graph[t][j] == 1 && color[j] == -1) {\n                            q.offer(j);\n                            color[j] = colors;\n                        }\n                    }\n                }\n                ++colors;\n            }\n        }\n\n        int[] area = new int[colors], count = new int[colors];\n        Set<Integer> initiallyInfected = new HashSet<>();\n        for (int i : initial) {\n            initiallyInfected.add(i);\n        }\n        for (int i = 0; i < n; ++i) {\n            ++area[color[i]];\n            if (initiallyInfected.contains(i)) {\n                ++count[color[i]];\n            }\n        }\n\n        for (int i : initial) {\n            if (count[color[i]] == 1) {\n                if (area[color[i]] < minSize) {\n                    minSize = area[color[i]];\n                    res = i;\n                } else if (area[color[i]] == minSize && i < res) {\n                    res = i;\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```\n    \n    Initially, we mark all nodes with a unique color in such a way that adjacent nodes have the same color, so that we can track how many uninfected nodes are connected to every infected node in the initial set. We use BFS to do the coloring operation. Then, we calculate the number of nodes for each unique color and calculate the count of nodes in the initial set that share the same color. \n\nFinally, we iterate through every node in the initial list, and if that node's color has a count of 1, meaning it is the only infected node in its group, we check if it minimizes the number of nodes infected post-removal. If so, the result is updated to the current node. The result is the node that, if removed, would minimize M(initial). If there are multiple such nodes, the one with the smallest index is returned.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n#include <queue>\nusing namespace std;\n\nint minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {\n    int n = graph.size(), res = 0, minSize = INT_MAX;\n    vector<int> color(n, -1);\n    int colors = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (color[i] == -1) {\n            queue<int> q;\n            q.push(i);\n            color[i] = colors;\n\n            while (!q.empty()) {\n                int t = q.front(); q.pop();\n                for (int j = 0; j < n; ++j) {\n                    if (graph[t][j] == 1 && color[j] == -1) {\n                        q.push(j);\n                        color[j] = colors;\n                    }\n                }\n            }\n            ++colors;\n        }\n    }\n\n    vector<int> area(colors, 0), count(colors, 0);\n    set<int> initiallyInfected(initial.begin(), initial.end());\n    for (int i = 0; i < n; ++i) {\n        ++area[color[i]];\n        if (initiallyInfected.count(i)) {\n            ++count[color[i]];\n        }\n    }\n\n    for (int i : initial) {\n        if (count[color[i]] == 1) {\n            if (area[color[i]] < minSize) {\n                minSize = area[color[i]];\n                res = i;\n            } else if (area[color[i]] == minSize && i < res) {\n                res = i;\n            }\n        }\n    }\n\n    return res;\n}\n```\n    \n    Initially, we mark all nodes with a unique color in such a way that adjacent nodes have the same color, so that we can track how many uninfected nodes are connected to every infected node in the initial set. We use BFS to do the coloring operation. Then, we calculate the number of nodes for each unique color and calculate the count of nodes in the initial set that share the same color. \n\nFinally, we iterate through every node in the initial list, and if that node's color has a count of 1, meaning it is the only infected node in its group, we check if it minimizes the number of nodes infected post-removal. If so, the result is updated to the current node. The result is the node that, if removed, would minimize M(initial). If there are multiple such nodes, the one with the smallest index is returned.\n    ", "python": "\n    ```python\nfrom collections import deque\nfrom typing import List\n\ndef minMalwareSpread(graph: List[List[int]], initial: List[int]) -> int:\n    n = len(graph)\n    color = [-1] * n\n    colors = 0\n\n    for i in range(n):\n        if color[i] == -1:\n            q = deque([i])\n            color[i] = colors\n\n            while q:\n                t = q.popleft()\n                for j in range(n):\n                    if graph[t][j] == 1 and color[j] == -1:\n                        q.append(j)\n                        color[j] = colors\n\n            colors += 1\n\n    area = [0] * colors\n    count = [0] * colors\n    initially_infected = set(initial)\n    for i in range(n):\n        area[color[i]] += 1\n        if i in initially_infected:\n            count[color[i]] += 1\n\n    res = min(initial)\n    min_size = n + 1\n    for i in initial:\n        if count[color[i]] == 1:\n            if area[color[i]] < min_size:\n                min_size = area[color[i]]\n                res = i\n            elif area[color[i]] == min_size and i < res:\n                res = i\n\n    return res\n```\n    \n    Initially, we mark all nodes with a unique color in such a way that adjacent nodes have the same color, so that we can track how many uninfected nodes are connected to every infected node in the initial set. We use BFS to do the coloring operation. Then, we calculate the number of nodes for each unique color and calculate the count of nodes in the initial set that share the same color. \n\nFinally, we iterate through every node in the initial list, and if that node's color has a count of 1, meaning it is the only infected node in its group, we check if it minimizes the number of nodes infected post-removal. If so, the result is updated to the current node. The result is the node that, if removed, would minimize M(initial). If there are multiple such nodes, the one with the smallest index is returned.\n    ", "javascript": "\n    ```javascript\nfunction minMalwareSpread(graph, initial) {\n    const n = graph.length;\n    const color = new Array(n).fill(-1);\n    let colors = 0;\n\n    for (let i = 0; i < n; ++i) {\n        if (color[i] === -1) {\n            const q = [i];\n            color[i] = colors;\n\n            while (q.length) {\n                const t = q.shift();\n                for (let j = 0; j < n; ++j) {\n                    if (graph[t][j] === 1 && color[j] === -1) {\n                        q.push(j);\n                        color[j] = colors;\n                    }\n                }\n            }\n            ++colors;\n        }\n    }\n\n    const area = new Array(colors).fill(0);\n    const count = new Array(colors).fill(0);\n    const initiallyInfected = new Set(initial);\n\n    for (let i = 0; i < n; ++i) {\n        ++area[color[i]];\n        if (initiallyInfected.has(i)) {\n            ++count[color[i]];\n        }\n    }\n\n    let res = initial[0];\n    let minSize = n + 1;\n    for (const i of initial) {\n        if (count[color[i]] === 1) {\n            if (area[color[i]] < minSize) {\n                minSize = area[color[i]];\n                res = i;\n            } else if (area[color[i]] === minSize && i < res) {\n                res = i;\n            }\n        }\n    }\n\n    return res;\n}\n```\n    \n    Initially, we mark all nodes with a unique color in such a way that adjacent nodes have the same color, so that we can track how many uninfected nodes are connected to every infected node in the initial set. We use BFS to do the coloring operation. Then, we calculate the number of nodes for each unique color and calculate the count of nodes in the initial set that share the same color. \n\nFinally, we iterate through every node in the initial list, and if that node's color has a count of 1, meaning it is the only infected node in its group, we check if it minimizes the number of nodes infected post-removal. If so, the result is updated to the current node. The result is the node that, if removed, would minimize M(initial). If there are multiple such nodes, the one with the smallest index is returned.\n    "}
{"id": 968, "slug": "binary-tree-cameras", "title": "Binary Tree Cameras", "difficulty": "Hard", "content": "You are given the `root` of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.\n\nReturn _the minimum number of cameras needed to monitor all nodes of the tree_.\n\n**Example 1:**\n\n**Input:** root = \\[0,0,null,0,0\\]\n**Output:** 1\n**Explanation:** One camera is enough to monitor all nodes if placed as shown.\n\n**Example 2:**\n\n**Input:** root = \\[0,0,null,0,null,0,null,null,0\\]\n**Output:** 2\n**Explanation:** At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `Node.val == 0`", "java": "\n    ```java\npublic int[] beautifulArray(int n) {\n    List<Integer> result = new ArrayList<>();\n    result.add(1);\n    while (result.size() < n) {\n        List<Integer> temp = new ArrayList<>();\n        for (int i : result) {\n            if (i * 2 - 1 <= n)\n                temp.add(i * 2 - 1);\n        }\n        for (int i : result) {\n            if (i * 2 <= n)\n                temp.add(i * 2);\n        }\n        result = temp;\n    }\n    return result.stream().mapToInt(i->i).toArray();\n}\n```\n    \n    The algorithm starts with an array containing just the number 1. It then generates a new array by iterating through the current array and checking if the element value multiplied by 2 minus 1 and the element value multiplied by 2 are both less than or equal to n. If they are, these two new numbers are added to a temporary array. The current array now becomes the temporary array. This process continues until the size of the current array is equal to the integer n.\n\nThe resulting array is a beautiful array because it satisfies the conditions of the question. This approach works as the operations in the algorithm ensure that elements in the odd positions and even positions will always be less than or equal to n, thus maintaining the desired intervals between elements.\n    ", "c++": "\n    ```cpp\nvector<int> beautifulArray(int n) {\n    vector<int> result = {1};\n    while (result.size() < n) {\n        vector<int> temp;\n        for (int i : result) {\n            if (i * 2 - 1 <= n)\n                temp.push_back(i * 2 - 1);\n        }\n        for (int i : result) {\n            if (i * 2 <= n)\n                temp.push_back(i * 2);\n        }\n        result = temp;\n    }\n    return result;\n}\n```\n    \n    The algorithm starts with an array containing just the number 1. It then generates a new array by iterating through the current array and checking if the element value multiplied by 2 minus 1 and the element value multiplied by 2 are both less than or equal to n. If they are, these two new numbers are added to a temporary array. The current array now becomes the temporary array. This process continues until the size of the current array is equal to the integer n.\n\nThe resulting array is a beautiful array because it satisfies the conditions of the question. This approach works as the operations in the algorithm ensure that elements in the odd positions and even positions will always be less than or equal to n, thus maintaining the desired intervals between elements.\n    ", "python": "\n    ```python\ndef beautifulArray(n: int) -> List[int]:\n    result = [1]\n    while len(result) < n:\n        temp = []\n        for i in result:\n            if i * 2 - 1 <= n:\n                temp.append(i * 2 - 1)\n        for i in result:\n            if i * 2 <= n:\n                temp.append(i * 2)\n        result = temp\n    return result\n```\n    \n    The algorithm starts with an array containing just the number 1. It then generates a new array by iterating through the current array and checking if the element value multiplied by 2 minus 1 and the element value multiplied by 2 are both less than or equal to n. If they are, these two new numbers are added to a temporary array. The current array now becomes the temporary array. This process continues until the size of the current array is equal to the integer n.\n\nThe resulting array is a beautiful array because it satisfies the conditions of the question. This approach works as the operations in the algorithm ensure that elements in the odd positions and even positions will always be less than or equal to n, thus maintaining the desired intervals between elements.\n    ", "javascript": "\n    ```javascript\nfunction beautifulArray(n) {\n    let result = [1];\n    while (result.length < n) {\n        let temp = [];\n        for (let i of result) {\n            if (i * 2 - 1 <= n)\n                temp.push(i * 2 - 1);\n        }\n        for (let i of result) {\n            if (i * 2 <= n)\n                temp.push(i * 2);\n        }\n        result = temp;\n    }\n    return result;\n}\n```\n    \n    The algorithm starts with an array containing just the number 1. It then generates a new array by iterating through the current array and checking if the element value multiplied by 2 minus 1 and the element value multiplied by 2 are both less than or equal to n. If they are, these two new numbers are added to a temporary array. The current array now becomes the temporary array. This process continues until the size of the current array is equal to the integer n.\n\nThe resulting array is a beautiful array because it satisfies the conditions of the question. This approach works as the operations in the algorithm ensure that elements in the odd positions and even positions will always be less than or equal to n, thus maintaining the desired intervals between elements.\n    "}
{"id": 975, "slug": "odd-even-jump", "title": "Odd Even Jump", "difficulty": "Hard", "content": "You are given an integer array `arr`. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called **odd-numbered jumps**, and the (2nd, 4th, 6th, ...) jumps in the series are called **even-numbered jumps**. Note that the **jumps** are numbered, not the indices.\n\nYou may jump forward from index `i` to index `j` (with `i < j`) in the following way:\n\n*   During **odd-numbered jumps** (i.e., jumps 1, 3, 5, ...), you jump to the index `j` such that `arr[i] <= arr[j]` and `arr[j]` is the smallest possible value. If there are multiple such indices `j`, you can only jump to the **smallest** such index `j`.\n*   During **even-numbered jumps** (i.e., jumps 2, 4, 6, ...), you jump to the index `j` such that `arr[i] >= arr[j]` and `arr[j]` is the largest possible value. If there are multiple such indices `j`, you can only jump to the **smallest** such index `j`.\n*   It may be the case that for some index `i`, there are no legal jumps.\n\nA starting index is **good** if, starting from that index, you can reach the end of the array (index `arr.length - 1`) by jumping some number of times (possibly 0 or more than once).\n\nReturn _the number of **good** starting indices_.\n\n**Example 1:**\n\n**Input:** arr = \\[10,13,12,14,15\\]\n**Output:** 2\n**Explanation:** \nFrom starting index i = 0, we can make our 1st jump to i = 2 (since arr\\[2\\] is the smallest among arr\\[1\\], arr\\[2\\], arr\\[3\\], arr\\[4\\] that is greater or equal to arr\\[0\\]), then we cannot jump any more.\nFrom starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.\nFrom starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.\nFrom starting index i = 4, we have reached the end already.\nIn total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of\njumps.\n\n**Example 2:**\n\n**Input:** arr = \\[2,3,1,1,4\\]\n**Output:** 3\n**Explanation:** \nFrom starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\nDuring our 1st jump (odd-numbered), we first jump to i = 1 because arr\\[1\\] is the smallest value in \\[arr\\[1\\], arr\\[2\\], arr\\[3\\], arr\\[4\\]\\] that is greater than or equal to arr\\[0\\].\nDuring our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr\\[2\\] is the largest value in \\[arr\\[2\\], arr\\[3\\], arr\\[4\\]\\] that is less than or equal to arr\\[1\\]. arr\\[3\\] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3\nDuring our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr\\[3\\] is the smallest value in \\[arr\\[3\\], arr\\[4\\]\\] that is greater than or equal to arr\\[2\\].\nWe can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\nIn a similar manner, we can deduce that:\nFrom starting index i = 1, we jump to i = 4, so we reach the end.\nFrom starting index i = 2, we jump to i = 3, and then we can't jump anymore.\nFrom starting index i = 3, we jump to i = 4, so we reach the end.\nFrom starting index i = 4, we are already at the end.\nIn total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some\nnumber of jumps.\n\n**Example 3:**\n\n**Input:** arr = \\[5,1,3,4,2\\]\n**Output:** 3\n**Explanation:** We can reach the end from starting indices 1, 2, and 4.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 2 * 104`\n*   `0 <= arr[i] < 105`", "java": "\n    ```java\npublic int rangeSumBST(TreeNode root, int low, int high) {\n    if (root == null) return 0;\n    if (root.val < low) return rangeSumBST(root.right, low, high);\n    if (root.val > high) return rangeSumBST(root.left, low, high);\n    return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\n}\n```\n    \n    The algorithm uses a recursive approach to traverse the binary search tree. At each step, we check whether the current node's value is within the given range or not. If it's within the range, we add it to the sum and continue traversing left and right subtrees. If the current node's value is less than `low`, it means that all the nodes in the left subtree will also be smaller, so we only traverse the right subtree. If the current node's value is greater than `high`, it means that all the nodes in the right subtree will also be larger, so we only traverse the left subtree.\n    ", "c++": "\n    ```cpp\nint rangeSumBST(TreeNode* root, int low, int high) {\n    if (!root) return 0;\n    if (root->val < low) return rangeSumBST(root->right, low, high);\n    if (root->val > high) return rangeSumBST(root->left, low, high);\n    return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\n}\n```\n    \n    The algorithm uses a recursive approach to traverse the binary search tree. At each step, we check whether the current node's value is within the given range or not. If it's within the range, we add it to the sum and continue traversing left and right subtrees. If the current node's value is less than `low`, it means that all the nodes in the left subtree will also be smaller, so we only traverse the right subtree. If the current node's value is greater than `high`, it means that all the nodes in the right subtree will also be larger, so we only traverse the left subtree.\n    ", "python": "\n    ```python\ndef rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\n    if not root:\n        return 0\n    if root.val < low:\n        return self.rangeSumBST(root.right, low, high)\n    if root.val > high:\n        return self.rangeSumBST(root.left, low, high)\n    return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\n```\n    \n    The algorithm uses a recursive approach to traverse the binary search tree. At each step, we check whether the current node's value is within the given range or not. If it's within the range, we add it to the sum and continue traversing left and right subtrees. If the current node's value is less than `low`, it means that all the nodes in the left subtree will also be smaller, so we only traverse the right subtree. If the current node's value is greater than `high`, it means that all the nodes in the right subtree will also be larger, so we only traverse the left subtree.\n    ", "javascript": "\n    ```javascript\nfunction rangeSumBST(root, low, high) {\n    if (!root) return 0;\n    if (root.val < low) return rangeSumBST(root.right, low, high);\n    if (root.val > high) return rangeSumBST(root.left, low, high);\n    return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\n}\n```\n    \n    The algorithm uses a recursive approach to traverse the binary search tree. At each step, we check whether the current node's value is within the given range or not. If it's within the range, we add it to the sum and continue traversing left and right subtrees. If the current node's value is less than `low`, it means that all the nodes in the left subtree will also be smaller, so we only traverse the right subtree. If the current node's value is greater than `high`, it means that all the nodes in the right subtree will also be larger, so we only traverse the left subtree.\n    "}
{"id": 978, "slug": "longest-turbulent-subarray", "title": "Longest Turbulent Subarray", "difficulty": "Medium", "content": "Given an integer array `arr`, return _the length of a maximum size turbulent subarray of_ `arr`.\n\nA subarray is **turbulent** if the comparison sign flips between each adjacent pair of elements in the subarray.\n\nMore formally, a subarray `[arr[i], arr[i + 1], ..., arr[j]]` of `arr` is said to be turbulent if and only if:\n\n*   For `i <= k < j`:\n    *   `arr[k] > arr[k + 1]` when `k` is odd, and\n    *   `arr[k] < arr[k + 1]` when `k` is even.\n*   Or, for `i <= k < j`:\n    *   `arr[k] > arr[k + 1]` when `k` is even, and\n    *   `arr[k] < arr[k + 1]` when `k` is odd.\n\n**Example 1:**\n\n**Input:** arr = \\[9,4,2,10,7,8,8,1,9\\]\n**Output:** 5\n**Explanation:** arr\\[1\\] > arr\\[2\\] < arr\\[3\\] > arr\\[4\\] < arr\\[5\\]\n\n**Example 2:**\n\n**Input:** arr = \\[4,8,12,16\\]\n**Output:** 2\n\n**Example 3:**\n\n**Input:** arr = \\[100\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= arr.length <= 4 * 104`\n*   `0 <= arr[i] <= 109`", "java": "\n    ```java\nboolean validMountainArray(int[] arr) {\n    int n = arr.length, i = 0, j = n - 1;\n    while (i + 1 < n && arr[i] < arr[i + 1]) i++;\n    while (j > 0 && arr[j - 1] > arr[j]) j--;\n    return i > 0 && i == j && j < n - 1;\n}\n```\n    \n    The algorithm starts with two pointers `i` and `j`. Pointer `i` is initialized to 0, and pointer `j` is initialized to the last index. We iterate through the array with pointer `i` while elements are in increasing order. Then, we iterate through the array with pointer `j` while elements are in decreasing order.\n\nFinally, we check if the pointers have moved from their initial positions (i.e., `i > 0` and `j < n - 1`). We also check if both pointers have stopped at the same index (i.e., `i == j`). If these conditions are met, it means that there is a valid mountain array, and we return `true`. Otherwise, we return `false`.\n    ", "c++": "\n    ```cpp\nbool validMountainArray(vector<int>& arr) {\n    int n = arr.size(), i = 0, j = n - 1;\n    while (i + 1 < n && arr[i] < arr[i + 1]) i++;\n    while (j > 0 && arr[j - 1] > arr[j]) j--;\n    return i > 0 && i == j && j < n - 1;\n}\n```\n    \n    The algorithm starts with two pointers `i` and `j`. Pointer `i` is initialized to 0, and pointer `j` is initialized to the last index. We iterate through the array with pointer `i` while elements are in increasing order. Then, we iterate through the array with pointer `j` while elements are in decreasing order.\n\nFinally, we check if the pointers have moved from their initial positions (i.e., `i > 0` and `j < n - 1`). We also check if both pointers have stopped at the same index (i.e., `i == j`). If these conditions are met, it means that there is a valid mountain array, and we return `true`. Otherwise, we return `false`.\n    ", "python": "\n    ```python\ndef valid_mountain_array(arr):\n    n, i, j = len(arr), 0, len(arr) - 1\n    while i + 1 < n and arr[i] < arr[i + 1]:\n        i += 1\n    while j > 0 and arr[j - 1] > arr[j]:\n        j -= 1\n    return i > 0 and i == j and j < n - 1\n```\n    \n    The algorithm starts with two pointers `i` and `j`. Pointer `i` is initialized to 0, and pointer `j` is initialized to the last index. We iterate through the array with pointer `i` while elements are in increasing order. Then, we iterate through the array with pointer `j` while elements are in decreasing order.\n\nFinally, we check if the pointers have moved from their initial positions (i.e., `i > 0` and `j < n - 1`). We also check if both pointers have stopped at the same index (i.e., `i == j`). If these conditions are met, it means that there is a valid mountain array, and we return `true`. Otherwise, we return `false`.\n    ", "javascript": "\n    ```javascript\nfunction validMountainArray(arr) {\n    let n = arr.length, i = 0, j = n - 1;\n    while (i + 1 < n && arr[i] < arr[i + 1]) i++;\n    while (j > 0 && arr[j - 1] > arr[j]) j--;\n    return i > 0 && i === j && j < n - 1;\n}\n```\n    \n    The algorithm starts with two pointers `i` and `j`. Pointer `i` is initialized to 0, and pointer `j` is initialized to the last index. We iterate through the array with pointer `i` while elements are in increasing order. Then, we iterate through the array with pointer `j` while elements are in decreasing order.\n\nFinally, we check if the pointers have moved from their initial positions (i.e., `i > 0` and `j < n - 1`). We also check if both pointers have stopped at the same index (i.e., `i == j`). If these conditions are met, it means that there is a valid mountain array, and we return `true`. Otherwise, we return `false`.\n    "}
{"id": 983, "slug": "minimum-cost-for-tickets", "title": "Minimum Cost For Tickets", "difficulty": "Medium", "content": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array `days`. Each day is an integer from `1` to `365`.\n\nTrain tickets are sold in **three different ways**:\n\n*   a **1-day** pass is sold for `costs[0]` dollars,\n*   a **7-day** pass is sold for `costs[1]` dollars, and\n*   a **30-day** pass is sold for `costs[2]` dollars.\n\nThe passes allow that many days of consecutive travel.\n\n*   For example, if we get a **7-day** pass on day `2`, then we can travel for `7` days: `2`, `3`, `4`, `5`, `6`, `7`, and `8`.\n\nReturn _the minimum number of dollars you need to travel every day in the given list of days_.\n\n**Example 1:**\n\n**Input:** days = \\[1,4,6,7,8,20\\], costs = \\[2,7,15\\]\n**Output:** 11\n**Explanation:** For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs\\[0\\] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs\\[1\\] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs\\[0\\] = $2, which covered day 20.\nIn total, you spent $11 and covered all the days of your travel.\n\n**Example 2:**\n\n**Input:** days = \\[1,2,3,4,5,6,7,8,9,10,30,31\\], costs = \\[2,7,15\\]\n**Output:** 17\n**Explanation:** For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs\\[2\\] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs\\[0\\] = $2 which covered day 31.\nIn total, you spent $17 and covered all the days of your travel.\n\n**Constraints:**\n\n*   `1 <= days.length <= 365`\n*   `1 <= days[i] <= 365`\n*   `days` is in strictly increasing order.\n*   `costs.length == 3`\n*   `1 <= costs[i] <= 1000`", "java": "\n    ```java\nimport java.util.Stack;\n\npublic boolean validateStackSequences(int[] pushed, int[] popped) {\n    Stack<Integer> stack = new Stack<>();\n    int popIndex = 0;\n    \n    for (int pushValue : pushed) {\n        stack.push(pushValue);\n        while (!stack.isEmpty() && stack.peek() == popped[popIndex]) {\n            stack.pop();\n            popIndex++;\n        }\n    }\n    \n    return stack.isEmpty();\n}\n```\n\n    \n    The algorithm simulates the behavior of a stack by iterating through the `pushed` elements and pushing them onto a new temporary stack. After each push operation, the algorithm checks if the top element of the stack matches the next expected `popped` element, specified by `popIndex`. If it does match, the algorithm pops the element from the temporary stack and increments `popIndex`. \n\nAfter iterating through all elements in the `pushed` array, if the temporary stack is empty, it indicates that the given `pushed` and `popped` sequences were valid for an initially empty stack. Otherwise, the sequences were not valid, and the function returns `false`.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\n\nbool validateStackSequences(std::vector<int>& pushed, std::vector<int>& popped) {\n    std::stack<int> stack;\n    int popIndex = 0;\n    \n    for (int pushValue : pushed) {\n        stack.push(pushValue);\n        while (!stack.empty() && stack.top() == popped[popIndex]) {\n            stack.pop();\n            popIndex++;\n        }\n    }\n    \n    return stack.empty();\n}\n```\n\n    \n    The algorithm simulates the behavior of a stack by iterating through the `pushed` elements and pushing them onto a new temporary stack. After each push operation, the algorithm checks if the top element of the stack matches the next expected `popped` element, specified by `popIndex`. If it does match, the algorithm pops the element from the temporary stack and increments `popIndex`. \n\nAfter iterating through all elements in the `pushed` array, if the temporary stack is empty, it indicates that the given `pushed` and `popped` sequences were valid for an initially empty stack. Otherwise, the sequences were not valid, and the function returns `false`.\n    ", "python": "\n    ```python\ndef validateStackSequences(pushed, popped):\n    stack = []\n    popIndex = 0\n    \n    for pushValue in pushed:\n        stack.append(pushValue)\n        while stack and stack[-1] == popped[popIndex]:\n            stack.pop()\n            popIndex += 1\n    \n    return not stack\n```\n\n    \n    The algorithm simulates the behavior of a stack by iterating through the `pushed` elements and pushing them onto a new temporary stack. After each push operation, the algorithm checks if the top element of the stack matches the next expected `popped` element, specified by `popIndex`. If it does match, the algorithm pops the element from the temporary stack and increments `popIndex`. \n\nAfter iterating through all elements in the `pushed` array, if the temporary stack is empty, it indicates that the given `pushed` and `popped` sequences were valid for an initially empty stack. Otherwise, the sequences were not valid, and the function returns `false`.\n    ", "javascript": "\n    ```javascript\nfunction validateStackSequences(pushed, popped) {\n    const stack = [];\n    let popIndex = 0;\n    \n    for (const pushValue of pushed) {\n        stack.push(pushValue);\n        while (stack.length > 0 && stack[stack.length - 1] === popped[popIndex]) {\n            stack.pop();\n            popIndex++;\n        }\n    }\n    \n    return stack.length === 0;\n}\n```\n\n    \n    The algorithm simulates the behavior of a stack by iterating through the `pushed` elements and pushing them onto a new temporary stack. After each push operation, the algorithm checks if the top element of the stack matches the next expected `popped` element, specified by `popIndex`. If it does match, the algorithm pops the element from the temporary stack and increments `popIndex`. \n\nAfter iterating through all elements in the `pushed` array, if the temporary stack is empty, it indicates that the given `pushed` and `popped` sequences were valid for an initially empty stack. Otherwise, the sequences were not valid, and the function returns `false`.\n    "}
{"id": 1000, "slug": "minimum-cost-to-merge-stones", "title": "Minimum Cost to Merge Stones", "difficulty": "Hard", "content": "There are `n` piles of `stones` arranged in a row. The `ith` pile has `stones[i]` stones.\n\nA move consists of merging exactly `k` **consecutive** piles into one pile, and the cost of this move is equal to the total number of stones in these `k` piles.\n\nReturn _the minimum cost to merge all piles of stones into one pile_. If it is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** stones = \\[3,2,4,1\\], k = 2\n**Output:** 20\n**Explanation:** We start with \\[3, 2, 4, 1\\].\nWe merge \\[3, 2\\] for a cost of 5, and we are left with \\[5, 4, 1\\].\nWe merge \\[4, 1\\] for a cost of 5, and we are left with \\[5, 5\\].\nWe merge \\[5, 5\\] for a cost of 10, and we are left with \\[10\\].\nThe total cost was 20, and this is the minimum possible.\n\n**Example 2:**\n\n**Input:** stones = \\[3,2,4,1\\], k = 3\n**Output:** -1\n**Explanation:** After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.\n\n**Example 3:**\n\n**Input:** stones = \\[3,5,1,2,6\\], k = 3\n**Output:** 25\n**Explanation:** We start with \\[3, 5, 1, 2, 6\\].\nWe merge \\[5, 1, 2\\] for a cost of 8, and we are left with \\[3, 8, 6\\].\nWe merge \\[3, 8, 6\\] for a cost of 17, and we are left with \\[17\\].\nThe total cost was 25, and this is the minimum possible.\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `1 <= n <= 30`\n*   `1 <= stones[i] <= 100`\n*   `2 <= k <= 30`", "java": "\n    ```java\npublic int minDeletionSize(String[] strs) {\n    int rows = strs.length, cols = strs[0].length();\n    int count = 0;\n    for (int c = 0; c < cols; ++c) {\n        for (int r = 1; r < rows; ++r) {\n            if (strs[r - 1].charAt(c) > strs[r].charAt(c)) {\n                ++count;\n                break;\n            }\n        }\n    }\n    return count;\n}\n```\n\n    \n    For a given set of strings, we need to find how many characters can be deleted so that each remaining string is in lexicographic order. To achieve this, we iterate through each column (character position) of the strings and compare each character in the current column to its adjacent one in the next row. If the character violates lexicographic order, we increment the deletion count and move to the next column. We do this for all columns and return the minimum number of character deletions required to satisfy the conditions mentioned.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint minDeletionSize(std::vector<std::string>& strs) {\n    int rows = strs.size(), cols = strs[0].size();\n    int count = 0;\n    for (int c = 0; c < cols; ++c) {\n        for (int r = 1; r < rows; ++r) {\n            if (strs[r - 1][c] > strs[r][c]) {\n                ++count;\n                break;\n            }\n        }\n    }\n    return count;\n}\n```\n\n    \n    For a given set of strings, we need to find how many characters can be deleted so that each remaining string is in lexicographic order. To achieve this, we iterate through each column (character position) of the strings and compare each character in the current column to its adjacent one in the next row. If the character violates lexicographic order, we increment the deletion count and move to the next column. We do this for all columns and return the minimum number of character deletions required to satisfy the conditions mentioned.\n    ", "python": "\n    ```python\ndef min_deletion_size(strs):\n    rows, cols = len(strs), len(strs[0])\n    count = 0\n    for c in range(cols):\n        for r in range(1, rows):\n            if strs[r - 1][c] > strs[r][c]:\n                count += 1\n                break\n    return count\n```\n\n    \n    For a given set of strings, we need to find how many characters can be deleted so that each remaining string is in lexicographic order. To achieve this, we iterate through each column (character position) of the strings and compare each character in the current column to its adjacent one in the next row. If the character violates lexicographic order, we increment the deletion count and move to the next column. We do this for all columns and return the minimum number of character deletions required to satisfy the conditions mentioned.\n    ", "javascript": "\n    ```javascript\nfunction minDeletionSize(strs) {\n    const rows = strs.length;\n    const cols = strs[0].length;\n    let count = 0;\n    for (let c = 0; c < cols; ++c) {\n        for (let r = 1; r < rows; ++r) {\n            if (strs[r - 1][c] > strs[r][c]) {\n                ++count;\n                break;\n            }\n        }\n    }\n    return count;\n}\n```\n\n    \n    For a given set of strings, we need to find how many characters can be deleted so that each remaining string is in lexicographic order. To achieve this, we iterate through each column (character position) of the strings and compare each character in the current column to its adjacent one in the next row. If the character violates lexicographic order, we increment the deletion count and move to the next column. We do this for all columns and return the minimum number of character deletions required to satisfy the conditions mentioned.\n    "}
{"id": 1012, "slug": "numbers-with-repeated-digits", "title": "Numbers With Repeated Digits", "difficulty": "Hard", "content": "Given an integer `n`, return _the number of positive integers in the range_ `[1, n]` _that have **at least one** repeated digit_.\n\n**Example 1:**\n\n**Input:** n = 20\n**Output:** 1\n**Explanation:** The only positive number (<= 20) with at least 1 repeated digit is 11.\n\n**Example 2:**\n\n**Input:** n = 100\n**Output:** 10\n**Explanation:** The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\n\n**Example 3:**\n\n**Input:** n = 1000\n**Output:** 262\n\n**Constraints:**\n\n*   `1 <= n <= 109`", "java": "\n    ```java\npublic boolean isRationalEqual(String s, String t) {\n    Double num1 = evaluateString(s);\n    Double num2 = evaluateString(t);\n    return Math.abs(num1 - num2) < 1e-12;\n}\n\nprivate double evaluateString(String s) {\n    int i = s.indexOf('(');\n    if (i != -1) {\n        String base = s.substring(0, i);\n        String rep = s.substring(i + 1, s.length() - 1);\n        for (int k = 0; k < 20; ++k) {\n            base += rep;\n        }\n        return Double.parseDouble(base);\n    }\n    return Double.parseDouble(s);\n}\n```\n    \n    The given algorithm proceeds in the following steps:\n\n1. Use a lambda function (or a separate function in Java) named 'eval' or 'evaluate' which takes a string representing a rational number as input.\n2. Check if the input string has the repeating part (by finding the index of the opening bracket `(`).\n3. If the input string has a repeating part, extract the base and repeating part separately. Then append the repeating part 20 times to the base part, and convert the resulting string into a floating-point number. Else, convert the input string into a floating-point number directly.\n4. Call the 'eval' or 'evaluate' function for both input strings `s` and `t`, and calculate the absolute difference between the two numbers.\n5. Check if the absolute difference is less than 1e-12, and if so, return true; else, return false.\n\nThe algorithm thus compares the given rational numbers by converting them into floating-point numbers and checking if they have the same numerical value within a very small margin of error (1e-12). This technique ensures that small differences in the way the numbers are represented do not affect the comparison result.\n    ", "c++": "\n    ```cpp\nbool isRationalEqual(std::string s, std::string t) {\n    auto eval = [](std::string s) {\n        int i = s.find('(');\n        if (i != std::string::npos) {\n            std::string base = s.substr(0, i);\n            std::string rep = s.substr(i + 1, s.length() - i - 2);\n            for (int k = 0; k < 20; ++k) base += rep;\n            return stod(base);\n        }\n        return stod(s);\n    };\n    return fabs(eval(s) - eval(t)) < 1e-12;\n}\n```\n    \n    The given algorithm proceeds in the following steps:\n\n1. Use a lambda function (or a separate function in Java) named 'eval' or 'evaluate' which takes a string representing a rational number as input.\n2. Check if the input string has the repeating part (by finding the index of the opening bracket `(`).\n3. If the input string has a repeating part, extract the base and repeating part separately. Then append the repeating part 20 times to the base part, and convert the resulting string into a floating-point number. Else, convert the input string into a floating-point number directly.\n4. Call the 'eval' or 'evaluate' function for both input strings `s` and `t`, and calculate the absolute difference between the two numbers.\n5. Check if the absolute difference is less than 1e-12, and if so, return true; else, return false.\n\nThe algorithm thus compares the given rational numbers by converting them into floating-point numbers and checking if they have the same numerical value within a very small margin of error (1e-12). This technique ensures that small differences in the way the numbers are represented do not affect the comparison result.\n    ", "python": "\n    ```python\ndef isRationalEqual(s: str, t: str) -> bool:\n    def evaluate(s: str) -> float:\n        i = s.find('(')\n        if i != -1:\n            base = s[:i]\n            rep = s[i + 1:-1]\n            return float(base + rep * 20)\n        return float(s)\n\n    return abs(evaluate(s) - evaluate(t)) < 1e-12\n```\n    \n    The given algorithm proceeds in the following steps:\n\n1. Use a lambda function (or a separate function in Java) named 'eval' or 'evaluate' which takes a string representing a rational number as input.\n2. Check if the input string has the repeating part (by finding the index of the opening bracket `(`).\n3. If the input string has a repeating part, extract the base and repeating part separately. Then append the repeating part 20 times to the base part, and convert the resulting string into a floating-point number. Else, convert the input string into a floating-point number directly.\n4. Call the 'eval' or 'evaluate' function for both input strings `s` and `t`, and calculate the absolute difference between the two numbers.\n5. Check if the absolute difference is less than 1e-12, and if so, return true; else, return false.\n\nThe algorithm thus compares the given rational numbers by converting them into floating-point numbers and checking if they have the same numerical value within a very small margin of error (1e-12). This technique ensures that small differences in the way the numbers are represented do not affect the comparison result.\n    ", "javascript": "\n    ```javascript\nfunction isRationalEqual(s, t) {\n    const evaluate = (s) => {\n        let i = s.indexOf('(');\n        if (i !== -1) {\n            let base = s.substring(0, i);\n            let rep = s.substring(i + 1, s.length - 1);\n            for (let k = 0; k < 20; ++k) {\n                base += rep;\n            }\n            return parseFloat(base);\n        }\n        return parseFloat(s);\n    };\n    return Math.abs(evaluate(s) - evaluate(t)) < 1e-12;\n}\n```\n    \n    The given algorithm proceeds in the following steps:\n\n1. Use a lambda function (or a separate function in Java) named 'eval' or 'evaluate' which takes a string representing a rational number as input.\n2. Check if the input string has the repeating part (by finding the index of the opening bracket `(`).\n3. If the input string has a repeating part, extract the base and repeating part separately. Then append the repeating part 20 times to the base part, and convert the resulting string into a floating-point number. Else, convert the input string into a floating-point number directly.\n4. Call the 'eval' or 'evaluate' function for both input strings `s` and `t`, and calculate the absolute difference between the two numbers.\n5. Check if the absolute difference is less than 1e-12, and if so, return true; else, return false.\n\nThe algorithm thus compares the given rational numbers by converting them into floating-point numbers and checking if they have the same numerical value within a very small margin of error (1e-12). This technique ensures that small differences in the way the numbers are represented do not affect the comparison result.\n    "}
{"id": 1014, "slug": "best-sightseeing-pair", "title": "Best Sightseeing Pair", "difficulty": "Medium", "content": "You are given an integer array `values` where values\\[i\\] represents the value of the `ith` sightseeing spot. Two sightseeing spots `i` and `j` have a **distance** `j - i` between them.\n\nThe score of a pair (`i < j`) of sightseeing spots is `values[i] + values[j] + i - j`: the sum of the values of the sightseeing spots, minus the distance between them.\n\nReturn _the maximum score of a pair of sightseeing spots_.\n\n**Example 1:**\n\n**Input:** values = \\[8,1,5,2,6\\]\n**Output:** 11\n**Explanation:** i = 0, j = 2, values\\[i\\] + values\\[j\\] + i - j = 8 + 5 + 0 - 2 = 11\n\n**Example 2:**\n\n**Input:** values = \\[1,2\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `2 <= values.length <= 5 * 104`\n*   `1 <= values[i] <= 1000`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[][] kClosest(int[][] points, int k) {\n    Arrays.sort(points, (a, b) -> (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1]));\n    return Arrays.copyOfRange(points, 0, k);\n}\n```\n    \n    We define a custom comparison function that calculates the Euclidean distance of two points from the origin. In C++, Python, and JavaScript, we use a lambda function, while in Java we use a lambda expression.\n\nWe then use a sorting algorithm provided by the language's standard library to sort the array of points based on the custom comparison function. In C++, we use the `partial_sort` function, whereas in the other languages, we use the `sort` function.\n\nThe `partial_sort` function in C++ allows us to sort only the first `k` elements in the array. After sorting, we then return a new vector containing only the first `k` elements of the `points` vector.\n\nIn Java, Python, and JavaScript, we sort the entire array of points and then return a new array or list containing only the first `k` points. In Java, we use `Arrays.copyOfRange` to make the new array, while in Python and JavaScript, we use array slicing to select the first `k` elements.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<std::vector<int>> kClosest(std::vector<std::vector<int>>& points, int k) {\n    std::partial_sort(points.begin(), points.begin() + k, points.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[0] * a[0] + a[1] * a[1] < b[0] * b[0] + b[1] * b[1];\n    });\n\n    return std::vector<std::vector<int>>(points.begin(), points.begin() + k);\n}\n```\n    \n    We define a custom comparison function that calculates the Euclidean distance of two points from the origin. In C++, Python, and JavaScript, we use a lambda function, while in Java we use a lambda expression.\n\nWe then use a sorting algorithm provided by the language's standard library to sort the array of points based on the custom comparison function. In C++, we use the `partial_sort` function, whereas in the other languages, we use the `sort` function.\n\nThe `partial_sort` function in C++ allows us to sort only the first `k` elements in the array. After sorting, we then return a new vector containing only the first `k` elements of the `points` vector.\n\nIn Java, Python, and JavaScript, we sort the entire array of points and then return a new array or list containing only the first `k` points. In Java, we use `Arrays.copyOfRange` to make the new array, while in Python and JavaScript, we use array slicing to select the first `k` elements.\n    ", "python": "\n    ```python\ndef kClosest(points, k):\n    points.sort(key=lambda x: x[0] ** 2 + x[1] ** 2)\n    return points[:k]\n```\n    \n    We define a custom comparison function that calculates the Euclidean distance of two points from the origin. In C++, Python, and JavaScript, we use a lambda function, while in Java we use a lambda expression.\n\nWe then use a sorting algorithm provided by the language's standard library to sort the array of points based on the custom comparison function. In C++, we use the `partial_sort` function, whereas in the other languages, we use the `sort` function.\n\nThe `partial_sort` function in C++ allows us to sort only the first `k` elements in the array. After sorting, we then return a new vector containing only the first `k` elements of the `points` vector.\n\nIn Java, Python, and JavaScript, we sort the entire array of points and then return a new array or list containing only the first `k` points. In Java, we use `Arrays.copyOfRange` to make the new array, while in Python and JavaScript, we use array slicing to select the first `k` elements.\n    ", "javascript": "\n    ```javascript\nfunction kClosest(points, k) {\n    return points.sort((a, b) => (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1])).slice(0, k);\n}\n```\n    \n    We define a custom comparison function that calculates the Euclidean distance of two points from the origin. In C++, Python, and JavaScript, we use a lambda function, while in Java we use a lambda expression.\n\nWe then use a sorting algorithm provided by the language's standard library to sort the array of points based on the custom comparison function. In C++, we use the `partial_sort` function, whereas in the other languages, we use the `sort` function.\n\nThe `partial_sort` function in C++ allows us to sort only the first `k` elements in the array. After sorting, we then return a new vector containing only the first `k` elements of the `points` vector.\n\nIn Java, Python, and JavaScript, we sort the entire array of points and then return a new array or list containing only the first `k` points. In Java, we use `Arrays.copyOfRange` to make the new array, while in Python and JavaScript, we use array slicing to select the first `k` elements.\n    "}
{"id": 1024, "slug": "video-stitching", "title": "Video Stitching", "difficulty": "Medium", "content": "You are given a series of video clips from a sporting event that lasted `time` seconds. These video clips can be overlapping with each other and have varying lengths.\n\nEach video clip is described by an array `clips` where `clips[i] = [starti, endi]` indicates that the ith clip started at `starti` and ended at `endi`.\n\nWe can cut these clips into segments freely.\n\n*   For example, a clip `[0, 7]` can be cut into segments `[0, 1] + [1, 3] + [3, 7]`.\n\nReturn _the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event_ `[0, time]`. If the task is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** clips = \\[\\[0,2\\],\\[4,6\\],\\[8,10\\],\\[1,9\\],\\[1,5\\],\\[5,9\\]\\], time = 10\n**Output:** 3\n**Explanation:** We take the clips \\[0,2\\], \\[8,10\\], \\[1,9\\]; a total of 3 clips.\nThen, we can reconstruct the sporting event as follows:\nWe cut \\[1,9\\] into segments \\[1,2\\] + \\[2,8\\] + \\[8,9\\].\nNow we have segments \\[0,2\\] + \\[2,8\\] + \\[8,10\\] which cover the sporting event \\[0, 10\\].\n\n**Example 2:**\n\n**Input:** clips = \\[\\[0,1\\],\\[1,2\\]\\], time = 5\n**Output:** -1\n**Explanation:** We cannot cover \\[0,5\\] with only \\[0,1\\] and \\[1,2\\].\n\n**Example 3:**\n\n**Input:** clips = \\[\\[0,1\\],\\[6,8\\],\\[0,2\\],\\[5,6\\],\\[0,4\\],\\[0,3\\],\\[6,7\\],\\[1,3\\],\\[4,7\\],\\[1,4\\],\\[2,5\\],\\[2,6\\],\\[3,4\\],\\[4,5\\],\\[5,7\\],\\[6,9\\]\\], time = 9\n**Output:** 3\n**Explanation:** We can take clips \\[0,4\\], \\[4,7\\], and \\[6,9\\].\n\n**Constraints:**\n\n*   `1 <= clips.length <= 100`\n*   `0 <= starti <= endi <= 100`\n*   `1 <= time <= 100`\n\n0 <= i < j < k < nums.length, and nums\\[i\\] & nums\\[j\\] & nums\\[k\\] != 0. (\\`&\\` represents the bitwise AND operation.)", "java": "\n    ```java\nint countAndTriples(int[] nums) {\n    int count = 0;\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            for (int k = j + 1; k < nums.length; k++) {\n                if ((nums[i] & nums[j] & nums[k]) != 0)\n                    count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm simply uses three nested loops to iterate over each possible combination of three integers, (i, j, k) in the input array 'nums'. If the bitwise AND operation of the three integers at the indices (i, j, k) is non-zero, the count is increased by 1. Finally, the algorithm returns the count which is the number of AND triples in the input array.\n    ", "c++": "\n    ```cpp\nint countAndTriples(vector<int>& nums) {\n    int count = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        for (int j = i + 1; j < nums.size(); ++j) {\n            for (int k = j + 1; k < nums.size(); ++k) {\n                if (nums[i] & nums[j] & nums[k])\n                    ++count;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm simply uses three nested loops to iterate over each possible combination of three integers, (i, j, k) in the input array 'nums'. If the bitwise AND operation of the three integers at the indices (i, j, k) is non-zero, the count is increased by 1. Finally, the algorithm returns the count which is the number of AND triples in the input array.\n    ", "python": "\n    ```python\ndef count_and_triples(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] & nums[j] & nums[k] != 0:\n                    count += 1\n    return count\n```\n    \n    The algorithm simply uses three nested loops to iterate over each possible combination of three integers, (i, j, k) in the input array 'nums'. If the bitwise AND operation of the three integers at the indices (i, j, k) is non-zero, the count is increased by 1. Finally, the algorithm returns the count which is the number of AND triples in the input array.\n    ", "javascript": "\n    ```javascript\nfunction countAndTriples(nums) {\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            for (let k = j + 1; k < nums.length; k++) {\n                if (nums[i] & nums[j] & nums[k] !== 0)\n                    count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm simply uses three nested loops to iterate over each possible combination of three integers, (i, j, k) in the input array 'nums'. If the bitwise AND operation of the three integers at the indices (i, j, k) is non-zero, the count is increased by 1. Finally, the algorithm returns the count which is the number of AND triples in the input array.\n    "}
{"id": 1025, "slug": "divisor-game", "title": "Divisor Game", "difficulty": "Easy", "content": "Alice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there is a number `n` on the chalkboard. On each player's turn, that player makes a move consisting of:\n\n*   Choosing any `x` with `0 < x < n` and `n % x == 0`.\n*   Replacing the number `n` on the chalkboard with `n - x`.\n\nAlso, if a player cannot make a move, they lose the game.\n\nReturn `true` _if and only if Alice wins the game, assuming both players play optimally_.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** true\n**Explanation:** Alice chooses 1, and Bob has no more moves.\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** false\n**Explanation:** Alice chooses 1, Bob chooses 1, and Alice has no more moves.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`", "java": "\n    ```java\nimport java.util.*;\n\npublic int mincostTickets(int[] days, int[] costs) {\n  Set<Integer> travelDays = new HashSet<>();\n  for (int day : days) travelDays.add(day);\n  int[] dp = new int[366];\n\n  for (int i = 1; i <= 365; ++i) {\n    if (!travelDays.contains(i)) {\n      dp[i] = dp[i - 1];\n    } else {\n      dp[i] = Math.min(dp[i - 1] + costs[0],\n                   Math.min(dp[Math.max(0, i - 7)] + costs[1],\n                            dp[Math.max(0, i - 30)] + costs[2]));\n    }\n  }\n\n  return dp[365];\n}\n```\n    \n    1. Create a set of travel days.\n2. Initialize a dynamic programming (dp) array of length 366, where dp[i] will represent the minimum cost to travel on the given days up to the i-th day of the year.\n3. Iterate through the days of the year (1 to 365).\n   a. If the current day is not a travel day, then there's no need to buy a pass for this day, therefore the minimum cost is the same as the previous day.\n   b. If the current day is a travel day, calculate the minimum cost to travel by considering the three options: buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass.\n4. Return the minimum cost to travel on all given days (dp[365]).\n\nThis algorithm leverages dynamic programming to calculate the minimum cost of traveling on the given days. By iterating through each day and updating the dp array based on previous results, the final minimum cost is obtained efficiently.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nint mincostTickets(vector<int>& days, vector<int>& costs) {\n  unordered_set<int> travel_days(days.begin(), days.end());\n  vector<int> dp(366, 0);\n\n  for (int i = 1; i <= 365; ++i) {\n    if (travel_days.count(i) == 0) {\n      dp[i] = dp[i - 1];\n    } else {\n      dp[i] = min({dp[i - 1] + costs[0],\n                   dp[max(0, i - 7)] + costs[1],\n                   dp[max(0, i - 30)] + costs[2]});\n    }\n  }\n\n  return dp[365];\n}\n```\n    \n    1. Create a set of travel days.\n2. Initialize a dynamic programming (dp) array of length 366, where dp[i] will represent the minimum cost to travel on the given days up to the i-th day of the year.\n3. Iterate through the days of the year (1 to 365).\n   a. If the current day is not a travel day, then there's no need to buy a pass for this day, therefore the minimum cost is the same as the previous day.\n   b. If the current day is a travel day, calculate the minimum cost to travel by considering the three options: buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass.\n4. Return the minimum cost to travel on all given days (dp[365]).\n\nThis algorithm leverages dynamic programming to calculate the minimum cost of traveling on the given days. By iterating through each day and updating the dp array based on previous results, the final minimum cost is obtained efficiently.\n    ", "python": "\n    ```python\ndef mincostTickets(days, costs):\n  travel_days = set(days)\n  dp = [0] * 366\n\n  for i in range(1, 366):\n    if i not in travel_days:\n      dp[i] = dp[i - 1]\n    else:\n      dp[i] = min(dp[i - 1] + costs[0],\n                  dp[max(0, i - 7)] + costs[1],\n                  dp[max(0, i - 30)] + costs[2])\n\n  return dp[365]\n```\n    \n    1. Create a set of travel days.\n2. Initialize a dynamic programming (dp) array of length 366, where dp[i] will represent the minimum cost to travel on the given days up to the i-th day of the year.\n3. Iterate through the days of the year (1 to 365).\n   a. If the current day is not a travel day, then there's no need to buy a pass for this day, therefore the minimum cost is the same as the previous day.\n   b. If the current day is a travel day, calculate the minimum cost to travel by considering the three options: buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass.\n4. Return the minimum cost to travel on all given days (dp[365]).\n\nThis algorithm leverages dynamic programming to calculate the minimum cost of traveling on the given days. By iterating through each day and updating the dp array based on previous results, the final minimum cost is obtained efficiently.\n    ", "javascript": "\n    ```javascript\nfunction mincostTickets(days, costs) {\n  const travelDays = new Set(days);\n  const dp = new Array(366).fill(0);\n\n  for (let i = 1; i <= 365; ++i) {\n    if (!travelDays.has(i)) {\n      dp[i] = dp[i - 1];\n    } else {\n      dp[i] = Math.min(dp[i - 1] + costs[0],\n                   Math.min(dp[Math.max(0, i - 7)] + costs[1],\n                            dp[Math.max(0, i - 30)] + costs[2]));\n    }\n  }\n\n  return dp[365];\n}\n```\n    \n    1. Create a set of travel days.\n2. Initialize a dynamic programming (dp) array of length 366, where dp[i] will represent the minimum cost to travel on the given days up to the i-th day of the year.\n3. Iterate through the days of the year (1 to 365).\n   a. If the current day is not a travel day, then there's no need to buy a pass for this day, therefore the minimum cost is the same as the previous day.\n   b. If the current day is a travel day, calculate the minimum cost to travel by considering the three options: buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass.\n4. Return the minimum cost to travel on all given days (dp[365]).\n\nThis algorithm leverages dynamic programming to calculate the minimum cost of traveling on the given days. By iterating through each day and updating the dp array based on previous results, the final minimum cost is obtained efficiently.\n    "}
{"id": 1027, "slug": "longest-arithmetic-subsequence", "title": "Longest Arithmetic Subsequence", "difficulty": "Medium", "content": "Given an array `nums` of integers, return _the length of the longest arithmetic subsequence in_ `nums`.\n\n**Note** that:\n\n*   A **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n*   A sequence `seq` is arithmetic if `seq[i + 1] - seq[i]` are all the same value (for `0 <= i < seq.length - 1`).\n\n**Example 1:**\n\n**Input:** nums = \\[3,6,9,12\\]\n**Output:** 4\n**Explanation: ** The whole array is an arithmetic sequence with steps of length = 3.\n\n**Example 2:**\n\n**Input:** nums = \\[9,4,7,2,10\\]\n**Output:** 3\n**Explanation: ** The longest arithmetic subsequence is \\[4,7,10\\].\n\n**Example 3:**\n\n**Input:** nums = \\[20,1,15,3,10,5,8\\]\n**Output:** 4\n**Explanation: ** The longest arithmetic subsequence is \\[20,15,10,5\\].\n\n**Constraints:**\n\n*   `2 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 500`", "java": "\n    ```java\nimport java.util.*;\n\npublic int[] sumEvenAfterQueries(int[] nums, int[][] queries) {\n    int[] answer = new int[queries.length];\n    int even_sum = 0;\n\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            even_sum += num;\n        }\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n        int value = queries[i][0];\n        int index = queries[i][1];\n\n        if (nums[index] % 2 == 0) {\n            even_sum -= nums[index];\n        }\n        nums[index] += value;\n        if (nums[index] % 2 == 0) {\n            even_sum += nums[index];\n        }\n        answer[i] = even_sum;\n    }\n\n    return answer;\n}\n```\n\n    \n    1. Calculate the initial sum of all even numbers in the given array.\n2. For each query:\n    a. Check if the number at the given index is even, and if so, subtract it from the even sum.\n    b. Add the given value to the number at the given index.\n    c. Check if the updated number at the given index is now even, and if so, add it to the even sum.\n    d. Append the current even sum to the answer array.\n3. Return the answer array after all queries have been processed.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> sumEvenAfterQueries(vector<int>& nums, vector<vector<int>>& queries) {\n    vector<int> answer;\n    int even_sum = 0;\n    \n    for (int num : nums) {\n        if (num % 2 == 0) {\n            even_sum += num;\n        }\n    }\n    \n    for (vector<int>& query : queries) {\n        int value = query[0];\n        int index = query[1];\n        \n        if (nums[index] % 2 == 0) {\n            even_sum -= nums[index];\n        }\n        nums[index] += value;\n        if (nums[index] % 2 == 0) {\n            even_sum += nums[index];\n        }\n        answer.push_back(even_sum);\n    }\n    \n    return answer;\n}\n```\n\n    \n    1. Calculate the initial sum of all even numbers in the given array.\n2. For each query:\n    a. Check if the number at the given index is even, and if so, subtract it from the even sum.\n    b. Add the given value to the number at the given index.\n    c. Check if the updated number at the given index is now even, and if so, add it to the even sum.\n    d. Append the current even sum to the answer array.\n3. Return the answer array after all queries have been processed.\n    ", "python": "\n    ```python\ndef sumEvenAfterQueries(nums, queries):\n    answer = []\n    even_sum = sum(num for num in nums if num % 2 == 0)\n\n    for value, index in queries:\n        if nums[index] % 2 == 0:\n            even_sum -= nums[index]\n        nums[index] += value\n        if nums[index] % 2 == 0:\n            even_sum += nums[index]\n        answer.append(even_sum)\n\n    return answer\n```\n\n    \n    1. Calculate the initial sum of all even numbers in the given array.\n2. For each query:\n    a. Check if the number at the given index is even, and if so, subtract it from the even sum.\n    b. Add the given value to the number at the given index.\n    c. Check if the updated number at the given index is now even, and if so, add it to the even sum.\n    d. Append the current even sum to the answer array.\n3. Return the answer array after all queries have been processed.\n    ", "javascript": "\n    ```javascript\nfunction sumEvenAfterQueries(nums, queries) {\n    const answer = [];\n    let even_sum = nums.reduce((sum, num) => num % 2 === 0 ? sum + num : sum, 0);\n\n    for (const [value, index] of queries) {\n        if (nums[index] % 2 === 0) {\n            even_sum -= nums[index];\n        }\n        nums[index] += value;\n        if (nums[index] % 2 === 0) {\n            even_sum += nums[index];\n        }\n        answer.push(even_sum);\n    }\n\n    return answer;\n}\n```\n\n    \n    1. Calculate the initial sum of all even numbers in the given array.\n2. For each query:\n    a. Check if the number at the given index is even, and if so, subtract it from the even sum.\n    b. Add the given value to the number at the given index.\n    c. Check if the updated number at the given index is now even, and if so, add it to the even sum.\n    d. Append the current even sum to the answer array.\n3. Return the answer array after all queries have been processed.\n    "}
{"id": 1031, "slug": "maximum-sum-of-two-non-overlapping-subarrays", "title": "Maximum Sum of Two Non-Overlapping Subarrays", "difficulty": "Medium", "content": "Given an integer array `nums` and two integers `firstLen` and `secondLen`, return _the maximum sum of elements in two non-overlapping **subarrays** with lengths_ `firstLen` _and_ `secondLen`.\n\nThe array with length `firstLen` could occur before or after the array with length `secondLen`, but they have to be non-overlapping.\n\nA **subarray** is a **contiguous** part of an array.\n\n**Example 1:**\n\n**Input:** nums = \\[0,6,5,2,2,5,1,9,4\\], firstLen = 1, secondLen = 2\n**Output:** 20\n**Explanation:** One choice of subarrays is \\[9\\] with length 1, and \\[6,5\\] with length 2.\n\n**Example 2:**\n\n**Input:** nums = \\[3,8,1,3,2,1,8,9,0\\], firstLen = 3, secondLen = 2\n**Output:** 29\n**Explanation:** One choice of subarrays is \\[3,8,1\\] with length 3, and \\[8,9\\] with length 2.\n\n**Example 3:**\n\n**Input:** nums = \\[2,1,5,6,0,9,5,0,3,8\\], firstLen = 4, secondLen = 3\n**Output:** 31\n**Explanation:** One choice of subarrays is \\[5,6,0,9\\] with length 4, and \\[0,3,8\\] with length 3.\n\n**Constraints:**\n\n*   `1 <= firstLen, secondLen <= 1000`\n*   `2 <= firstLen + secondLen <= 1000`\n*   `firstLen + secondLen <= nums.length <= 1000`\n*   `0 <= nums[i] <= 1000`", "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> result = new ArrayList<>();\n    int carry = k, i = num.length - 1;\n    while (i >= 0 || carry > 0) {\n        if (i >= 0) {\n            carry += num[i--];\n        }\n        result.add(carry % 10);\n        carry /= 10;\n    }\n    Collections.reverse(result);\n    return result;\n}\n```\n\n    \n    The algorithm processes the input digit by digit, starting from the least significant digit (the digits farthest to the right). The logic is as follows:\n\n1. Add k to the least significant digit.\n2. Iterate through the digits. For each digit:\n   a. If the digit is greater than or equal to 10, carry over the left digit by dividing the current digit by 10 and adding the result to the left neighboring digit.\n   b. Set the current digit to the remainder of the digit divided by 10.\n3. If there is any remaining carry, handle it by adding new digits to the beginning of the array.\n4. Return the modified array.\n\nThe algorithm above works for all the given programming languages since it only relies on basic arithmetic operations and list operations that are available in all languages. The main difference between implementations is the specific syntax for inserting and accessing elements in an array or list.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    // add k to the least significant digit of the integer represented by num\n    num.back() += k;\n    // sum digits from least to most significant digit\n    for (int i = num.size() - 1; i > 0 && num[i]; --i) {\n        num[i - 1] += num[i] / 10;\n        num[i] %= 10;\n    }\n    // handle possible remaining carry\n    while (num[0] >= 10) {\n        num.insert(num.begin(), num[0] / 10);\n        num[1] %= 10;\n    }\n    return num;\n}\n```\n\n    \n    The algorithm processes the input digit by digit, starting from the least significant digit (the digits farthest to the right). The logic is as follows:\n\n1. Add k to the least significant digit.\n2. Iterate through the digits. For each digit:\n   a. If the digit is greater than or equal to 10, carry over the left digit by dividing the current digit by 10 and adding the result to the left neighboring digit.\n   b. Set the current digit to the remainder of the digit divided by 10.\n3. If there is any remaining carry, handle it by adding new digits to the beginning of the array.\n4. Return the modified array.\n\nThe algorithm above works for all the given programming languages since it only relies on basic arithmetic operations and list operations that are available in all languages. The main difference between implementations is the specific syntax for inserting and accessing elements in an array or list.\n    ", "python": "\n    ```python\ndef add_to_array_form(num, k):\n    for i in range(len(num) - 1, -1, -1):\n        k, num[i] = divmod(num[i] + k, 10)\n        if k == 0:\n            break\n    while k:\n        k, digit = divmod(k, 10)\n        num.insert(0, digit)\n    return num\n```\n\n    \n    The algorithm processes the input digit by digit, starting from the least significant digit (the digits farthest to the right). The logic is as follows:\n\n1. Add k to the least significant digit.\n2. Iterate through the digits. For each digit:\n   a. If the digit is greater than or equal to 10, carry over the left digit by dividing the current digit by 10 and adding the result to the left neighboring digit.\n   b. Set the current digit to the remainder of the digit divided by 10.\n3. If there is any remaining carry, handle it by adding new digits to the beginning of the array.\n4. Return the modified array.\n\nThe algorithm above works for all the given programming languages since it only relies on basic arithmetic operations and list operations that are available in all languages. The main difference between implementations is the specific syntax for inserting and accessing elements in an array or list.\n    ", "javascript": "\n    ```javascript\nfunction addToArrayForm(num, k) {\n    for (let i = num.length - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            sum -= 10;\n            k++;\n        }\n        num[i] = sum;\n        if (k === 0)\n            break;\n    }\n    while (k !== 0) {\n        num.unshift(k % 10);\n        k = Math.floor(k / 10);\n    }\n    return num;\n}\n```\n\n    \n    The algorithm processes the input digit by digit, starting from the least significant digit (the digits farthest to the right). The logic is as follows:\n\n1. Add k to the least significant digit.\n2. Iterate through the digits. For each digit:\n   a. If the digit is greater than or equal to 10, carry over the left digit by dividing the current digit by 10 and adding the result to the left neighboring digit.\n   b. Set the current digit to the remainder of the digit divided by 10.\n3. If there is any remaining carry, handle it by adding new digits to the beginning of the array.\n4. Return the modified array.\n\nThe algorithm above works for all the given programming languages since it only relies on basic arithmetic operations and list operations that are available in all languages. The main difference between implementations is the specific syntax for inserting and accessing elements in an array or list.\n    "}
{"id": 1035, "slug": "uncrossed-lines", "title": "Uncrossed Lines", "difficulty": "Medium", "content": "You are given two integer arrays `nums1` and `nums2`. We write the integers of `nums1` and `nums2` (in the order they are given) on two separate horizontal lines.\n\nWe may draw connecting lines: a straight line connecting two numbers `nums1[i]` and `nums2[j]` such that:\n\n*   `nums1[i] == nums2[j]`, and\n*   the line we draw does not intersect any other connecting (non-horizontal) line.\n\nNote that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).\n\nReturn _the maximum number of connecting lines we can draw in this way_.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,4,2\\], nums2 = \\[1,2,4\\]\n**Output:** 2\n**Explanation:** We can draw 2 uncrossed lines as in the diagram.\nWe cannot draw 3 uncrossed lines, because the line from nums1\\[1\\] = 4 to nums2\\[2\\] = 4 will intersect the line from nums1\\[2\\]=2 to nums2\\[1\\]=2.\n\n**Example 2:**\n\n**Input:** nums1 = \\[2,5,1,2,5\\], nums2 = \\[10,5,2,1,5,2\\]\n**Output:** 3\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,3,7,1,7,5\\], nums2 = \\[1,9,2,5,1\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 500`\n*   `1 <= nums1[i], nums2[j] <= 2000`", "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public boolean isCousins(TreeNode root, int x, int y) {\n        int xDepth = findDepth(root, x, 0);\n        int yDepth = findDepth(root, y, 0);\n        TreeNode xParent = findParent(root, x);\n        TreeNode yParent = findParent(root, y);\n        return (xDepth == yDepth) && (xParent != yParent);\n    }\n\n    private int findDepth(TreeNode node, int searchVal, int depth) {\n        if (node == null) return -1;\n        if (node.val == searchVal) return depth;\n        int leftDepth = findDepth(node.left, searchVal, depth + 1);\n        if (leftDepth != -1) return leftDepth;\n        return findDepth(node.right, searchVal, depth + 1);\n    }\n    \n    private TreeNode findParent(TreeNode node, int searchVal) {\n        if (node == null || (node.left == null && node.right == null)) return null;\n        if ((node.left != null && node.left.val == searchVal) || (node.right != null && node.right.val == searchVal)) return node;\n        TreeNode leftParent = findParent(node.left, searchVal);\n        if (leftParent != null) return leftParent;\n        return findParent(node.right, searchVal);\n    }\n}\n```\n    \n    The algorithm consists of two parts: find the depth and parent of each node with the values x and y.\n\n1. `findDepth` function: It is a recursive function that searches for the node with the `searchVal` value in a depth-first manner (left-to-right). When the target node is found, it returns the depth.\n\n2. `findParent` function: It is a recursive function that searches for the node with the `searchVal` value in a depth-first manner (left-to-right). When the target node's children contain the value, it returns the node itself as the parent.\n\nAfter finding the depth and parent of each node with the values x and y, the nodes are cousins if and only if their depths are the same, and their parents are different.\n    ", "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    bool isCousins(TreeNode* root, int x, int y) {\n        int x_depth = findDepth(root, x, 0);\n        int y_depth = findDepth(root, y, 0);\n        TreeNode* x_parent = findParent(root, x);\n        TreeNode* y_parent = findParent(root, y);\n        return (x_depth == y_depth) && (x_parent != y_parent);\n    }\n\nprivate:\n    int findDepth(TreeNode* node, int search_val, int depth) {\n        if (!node) return -1;\n        if (node->val == search_val) return depth;\n        int left_depth = findDepth(node->left, search_val, depth + 1);\n        if (left_depth != -1) return left_depth;\n        return findDepth(node->right, search_val, depth + 1);\n    }\n    \n    TreeNode* findParent(TreeNode* node, int search_val) {\n        if (!node || (!node->left && !node->right)) return nullptr;\n        if ((node->left && node->left->val == search_val) || (node->right && node->right->val == search_val)) return node;\n        TreeNode* left_parent = findParent(node->left, search_val);\n        if (left_parent) return left_parent;\n        return findParent(node->right, search_val);\n    }\n};\n```\n    \n    The algorithm consists of two parts: find the depth and parent of each node with the values x and y.\n\n1. `findDepth` function: It is a recursive function that searches for the node with the `searchVal` value in a depth-first manner (left-to-right). When the target node is found, it returns the depth.\n\n2. `findParent` function: It is a recursive function that searches for the node with the `searchVal` value in a depth-first manner (left-to-right). When the target node's children contain the value, it returns the node itself as the parent.\n\nAfter finding the depth and parent of each node with the values x and y, the nodes are cousins if and only if their depths are the same, and their parents are different.\n    ", "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isCousins(self, root, x, y):\n        def findDepth(node, search_val, depth):\n            if not node:\n                return -1\n            if node.val == search_val:\n                return depth\n            left_depth = findDepth(node.left, search_val, depth + 1)\n            if left_depth != -1:\n                return left_depth\n            return findDepth(node.right, search_val, depth + 1)\n\n        def findParent(node, search_val):\n            if not node or not (node.left or node.right):\n                return None\n            if (node.left and node.left.val == search_val) or (node.right and node.right.val == search_val):\n                return node\n            left_parent = findParent(node.left, search_val)\n            if left_parent:\n                return left_parent\n            return findParent(node.right, search_val)\n\n        x_depth = findDepth(root, x, 0)\n        y_depth = findDepth(root, y, 0)\n        x_parent = findParent(root, x)\n        y_parent = findParent(root, y)\n        return (x_depth == y_depth) and (x_parent != y_parent)\n```\n    \n    The algorithm consists of two parts: find the depth and parent of each node with the values x and y.\n\n1. `findDepth` function: It is a recursive function that searches for the node with the `searchVal` value in a depth-first manner (left-to-right). When the target node is found, it returns the depth.\n\n2. `findParent` function: It is a recursive function that searches for the node with the `searchVal` value in a depth-first manner (left-to-right). When the target node's children contain the value, it returns the node itself as the parent.\n\nAfter finding the depth and parent of each node with the values x and y, the nodes are cousins if and only if their depths are the same, and their parents are different.\n    ", "javascript": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction isCousins(root, x, y) {\n    function findDepth(node, searchVal, depth) {\n        if (!node) return -1;\n        if (node.val === searchVal) return depth;\n        let leftDepth = findDepth(node.left, searchVal, depth + 1);\n        if (leftDepth !== -1) return leftDepth;\n        return findDepth(node.right, searchVal, depth + 1);\n    }\n\n    function findParent(node, searchVal) {\n        if (!node || (!node.left && !node.right)) return null;\n        if ((node.left && node.left.val === searchVal) || (node.right && node.right.val === searchVal)) return node;\n        let leftParent = findParent(node.left, searchVal);\n        if (leftParent) return leftParent;\n        return findParent(node.right, search_val);\n    }\n\n    let xDepth = findDepth(root, x, 0);\n    let yDepth = findDepth(root, y, 0);\n    let xParent = findParent(root, x);\n    let yParent = findParent(root, y);\n    return (xDepth === yDepth) && (xParent !== yParent);\n}\n```\n    \n    The algorithm consists of two parts: find the depth and parent of each node with the values x and y.\n\n1. `findDepth` function: It is a recursive function that searches for the node with the `searchVal` value in a depth-first manner (left-to-right). When the target node is found, it returns the depth.\n\n2. `findParent` function: It is a recursive function that searches for the node with the `searchVal` value in a depth-first manner (left-to-right). When the target node's children contain the value, it returns the node itself as the parent.\n\nAfter finding the depth and parent of each node with the values x and y, the nodes are cousins if and only if their depths are the same, and their parents are different.\n    "}
{"id": 1039, "slug": "minimum-score-triangulation-of-polygon", "title": "Minimum Score Triangulation of Polygon", "difficulty": "Medium", "content": "You have a convex `n`\\-sided polygon where each vertex has an integer value. You are given an integer array `values` where `values[i]` is the value of the `ith` vertex (i.e., **clockwise order**).\n\nYou will **triangulate** the polygon into `n - 2` triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all `n - 2` triangles in the triangulation.\n\nReturn _the smallest possible total score that you can achieve with some triangulation of the polygon_.\n\n**Example 1:**\n\n**Input:** values = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** The polygon is already triangulated, and the score of the only triangle is 6.\n\n**Example 2:**\n\n**Input:** values = \\[3,7,4,5\\]\n**Output:** 144\n**Explanation:** There are two triangulations, with possible scores: 3\\*7\\*5 + 4\\*5\\*7 = 245, or 3\\*4\\*5 + 3\\*4\\*7 = 144.\nThe minimum score is 144.\n\n**Example 3:**\n\n**Input:** values = \\[1,3,1,4,1,5\\]\n**Output:** 13\n**Explanation:** The minimum score triangulation has score 1\\*1\\*3 + 1\\*1\\*4 + 1\\*1\\*5 + 1\\*1\\*1 = 13.\n\n**Constraints:**\n\n*   `n == values.length`\n*   `3 <= n <= 50`\n*   `1 <= values[i] <= 100`", "java": "\n    ```java\npublic int findJudge(int n, int[][] trust) {\n    int[] trustCounts = new int[n + 1];\n    for (int[] relation : trust) {\n        trustCounts[relation[0]]--;\n        trustCounts[relation[1]]++;\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (trustCounts[i] == n - 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n    \n    1. We create an array `trustCounts` of length `n+1` initialized with zeroes. This will hold the number of trust relationships for each person.\n2. For each trust[i] = [a, b] in the input trust array, we decrease the count for person 'a' by 1 (since 'a' trusts someone else) and increase the count for person 'b' by 1 (since 'b' is trusted by 'a').\n3. We then iterate through the `trustCounts` array from 1 to n (inclusive). If the trust count for person 'i' is `n - 1`, this means that every other person trusts 'i', and 'i' trusts no one else. In this case, 'i' is the town judge and we return 'i'.\n4. If no such 'i' is found, we return -1 as the town judge cannot be identified.\n    ", "c++": "\n    ```cpp\nint findJudge(int n, vector<vector<int>>& trust) {\n    vector<int> trustCounts(n + 1, 0);\n    for (vector<int>& relation : trust) {\n        trustCounts[relation[0]]--;\n        trustCounts[relation[1]]++;\n    }\n    \n    for (int i = 1; i <= n; ++i) {\n        if (trustCounts[i] == n - 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n    \n    1. We create an array `trustCounts` of length `n+1` initialized with zeroes. This will hold the number of trust relationships for each person.\n2. For each trust[i] = [a, b] in the input trust array, we decrease the count for person 'a' by 1 (since 'a' trusts someone else) and increase the count for person 'b' by 1 (since 'b' is trusted by 'a').\n3. We then iterate through the `trustCounts` array from 1 to n (inclusive). If the trust count for person 'i' is `n - 1`, this means that every other person trusts 'i', and 'i' trusts no one else. In this case, 'i' is the town judge and we return 'i'.\n4. If no such 'i' is found, we return -1 as the town judge cannot be identified.\n    ", "python": "\n    ```python\ndef find_judge(n, trust):\n    trustCounts = [0] * (n + 1)\n    for a, b in trust:\n        trustCounts[a] -= 1\n        trustCounts[b] += 1\n\n    for i in range(1, n + 1):\n        if trustCounts[i] == n - 1:\n            return i\n    return -1\n```\n    \n    1. We create an array `trustCounts` of length `n+1` initialized with zeroes. This will hold the number of trust relationships for each person.\n2. For each trust[i] = [a, b] in the input trust array, we decrease the count for person 'a' by 1 (since 'a' trusts someone else) and increase the count for person 'b' by 1 (since 'b' is trusted by 'a').\n3. We then iterate through the `trustCounts` array from 1 to n (inclusive). If the trust count for person 'i' is `n - 1`, this means that every other person trusts 'i', and 'i' trusts no one else. In this case, 'i' is the town judge and we return 'i'.\n4. If no such 'i' is found, we return -1 as the town judge cannot be identified.\n    ", "javascript": "\n    ```javascript\nfunction findJudge(n, trust) {\n    const trustCounts = new Array(n + 1).fill(0);\n    for (const relation of trust) {\n        trustCounts[relation[0]]--;\n        trustCounts[relation[1]]++;\n    }\n\n    for (let i = 1; i <= n; i++) {\n        if (trustCounts[i] === n - 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\n    \n    1. We create an array `trustCounts` of length `n+1` initialized with zeroes. This will hold the number of trust relationships for each person.\n2. For each trust[i] = [a, b] in the input trust array, we decrease the count for person 'a' by 1 (since 'a' trusts someone else) and increase the count for person 'b' by 1 (since 'b' is trusted by 'a').\n3. We then iterate through the `trustCounts` array from 1 to n (inclusive). If the trust count for person 'i' is `n - 1`, this means that every other person trusts 'i', and 'i' trusts no one else. In this case, 'i' is the town judge and we return 'i'.\n4. If no such 'i' is found, we return -1 as the town judge cannot be identified.\n    "}
{"id": 1043, "slug": "partition-array-for-maximum-sum", "title": "Partition Array for Maximum Sum", "difficulty": "Medium", "content": "Given an integer array `arr`, partition the array into (contiguous) subarrays of length **at most** `k`. After partitioning, each subarray has their values changed to become the maximum value of that subarray.\n\nReturn _the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a **32-bit** integer._\n\n**Example 1:**\n\n**Input:** arr = \\[1,15,7,9,2,5,10\\], k = 3\n**Output:** 84\n**Explanation:** arr becomes \\[15,15,15,9,10,10,10\\]\n\n**Example 2:**\n\n**Input:** arr = \\[1,4,1,5,7,3,6,1,9,9,3\\], k = 4\n**Output:** 83\n\n**Example 3:**\n\n**Input:** arr = \\[1\\], k = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= arr.length <= 500`\n*   `0 <= arr[i] <= 109`\n*   `1 <= k <= arr.length`", "java": "\n    ```java\nimport java.util.*;\n\npublic int[] gridIllumination(int n, int[][] lamps, int[][] queries) {\n    Set<Integer> lampCols = new HashSet<>();\n    Set<Integer> lampRows = new HashSet<>();\n    Set<Integer> lampLeftDiag = new HashSet<>();\n    Set<Integer> lampRightDiag = new HashSet<>();\n\n    for (int[] lamp : lamps) {\n        lampRows.add(lamp[0]);\n        lampCols.add(lamp[1]);\n        lampLeftDiag.add(lamp[0] - lamp[1]);\n        lampRightDiag.add(lamp[0] + lamp[1]);\n    }\n\n    int[] ans = new int[queries.length];\n\n    for (int j = 0; j < queries.length; j++) {\n        int row = queries[j][0];\n        int col = queries[j][1];\n        if (lampRows.contains(row) || lampCols.contains(col) || lampLeftDiag.contains(row - col) || lampRightDiag.contains(row + col)) {\n            ans[j] = 1;\n        } else {\n            ans[j] = 0;\n        }\n        for (int i = -1; i <= 1; i++) {\n            for (int k = -1; k <= 1; k++) {\n                int newRow = row + i;\n                int newCol = col + k;\n                lampRows.remove(newRow);\n                lampCols.remove(newCol);\n                lampLeftDiag.remove(newRow - newCol);\n                lampRightDiag.remove(newRow + newCol);\n            }\n        }\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm maintains four sets: `lampRows`, `lampCols`, `lampLeftDiag`, and `lampRightDiag`. Each set stores the row number, column number, row - column value, and row + column value of lamps, respectively.\n\nFor each query, check the presence of the queried row and column in the four sets. If any of them contains the queried row or column, the query cell is illuminated, so append 1 to the answer array, otherwise append 0.\n\nAfter processing each query, iterate through the adjacent cells and remove their rows and columns from the four sets, effectively turning off the lamps.\n\nReturn the answer array containing 1s and 0s indicating illuminated and non-illuminated query cells, respectively.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nvector<int> gridIllumination(int n, vector<vector<int>>& lamps, vector<vector<int>>& queries) {\n    unordered_set<int> lampCols, lampRows, lampLeftDiag, lampRightDiag;\n    vector<int> ans;\n\n    for (auto& lamp : lamps) {\n        int row = lamp[0];\n        int col = lamp[1];\n        lampRows.insert(row);\n        lampCols.insert(col);\n        lampLeftDiag.insert(row - col);\n        lampRightDiag.insert(row + col);\n    }\n\n    for (auto& query : queries) {\n        int row = query[0];\n        int col = query[1];\n        if (lampRows.count(row) || lampCols.count(col) || lampLeftDiag.count(row - col) || lampRightDiag.count(row + col)) {\n            ans.push_back(1);\n        } else {\n            ans.push_back(0);\n        }\n        for (int i = -1; i <= 1; i++) {\n            for (int j = -1; j <= 1; j++) {\n                int newRow = row + i;\n                int newCol = col + j;\n                lampRows.erase(newRow);\n                lampCols.erase(newCol);\n                lampLeftDiag.erase(newRow - newCol);\n                lampRightDiag.erase(newRow + newCol);\n            }\n        }\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm maintains four sets: `lampRows`, `lampCols`, `lampLeftDiag`, and `lampRightDiag`. Each set stores the row number, column number, row - column value, and row + column value of lamps, respectively.\n\nFor each query, check the presence of the queried row and column in the four sets. If any of them contains the queried row or column, the query cell is illuminated, so append 1 to the answer array, otherwise append 0.\n\nAfter processing each query, iterate through the adjacent cells and remove their rows and columns from the four sets, effectively turning off the lamps.\n\nReturn the answer array containing 1s and 0s indicating illuminated and non-illuminated query cells, respectively.\n    ", "python": "\n    ```python\ndef grid_illumination(n, lamps, queries):\n    lamp_rows = set()\n    lamp_cols = set()\n    lamp_left_diag = set()\n    lamp_right_diag = set()\n\n    for lamp in lamps:\n        row, col = lamp\n        lamp_rows.add(row)\n        lamp_cols.add(col)\n        lamp_left_diag.add(row - col)\n        lamp_right_diag.add(row + col)\n\n    ans = []\n\n    for query in queries:\n        row, col = query\n        if row in lamp_rows or col in lamp_cols or (row - col) in lamp_left_diag or (row + col) in lamp_right_diag:\n            ans.append(1)\n        else:\n            ans.append(0)\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                newRow, newCol = row + i, col + j\n                lamp_rows.discard(newRow)\n                lamp_cols.discard(newCol)\n                lamp_left_diag.discard(newRow - newCol)\n                lamp_right_diag.discard(newRow + newCol)\n\n    return ans\n```\n\n    \n    The algorithm maintains four sets: `lampRows`, `lampCols`, `lampLeftDiag`, and `lampRightDiag`. Each set stores the row number, column number, row - column value, and row + column value of lamps, respectively.\n\nFor each query, check the presence of the queried row and column in the four sets. If any of them contains the queried row or column, the query cell is illuminated, so append 1 to the answer array, otherwise append 0.\n\nAfter processing each query, iterate through the adjacent cells and remove their rows and columns from the four sets, effectively turning off the lamps.\n\nReturn the answer array containing 1s and 0s indicating illuminated and non-illuminated query cells, respectively.\n    ", "javascript": "\n    ```javascript\nfunction gridIllumination(n, lamps, queries) {\n    const lampRows = new Set();\n    const lampCols = new Set();\n    const lampLeftDiag = new Set();\n    const lampRightDiag = new Set();\n\n    for (const lamp of lamps) {\n        const [row, col] = lamp;\n        lampRows.add(row);\n        lampCols.add(col);\n        lampLeftDiag.add(row - col);\n        lampRightDiag.add(row + col);\n    }\n\n    const ans = [];\n\n    for (const query of queries) {\n        const [row, col] = query;\n        if (lampRows.has(row) || lampCols.has(col) || lampLeftDiag.has(row - col) || lampRightDiag.has(row + col)) {\n            ans.push(1);\n        } else {\n            ans.push(0);\n        }\n        for (let i = -1; i <= 1; i++) {\n            for (let j = -1; j <= 1; j++) {\n                const newRow = row + i;\n                const newCol = col + j;\n                lampRows.delete(newRow);\n                lampCols.delete(newCol);\n                lampLeftDiag.delete(newRow - newCol);\n                lampRightDiag.delete(newRow + newCol);\n            }\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm maintains four sets: `lampRows`, `lampCols`, `lampLeftDiag`, and `lampRightDiag`. Each set stores the row number, column number, row - column value, and row + column value of lamps, respectively.\n\nFor each query, check the presence of the queried row and column in the four sets. If any of them contains the queried row or column, the query cell is illuminated, so append 1 to the answer array, otherwise append 0.\n\nAfter processing each query, iterate through the adjacent cells and remove their rows and columns from the four sets, effectively turning off the lamps.\n\nReturn the answer array containing 1s and 0s indicating illuminated and non-illuminated query cells, respectively.\n    "}
{"id": 1048, "slug": "longest-string-chain", "title": "Longest String Chain", "difficulty": "Medium", "content": "You are given an array of `words` where each word consists of lowercase English letters.\n\n`wordA` is a **predecessor** of `wordB` if and only if we can insert **exactly one** letter anywhere in `wordA` **without changing the order of the other characters** to make it equal to `wordB`.\n\n*   For example, `\"abc \"` is a **predecessor** of `\"abac \"`, while `\"cba \"` is not a **predecessor** of `\"bcad \"`.\n\nA **word chain** is a sequence of words `[word1, word2, ..., wordk]` with `k >= 1`, where `word1` is a **predecessor** of `word2`, `word2` is a **predecessor** of `word3`, and so on. A single word is trivially a **word chain** with `k == 1`.\n\nReturn _the **length** of the **longest possible word chain** with words chosen from the given list of_ `words`.\n\n**Example 1:**\n\n**Input:** words = \\[ \"a \", \"b \", \"ba \", \"bca \", \"bda \", \"bdca \"\\]\n**Output:** 4\n**Explanation**: One of the longest word chains is \\[ \"a \", \"ba \", \"bda \", \"bdca \"\\].\n\n**Example 2:**\n\n**Input:** words = \\[ \"xbc \", \"pcxbcf \", \"xb \", \"cxbc \", \"pcxbc \"\\]\n**Output:** 5\n**Explanation:** All the words can be put in a word chain \\[ \"xb \",  \"xbc \",  \"cxbc \",  \"pcxbc \",  \"pcxbcf \"\\].\n\n**Example 3:**\n\n**Input:** words = \\[ \"abcd \", \"dbqca \"\\]\n**Output:** 1\n**Explanation:** The trivial word chain \\[ \"abcd \"\\] is one of the longest word chains.\n\\[ \"abcd \", \"dbqca \"\\] is not a valid word chain because the ordering of the letters is changed.\n\n**Constraints:**\n\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length <= 16`\n*   `words[i]` only consists of lowercase English letters.", "java": "\n    ```java\npublic int clumsy(int n) {\n    if (n <= 2) {\n        return n;\n    }\n    if (n == 3) {\n        return 6;\n    }\n    int result = n * (n - 1) / (n - 2) + (n - 3);\n    n -= 4;\n    while (n >= 4) {\n        result = result - (n * (n - 1) / (n - 2)) + (n - 3);\n        n -= 4;\n    }\n    return result - clumsy(n);\n}\n```\n\n    \n    The algorithm starts by checking the base cases for when n is less than or equal to 2 or when n equals 3. Each case returns the appropriate value. Then we initialize the result variable to the first four operations for n. To do this, we perform multiplication and division first, then addition, and any remaining subtraction.\n\nWe then decrement n by 4, and enter a loop to continue the clumsy factorial, evaluating the next four operations until n is less than 4. Inside the loop, we do the same operation as before, but subtracting instead of adding the result for each group. We end the loop when n is less than 4.\n\nFinally, we subtract the clumsy factorial of the remaining n (less than 4) from the result and return it. This ensures that the last steps follow the rotation of operations correctly.\n    ", "c++": "\n    ```cpp\nint clumsy(int n) {\n    if (n <= 2) {\n        return n;\n    }\n    if (n == 3) {\n        return 6;\n    }\n    int result = n * (n - 1) / (n - 2) + (n - 3);\n    n -= 4;\n    while (n >= 4) {\n        result = result - (n * (n - 1) / (n - 2)) + (n - 3);\n        n -= 4;\n    }\n    return result - clumsy(n);\n}\n```\n\n    \n    The algorithm starts by checking the base cases for when n is less than or equal to 2 or when n equals 3. Each case returns the appropriate value. Then we initialize the result variable to the first four operations for n. To do this, we perform multiplication and division first, then addition, and any remaining subtraction.\n\nWe then decrement n by 4, and enter a loop to continue the clumsy factorial, evaluating the next four operations until n is less than 4. Inside the loop, we do the same operation as before, but subtracting instead of adding the result for each group. We end the loop when n is less than 4.\n\nFinally, we subtract the clumsy factorial of the remaining n (less than 4) from the result and return it. This ensures that the last steps follow the rotation of operations correctly.\n    ", "python": "\n    ```python\ndef clumsy(n: int) -> int:\n    if n <= 2:\n        return n\n    if n == 3:\n        return 6\n    result = n * (n - 1) // (n - 2) + (n - 3)\n    n -= 4\n    while n >= 4:\n        result = result - (n * (n - 1) // (n - 2)) + (n - 3)\n        n -= 4\n    return result - clumsy(n)\n```\n\n    \n    The algorithm starts by checking the base cases for when n is less than or equal to 2 or when n equals 3. Each case returns the appropriate value. Then we initialize the result variable to the first four operations for n. To do this, we perform multiplication and division first, then addition, and any remaining subtraction.\n\nWe then decrement n by 4, and enter a loop to continue the clumsy factorial, evaluating the next four operations until n is less than 4. Inside the loop, we do the same operation as before, but subtracting instead of adding the result for each group. We end the loop when n is less than 4.\n\nFinally, we subtract the clumsy factorial of the remaining n (less than 4) from the result and return it. This ensures that the last steps follow the rotation of operations correctly.\n    ", "javascript": "\n    ```javascript\nfunction clumsy(n) {\n    if (n <= 2) {\n        return n;\n    }\n    if (n === 3) {\n        return 6;\n    }\n    let result = Math.floor(n * (n - 1) / (n - 2)) + (n - 3);\n    n -= 4;\n    while (n >= 4) {\n        result = result - Math.floor(n * (n - 1) / (n - 2)) + (n - 3);\n        n -= 4;\n    }\n    return result - clumsy(n);\n}\n```\n\n    \n    The algorithm starts by checking the base cases for when n is less than or equal to 2 or when n equals 3. Each case returns the appropriate value. Then we initialize the result variable to the first four operations for n. To do this, we perform multiplication and division first, then addition, and any remaining subtraction.\n\nWe then decrement n by 4, and enter a loop to continue the clumsy factorial, evaluating the next four operations until n is less than 4. Inside the loop, we do the same operation as before, but subtracting instead of adding the result for each group. We end the loop when n is less than 4.\n\nFinally, we subtract the clumsy factorial of the remaining n (less than 4) from the result and return it. This ensures that the last steps follow the rotation of operations correctly.\n    "}
{"id": 1049, "slug": "last-stone-weight-ii", "title": "Last Stone Weight II", "difficulty": "Medium", "content": "You are given an array of integers `stones` where `stones[i]` is the weight of the `ith` stone.\n\nWe are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights `x` and `y` with `x <= y`. The result of this smash is:\n\n*   If `x == y`, both stones are destroyed, and\n*   If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.\n\nAt the end of the game, there is **at most one** stone left.\n\nReturn _the smallest possible weight of the left stone_. If there are no stones left, return `0`.\n\n**Example 1:**\n\n**Input:** stones = \\[2,7,4,1,8,1\\]\n**Output:** 1\n**Explanation:**\nWe can combine 2 and 4 to get 2, so the array converts to \\[2,7,1,8,1\\] then,\nwe can combine 7 and 8 to get 1, so the array converts to \\[2,1,1,1\\] then,\nwe can combine 2 and 1 to get 1, so the array converts to \\[1,1,1\\] then,\nwe can combine 1 and 1 to get 0, so the array converts to \\[1\\], then that's the optimal value.\n\n**Example 2:**\n\n**Input:** stones = \\[31,26,33,21,40\\]\n**Output:** 5\n\n**Constraints:**\n\n*   `1 <= stones.length <= 30`\n*   `1 <= stones[i] <= 100`", "java": "\n    ```java\npublic int min_rotations(int[] tops, int[] bottoms) {\n    int res = Integer.MAX_VALUE;\n\n    for (int target : new int[] {tops[0], bottoms[0]}) {\n        int top_rot = 0, bot_rot = 0;\n        for (int i = 0; i < tops.length; ++i) {\n            if (tops[i] != target && bottoms[i] != target) {\n                top_rot = bot_rot = Integer.MAX_VALUE;\n                break;\n            }\n            top_rot += tops[i] != target ? 1 : 0;\n            bot_rot += bottoms[i] != target ? 1 : 0;\n        }\n        res = Math.min(res, Math.min(top_rot, bot_rot));\n    }\n\n    return res == Integer.MAX_VALUE ? -1 : res;\n}\n```\n    \n    The algorithm iterates through the given tops and bottoms lists (arrays in C++ and Java). The goal is to check if we can make all values in tops or bottoms the same by swapping tops[i] and bottoms[i] values. We take the first domino's top and bottom values as our initial targets.\n\nFor each target value, we initialize `top_rot` and `bot_rot` to store the number of rotations required to make all elements of the tops and bottoms the same. We iterate the tops and bottoms and check if either the top or bottom values are the same as the target. If neither is the target, we set both `top_rot` and `bot_rot` to the maximum possible value, and break from the loop. Otherwise, we increment `top_rot` and/or `bot_rot` accordingly.\n\nAfter iterating for both targets, we take the minimum of `top_rot`, `bot_rot`, and `res`. If we couldn't find a solution, `res` will remain as the maximum possible value, and we return -1. Otherwise, we return the minimum number of rotations needed.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint min_rotations(std::vector<int>& tops, std::vector<int>& bottoms) {\n    int res = INT_MAX;\n\n    for (int target : {tops[0], bottoms[0]}) {\n        int top_rot = 0, bot_rot = 0;\n        for (int i = 0; i < tops.size(); ++i) {\n            if (tops[i] != target && bottoms[i] != target) {\n                top_rot = bot_rot = INT_MAX;\n                break;\n            }\n            top_rot += tops[i] != target;\n            bot_rot += bottoms[i] != target;\n        }\n        res = std::min({res, top_rot, bot_rot});\n    }\n\n    return res == INT_MAX ? -1 : res;\n}\n```\n    \n    The algorithm iterates through the given tops and bottoms lists (arrays in C++ and Java). The goal is to check if we can make all values in tops or bottoms the same by swapping tops[i] and bottoms[i] values. We take the first domino's top and bottom values as our initial targets.\n\nFor each target value, we initialize `top_rot` and `bot_rot` to store the number of rotations required to make all elements of the tops and bottoms the same. We iterate the tops and bottoms and check if either the top or bottom values are the same as the target. If neither is the target, we set both `top_rot` and `bot_rot` to the maximum possible value, and break from the loop. Otherwise, we increment `top_rot` and/or `bot_rot` accordingly.\n\nAfter iterating for both targets, we take the minimum of `top_rot`, `bot_rot`, and `res`. If we couldn't find a solution, `res` will remain as the maximum possible value, and we return -1. Otherwise, we return the minimum number of rotations needed.\n    ", "python": "\n    ```python\ndef min_rotations(tops, bottoms):\n    res = float('inf')\n\n    for target in (tops[0], bottoms[0]):\n        top_rot, bot_rot = 0, 0\n        for ti, bi in zip(tops, bottoms):\n            if ti != target and bi != target:\n                top_rot = bot_rot = float('inf')\n                break\n            top_rot += ti != target\n            bot_rot += bi != target\n\n        res = min(res, top_rot, bot_rot)\n\n    return -1 if res == float('inf') else res\n```\n    \n    The algorithm iterates through the given tops and bottoms lists (arrays in C++ and Java). The goal is to check if we can make all values in tops or bottoms the same by swapping tops[i] and bottoms[i] values. We take the first domino's top and bottom values as our initial targets.\n\nFor each target value, we initialize `top_rot` and `bot_rot` to store the number of rotations required to make all elements of the tops and bottoms the same. We iterate the tops and bottoms and check if either the top or bottom values are the same as the target. If neither is the target, we set both `top_rot` and `bot_rot` to the maximum possible value, and break from the loop. Otherwise, we increment `top_rot` and/or `bot_rot` accordingly.\n\nAfter iterating for both targets, we take the minimum of `top_rot`, `bot_rot`, and `res`. If we couldn't find a solution, `res` will remain as the maximum possible value, and we return -1. Otherwise, we return the minimum number of rotations needed.\n    ", "javascript": "\n    ```javascript\nfunction min_rotations(tops, bottoms) {\n    let res = Infinity;\n\n    let targets = [tops[0], bottoms[0]];\n\n    for (let target of targets) {\n        let top_rot = 0;\n        let bot_rot = 0;\n\n        for (let i = 0; i < tops.length; ++i) {\n            if (tops[i] !== target && bottoms[i] !== target) {\n                top_rot = bot_rot = Infinity;\n                break;\n            }\n\n            if (tops[i] !== target) {\n                top_rot++;\n            }\n\n            if (bottoms[i] !== target) {\n                bot_rot++;\n            }\n        }\n        res = Math.min(res, top_rot, bot_rot);\n    }\n\n    return res === Infinity ? -1 : res;\n}\n```\n    \n    The algorithm iterates through the given tops and bottoms lists (arrays in C++ and Java). The goal is to check if we can make all values in tops or bottoms the same by swapping tops[i] and bottoms[i] values. We take the first domino's top and bottom values as our initial targets.\n\nFor each target value, we initialize `top_rot` and `bot_rot` to store the number of rotations required to make all elements of the tops and bottoms the same. We iterate the tops and bottoms and check if either the top or bottom values are the same as the target. If neither is the target, we set both `top_rot` and `bot_rot` to the maximum possible value, and break from the loop. Otherwise, we increment `top_rot` and/or `bot_rot` accordingly.\n\nAfter iterating for both targets, we take the minimum of `top_rot`, `bot_rot`, and `res`. If we couldn't find a solution, `res` will remain as the maximum possible value, and we return -1. Otherwise, we return the minimum number of rotations needed.\n    "}
{"id": 1062, "slug": "longest-repeating-substring", "title": "Longest Repeating Substring", "difficulty": "Medium", "content": "Given a string `s`, return _the length of the longest repeating substrings_. If no repeating substring exists, return `0`.\n\n**Example 1:**\n\n**Input:** s =  \"abcd \"\n**Output:** 0\n**Explanation:** There is no repeating substring.\n\n**Example 2:**\n\n**Input:** s =  \"abbaba \"\n**Output:** 2\n**Explanation:** The longest repeating substrings are  \"ab \" and  \"ba \", each of which occurs twice.\n\n**Example 3:**\n\n**Input:** s =  \"aabcaabdaab \"\n**Output:** 3\n**Explanation:** The longest repeating substring is  \"aab \", which occurs `3` times.\n\n**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase English letters.", "java": "\n    ```java\npublic int findLongestRepeatingSubstring(String s) {\n    int n = s.length();\n    int maxSubstrLength = 0;\n    for (int len = 1; len <= n / 2; ++len) {\n        int maxRepeatCount = 0, repeatCount = 0;\n        for (int i = 0; i < n - len; ++i) {\n            if (s.substring(i, i + len).equals(s.substring(i + len, i + 2 * len))) {\n                repeatCount++;\n            } else {\n                maxRepeatCount = Math.max(maxRepeatCount, repeatCount);\n                repeatCount = 0;\n            }\n        }\n        maxSubstrLength = Math.max(maxSubstrLength, maxRepeatCount * len);\n    }\n    return maxSubstrLength;\n}\n```\n    \n    The algorithm iterates through each possible length of a substring (`len`). For each `len`, it checks if the current substring `s[i:i+len]` is equal to the next substring `s[i+len:i+2*len]`. If the substrings are equal, it increments `repeat_count` and updates `max_repeat_count` if needed. After iterating through all possible substring lengths, it returns the longest length of the repeated substrings as `max_substr_length`.\n    ", "c++": "\n    ```cpp\nint findLongestRepeatingSubstring(const std::string &s) {\n    int n = s.length();\n    int max_substr_length = 0;\n    for (int len = 1; len <= n/2; ++len) {\n        int max_repeat_count = 0, repeat_count = 0;\n        for (int i = 0; i < n - len; ++i) {\n            if (s.substr(i, len) == s.substr(i + len, len)) {\n                repeat_count++;\n            } else {\n                max_repeat_count = std::max(max_repeat_count, repeat_count);\n                repeat_count = 0;\n            }\n        }\n        max_substr_length = std::max(max_substr_length, max_repeat_count * len);\n    }\n    return max_substr_length;\n}\n```\n    \n    The algorithm iterates through each possible length of a substring (`len`). For each `len`, it checks if the current substring `s[i:i+len]` is equal to the next substring `s[i+len:i+2*len]`. If the substrings are equal, it increments `repeat_count` and updates `max_repeat_count` if needed. After iterating through all possible substring lengths, it returns the longest length of the repeated substrings as `max_substr_length`.\n    ", "python": "\n    ```python\ndef find_longest_repeating_substring(s: str) -> int:\n    n = len(s)\n    max_substr_length = 0\n    for length in range(1, n // 2 + 1):\n        max_repeat_count = repeat_count = 0\n        for i in range(n - length):\n            if s[i:i + length] == s[i + length:i + 2 * length]:\n                repeat_count += 1\n            else:\n                max_repeat_count = max(max_repeat_count, repeat_count)\n                repeat_count = 0\n        max_substr_length = max(max_substr_length, max_repeat_count * length)\n    return max_substr_length\n```\n    \n    The algorithm iterates through each possible length of a substring (`len`). For each `len`, it checks if the current substring `s[i:i+len]` is equal to the next substring `s[i+len:i+2*len]`. If the substrings are equal, it increments `repeat_count` and updates `max_repeat_count` if needed. After iterating through all possible substring lengths, it returns the longest length of the repeated substrings as `max_substr_length`.\n    ", "javascript": "\n    ```javascript\nfunction findLongestRepeatingSubstring(s) {\n    let n = s.length;\n    let maxSubstrLength = 0;\n    for (let len = 1; len <= n / 2; ++len) {\n        let maxRepeatCount = 0, repeatCount = 0;\n        for (let i = 0; i < n - len; ++i) {\n            if (s.substring(i, i + len) === s.substring(i + len, i + 2 * len)) {\n                repeatCount++;\n            } else {\n                maxRepeatCount = Math.max(maxRepeatCount, repeatCount);\n                repeatCount = 0;\n            }\n        }\n        maxSubstrLength = Math.max(maxSubstrLength, maxRepeatCount * len);\n    }\n    return maxSubstrLength;\n}\n```\n    \n    The algorithm iterates through each possible length of a substring (`len`). For each `len`, it checks if the current substring `s[i:i+len]` is equal to the next substring `s[i+len:i+2*len]`. If the substrings are equal, it increments `repeat_count` and updates `max_repeat_count` if needed. After iterating through all possible substring lengths, it returns the longest length of the repeated substrings as `max_substr_length`.\n    "}
{"id": 1092, "slug": "shortest-common-supersequence", "title": "Shortest Common Supersequence ", "difficulty": "Hard", "content": "Given two strings `str1` and `str2`, return _the shortest string that has both_ `str1` _and_ `str2` _as **subsequences**_. If there are multiple valid strings, return **any** of them.\n\nA string `s` is a **subsequence** of string `t` if deleting some number of characters from `t` (possibly `0`) results in the string `s`.\n\n**Example 1:**\n\n**Input:** str1 =  \"abac \", str2 =  \"cab \"\n**Output:**  \"cabac \"\n**Explanation:** \nstr1 =  \"abac \" is a subsequence of  \"cabac \" because we can delete the first  \"c \".\nstr2 =  \"cab \" is a subsequence of  \"cabac \" because we can delete the last  \"ac \".\nThe answer provided is the shortest such string that satisfies these properties.\n\n**Example 2:**\n\n**Input:** str1 =  \"aaaaaaaa \", str2 =  \"aaaaaaaa \"\n**Output:**  \"aaaaaaaa \"\n\n**Constraints:**\n\n*   `1 <= str1.length, str2.length <= 1000`\n*   `str1` and `str2` consist of lowercase English letters.", "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int val) { this.val = val; }\n}\n\nclass Result {\n    int min;\n    int max;\n}\n\nint dfs(TreeNode node, Result result) {\n    if (node == null) return 0;\n    Result leftResult = new Result();\n    Result rightResult = new Result();\n    int leftDiff = dfs(node.left, leftResult);\n    int rightDiff = dfs(node.right, rightResult);\n    result.min = Math.min(node.val, Math.min(leftResult.min, rightResult.min));\n    result.max = Math.max(node.val, Math.max(leftResult.max, rightResult.max));\n    return Math.max(Math.max(leftDiff, rightDiff), Math.max(Math.abs(node.val - leftResult.min), Math.abs(node.val - rightResult.max)));\n}\n\nint maxAncestorDiff(TreeNode root) {\n    Result result = new Result();\n    return dfs(root, result);\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) to traverse the input binary tree. The base case is reached when the root node is `null`, in which case the maximum value and minimum value are set to positive and negative infinity, respectively. While traversing the nodes, the algorithm maintains the maximum and minimum values of each subtree, as well as the maximum absolute difference.\n\nAt each node of the tree, the algorithm compares the difference in the node's value to the minimum and maximum values of both the left and right subtrees. This way, the potential new maximum difference is computed by comparing the current maximum difference to the absolute differences $(node.val - leftMin)$ and $(node.val - rightMax)$. The final maximum absolute difference is returned after the entire tree has been traversed. \n    ", "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int _val) : val(_val), left(nullptr), right(nullptr) {}\n};\n\nint dfs(TreeNode* node, int& mn, int& mx) {\n    if (!node) return 0;\n    int left_min = node->val, right_min = node->val;\n    int left_max = node->val, right_max = node->val;\n    int left_diff = dfs(node->left, left_min, left_max);\n    int right_diff = dfs(node->right, right_min, right_max);\n    mn = min(node->val, min(left_min, right_min));\n    mx = max(node->val, max(left_max, right_max));\n    return max(max(left_diff, right_diff), max(abs(node->val - left_min), abs(node->val - right_max)));\n}\nint maxAncestorDiff(TreeNode* root) {\n    int mn = root->val, mx = root->val;\n    return dfs(root, mn, mx);\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) to traverse the input binary tree. The base case is reached when the root node is `null`, in which case the maximum value and minimum value are set to positive and negative infinity, respectively. While traversing the nodes, the algorithm maintains the maximum and minimum values of each subtree, as well as the maximum absolute difference.\n\nAt each node of the tree, the algorithm compares the difference in the node's value to the minimum and maximum values of both the left and right subtrees. This way, the potential new maximum difference is computed by comparing the current maximum difference to the absolute differences $(node.val - leftMin)$ and $(node.val - rightMax)$. The final maximum absolute difference is returned after the entire tree has been traversed. \n    ", "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef dfs(node):\n    if not node:\n        return 0, float('inf'), float('-inf')\n    left_diff, left_min, left_max = dfs(node.left)\n    right_diff, right_min, right_max = dfs(node.right)\n    mn = min(node.val, left_min, right_min)\n    mx = max(node.val, left_max, right_max)\n    return max(max(left_diff, right_diff), max(abs(node.val - left_min), abs(node.val - right_max))), mn, mx\n\ndef maxAncestorDiff(root):\n    diff, _, _ = dfs(root)\n    return diff\n```\n    \n    The algorithm uses a depth-first search (DFS) to traverse the input binary tree. The base case is reached when the root node is `null`, in which case the maximum value and minimum value are set to positive and negative infinity, respectively. While traversing the nodes, the algorithm maintains the maximum and minimum values of each subtree, as well as the maximum absolute difference.\n\nAt each node of the tree, the algorithm compares the difference in the node's value to the minimum and maximum values of both the left and right subtrees. This way, the potential new maximum difference is computed by comparing the current maximum difference to the absolute differences $(node.val - leftMin)$ and $(node.val - rightMax)$. The final maximum absolute difference is returned after the entire tree has been traversed. \n    ", "javascript": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction dfs(node) {\n    if (!node) return [0, Infinity, -Infinity];\n    const [leftDiff, leftMin, leftMax] = dfs(node.left);\n    const [rightDiff, rightMin, rightMax] = dfs(node.right);\n    const mn = Math.min(node.val, leftMin, rightMin);\n    const mx = Math.max(node.val, leftMax, rightMax);\n    return [Math.max(Math.max(leftDiff, rightDiff), Math.max(Math.abs(node.val - leftMin), Math.abs(node.val - rightMax))), mn, mx];\n}\n\nfunction maxAncestorDiff(root) {\n    const [diff, _, _] = dfs(root);\n    return diff;\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) to traverse the input binary tree. The base case is reached when the root node is `null`, in which case the maximum value and minimum value are set to positive and negative infinity, respectively. While traversing the nodes, the algorithm maintains the maximum and minimum values of each subtree, as well as the maximum absolute difference.\n\nAt each node of the tree, the algorithm compares the difference in the node's value to the minimum and maximum values of both the left and right subtrees. This way, the potential new maximum difference is computed by comparing the current maximum difference to the absolute differences $(node.val - leftMin)$ and $(node.val - rightMax)$. The final maximum absolute difference is returned after the entire tree has been traversed. \n    "}
{"id": 1105, "slug": "filling-bookcase-shelves", "title": "Filling Bookcase Shelves", "difficulty": "Medium", "content": "You are given an array `books` where `books[i] = [thicknessi, heighti]` indicates the thickness and height of the `ith` book. You are also given an integer `shelfWidth`.\n\nWe want to place these books in order onto bookcase shelves that have a total width `shelfWidth`.\n\nWe choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to `shelfWidth`, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.\n\nNote that at each step of the above process, the order of the books we place is the same order as the given sequence of books.\n\n*   For example, if we have an ordered list of `5` books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\n\nReturn _the minimum possible height that the total bookshelf can be after placing shelves in this manner_.\n\n**Example 1:**\n\n**Input:** books = \\[\\[1,1\\],\\[2,3\\],\\[2,3\\],\\[1,1\\],\\[1,1\\],\\[1,1\\],\\[1,2\\]\\], shelfWidth = 4\n**Output:** 6\n**Explanation:**\nThe sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.\nNotice that book number 2 does not have to be on the first shelf.\n\n**Example 2:**\n\n**Input:** books = \\[\\[1,3\\],\\[2,4\\],\\[3,2\\]\\], shelfWidth = 6\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= books.length <= 1000`\n*   `1 <= thicknessi <= shelfWidth <= 1000`\n*   `1 <= heighti <= 1000`", "java": "\n    ```java\npublic int maxUncrossedLines(int[] nums1, int[] nums2) {\n    int m = nums1.length;\n    int n = nums2.length;\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (nums1[i - 1] == nums2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}\n```\n\n    \n    The problem can be solved using dynamic programming. We create a dp matrix (m+1)x(n+1) where m and n are the lengths of nums1 and nums2 respectively. The value dp[i][j] will store the maximum number of connecting lines between the first i numbers in nums1 and the first j numbers in nums2.\n\nWe iterate through the dp matrix, and if nums1[i-1] is equal to nums2[j-1], we get a new connecting line, and the value will be dp[i-1][j-1] + 1. If the numbers are not equal, we pick the maximum value from the left or the upper cell (dp[i-1][j] and dp[i][j-1]) because either we pick a number from nums1 or nums2 but not both.\n\nThe result will be stored in dp[m][n], which will give us the maximum number of connecting lines for the complete nums1 and nums2 arrays.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {\n    int m = nums1.size();\n    int n = nums2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (nums1[i - 1] == nums2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}\n```\n    \n    The problem can be solved using dynamic programming. We create a dp matrix (m+1)x(n+1) where m and n are the lengths of nums1 and nums2 respectively. The value dp[i][j] will store the maximum number of connecting lines between the first i numbers in nums1 and the first j numbers in nums2.\n\nWe iterate through the dp matrix, and if nums1[i-1] is equal to nums2[j-1], we get a new connecting line, and the value will be dp[i-1][j-1] + 1. If the numbers are not equal, we pick the maximum value from the left or the upper cell (dp[i-1][j] and dp[i][j-1]) because either we pick a number from nums1 or nums2 but not both.\n\nThe result will be stored in dp[m][n], which will give us the maximum number of connecting lines for the complete nums1 and nums2 arrays.\n    ", "python": "\n    ```python\ndef max_uncrossed_lines(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]\n```\n\n    \n    The problem can be solved using dynamic programming. We create a dp matrix (m+1)x(n+1) where m and n are the lengths of nums1 and nums2 respectively. The value dp[i][j] will store the maximum number of connecting lines between the first i numbers in nums1 and the first j numbers in nums2.\n\nWe iterate through the dp matrix, and if nums1[i-1] is equal to nums2[j-1], we get a new connecting line, and the value will be dp[i-1][j-1] + 1. If the numbers are not equal, we pick the maximum value from the left or the upper cell (dp[i-1][j] and dp[i][j-1]) because either we pick a number from nums1 or nums2 but not both.\n\nThe result will be stored in dp[m][n], which will give us the maximum number of connecting lines for the complete nums1 and nums2 arrays.\n    ", "javascript": "\n    ```javascript\nfunction maxUncrossedLines(nums1, nums2) {\n    let m = nums1.length, n = nums2.length;\n    let dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (nums1[i - 1] === nums2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}\n```\n\n    \n    The problem can be solved using dynamic programming. We create a dp matrix (m+1)x(n+1) where m and n are the lengths of nums1 and nums2 respectively. The value dp[i][j] will store the maximum number of connecting lines between the first i numbers in nums1 and the first j numbers in nums2.\n\nWe iterate through the dp matrix, and if nums1[i-1] is equal to nums2[j-1], we get a new connecting line, and the value will be dp[i-1][j-1] + 1. If the numbers are not equal, we pick the maximum value from the left or the upper cell (dp[i-1][j] and dp[i][j-1]) because either we pick a number from nums1 or nums2 but not both.\n\nThe result will be stored in dp[m][n], which will give us the maximum number of connecting lines for the complete nums1 and nums2 arrays.\n    "}
{"id": 1130, "slug": "minimum-cost-tree-from-leaf-values", "title": "Minimum Cost Tree From Leaf Values", "difficulty": "Medium", "content": "Given an array `arr` of positive integers, consider all binary trees such that:\n\n*   Each node has either `0` or `2` children;\n*   The values of `arr` correspond to the values of each **leaf** in an in-order traversal of the tree.\n*   The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.\n\nAmong all possible binary trees considered, return _the smallest possible sum of the values of each non-leaf node_. It is guaranteed this sum fits into a **32-bit** integer.\n\nA node is a **leaf** if and only if it has zero children.\n\n**Example 1:**\n\n**Input:** arr = \\[6,2,4\\]\n**Output:** 32\n**Explanation:** There are two possible trees shown.\nThe first has a non-leaf node sum 36, and the second has non-leaf node sum 32.\n\n**Example 2:**\n\n**Input:** arr = \\[4,11\\]\n**Output:** 44\n\n**Constraints:**\n\n*   `2 <= arr.length <= 40`\n*   `1 <= arr[i] <= 15`\n*   It is guaranteed that the answer fits into a **32-bit** signed integer (i.e., it is less than 231).", "java": "\n    ```java\npublic int lastStoneWeight(int[] stones) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n    for (int stone : stones) {\n        pq.add(stone);\n    }\n    while (pq.size() > 1) {\n        int x = pq.poll();\n        int y = pq.poll();\n        if (x != y) {\n            pq.add(y - x);\n        }\n    }\n    return pq.isEmpty() ? 0 : pq.peek();\n}\n```\n    \n    The algorithm makes use of a max priority queue to store the stones' weights. In each iteration, we dequeue the two largest stones (x and y) and smash them together. If their weights aren't the same, we enqueue the leftover weight (y - x) back into the priority queue. We repeat this process until there's only one stone left or no stone left in the queue. Finally, we return the weight of the remaining stone or 0 if there's none.\n\nNote: In the _JavaScript_ implementation, you need to use an external library for priority queue such as \"priorityqueuejs\", or you can create your own implementation of max priority queue.\n    ", "c++": "\n    ```cpp\nint lastStoneWeight(vector<int>& stones) {\n    priority_queue<int> pq(stones.begin(), stones.end());\n    while (pq.size() > 1) {\n        int x = pq.top(); pq.pop();\n        int y = pq.top(); pq.pop();\n        if (x != y) {\n            pq.push(y - x);\n        }\n    }\n    return pq.empty() ? 0 : pq.top();\n}\n```\n    \n    The algorithm makes use of a max priority queue to store the stones' weights. In each iteration, we dequeue the two largest stones (x and y) and smash them together. If their weights aren't the same, we enqueue the leftover weight (y - x) back into the priority queue. We repeat this process until there's only one stone left or no stone left in the queue. Finally, we return the weight of the remaining stone or 0 if there's none.\n\nNote: In the _JavaScript_ implementation, you need to use an external library for priority queue such as \"priorityqueuejs\", or you can create your own implementation of max priority queue.\n    ", "python": "\n    ```python\nimport heapq\n\ndef lastStoneWeight(stones):\n    stones = [-stone for stone in stones]\n    heapq.heapify(stones)\n    while len(stones) > 1:\n        y = -heapq.heappop(stones)\n        x = -heapq.heappop(stones)\n        if x != y:\n            heapq.heappush(stones, -(y - x))\n    return -stones[0] if stones else 0\n```\n    \n    The algorithm makes use of a max priority queue to store the stones' weights. In each iteration, we dequeue the two largest stones (x and y) and smash them together. If their weights aren't the same, we enqueue the leftover weight (y - x) back into the priority queue. We repeat this process until there's only one stone left or no stone left in the queue. Finally, we return the weight of the remaining stone or 0 if there's none.\n\nNote: In the _JavaScript_ implementation, you need to use an external library for priority queue such as \"priorityqueuejs\", or you can create your own implementation of max priority queue.\n    ", "javascript": "\n    ```javascript\nfunction lastStoneWeight(stones) {\n    const pq = new MinPriorityQueue({ priority: x => -x });\n    stones.forEach(stone => pq.enqueue(stone));\n    while (pq.size() > 1) {\n        const x = pq.dequeue().element;\n        const y = pq.dequeue().element;\n        if (x !== y) {\n            pq.enqueue(y - x);\n        }\n    }\n    return pq.isEmpty() ? 0 : pq.front().element;\n}\n```\n    \n    The algorithm makes use of a max priority queue to store the stones' weights. In each iteration, we dequeue the two largest stones (x and y) and smash them together. If their weights aren't the same, we enqueue the leftover weight (y - x) back into the priority queue. We repeat this process until there's only one stone left or no stone left in the queue. Finally, we return the weight of the remaining stone or 0 if there's none.\n\nNote: In the _JavaScript_ implementation, you need to use an external library for priority queue such as \"priorityqueuejs\", or you can create your own implementation of max priority queue.\n    "}
{"id": 1137, "slug": "n-th-tribonacci-number", "title": "N-th Tribonacci Number", "difficulty": "Easy", "content": "The Tribonacci sequence Tn is defined as follows:\n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven `n`, return the value of Tn.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** 4\n**Explanation:**\nT\\_3 = 0 + 1 + 1 = 2\nT\\_4 = 1 + 1 + 2 = 4\n\n**Example 2:**\n\n**Input:** n = 25\n**Output:** 1389537\n\n**Constraints:**\n\n*   `0 <= n <= 37`\n*   The answer is guaranteed to fit within a 32-bit integer, ie. `answer <= 2^31 - 1`.", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int heightChecker(int[] heights) {\n    int[] expected = heights.clone();\n    Arrays.sort(expected);\n    int count = 0;\n    for (int i = 0; i < heights.length; i++) {\n        if (heights[i] != expected[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm consists of the following steps:\n1. Create a copy of the given `heights` array and sort it in non-decreasing order to create the `expected` array.\n2. Iterate through both `heights` and `expected` arrays simultaneously and compare the corresponding elements.\n3. If `heights[i]` is not equal to `expected[i]`, increment the counter.\n4. Return the counter as the final answer.\n\nThis algorithm has time complexity O(n log n) due to the sorting step, where n is the number of students.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint heightChecker(std::vector<int>& heights) {\n    std::vector<int> expected = heights;\n    std::sort(expected.begin(), expected.end());\n    int count = 0;\n    for (size_t i = 0; i < heights.size(); i++) {\n        if (heights[i] != expected[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm consists of the following steps:\n1. Create a copy of the given `heights` array and sort it in non-decreasing order to create the `expected` array.\n2. Iterate through both `heights` and `expected` arrays simultaneously and compare the corresponding elements.\n3. If `heights[i]` is not equal to `expected[i]`, increment the counter.\n4. Return the counter as the final answer.\n\nThis algorithm has time complexity O(n log n) due to the sorting step, where n is the number of students.\n    ", "python": "\n    ```python\ndef height_checker(heights):\n    expected = sorted(heights)\n    count = 0\n    for i in range(len(heights)):\n        if heights[i] != expected[i]:\n            count += 1\n    return count\n```\n    \n    The algorithm consists of the following steps:\n1. Create a copy of the given `heights` array and sort it in non-decreasing order to create the `expected` array.\n2. Iterate through both `heights` and `expected` arrays simultaneously and compare the corresponding elements.\n3. If `heights[i]` is not equal to `expected[i]`, increment the counter.\n4. Return the counter as the final answer.\n\nThis algorithm has time complexity O(n log n) due to the sorting step, where n is the number of students.\n    ", "javascript": "\n    ```javascript\nfunction heightChecker(heights) {\n    const studentsInTheWrongLine = heights\n        .slice()\n        .sort((a, b) => a - b)\n        .reduce((count, height, idx) => {\n            return height === heights[idx] ? count : count + 1;\n        }, 0);\n\n    return studentsInTheWrongLine;\n}\n```\n    \n    The algorithm consists of the following steps:\n1. Create a copy of the given `heights` array and sort it in non-decreasing order to create the `expected` array.\n2. Iterate through both `heights` and `expected` arrays simultaneously and compare the corresponding elements.\n3. If `heights[i]` is not equal to `expected[i]`, increment the counter.\n4. Return the counter as the final answer.\n\nThis algorithm has time complexity O(n log n) due to the sorting step, where n is the number of students.\n    "}
{"id": 1139, "slug": "largest-1-bordered-square", "title": "Largest 1-Bordered Square", "difficulty": "Medium", "content": "Given a 2D `grid` of `0`s and `1`s, return the number of elements in the largest **square** subgrid that has all `1`s on its **border**, or `0` if such a subgrid doesn't exist in the `grid`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** 9\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,0,0\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= grid.length <= 100`\n*   `1 <= grid[0].length <= 100`\n*   `grid[i][j]` is `0` or `1`", "java": "\n    ```java\npublic int[] prevPermOpt1(int[] arr) {\n    int n = arr.length;\n    for (int i = n - 2; i >= 0; i--) {\n        if (arr[i] > arr[i + 1]) {\n            int j = i + 1;\n            while (j < n && arr[j] < arr[i]) j++;\n            int temp = arr[i];\n            arr[i] = arr[j - 1];\n            arr[j - 1] = temp;\n            return arr;\n        }\n    }\n    return arr;\n}\n```\n    \n    - Starting from the right end of the array, search for the first pair of elements where the left one is greater than the right one.\n- Then, find the next greatest element on the right side which is smaller than the left element.\n- Swap these two elements to create the lexicographically largest permutation that is smaller than the original array.\n- If the array is already the lexicographically smallest permutation, return the same array.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> prevPermOpt1(std::vector<int>& arr) {\n    int n = arr.size();\n    for(int i = n - 2; i >= 0; i--){\n        if(arr[i] > arr[i + 1]){\n            int j = i + 1;\n            while(j < n && arr[j] < arr[i]) j++;\n            std::swap(arr[i], arr[j - 1]);\n            return arr;\n        }\n    }\n    return arr;\n}\n```\n    \n    - Starting from the right end of the array, search for the first pair of elements where the left one is greater than the right one.\n- Then, find the next greatest element on the right side which is smaller than the left element.\n- Swap these two elements to create the lexicographically largest permutation that is smaller than the original array.\n- If the array is already the lexicographically smallest permutation, return the same array.\n    ", "python": "\n    ```python\ndef prev_perm_opt1(arr):\n    n = len(arr)\n    for i in range(n - 2, -1, -1):\n        if arr[i] > arr[i + 1]:\n            j = i + 1\n            while j < n and arr[j] < arr[i]:\n                j += 1\n            arr[i], arr[j - 1] = arr[j - 1], arr[i]\n            return arr\n    return arr\n```\n    \n    - Starting from the right end of the array, search for the first pair of elements where the left one is greater than the right one.\n- Then, find the next greatest element on the right side which is smaller than the left element.\n- Swap these two elements to create the lexicographically largest permutation that is smaller than the original array.\n- If the array is already the lexicographically smallest permutation, return the same array.\n    ", "javascript": "\n    ```javascript\nfunction prevPermOpt1(arr) {\n    let n = arr.length;\n    for (let i = n - 2; i >= 0; i--) {\n        if (arr[i] > arr[i + 1]) {\n            let j = i + 1;\n            while (j < n && arr[j] < arr[i]) j++;\n            [arr[i], arr[j - 1]] = [arr[j - 1], arr[i]];\n            return arr;\n        }\n    }\n    return arr;\n}\n```\n    \n    - Starting from the right end of the array, search for the first pair of elements where the left one is greater than the right one.\n- Then, find the next greatest element on the right side which is smaller than the left element.\n- Swap these two elements to create the lexicographically largest permutation that is smaller than the original array.\n- If the array is already the lexicographically smallest permutation, return the same array.\n    "}
{"id": 1140, "slug": "stone-game-ii", "title": "Stone Game II", "difficulty": "Medium", "content": "Alice and Bob continue their games with piles of stones. There are a number of piles **arranged in a row**, and each pile has a positive integer number of stones `piles[i]`. The objective of the game is to end with the most stones.\n\nAlice and Bob take turns, with Alice starting first. Initially, `M = 1`.\n\nOn each player's turn, that player can take **all the stones** in the **first** `X` remaining piles, where `1 <= X <= 2M`. Then, we set `M = max(M, X)`.\n\nThe game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n**Example 1:**\n\n**Input:** piles = \\[2,7,9,4,4\\]\n**Output:** 10\n**Explanation:**  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n\n**Example 2:**\n\n**Input:** piles = \\[1,2,3,4,5,100\\]\n**Output:** 104\n\n**Constraints:**\n\n*   `1 <= piles.length <= 100`\n*   `1 <= piles[i] <= 104`", "java": "\n    ```java\nimport java.util.*;\n\npublic int[] rearrangeBarcodes(int[] barcodes) {\n    int n = barcodes.length;\n    int[] count = new int[10001];\n    for (int i = 0; i < n; i++) {\n        count[barcodes[i]]++;\n    }\n\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);\n    for (int i = 1; i <= 10000; i++) {\n        if (count[i] > 0) {\n            pq.offer(new int[]{i, count[i]});\n        }\n    }\n\n    int index = 0;\n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        while (curr[1] > 0) {\n            barcodes[index] = curr[0];\n            curr[1]--;\n            index += 2;\n            if (index >= n) {\n                index = 1;\n            }\n        }\n    }\n    return barcodes;\n}\n```\n    \n    1. Count the occurrences of each barcode.\n2. Create a max-heap based on the count of occurrences (in descending order).\n3. Iterate through the priority queue, and assign the barcode to every second position (even positions first, odd positions next) while keeping track of counts. This ensures that no two adjacent barcodes are equal.\n4. Return the rearranged barcodes.\n    ", "c++": "\n    ```cpp\n#include<vector>\n#include<queue>\nusing namespace std;\n\nvector<int> rearrangeBarcodes(vector<int> &barcodes) {\n    int n = barcodes.size();\n    vector<int> count(10001, 0);\n    for (int i = 0; i < n; ++i) {\n        ++count[barcodes[i]];\n    }\n\n    auto comp = [](const pair<int, int>& a, const pair<int, int>& b) { return a.second < b.second; };\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);\n    for (int i = 1; i <= 10000; ++i) {\n        if (count[i] > 0) {\n            pq.push({i, count[i]});\n        }\n    }\n\n    int idx = 0;\n    while (!pq.empty()) {\n        auto curr = pq.top();\n        pq.pop();\n        while (curr.second > 0) {\n            barcodes[idx] = curr.first;\n            curr.second--;\n            idx += 2;\n            if (idx >= n) {\n                idx = 1;\n            }\n        }\n    }\n    return barcodes;\n}\n```\n    \n    1. Count the occurrences of each barcode.\n2. Create a max-heap based on the count of occurrences (in descending order).\n3. Iterate through the priority queue, and assign the barcode to every second position (even positions first, odd positions next) while keeping track of counts. This ensures that no two adjacent barcodes are equal.\n4. Return the rearranged barcodes.\n    ", "python": "\n    ```python\nfrom heapq import heappush, heappop\n\ndef rearrange_barcodes(barcodes):\n    count = {}\n    for barcode in barcodes:\n        if barcode not in count:\n            count[barcode] = 0\n        count[barcode] += 1\n\n    pq = []\n    for key, value in count.items():\n        heappush(pq, (-value, key))\n\n    idx = 0\n    while pq:\n        curr = heappop(pq)\n        while curr[0] < 0:\n            barcodes[idx] = curr[1]\n            curr = (curr[0] + 1, curr[1])\n            idx += 2\n            if idx >= len(barcodes):\n                idx = 1\n    return barcodes\n```\n    \n    1. Count the occurrences of each barcode.\n2. Create a max-heap based on the count of occurrences (in descending order).\n3. Iterate through the priority queue, and assign the barcode to every second position (even positions first, odd positions next) while keeping track of counts. This ensures that no two adjacent barcodes are equal.\n4. Return the rearranged barcodes.\n    ", "javascript": "\n    ```javascript\nfunction rearrangeBarcodes(barcodes) {\n    const count = new Map();\n    for (const barcode of barcodes) {\n        count.set(barcode, (count.get(barcode) || 0) + 1);\n    }\n\n    const pq = Array.from(count.entries());\n    pq.sort((a, b) => b[1] - a[1]);\n\n    let index = 0;\n    while (pq.length) {\n        const curr = pq.shift();\n        while (curr[1] > 0) {\n            barcodes[index] = curr[0];\n            curr[1]--;\n            index += 2;\n            if (index >= barcodes.length) {\n                index = 1;\n            }\n        }\n    }\n    return barcodes;\n}\n```\n    \n    1. Count the occurrences of each barcode.\n2. Create a max-heap based on the count of occurrences (in descending order).\n3. Iterate through the priority queue, and assign the barcode to every second position (even positions first, odd positions next) while keeping track of counts. This ensures that no two adjacent barcodes are equal.\n4. Return the rearranged barcodes.\n    "}
{"id": 1147, "slug": "longest-chunked-palindrome-decomposition", "title": "Longest Chunked Palindrome Decomposition", "difficulty": "Hard", "content": "You are given a string `text`. You should split it to k substrings `(subtext1, subtext2, ..., subtextk)` such that:\n\n*   `subtexti` is a **non-empty** string.\n*   The concatenation of all the substrings is equal to `text` (i.e., `subtext1 + subtext2 + ... + subtextk == text`).\n*   `subtexti == subtextk - i + 1` for all valid values of `i` (i.e., `1 <= i <= k`).\n\nReturn the largest possible value of `k`.\n\n**Example 1:**\n\n**Input:** text =  \"ghiabcdefhelloadamhelloabcdefghi \"\n**Output:** 7\n**Explanation:** We can split the string on  \"(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi) \".\n\n**Example 2:**\n\n**Input:** text =  \"merchant \"\n**Output:** 1\n**Explanation:** We can split the string on  \"(merchant) \".\n\n**Example 3:**\n\n**Input:** text =  \"antaprezatepzapreanta \"\n**Output:** 11\n**Explanation:** We can split the string on  \"(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a) \".\n\n**Constraints:**\n\n*   `1 <= text.length <= 1000`\n*   `text` consists only of lowercase English characters.", "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int maxEqualRowsAfterFlips(int[][] matrix) {\n    Map<String, Integer> count = new HashMap<>();\n    for (int[] row : matrix) {\n        StringBuilder row_str = new StringBuilder();\n        int first = row[0];\n        for (int val : row) {\n            row_str.append(first == 1 ? 1 - val : val);\n        }\n        count.put(row_str.toString(), count.getOrDefault(row_str.toString(), 0) + 1);\n    }\n    int res = 0;\n    for (int value : count.values()) {\n        res = Math.max(res, value);\n    }\n    return res;\n}\n```\n    \n    The algorithm initializes an empty map (or dictionary) for counting rows. For each row in the matrix, the algorithm generates a string composed of the XOR of the first element in the row with every element in that row. This operation helps to represent the rows that can be flipped to be equal. The row string is stored as a key in the dictionary, and the count of such rows is incremented.\n\nFinally, the algorithm iterates through the values in the dictionary and returns the maximum count encountered. This is the maximum number of rows that become equal after some number of flips.\n\nThe time complexity of this algorithm is O(m * n), where m is the number of rows and n is the number of columns in the matrix, as it iterates through every cell of the matrix.\n    ", "c++": "\n    ```cpp\nint maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {\n    unordered_map<string, int> count;\n    for (auto& row : matrix) {\n        string row_str;\n        if (row[0] == 1) {\n            for (int val : row)\n                row_str += '0' + 1 - val;\n        } else {\n            for (int val : row)\n                row_str += '0' + val;\n        }\n        count[row_str]++;\n    }\n    int res = 0;\n    for (auto& [key, value] : count)\n        res = max(res, value);\n    return res;\n}\n```\n    \n    The algorithm initializes an empty map (or dictionary) for counting rows. For each row in the matrix, the algorithm generates a string composed of the XOR of the first element in the row with every element in that row. This operation helps to represent the rows that can be flipped to be equal. The row string is stored as a key in the dictionary, and the count of such rows is incremented.\n\nFinally, the algorithm iterates through the values in the dictionary and returns the maximum count encountered. This is the maximum number of rows that become equal after some number of flips.\n\nThe time complexity of this algorithm is O(m * n), where m is the number of rows and n is the number of columns in the matrix, as it iterates through every cell of the matrix.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\n\ndef maxEqualRowsAfterFlips(matrix):\n    count = defaultdict(int)\n    for row in matrix:\n        row_str = \"\".join(str(row[0] ^ val) for val in row)\n        count[row_str] += 1\n    return max(count.values())\n```\n    \n    The algorithm initializes an empty map (or dictionary) for counting rows. For each row in the matrix, the algorithm generates a string composed of the XOR of the first element in the row with every element in that row. This operation helps to represent the rows that can be flipped to be equal. The row string is stored as a key in the dictionary, and the count of such rows is incremented.\n\nFinally, the algorithm iterates through the values in the dictionary and returns the maximum count encountered. This is the maximum number of rows that become equal after some number of flips.\n\nThe time complexity of this algorithm is O(m * n), where m is the number of rows and n is the number of columns in the matrix, as it iterates through every cell of the matrix.\n    ", "javascript": "\n    ```javascript\nfunction maxEqualRowsAfterFlips(matrix) {\n    const count = new Map();\n    for (const row of matrix) {\n        const rowStr = row.map(val => row[0] ^ val).join('');\n        count.set(rowStr, (count.get(rowStr) || 0) + 1);\n    }\n    let res = 0;\n    for (const value of count.values()) {\n        res = Math.max(res, value);\n    }\n    return res;\n}\n```\n    \n    The algorithm initializes an empty map (or dictionary) for counting rows. For each row in the matrix, the algorithm generates a string composed of the XOR of the first element in the row with every element in that row. This operation helps to represent the rows that can be flipped to be equal. The row string is stored as a key in the dictionary, and the count of such rows is incremented.\n\nFinally, the algorithm iterates through the values in the dictionary and returns the maximum count encountered. This is the maximum number of rows that become equal after some number of flips.\n\nThe time complexity of this algorithm is O(m * n), where m is the number of rows and n is the number of columns in the matrix, as it iterates through every cell of the matrix.\n    "}
{"id": 1186, "slug": "maximum-subarray-sum-with-one-deletion", "title": "Maximum Subarray Sum with One Deletion", "difficulty": "Medium", "content": "Given an array of integers, return the maximum sum for a **non-empty** subarray (contiguous elements) with at most one element deletion. In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the sum of the remaining elements is maximum possible.\n\nNote that the subarray needs to be **non-empty** after deleting one element.\n\n**Example 1:**\n\n**Input:** arr = \\[1,-2,0,3\\]\n**Output:** 4\n**Explanation:** Because we can choose \\[1, -2, 0, 3\\] and drop -2, thus the subarray \\[1, 0, 3\\] becomes the maximum value.\n\n**Example 2:**\n\n**Input:** arr = \\[1,-2,-2,3\\]\n**Output:** 3\n**Explanation:** We just choose \\[3\\] and it's the maximum sum.\n\n**Example 3:**\n\n**Input:** arr = \\[-1,-1,-1,-1\\]\n**Output:** -1\n**Explanation:** The final subarray needs to be non-empty. You can't choose \\[-1\\] and delete -1 from it, then get an empty subarray to make the sum equals to 0.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `-104 <= arr[i] <= 104`", "java": "\n    ```java\nimport java.util.concurrent.Semaphore;\n\nclass H2O {\n    private Semaphore hydrogenSemaphore = new Semaphore(2);\n    private Semaphore oxygenSemaphore = new Semaphore(1);\n\n    public void hydrogen(Runnable releaseHydrogen) throws InterruptedException {\n        hydrogenSemaphore.acquire();\n        releaseHydrogen.run();\n        oxygenSemaphore.release();\n    }\n\n    public void oxygen(Runnable releaseOxygen) throws InterruptedException {\n        oxygenSemaphore.acquire();\n        releaseOxygen.run();\n        hydrogenSemaphore.release(2);\n    }\n}\n```\n    \n    In the synchronization solution, we use semaphores to ensure that a group of three threads containing one oxygen and two hydrogen threads pass through the barriers. In this problem, we use two semaphores, `hydrogenSemaphore` and `oxygenSemaphore`. \n\nWe initialize the `hydrogenSemaphore` with an initial value of 2 since we need two hydrogen threads for each water molecule, this semaphore allows us to control the access for the hydrogen threads. Similarly, we initialize the `oxygenSemaphore` with an initial value of 1, to control access to the oxygen thread.\n\nFor the hydrogen function, we do the following:\n- Acquire hydrogen semaphore.\n- Release hydrogen.\n- Release oxygen semaphore.\n\nFor the oxygen function, we do the following:\n- Acquire oxygen semaphore.\n- Release oxygen.\n- Release hydrogen semaphore by 2 to allow the next two hydrogen threads.\n\nBy using both semaphores, we ensure that the threads pass through the barriers in complete sets of water molecules. With this approach, we control the flow of hydrogen and oxygen threads and allow them to pass the barriers in complete groups.\n    ", "c++": "\n    ```cpp\n#include <semaphore.h>\n\nclass H2O {\npublic:\n    sem_t hydrogenSemaphore;\n    sem_t oxygenSemaphore;\n    \n    H2O() {\n        sem_init(&hydrogenSemaphore, 0, 2);\n        sem_init(&oxygenSemaphore, 0, 1);\n    }\n\n    void hydrogen(function<void()> releaseHydrogen) {\n        sem_wait(&hydrogenSemaphore);\n        releaseHydrogen();\n        sem_post(&oxygenSemaphore);\n    }\n\n    void oxygen(function<void()> releaseOxygen) {\n        sem_wait(&oxygenSemaphore);\n        releaseOxygen();\n        sem_post(&hydrogenSemaphore);\n        sem_post(&hydrogenSemaphore);\n    }\n};\n```\n    \n    In the synchronization solution, we use semaphores to ensure that a group of three threads containing one oxygen and two hydrogen threads pass through the barriers. In this problem, we use two semaphores, `hydrogenSemaphore` and `oxygenSemaphore`. \n\nWe initialize the `hydrogenSemaphore` with an initial value of 2 since we need two hydrogen threads for each water molecule, this semaphore allows us to control the access for the hydrogen threads. Similarly, we initialize the `oxygenSemaphore` with an initial value of 1, to control access to the oxygen thread.\n\nFor the hydrogen function, we do the following:\n- Acquire hydrogen semaphore.\n- Release hydrogen.\n- Release oxygen semaphore.\n\nFor the oxygen function, we do the following:\n- Acquire oxygen semaphore.\n- Release oxygen.\n- Release hydrogen semaphore by 2 to allow the next two hydrogen threads.\n\nBy using both semaphores, we ensure that the threads pass through the barriers in complete sets of water molecules. With this approach, we control the flow of hydrogen and oxygen threads and allow them to pass the barriers in complete groups.\n    ", "python": "\n    ```python\nfrom threading import Semaphore\n\nclass H2O:\n    def __init__(self):\n        self.hydrogenSemaphore = Semaphore(2)\n        self.oxygenSemaphore = Semaphore(1)\n\n    def hydrogen(self, releaseHydrogen):\n        self.hydrogenSemaphore.acquire()\n        releaseHydrogen()\n        self.oxygenSemaphore.release()\n\n    def oxygen(self, releaseOxygen):\n        self.oxygenSemaphore.acquire()\n        releaseOxygen()\n        self.hydrogenSemaphore.release(2)\n```\n    \n    In the synchronization solution, we use semaphores to ensure that a group of three threads containing one oxygen and two hydrogen threads pass through the barriers. In this problem, we use two semaphores, `hydrogenSemaphore` and `oxygenSemaphore`. \n\nWe initialize the `hydrogenSemaphore` with an initial value of 2 since we need two hydrogen threads for each water molecule, this semaphore allows us to control the access for the hydrogen threads. Similarly, we initialize the `oxygenSemaphore` with an initial value of 1, to control access to the oxygen thread.\n\nFor the hydrogen function, we do the following:\n- Acquire hydrogen semaphore.\n- Release hydrogen.\n- Release oxygen semaphore.\n\nFor the oxygen function, we do the following:\n- Acquire oxygen semaphore.\n- Release oxygen.\n- Release hydrogen semaphore by 2 to allow the next two hydrogen threads.\n\nBy using both semaphores, we ensure that the threads pass through the barriers in complete sets of water molecules. With this approach, we control the flow of hydrogen and oxygen threads and allow them to pass the barriers in complete groups.\n    ", "javascript": "\n    ```javascript\nconst { Semaphore } = require('await-semaphore');\n\nclass H2O {\n  constructor() {\n    this.hydrogenSemaphore = new Semaphore(2);\n    this.oxygenSemaphore = new Semaphore(1);\n  }\n\n  async hydrogen(releaseHydrogen) {\n    await this.hydrogenSemaphore.acquire();\n    releaseHydrogen();\n    this.oxygenSemaphore.release();\n  }\n\n  async oxygen(releaseOxygen) {\n    await this.oxygenSemaphore.acquire();\n    releaseOxygen();\n    this.hydrogenSemaphore.release(2);\n  }\n}\n```\n\n    \n    In the synchronization solution, we use semaphores to ensure that a group of three threads containing one oxygen and two hydrogen threads pass through the barriers. In this problem, we use two semaphores, `hydrogenSemaphore` and `oxygenSemaphore`. \n\nWe initialize the `hydrogenSemaphore` with an initial value of 2 since we need two hydrogen threads for each water molecule, this semaphore allows us to control the access for the hydrogen threads. Similarly, we initialize the `oxygenSemaphore` with an initial value of 1, to control access to the oxygen thread.\n\nFor the hydrogen function, we do the following:\n- Acquire hydrogen semaphore.\n- Release hydrogen.\n- Release oxygen semaphore.\n\nFor the oxygen function, we do the following:\n- Acquire oxygen semaphore.\n- Release oxygen.\n- Release hydrogen semaphore by 2 to allow the next two hydrogen threads.\n\nBy using both semaphores, we ensure that the threads pass through the barriers in complete sets of water molecules. With this approach, we control the flow of hydrogen and oxygen threads and allow them to pass the barriers in complete groups.\n    "}
{"id": 1187, "slug": "make-array-strictly-increasing", "title": "Make Array Strictly Increasing", "difficulty": "Hard", "content": "Given two integer arrays `arr1` and `arr2`, return the minimum number of operations (possibly zero) needed to make `arr1` strictly increasing.\n\nIn one operation, you can choose two indices `0 <= i < arr1.length` and `0 <= j < arr2.length` and do the assignment `arr1[i] = arr2[j]`.\n\nIf there is no way to make `arr1` strictly increasing, return `-1`.\n\n**Example 1:**\n\n**Input:** arr1 = \\[1,5,3,6,7\\], arr2 = \\[1,3,2,4\\]\n**Output:** 1\n**Explanation:** Replace `5` with `2`, then `arr1 = [1, 2, 3, 6, 7]`.\n\n**Example 2:**\n\n**Input:** arr1 = \\[1,5,3,6,7\\], arr2 = \\[4,3,1\\]\n**Output:** 2\n**Explanation:** Replace `5` with `3` and then replace `3` with `4`. `arr1 = [1, 3, 4, 6, 7]`.\n\n**Example 3:**\n\n**Input:** arr1 = \\[1,5,3,6,7\\], arr2 = \\[1,6,3,3\\]\n**Output:** -1\n**Explanation:** You can't make `arr1` strictly increasing.\n\n**Constraints:**\n\n*   `1 <= arr1.length, arr2.length <= 2000`\n*   `0 <= arr1[i], arr2[i] <= 10^9`", "java": "\n    ```java\nimport java.util.concurrent.*;\n\nclass FooBar {\n    private int n;\n    private Semaphore fooSemaphore = new Semaphore(1);\n    private Semaphore barSemaphore = new Semaphore(0);\n\n    public FooBar(int n) {\n        this.n = n;\n    }\n\n    public void foo(Runnable printFoo) throws InterruptedException {\n        for (int i = 0; i < n; i++) {\n            fooSemaphore.acquire();\n            printFoo.run();\n            barSemaphore.release();\n        }\n    }\n\n    public void bar(Runnable printBar) throws InterruptedException {\n        for (int i = 0; i < n; i++) {\n            barSemaphore.acquire();\n            printBar.run();\n            fooSemaphore.release();\n        }\n    }\n}\n```\n    \n    1. In all four languages, a class named FooBar is created. The constructor accepts a single integer argument, `n`, which will be used later for looping purposes.\n\n2. The main challenge is to ensure that functions 'foo' and 'bar' are executed in the correct order (\"foobar\") `n` times by the two threads simultaneously. The method of synchronization differs in each language implementation.\n\n3. In C++, the implementation uses mutex and condition_variable from the standard library to synchronize the threads. A boolean, `foo_done`, is used to maintain the state of whether the foo function has been executed or not.\n\n4. In Java, semaphores are used to synchronize the threads in the `foo` and `bar` functions. The `acquire()` and `release()` methods of semaphores ensure that the threads wait and proceed in the correct order.\n\n5. In Python, Lock objects from the `threading` library are used to synchronize the two functions. `foo_lock` and `bar_lock` ensure the correct order of execution.\n\n6. In JavaScript, Promises and async/await are used to synchronize the execution of the `foo` and `bar` functions. By using the `await` keyword, the functions wait for each other to complete their execution before progressing, ensuring the correct order.\n\nIn all implementations, the goal is to ensure that the 'foo' function is executed before the 'bar' function for `n` iterations in two separate threads, such that the output is \"foobar\" repeated `n` times.\n    ", "c++": "\n    ```cpp\n#include <mutex>\n#include <condition_variable>\n\nclass FooBar {\nprivate:\n    int n;\n    std::mutex mtx;\n    std::condition_variable cv;\n    bool foo_done = false;\n\npublic:\n    FooBar(int n) {\n        this->n = n;\n    }\n\n    void foo(function<void()> printFoo) {\n        for (int i = 0; i < n; i++) {\n            std::unique_lock<std::mutex> lock(mtx);\n            cv.wait(lock, [this]() { return !foo_done; });\n            printFoo();\n            foo_done = true;\n            cv.notify_all();\n        }\n    }\n\n    void bar(function<void()> printBar) {\n        for (int i = 0; i < n; i++) {\n            std::unique_lock<std::mutex> lock(mtx);\n            cv.wait(lock, [this]() { return foo_done; });\n            printBar();\n            foo_done = false;\n            cv.notify_all();\n        }\n    }\n};\n```\n    \n    1. In all four languages, a class named FooBar is created. The constructor accepts a single integer argument, `n`, which will be used later for looping purposes.\n\n2. The main challenge is to ensure that functions 'foo' and 'bar' are executed in the correct order (\"foobar\") `n` times by the two threads simultaneously. The method of synchronization differs in each language implementation.\n\n3. In C++, the implementation uses mutex and condition_variable from the standard library to synchronize the threads. A boolean, `foo_done`, is used to maintain the state of whether the foo function has been executed or not.\n\n4. In Java, semaphores are used to synchronize the threads in the `foo` and `bar` functions. The `acquire()` and `release()` methods of semaphores ensure that the threads wait and proceed in the correct order.\n\n5. In Python, Lock objects from the `threading` library are used to synchronize the two functions. `foo_lock` and `bar_lock` ensure the correct order of execution.\n\n6. In JavaScript, Promises and async/await are used to synchronize the execution of the `foo` and `bar` functions. By using the `await` keyword, the functions wait for each other to complete their execution before progressing, ensuring the correct order.\n\nIn all implementations, the goal is to ensure that the 'foo' function is executed before the 'bar' function for `n` iterations in two separate threads, such that the output is \"foobar\" repeated `n` times.\n    ", "python": "\n    ```python\nfrom threading import Lock\n\nclass FooBar:\n    def __init__(self, n: int):\n        self.n = n\n        self.foo_lock = Lock()\n        self.bar_lock = Lock()\n        self.bar_lock.acquire()\n\n    def foo(self, printFoo) -> None:\n        for _ in range(self.n):\n            self.foo_lock.acquire()\n            printFoo()\n            self.bar_lock.release()\n\n    def bar(self, printBar) -> None:\n        for _ in range(self.n):\n            self.bar_lock.acquire()\n            printBar()\n            self.foo_lock.release()\n```\n    \n    1. In all four languages, a class named FooBar is created. The constructor accepts a single integer argument, `n`, which will be used later for looping purposes.\n\n2. The main challenge is to ensure that functions 'foo' and 'bar' are executed in the correct order (\"foobar\") `n` times by the two threads simultaneously. The method of synchronization differs in each language implementation.\n\n3. In C++, the implementation uses mutex and condition_variable from the standard library to synchronize the threads. A boolean, `foo_done`, is used to maintain the state of whether the foo function has been executed or not.\n\n4. In Java, semaphores are used to synchronize the threads in the `foo` and `bar` functions. The `acquire()` and `release()` methods of semaphores ensure that the threads wait and proceed in the correct order.\n\n5. In Python, Lock objects from the `threading` library are used to synchronize the two functions. `foo_lock` and `bar_lock` ensure the correct order of execution.\n\n6. In JavaScript, Promises and async/await are used to synchronize the execution of the `foo` and `bar` functions. By using the `await` keyword, the functions wait for each other to complete their execution before progressing, ensuring the correct order.\n\nIn all implementations, the goal is to ensure that the 'foo' function is executed before the 'bar' function for `n` iterations in two separate threads, such that the output is \"foobar\" repeated `n` times.\n    ", "javascript": "\n    ```javascript\nclass FooBar {\n  constructor(n) {\n    this.n = n;\n    this.fooPromiseResolver = null;\n    this.fooPromise = new Promise((resolve) => (this.fooPromiseResolver = resolve));\n    this.barPromiseResolver = null;\n    this.barPromise = new Promise((resolve) => (this.barPromiseResolver = resolve));\n  }\n\n  async foo(printFoo) {\n    for (let i = 0; i < this.n; i++) {\n      await this.fooPromise;\n      printFoo();\n      this.barPromiseResolver();\n      this.fooPromise = new Promise((resolve) => (this.fooPromiseResolver = resolve));\n    }\n  }\n\n  async bar(printBar) {\n    for (let i = 0; i < this.n; i++) {\n      await this.barPromise;\n      printBar();\n      this.fooPromiseResolver();\n      this.barPromise = new Promise((resolve) => (this.barPromiseResolver = resolve));\n    }\n  }\n}\n```\n    \n    1. In all four languages, a class named FooBar is created. The constructor accepts a single integer argument, `n`, which will be used later for looping purposes.\n\n2. The main challenge is to ensure that functions 'foo' and 'bar' are executed in the correct order (\"foobar\") `n` times by the two threads simultaneously. The method of synchronization differs in each language implementation.\n\n3. In C++, the implementation uses mutex and condition_variable from the standard library to synchronize the threads. A boolean, `foo_done`, is used to maintain the state of whether the foo function has been executed or not.\n\n4. In Java, semaphores are used to synchronize the threads in the `foo` and `bar` functions. The `acquire()` and `release()` methods of semaphores ensure that the threads wait and proceed in the correct order.\n\n5. In Python, Lock objects from the `threading` library are used to synchronize the two functions. `foo_lock` and `bar_lock` ensure the correct order of execution.\n\n6. In JavaScript, Promises and async/await are used to synchronize the execution of the `foo` and `bar` functions. By using the `await` keyword, the functions wait for each other to complete their execution before progressing, ensuring the correct order.\n\nIn all implementations, the goal is to ensure that the 'foo' function is executed before the 'bar' function for `n` iterations in two separate threads, such that the output is \"foobar\" repeated `n` times.\n    "}
{"id": 1216, "slug": "valid-palindrome-iii", "title": "Valid Palindrome III", "difficulty": "Hard", "content": "Given a string `s` and an integer `k`, return `true` if `s` is a `k`**\\-palindrome**.\n\nA string is `k`**\\-palindrome** if it can be transformed into a palindrome by removing at most `k` characters from it.\n\n**Example 1:**\n\n**Input:** s =  \"abcdeca \", k = 2\n**Output:** true\n**Explanation:** Remove 'b' and 'e' characters.\n\n**Example 2:**\n\n**Input:** s =  \"abbababa \", k = 1\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of only lowercase English letters.\n*   `1 <= k <= s.length`", "java": "\n    ```java\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.IntConsumer;\n\nclass ZeroEvenOdd {\n    private int n;\n    private int cnt;\n    private Lock lock;\n    private Condition condition;\n    \n    public ZeroEvenOdd(int n) {\n        this.n = n;\n        cnt = 1;\n        lock = new ReentrantLock();\n        condition = lock.newCondition();\n    }\n\n    public void zero(IntConsumer printNumber) throws InterruptedException {\n        for(int i = 1; i <= n; i++) {\n            lock.lock();\n            try {\n                while (cnt % 2 == 0)\n                    condition.await();\n                printNumber.accept(0);\n                cnt++;\n                condition.signalAll();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    public void even(IntConsumer printNumber) throws InterruptedException {\n        for(int i = 2; i <= n; i+=2) {\n            lock.lock();\n            try {\n                while (cnt != 2 * i)\n                    condition.await();\n                printNumber.accept(i);\n                cnt++;\n                condition.signalAll();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    public void odd(IntConsumer printNumber) throws InterruptedException {\n        for(int i = 1; i <= n; i+=2) {\n            lock.lock();\n            try {\n                while (cnt != 2 * i - 1)\n                    condition.await();\n                printNumber.accept(i);\n                cnt++;\n                condition.signalAll();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n```\n    \n    The algorithm uses condition variables (C++ and Java), locks (Python), or Promises (JavaScript). These are used to make sure that the three functions `zero`, `even`, and `odd` are called in the correct order. We maintain a counter `cnt` that is incremented after printing each number. The functions wait for the condition `cnt` to satisfy their respective conditions before they print the numbers and then they notify others to proceed. In the case of `zero`, it waits until `cnt` is odd and then prints 0, `even` waits until `cnt` equals 2 * current even number, and `odd` waits until `cnt` equals 2 * current odd number - 1. They repeat this process up to a length of 2n, producing the required series \"010203040506...\"\n    ", "c++": "\n    ```cpp\n#include <functional>\n#include <mutex>\n#include <condition_variable>\n\nclass ZeroEvenOdd {\nprivate:\n    int n;\n    int cnt;\n    std::mutex mtx;\n    std::condition_variable cv;\n\npublic:\n    ZeroEvenOdd(int n) {\n        this->n = n;\n        cnt = 1;\n    }\n\n    void zero(function<void(int)> printNumber) {\n        for(int i = 1; i <= n; i++) {\n            unique_lock<mutex> lck(mtx);\n            cv.wait(lck, [this](){ return cnt % 2 != 0; });\n            printNumber(0);\n            cnt++;\n            cv.notify_all();\n        }\n    }\n\n    void even(function<void(int)> printNumber) {\n        for(int i = 2; i <= n; i+=2) {\n            unique_lock<mutex> lck(mtx);\n            cv.wait(lck, [this, i](){ return cnt == 2 * i; });\n            printNumber(i);\n            cnt++;\n            cv.notify_all();\n        }\n    }\n\n    void odd(function<void(int)> printNumber) {\n        for(int i = 1; i <= n; i+=2) {\n            unique_lock<mutex> lck(mtx);\n            cv.wait(lck, [this, i](){ return cnt == 2 * i - 1; });\n            printNumber(i);\n            cnt++;\n            cv.notify_all();\n        }\n    }\n};\n```\n    \n    The algorithm uses condition variables (C++ and Java), locks (Python), or Promises (JavaScript). These are used to make sure that the three functions `zero`, `even`, and `odd` are called in the correct order. We maintain a counter `cnt` that is incremented after printing each number. The functions wait for the condition `cnt` to satisfy their respective conditions before they print the numbers and then they notify others to proceed. In the case of `zero`, it waits until `cnt` is odd and then prints 0, `even` waits until `cnt` equals 2 * current even number, and `odd` waits until `cnt` equals 2 * current odd number - 1. They repeat this process up to a length of 2n, producing the required series \"010203040506...\"\n    ", "python": "\n    ```python\nfrom threading import Lock\n\nclass ZeroEvenOdd:\n    def __init__(self, n):\n        self.n = n\n        self.cnt = 1\n        self.lock = Lock()\n\n    def zero(self, printNumber):\n        for i in range(1, self.n + 1):\n            with self.lock:\n                while self.cnt % 2 == 0:\n                    self.lock.wait()\n                printNumber(0)\n                self.cnt += 1\n                self.lock.notify_all()\n\n    def even(self, printNumber):\n        for i in range(2, self.n + 1, 2):\n            with self.lock:\n                while self.cnt != 2 * i:\n                    self.lock.wait()\n                printNumber(i)\n                self.cnt += 1\n                self.lock.notify_all()\n\n    def odd(self, printNumber):\n        for i in range(1, self.n + 1, 2):\n            with self.lock:\n                while self.cnt != 2 * i - 1:\n                    self.lock.wait()\n                printNumber(i)\n                self.cnt += 1\n                self.lock.notify_all()\n```\n    \n    The algorithm uses condition variables (C++ and Java), locks (Python), or Promises (JavaScript). These are used to make sure that the three functions `zero`, `even`, and `odd` are called in the correct order. We maintain a counter `cnt` that is incremented after printing each number. The functions wait for the condition `cnt` to satisfy their respective conditions before they print the numbers and then they notify others to proceed. In the case of `zero`, it waits until `cnt` is odd and then prints 0, `even` waits until `cnt` equals 2 * current even number, and `odd` waits until `cnt` equals 2 * current odd number - 1. They repeat this process up to a length of 2n, producing the required series \"010203040506...\"\n    ", "javascript": "\n    ```javascript\nclass ZeroEvenOdd {\n    constructor(n) {\n        this.n = n;\n        this.cnt = 1;\n        this.lock = new Promise(resolve => this.unlock = resolve);\n    }\n\n    async zero(printNumber) {\n        for(let i = 1; i <= this.n; i++) {\n            await this.lock;\n            while(this.cnt % 2 === 0) {\n                await new Promise(resolve => setTimeout(resolve, 10));\n            }\n            printNumber(0);\n            this.cnt++;\n            this.unlock();\n        }\n    }\n\n    async even(printNumber) {\n        for(let i = 2; i <= this.n; i+=2) {\n            await this.lock;\n            while(this.cnt !== 2 * i) {\n                await new Promise(resolve => setTimeout(resolve, 10));\n            }\n            printNumber(i);\n            this.cnt++;\n            this.unlock();\n        }\n    }\n\n    async odd(printNumber) {\n        for(let i = 1; i <= this.n; i+=2) {\n            await this.lock;\n            while(this.cnt !== 2 * i - 1) {\n                await new Promise(resolve => setTimeout(resolve, 10));\n            }\n            printNumber(i);\n            this.cnt++;\n            this.unlock();\n        }\n    }\n}\n```\n    \n    The algorithm uses condition variables (C++ and Java), locks (Python), or Promises (JavaScript). These are used to make sure that the three functions `zero`, `even`, and `odd` are called in the correct order. We maintain a counter `cnt` that is incremented after printing each number. The functions wait for the condition `cnt` to satisfy their respective conditions before they print the numbers and then they notify others to proceed. In the case of `zero`, it waits until `cnt` is odd and then prints 0, `even` waits until `cnt` equals 2 * current even number, and `odd` waits until `cnt` equals 2 * current odd number - 1. They repeat this process up to a length of 2n, producing the required series \"010203040506...\"\n    "}
{"id": 1218, "slug": "longest-arithmetic-subsequence-of-given-difference", "title": "Longest Arithmetic Subsequence of Given Difference", "difficulty": "Medium", "content": "Given an integer array `arr` and an integer `difference`, return the length of the longest subsequence in `arr` which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals `difference`.\n\nA **subsequence** is a sequence that can be derived from `arr` by deleting some or no elements without changing the order of the remaining elements.\n\n**Example 1:**\n\n**Input:** arr = \\[1,2,3,4\\], difference = 1\n**Output:** 4\n**Explanation:** The longest arithmetic subsequence is \\[1,2,3,4\\].\n\n**Example 2:**\n\n**Input:** arr = \\[1,3,5,7\\], difference = 1\n**Output:** 1\n**Explanation:** The longest arithmetic subsequence is any single element.\n\n**Example 3:**\n\n**Input:** arr = \\[1,5,7,8,5,3,4,2,1\\], difference = -2\n**Output:** 4\n**Explanation:** The longest arithmetic subsequence is \\[7,5,3,1\\].\n\n**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `-104 <= arr[i], difference <= 104`\n\nThe node of a binary tree is a leaf if and only if it has no children. The depth of the node of a binary tree is the number of nodes along the path from the root node down to the node itself.", "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    public class Pair {\n        TreeNode node;\n        int depth;\n\n        public Pair(TreeNode node, int depth) {\n            this.node = node;\n            this.depth = depth;\n        }\n    }\n\n    public Pair dfs(TreeNode node) {\n        if (node == null) return new Pair(null, 0);\n        Pair left = dfs(node.left);\n        Pair right = dfs(node.right);\n        if (left.depth > right.depth) {\n            return new Pair(left.node, left.depth + 1);\n        } else if (left.depth < right.depth) {\n            return new Pair(right.node, right.depth + 1);\n        } else {\n            return new Pair(node, left.depth + 1);\n        }\n    }\n\n    public TreeNode lcaDeepestLeaves(TreeNode root) {\n        return dfs(root).node;\n    }\n}\n```\n\n    \n    We use Depth-First Search for traversing the binary tree. In the DFS algorithm, we go deep into the tree before backtracking. While traversing, we calculate the depth of each node as we go along. If one of the child nodes has a greater depth than the other, we return that child node with an incremented depth. If both child nodes have the same depth, we return the current node along with the incremented depth. We continue this process and finally return the lowest common ancestor of the deepest leaves.\n    ", "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left, *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    pair<TreeNode*, int> dfs(TreeNode* node) {\n        if (!node) return {nullptr, 0};\n        auto left = dfs(node->left);\n        auto right = dfs(node->right);\n        if (left.second > right.second) {\n            return {left.first, left.second + 1};\n        } else if (left.second < right.second) {\n            return {right.first, right.second + 1};\n        } else {\n            return {node, left.second + 1};\n        }\n    }\n\n    TreeNode* lcaDeepestLeaves(TreeNode* root) {\n        return dfs(root).first;\n    }\n};\n```\n\n    \n    We use Depth-First Search for traversing the binary tree. In the DFS algorithm, we go deep into the tree before backtracking. While traversing, we calculate the depth of each node as we go along. If one of the child nodes has a greater depth than the other, we return that child node with an incremented depth. If both child nodes have the same depth, we return the current node along with the incremented depth. We continue this process and finally return the lowest common ancestor of the deepest leaves.\n    ", "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        def dfs(node):\n            if not node:\n                return (None, 0)\n            left, right = dfs(node.left), dfs(node.right)\n            if left[1] > right[1]:\n                return (left[0], left[1] + 1)\n            elif left[1] < right[1]:\n                return (right[0], right[1] + 1)\n            else:\n                return (node, left[1] + 1)\n        \n        return dfs(root)[0]\n```\n\n    \n    We use Depth-First Search for traversing the binary tree. In the DFS algorithm, we go deep into the tree before backtracking. While traversing, we calculate the depth of each node as we go along. If one of the child nodes has a greater depth than the other, we return that child node with an incremented depth. If both child nodes have the same depth, we return the current node along with the incremented depth. We continue this process and finally return the lowest common ancestor of the deepest leaves.\n    ", "javascript": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left=null, right=null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction lcaDeepestLeaves(root) {\n    function dfs(node) {\n        if (!node) return {node: null, depth: 0};\n        const left = dfs(node.left);\n        const right = dfs(node.right);\n        if (left.depth > right.depth) {\n            return {node: left.node, depth: left.depth + 1};\n        } else if (left.depth < right.depth) {\n            return {node: right.node, depth: right.depth + 1};\n        } else {\n            return {node, depth: left.depth + 1};\n        }\n    }\n\n    return dfs(root).node;\n}\n```\n\n    \n    We use Depth-First Search for traversing the binary tree. In the DFS algorithm, we go deep into the tree before backtracking. While traversing, we calculate the depth of each node as we go along. If one of the child nodes has a greater depth than the other, we return that child node with an incremented depth. If both child nodes have the same depth, we return the current node along with the incremented depth. We continue this process and finally return the lowest common ancestor of the deepest leaves.\n    "}
{"id": 1220, "slug": "count-vowels-permutation", "title": "Count Vowels Permutation", "difficulty": "Hard", "content": "Given an integer `n`, your task is to count how many strings of length `n` can be formed under the following rules:\n\n*   Each character is a lower case vowel (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`)\n*   Each vowel `'a'` may only be followed by an `'e'`.\n*   Each vowel `'e'` may only be followed by an `'a'` or an `'i'`.\n*   Each vowel `'i'` **may not** be followed by another `'i'`.\n*   Each vowel `'o'` may only be followed by an `'i'` or a `'u'`.\n*   Each vowel `'u'` may only be followed by an `'a'.`\n\nSince the answer may be too large, return it modulo `10^9 + 7.`\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** 5\n**Explanation:** All possible strings are:  \"a \",  \"e \",  \"i \" ,  \"o \" and  \"u \".\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 10\n**Explanation:** All possible strings are:  \"ae \",  \"ea \",  \"ei \",  \"ia \",  \"ie \",  \"io \",  \"iu \",  \"oi \",  \"ou \" and  \"ua \".\n\n**Example 3:**\n\n**Input:** n = 5\n**Output:** 68\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 10^4`", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int[] smallestSufficientTeam(String[] req_skills, List<List<String>> people) {\n        Map<String, Integer> index = new HashMap<>();\n        int num_skills = req_skills.length;\n        for (int i = 0; i < num_skills; i++) {\n            index.put(req_skills[i], i);\n        }\n        \n        List<Integer> sks = new ArrayList<>();\n        for (int i = 0; i < people.size(); i++) {\n            int cur = 0;\n            for (String s : people.get(i)) {\n                cur |= 1 << index.get(s);\n            }\n            sks.add(cur);\n        }\n\n        int INF = 64;\n        int[] dp = new int[1 << num_skills];\n        int[] parent = new int[1 << num_skills];\n        Arrays.fill(dp, INF);\n        dp[0] = 0;\n        \n        for (int i = 0; i < people.size(); i++) {\n            int hiskills = sks.get(i);\n            for (int done = (1 << num_skills) - 1; done >= 0; done--) {\n                int withhim = done | hiskills;\n                if (dp[withhim] > dp[done] + 1) {\n                    dp[withhim] = dp[done] + 1;\n                    parent[withhim] = done;\n                }\n            }\n        }\n        \n        int[] ans = new int[dp[(1 << num_skills) - 1]];\n        int cur = (1 << num_skills) - 1;\n        int t = dp[(1 << num_skills) - 1] - 1;\n        \n        for (int i = people.size() - 1; i >= 0; i--) {\n            int old = parent[cur];\n            int diff = cur ^ old;\n            boolean isEssential = (sks.get(i) & diff) > 0;\n            if (isEssential) {\n                ans[t] = i;\n                t--;\n            }\n            cur = old;\n        }\n        return ans;\n    }\n}\n```\n    \n    The algorithm can be described as follows:\n\n1. Create a map of each required skill to a unique integer (0-indexed).\n2. Convert the people's skills into integers using bitwise operations, where each bit represents whether the person has a particular skill or not.\n3. Use dynamic programming to find the smallest sufficient team. For each person in the list, iterate through all possible skill subsets (done by looping from (2^n - 1) to 0, where n is the number of required skills) and calculate the skill set with the current person.\n4. If the team size with the current person is smaller than the previously known team size without the person for the same skill set, update the dynamic programming table with the new team size and store the parent state.\n5. Finally, iterate through the parent state array to reconstruct the team and return the indices of the team members.\n\nThe time complexity of the algorithm is O(people * 2^req_skills). As req_skills is guaranteed to be at most 16, the time complexity is at most O(60 * 2^16), which is enough for the constraints in the problem statement.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nvector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {\n    int n = req_skills.size(), m = people.size();\n    vector<int> skill_to_int(128, -1);\n    vector<vector<int>> people_int(m);\n    vector<int> res(n);\n    int cur_min = n + 1;\n\n    for (int i = 0; i < n; ++i) skill_to_int[req_skills[i].front()] = i;\n\n    for (int i = 0; i < m; ++i)\n        for (const string& s : people[i]) people_int[i].push_back(skill_to_int[s.front()]);\n\n    function<void(bitset<26>, int, int)> dfs = [&](bitset<26> s, int p, int count) {\n        if (count >= cur_min) return;\n        if (p == m && (s & ((1 << n) - 1)) != (1 << n) - 1) return;\n        if (p == m) {\n            cur_min = count;\n            int idx = 0;\n            for (int i = 0; i < m; ++i) if (s[26 - i - 1]) res[idx++] = i;\n            return;\n    }\n        dfs(s | (s >> people_int[p]) | (s << n << people_int[p]), p + 1, count + 1);\n        dfs(s, p + 1, count);\n    };\n\n    dfs(0, 0, 0);\n    res.resize(cur_min);\n    return res;\n}\n```\n    \n    The algorithm can be described as follows:\n\n1. Create a map of each required skill to a unique integer (0-indexed).\n2. Convert the people's skills into integers using bitwise operations, where each bit represents whether the person has a particular skill or not.\n3. Use dynamic programming to find the smallest sufficient team. For each person in the list, iterate through all possible skill subsets (done by looping from (2^n - 1) to 0, where n is the number of required skills) and calculate the skill set with the current person.\n4. If the team size with the current person is smaller than the previously known team size without the person for the same skill set, update the dynamic programming table with the new team size and store the parent state.\n5. Finally, iterate through the parent state array to reconstruct the team and return the indices of the team members.\n\nThe time complexity of the algorithm is O(people * 2^req_skills). As req_skills is guaranteed to be at most 16, the time complexity is at most O(60 * 2^16), which is enough for the constraints in the problem statement.\n    ", "python": "\n    ```python\nfrom typing import List\n\ndef smallestSufficientTeam(req_skills: List[str], people: List[List[str]]) -> List[int]:\n    skill_to_int = {s: i for i, s in enumerate(req_skills)}\n    people_skills = [sum(1 << skill_to_int[skill] for skill in person) for person in people]\n        \n    n = len(req_skills)\n    INF = 64\n    dp = [INF] * (1 << n)\n    dp[0] = 0\n    parent = [None] * (1 << n)\n        \n    for i, person_skills in enumerate(people_skills):\n        for completed_skills in range((1 << n) - 1, -1, -1):\n            with_person_skills = completed_skills | person_skills\n            if dp[with_person_skills] > dp[completed_skills] + 1:\n                dp[with_person_skills] = dp[completed_skills] + 1\n                parent[with_person_skills] = completed_skills\n                \n    ans = [0] * dp[-1]\n    cur = (1 << n) - 1\n    t = dp[-1] - 1\n        \n    for i in range(len(people) - 1, -1, -1):\n        old = parent[cur]\n        diff = cur ^ old\n        is_essential = (people_skills[i] & diff) > 0\n        if is_essential:\n            ans[t] = i\n            t -= 1\n        cur = old\n    return ans\n```\n    \n    The algorithm can be described as follows:\n\n1. Create a map of each required skill to a unique integer (0-indexed).\n2. Convert the people's skills into integers using bitwise operations, where each bit represents whether the person has a particular skill or not.\n3. Use dynamic programming to find the smallest sufficient team. For each person in the list, iterate through all possible skill subsets (done by looping from (2^n - 1) to 0, where n is the number of required skills) and calculate the skill set with the current person.\n4. If the team size with the current person is smaller than the previously known team size without the person for the same skill set, update the dynamic programming table with the new team size and store the parent state.\n5. Finally, iterate through the parent state array to reconstruct the team and return the indices of the team members.\n\nThe time complexity of the algorithm is O(people * 2^req_skills). As req_skills is guaranteed to be at most 16, the time complexity is at most O(60 * 2^16), which is enough for the constraints in the problem statement.\n    ", "javascript": "\n    ```javascript\nfunction smallestSufficientTeam(req_skills, people) {\n    const skill_to_int = new Map()\n    req_skills.forEach((v, i) => skill_to_int.set(v, i))\n\n    const people_int = people.map(person =>\n        person.reduce((skills, p) => skills | 1 << skill_to_int.get(p), 0)\n    )\n\n    const n = req_skills.length\n    const INF = 64\n    const dp = Array(1 << n).fill(INF)\n    const parent = Array(1 << n).fill(0)\n\n    dp[0] = 0\n\n    for (let i = 0; i < people.length; i++) {\n        for (let skills_done = (1 << n) - 1; skills_done >= 0; skills_done--) {\n            const with_person_skills = skills_done | people_int[i]\n            if (dp[with_person_skills] > dp[skills_done] + 1) {\n                dp[with_person_skills] = dp[skills_done] + 1\n                parent[with_person_skills] = skills_done\n            }\n        }\n    }\n\n    const result = Array(dp[(1 << n) - 1])\n    let cur = (1 << n) - 1\n    let t = result.length - 1\n\n    for (let i = people.length - 1; i >= 0; i--) {\n        const old = parent[cur]\n        const diff = cur ^ old\n        const is_essential = (people_int[i] & diff) > 0\n        if (is_essential) {\n            result[t] = i\n            t -= 1\n        }\n        cur = old\n    }\n\n    return result\n}\n```\n    \n    The algorithm can be described as follows:\n\n1. Create a map of each required skill to a unique integer (0-indexed).\n2. Convert the people's skills into integers using bitwise operations, where each bit represents whether the person has a particular skill or not.\n3. Use dynamic programming to find the smallest sufficient team. For each person in the list, iterate through all possible skill subsets (done by looping from (2^n - 1) to 0, where n is the number of required skills) and calculate the skill set with the current person.\n4. If the team size with the current person is smaller than the previously known team size without the person for the same skill set, update the dynamic programming table with the new team size and store the parent state.\n5. Finally, iterate through the parent state array to reconstruct the team and return the indices of the team members.\n\nThe time complexity of the algorithm is O(people * 2^req_skills). As req_skills is guaranteed to be at most 16, the time complexity is at most O(60 * 2^16), which is enough for the constraints in the problem statement.\n    "}
{"id": 1223, "slug": "dice-roll-simulation", "title": "Dice Roll Simulation", "difficulty": "Hard", "content": "A die simulator generates a random number from `1` to `6` for each roll. You introduced a constraint to the generator such that it cannot roll the number `i` more than `rollMax[i]` (**1-indexed**) consecutive times.\n\nGiven an array of integers `rollMax` and an integer `n`, return _the number of distinct sequences that can be obtained with exact_ `n` _rolls_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\nTwo sequences are considered different if at least one element differs from each other.\n\n**Example 1:**\n\n**Input:** n = 2, rollMax = \\[1,1,2,2,2,3\\]\n**Output:** 34\n**Explanation:** There will be 2 rolls of die, if there are no constraints on the die, there are 6 \\* 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.\n\n**Example 2:**\n\n**Input:** n = 2, rollMax = \\[1,1,1,1,1,1\\]\n**Output:** 30\n\n**Example 3:**\n\n**Input:** n = 3, rollMax = \\[1,1,1,2,2,3\\]\n**Output:** 181\n\n**Constraints:**\n\n*   `1 <= n <= 5000`\n*   `rollMax.length == 6`\n*   `1 <= rollMax[i] <= 15`", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.function.Function;\nimport java.util.function.BiConsumer;\n\npublic boolean[] areConnected(int n, int threshold, int[][] queries) {\n    boolean[] answer = new boolean[queries.length];\n    int[] parent = new int[n + 1];\n    int[] rank = new int[n + 1];\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n\n    Function<Integer, Integer> find = x -> {\n        if (parent[x] != x)\n            parent[x] = find.apply(parent[x]);\n        return parent[x];\n    };\n\n    BiConsumer<Integer, Integer> unite = (x, y) -> {\n        int rootx = find.apply(x);\n        int rooty = find.apply(y);\n        if (rootx != rooty) {\n            if (rank[rootx] > rank[rooty]) {\n                int temp = rootx;\n                rootx = rooty;\n                rooty = temp;\n            }\n            parent[rootx] = rooty;\n            if (rank[rootx] == rank[rooty])\n                rank[rooty]++;\n        }\n    };\n\n    for (int i = threshold + 1; i <= n; i++) {\n        for (int j = 2 * i; j <= n; j += i) {\n            unite.accept(i, j);\n        }\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n        answer[i] = find.apply(queries[i][0]) == find.apply(queries[i][1]);\n    }\n\n    return answer;\n}\n```\n    \n    We can treat each city as a node, and if city x and y are connected, we can add an edge between them. To solve this problem, we can use the disjoint set data structure (union-find). First, we initialize the data structure with n sets, each containing one element (city).\nNext, we use a nested loop to iterate over all possible pairs of cities (i and j), and if i and j share a common divisor greater than the threshold, we connect them in the data structure. Note that we start the inner loop at 2 * i since we don't need to consider divisors less than i. After finding and connecting all cities that share a common divisor and satisfy the condition, we can then iterate through the queries and check if the cities in the query are connected using the find function. If they are connected, we return true, otherwise false for the corresponding query.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<bool> areConnected(int n, int threshold, vector<vector<int>>& queries) {\n    vector<bool> answer(queries.size());\n    vector<int> parent(n + 1), rank(n + 1, 0);\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        int rootx = find(x);\n        int rooty = find(y);\n        if (rootx != rooty) {\n            if (rank[rootx] > rank[rooty])\n                swap(rootx, rooty);\n            parent[rootx] = rooty;\n            if (rank[rootx] == rank[rooty])\n                rank[rooty]++;\n        }\n    };\n\n    for (int i = threshold + 1; i <= n; ++i)\n        for (int j = 2 * i; j <= n; j += i)\n            unite(i, j);\n\n    for (int i = 0; i < queries.size(); ++i)\n        answer[i] = find(queries[i][0]) == find(queries[i][1]);\n\n    return answer;\n}\n```\n    \n    We can treat each city as a node, and if city x and y are connected, we can add an edge between them. To solve this problem, we can use the disjoint set data structure (union-find). First, we initialize the data structure with n sets, each containing one element (city).\nNext, we use a nested loop to iterate over all possible pairs of cities (i and j), and if i and j share a common divisor greater than the threshold, we connect them in the data structure. Note that we start the inner loop at 2 * i since we don't need to consider divisors less than i. After finding and connecting all cities that share a common divisor and satisfy the condition, we can then iterate through the queries and check if the cities in the query are connected using the find function. If they are connected, we return true, otherwise false for the corresponding query.\n    ", "python": "\n    ```python\ndef areConnected(n, threshold, queries):\n    answer = [False] * len(queries)\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def unite(x, y):\n        rootx = find(x)\n        rooty = find(y)\n        if rootx != rooty:\n            if rank[rootx] > rank[rooty]:\n                rootx, rooty = rooty, rootx\n            parent[rootx] = rooty\n            if rank[rootx] == rank[rooty]:\n                rank[rooty] += 1\n\n    for i in range(threshold + 1, n + 1):\n        for j in range(i * 2, n + 1, i):\n            unite(i, j)\n\n    for i, query in enumerate(queries):\n        answer[i] = find(query[0]) == find(query[1])\n\n    return answer\n```\n    \n    We can treat each city as a node, and if city x and y are connected, we can add an edge between them. To solve this problem, we can use the disjoint set data structure (union-find). First, we initialize the data structure with n sets, each containing one element (city).\nNext, we use a nested loop to iterate over all possible pairs of cities (i and j), and if i and j share a common divisor greater than the threshold, we connect them in the data structure. Note that we start the inner loop at 2 * i since we don't need to consider divisors less than i. After finding and connecting all cities that share a common divisor and satisfy the condition, we can then iterate through the queries and check if the cities in the query are connected using the find function. If they are connected, we return true, otherwise false for the corresponding query.\n    ", "javascript": "\n    ```javascript\nfunction areConnected(n, threshold, queries) {\n    const answer = new Array(queries.length).fill(false);\n    const parent = Array.from({ length: n + 1 }, (v, i) => i);\n    const rank = new Array(n + 1).fill(0);\n\n    function find(x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    function unite(x, y) {\n        let rootx = find(x);\n        let rooty = find(y);\n        if (rootx !== rooty) {\n            if (rank[rootx] > rank[rooty]) {\n                [rootx, rooty] = [rooty, rootx];\n            }\n            parent[rootx] = rooty;\n            if (rank[rootx] === rank[rooty]) {\n                rank[rooty]++;\n            }\n        }\n    }\n\n    for (let i = threshold + 1; i <= n; i++) {\n        for (let j = 2 * i; j <= n; j += i) {\n            unite(i, j);\n        }\n    }\n\n    for (let i = 0; i < queries.length; i++) {\n        answer[i] = find(queries[i][0]) === find(queries[i][1]);\n    }\n\n    return answer;\n}\n```\n    \n    We can treat each city as a node, and if city x and y are connected, we can add an edge between them. To solve this problem, we can use the disjoint set data structure (union-find). First, we initialize the data structure with n sets, each containing one element (city).\nNext, we use a nested loop to iterate over all possible pairs of cities (i and j), and if i and j share a common divisor greater than the threshold, we connect them in the data structure. Note that we start the inner loop at 2 * i since we don't need to consider divisors less than i. After finding and connecting all cities that share a common divisor and satisfy the condition, we can then iterate through the queries and check if the cities in the query are connected using the find function. If they are connected, we return true, otherwise false for the corresponding query.\n    "}
{"id": 1227, "slug": "airplane-seat-assignment-probability", "title": "Airplane Seat Assignment Probability", "difficulty": "Medium", "content": "`n` passengers board an airplane with exactly `n` seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will:\n\n*   Take their own seat if it is still available, and\n*   Pick other seats randomly when they find their seat occupied\n\nReturn _the probability that the_ `nth` _person gets his own seat_.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** 1.00000\n**Explanation:** The first person can only get the first seat.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 0.50000\n**Explanation:** The second person has a probability of 0.5 to get the second seat (when first person gets the first seat).\n\n**Constraints:**\n\n*   `1 <= n <= 105`", "java": "\n    ```java\nimport java.util.*;\n\npublic int numEquivDominoPairs(int[][] dominoes) {\n    Map<Integer, Integer> freq = new HashMap<>();\n    int result = 0;\n    for (int[] domino : dominoes) {\n        int key = Math.min(domino[0], domino[1]) * 10 + Math.max(domino[0], domino[1]);\n        result += freq.getOrDefault(key, 0);\n        freq.put(key, freq.getOrDefault(key, 0) + 1);\n    }\n    return result;\n}\n```\n    \n    To find the number of equivalent domino pairs, we can use a hash map to count the frequencies of distinct dominoes. We loop through the given domino list and create a unique key for each domino by taking the minimum of the two numbers as the first part, and the maximum as the second part (this ensures that equivalent rotated dominoes have the same key).\n\nFor each domino, we increment the frequency count in the hash map and then add the current frequency count to the result. This sum represents the count of equivalent pairs found so far.\n\nOnce the loop is completed, we return the result as the total number of equivalent domino pairs.\n    ", "c++": "\n    ```cpp\n#include<vector>\n#include<unordered_map>\n\nint num_equiv_domino_pairs(std::vector<std::vector<int>>& dominoes) {\n    std::unordered_map<int, int> freq;\n    int result = 0;\n    for (auto& domino : dominoes) {\n        int key = (std::min(domino[0], domino[1]) << 4) | std::max(domino[0], domino[1]);\n        result += freq[key]++;\n    }\n    return result;\n}\n```\n    \n    To find the number of equivalent domino pairs, we can use a hash map to count the frequencies of distinct dominoes. We loop through the given domino list and create a unique key for each domino by taking the minimum of the two numbers as the first part, and the maximum as the second part (this ensures that equivalent rotated dominoes have the same key).\n\nFor each domino, we increment the frequency count in the hash map and then add the current frequency count to the result. This sum represents the count of equivalent pairs found so far.\n\nOnce the loop is completed, we return the result as the total number of equivalent domino pairs.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\n\ndef num_equiv_domino_pairs(dominoes):\n    freq = defaultdict(int)\n    result = 0\n    for domino in dominoes:\n        key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1])\n        result += freq[key]\n        freq[key] += 1\n    return result\n```\n    \n    To find the number of equivalent domino pairs, we can use a hash map to count the frequencies of distinct dominoes. We loop through the given domino list and create a unique key for each domino by taking the minimum of the two numbers as the first part, and the maximum as the second part (this ensures that equivalent rotated dominoes have the same key).\n\nFor each domino, we increment the frequency count in the hash map and then add the current frequency count to the result. This sum represents the count of equivalent pairs found so far.\n\nOnce the loop is completed, we return the result as the total number of equivalent domino pairs.\n    ", "javascript": "\n    ```javascript\nfunction numEquivDominoPairs(dominoes) {\n    const freq = {};\n    let result = 0;\n    for (const domino of dominoes) {\n        const key = Math.min(domino[0], domino[1]) * 10 + Math.max(domino[0], domino[1]);\n        result += (freq[key] || 0);\n        freq[key] = (freq[key] || 0) + 1;\n    }\n    return result;\n}\n```\n    \n    To find the number of equivalent domino pairs, we can use a hash map to count the frequencies of distinct dominoes. We loop through the given domino list and create a unique key for each domino by taking the minimum of the two numbers as the first part, and the maximum as the second part (this ensures that equivalent rotated dominoes have the same key).\n\nFor each domino, we increment the frequency count in the hash map and then add the current frequency count to the result. This sum represents the count of equivalent pairs found so far.\n\nOnce the loop is completed, we return the result as the total number of equivalent domino pairs.\n    "}
{"id": 1230, "slug": "toss-strange-coins", "title": "Toss Strange Coins", "difficulty": "Medium", "content": "You have some coins. The `i`\\-th coin has a probability `prob[i]` of facing heads when tossed.\n\nReturn the probability that the number of coins facing heads equals `target` if you toss every coin exactly once.\n\n**Example 1:**\n\n**Input:** prob = \\[0.4\\], target = 1\n**Output:** 0.40000\n\n**Example 2:**\n\n**Input:** prob = \\[0.5,0.5,0.5,0.5,0.5\\], target = 0\n**Output:** 0.03125\n\n**Constraints:**\n\n*   `1 <= prob.length <= 1000`\n*   `0 <= prob[i] <= 1`\n*   `0 <= target` `<= prob.length`\n*   Answers will be accepted as correct if they are within `10^-5` of the correct answer.", "java": "\n    ```java\npublic int maxValue(int[] arr1, int[] arr2) {\n    int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE,\n        max3 = Integer.MIN_VALUE, max4 = Integer.MIN_VALUE;\n    int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE,\n        min3 = Integer.MAX_VALUE, min4 = Integer.MAX_VALUE;\n    int n = arr1.length;\n\n    for (int i = 0; i < n; i++) {\n        max1 = Math.max(max1, arr1[i] - arr2[i] + i);\n        max2 = Math.max(max2, arr1[i] + arr2[i] + i);\n        max3 = Math.max(max3, -arr1[i] + arr2[i] + i);\n        max4 = Math.max(max4, -arr1[i] - arr2[i] + i);\n\n        min1 = Math.min(min1, arr1[i] - arr2[i] + i);\n        min2 = Math.min(min2, arr1[i] + arr2[i] + i);\n        min3 = Math.min(min3, -arr1[i] + arr2[i] + i);\n        min4 = Math.min(min4, -arr1[i] - arr2[i] + i);\n    }\n    return Math.max(Math.max(max1 - min1, max2 - min2),\n            Math.max(max3 - min3, max4 - min4));\n}\n```\n\n    \n    The algorithm first initializes four maximum and four minimum values with appropriate maximum and minimum integer values for the specific programming language. \n\nFor each i in [0, arr1.length), the algorithm calculates the maximum and minimum values for the four possibilities of the expression, i.e.,\n1. arr1[i] - arr2[i] + i\n2. arr1[i] + arr2[i] + i\n3. -arr1[i] + arr2[i] + i\n4. -arr1[i] - arr2[i] + i\n\nAt the end of the loop, the algorithm returns the maximum value of the differences between each maximum value and its corresponding minimum value.\n\nThis approach ensures that the maximum value of the given expression is found efficiently in O(n) time complexity.\n    ", "c++": "\n    ```cpp\nint max_value(int arr1[], int arr2[], int n) {\n    int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN, max4 = INT_MIN;\n    int min1 = INT_MAX, min2 = INT_MAX, min3 = INT_MAX, min4 = INT_MAX;\n\n    for (int i = 0; i < n; i++) {\n        max1 = max(max1, arr1[i] - arr2[i] + i);\n        max2 = max(max2, arr1[i] + arr2[i] + i);\n        max3 = max(max3, -arr1[i] + arr2[i] + i);\n        max4 = max(max4, -arr1[i] - arr2[i] + i);\n\n        min1 = min(min1, arr1[i] - arr2[i] + i);\n        min2 = min(min2, arr1[i] + arr2[i] + i);\n        min3 = min(min3, -arr1[i] + arr2[i] + i);\n        min4 = min(min4, -arr1[i] - arr2[i] + i);\n    }\n    return max({max1 - min1, max2 - min2, max3 - min3, max4 - min4});\n}\n```\n\n    \n    The algorithm first initializes four maximum and four minimum values with appropriate maximum and minimum integer values for the specific programming language. \n\nFor each i in [0, arr1.length), the algorithm calculates the maximum and minimum values for the four possibilities of the expression, i.e.,\n1. arr1[i] - arr2[i] + i\n2. arr1[i] + arr2[i] + i\n3. -arr1[i] + arr2[i] + i\n4. -arr1[i] - arr2[i] + i\n\nAt the end of the loop, the algorithm returns the maximum value of the differences between each maximum value and its corresponding minimum value.\n\nThis approach ensures that the maximum value of the given expression is found efficiently in O(n) time complexity.\n    ", "python": "\n    ```python\ndef max_value(arr1, arr2):\n    n = len(arr1)\n    max1 = max2 = max3 = max4 = float('-inf')\n    min1 = min2 = min3 = min4 = float('inf')\n\n    for i in range(n):\n        max1 = max(max1, arr1[i] - arr2[i] + i)\n        max2 = max(max2, arr1[i] + arr2[i] + i)\n        max3 = max(max3, -arr1[i] + arr2[i] + i)\n        max4 = max(max4, -arr1[i] - arr2[i] + i)\n\n        min1 = min(min1, arr1[i] - arr2[i] + i)\n        min2 = min(min2, arr1[i] + arr2[i] + i)\n        min3 = min(min3, -arr1[i] + arr2[i] + i)\n        min4 = min(min4, -arr1[i] - arr2[i] + i)\n\n    return max(max1 - min1, max2 - min2, max3 - min3, max4 - min4)\n```\n\n    \n    The algorithm first initializes four maximum and four minimum values with appropriate maximum and minimum integer values for the specific programming language. \n\nFor each i in [0, arr1.length), the algorithm calculates the maximum and minimum values for the four possibilities of the expression, i.e.,\n1. arr1[i] - arr2[i] + i\n2. arr1[i] + arr2[i] + i\n3. -arr1[i] + arr2[i] + i\n4. -arr1[i] - arr2[i] + i\n\nAt the end of the loop, the algorithm returns the maximum value of the differences between each maximum value and its corresponding minimum value.\n\nThis approach ensures that the maximum value of the given expression is found efficiently in O(n) time complexity.\n    ", "javascript": "\n    ```javascript\nfunction maxValue(arr1, arr2) {\n    let max1 = -Infinity, max2 = -Infinity, max3 = -Infinity, max4 = -Infinity;\n    let min1 = Infinity, min2 = Infinity, min3 = Infinity, min4 = Infinity;\n    let n = arr1.length;\n\n    for (let i = 0; i < n; i++) {\n        max1 = Math.max(max1, arr1[i] - arr2[i] + i);\n        max2 = Math.max(max2, arr1[i] + arr2[i] + i);\n        max3 = Math.max(max3, -arr1[i] + arr2[i] + i);\n        max4 = Math.max(max4, -arr1[i] - arr2[i] + i);\n\n        min1 = Math.min(min1, arr1[i] - arr2[i] + i);\n        min2 = Math.min(min2, arr1[i] + arr2[i] + i);\n        min3 = Math.min(min3, -arr1[i] + arr2[i] + i);\n        min4 = Math.min(min4, -arr1[i] - arr2[i] + i);\n    }\n    return Math.max(Math.max(max1 - min1, max2 - min2),\n            Math.max(max3 - min3, max4 - min4));\n}\n```\n\n    \n    The algorithm first initializes four maximum and four minimum values with appropriate maximum and minimum integer values for the specific programming language. \n\nFor each i in [0, arr1.length), the algorithm calculates the maximum and minimum values for the four possibilities of the expression, i.e.,\n1. arr1[i] - arr2[i] + i\n2. arr1[i] + arr2[i] + i\n3. -arr1[i] + arr2[i] + i\n4. -arr1[i] - arr2[i] + i\n\nAt the end of the loop, the algorithm returns the maximum value of the differences between each maximum value and its corresponding minimum value.\n\nThis approach ensures that the maximum value of the given expression is found efficiently in O(n) time complexity.\n    "}
{"id": 1255, "slug": "maximum-score-words-formed-by-letters", "title": "Maximum Score Words Formed by Letters", "difficulty": "Hard", "content": "Given a list of `words`, list of single `letters` (might be repeating) and `score` of every character.\n\nReturn the maximum score of **any** valid set of words formed by using the given letters (`words[i]` cannot be used two or more times).\n\nIt is not necessary to use all characters in `letters` and each letter can only be used once. Score of letters `'a'`, `'b'`, `'c'`, ... ,`'z'` is given by `score[0]`, `score[1]`, ... , `score[25]` respectively.\n\n**Example 1:**\n\n**Input:** words = \\[ \"dog \", \"cat \", \"dad \", \"good \"\\], letters = \\[ \"a \", \"a \", \"c \", \"d \", \"d \", \"d \", \"g \", \"o \", \"o \"\\], score = \\[1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0\\]\n**Output:** 23\n**Explanation:**\nScore  a=1, c=9, d=5, g=3, o=2\nGiven letters, we can form the words  \"dad \" (5+1+5) and  \"good \" (3+2+2+5) with a score of 23.\nWords  \"dad \" and  \"dog \" only get a score of 21.\n\n**Example 2:**\n\n**Input:** words = \\[ \"xxxz \", \"ax \", \"bx \", \"cx \"\\], letters = \\[ \"z \", \"a \", \"b \", \"c \", \"x \", \"x \", \"x \"\\], score = \\[4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10\\]\n**Output:** 27\n**Explanation:**\nScore  a=4, b=4, c=4, x=5, z=10\nGiven letters, we can form the words  \"ax \" (4+5),  \"bx \" (4+5) and  \"cx \" (4+5) with a score of 27.\nWord  \"xxxz \" only get a score of 25.\n\n**Example 3:**\n\n**Input:** words = \\[ \"leetcode \"\\], letters = \\[ \"l \", \"e \", \"t \", \"c \", \"o \", \"d \"\\], score = \\[0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0\\]\n**Output:** 0\n**Explanation:**\nLetter  \"e \" can only be used once.\n\n**Constraints:**\n\n*   `1 <= words.length <= 14`\n*   `1 <= words[i].length <= 15`\n*   `1 <= letters.length <= 100`\n*   `letters[i].length == 1`\n*   `score.length == 26`\n*   `0 <= score[i] <= 10`\n*   `words[i]`, `letters[i]` contains only lower case English letters.", "java": "\n    ```java\npublic int maxValueAfterReverse(int[] nums) {\n    int total = 0, diff = 0;\n    int min2 = Integer.MAX_VALUE, max2 = Integer.MIN_VALUE;\n    for (int i = 0; i < nums.length - 1; ++i) {\n        total += Math.abs(nums[i] - nums[i + 1]);\n        min2 = Math.min(min2, Math.max(nums[i], nums[i + 1]));\n        max2 = Math.max(max2, Math.min(nums[i], nums[i + 1]));\n        diff = Math.max(diff, Math.abs(nums[i + 1] - nums[0]) - Math.abs(nums[i + 1] - nums[i]));\n        diff = Math.max(diff, Math.abs(nums[i] - nums[nums.length - 1]) - Math.abs(nums[i] - nums[i + 1]));\n    }\n    return total + Math.max(diff, 2 * (max2 - min2));\n}\n```\n    \n    1. Initialize the required variables for total sum, difference, and minimum and maximum values for further calculations.\n2. Iterate through the given array from index 0 to nums.length - 2.\n3. Calculate the total sum by adding the absolute difference between nums[i] and nums[i+1].\n4. Update the min2 and max2 with the required calculations.\n5. Find the maximum possible difference by considering swapping a subarray (0...i+1) or (i...nums.length-1).\n6. Return the sum of the total and the maximum value of the calculated difference and 2 times (max2 - min2).\n    ", "c++": "\n    ```cpp\nint maxValueAfterReverse(vector<int>& nums) {\n    int total = 0, diff = 0;\n    int min2 = INT_MAX, max2 = INT_MIN;\n    for (int i = 0; i < nums.size() - 1; ++i) {\n        total += abs(nums[i] - nums[i + 1]);\n        min2 = min(min2, max(nums[i], nums[i + 1]));\n        max2 = max(max2, min(nums[i], nums[i + 1]));\n        diff = max(diff, abs(nums[i + 1] - nums[0]) - abs(nums[i + 1] - nums[i]));\n        diff = max(diff, abs(nums[i] - nums[nums.size() - 1]) - abs(nums[i] - nums[i + 1]));\n    }\n    return total + max(diff, 2 * (max2 - min2));\n}\n```\n    \n    1. Initialize the required variables for total sum, difference, and minimum and maximum values for further calculations.\n2. Iterate through the given array from index 0 to nums.length - 2.\n3. Calculate the total sum by adding the absolute difference between nums[i] and nums[i+1].\n4. Update the min2 and max2 with the required calculations.\n5. Find the maximum possible difference by considering swapping a subarray (0...i+1) or (i...nums.length-1).\n6. Return the sum of the total and the maximum value of the calculated difference and 2 times (max2 - min2).\n    ", "python": "\n    ```python\ndef maxValueAfterReverse(nums):\n    total, diff = 0, 0\n    min2, max2 = float('inf'), float('-inf')\n    for i in range(len(nums) - 1):\n        total += abs(nums[i] - nums[i + 1])\n        min2 = min(min2, max(nums[i], nums[i + 1]))\n        max2 = max(max2, min(nums[i], nums[i + 1]))\n        diff = max(diff, abs(nums[i + 1] - nums[0]) - abs(nums[i + 1] - nums[i]))\n        diff = max(diff, abs(nums[i] - nums[-1]) - abs(nums[i] - nums[i + 1]))\n    return total + max(diff, 2 * (max2 - min2))\n```\n    \n    1. Initialize the required variables for total sum, difference, and minimum and maximum values for further calculations.\n2. Iterate through the given array from index 0 to nums.length - 2.\n3. Calculate the total sum by adding the absolute difference between nums[i] and nums[i+1].\n4. Update the min2 and max2 with the required calculations.\n5. Find the maximum possible difference by considering swapping a subarray (0...i+1) or (i...nums.length-1).\n6. Return the sum of the total and the maximum value of the calculated difference and 2 times (max2 - min2).\n    ", "javascript": "\n    ```javascript\nfunction maxValueAfterReverse(nums) {\n    let total = 0, diff = 0;\n    let min2 = Infinity, max2 = -Infinity;\n    for (let i = 0; i < nums.length - 1; ++i) {\n        total += Math.abs(nums[i] - nums[i + 1]);\n        min2 = Math.min(min2, Math.max(nums[i], nums[i + 1]));\n        max2 = Math.max(max2, Math.min(nums[i], nums[i + 1]));\n        diff = Math.max(diff, Math.abs(nums[i + 1] - nums[0]) - Math.abs(nums[i + 1] - nums[i]));\n        diff = Math.max(diff, Math.abs(nums[i] - nums[nums.length - 1]) - Math.abs(nums[i] - nums[i + 1]));\n    }\n    return total + Math.max(diff, 2 * (max2 - min2));\n}\n```\n    \n    1. Initialize the required variables for total sum, difference, and minimum and maximum values for further calculations.\n2. Iterate through the given array from index 0 to nums.length - 2.\n3. Calculate the total sum by adding the absolute difference between nums[i] and nums[i+1].\n4. Update the min2 and max2 with the required calculations.\n5. Find the maximum possible difference by considering swapping a subarray (0...i+1) or (i...nums.length-1).\n6. Return the sum of the total and the maximum value of the calculated difference and 2 times (max2 - min2).\n    "}
{"id": 1262, "slug": "greatest-sum-divisible-by-three", "title": "Greatest Sum Divisible by Three", "difficulty": "Medium", "content": "Given an integer array `nums`, return _the **maximum possible sum** of elements of the array such that it is divisible by three_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,6,5,1,8\\]\n**Output:** 18\n**Explanation:** Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).\n\n**Example 2:**\n\n**Input:** nums = \\[4\\]\n**Output:** 0\n**Explanation:** Since 4 is not divisible by 3, do not pick any number.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,4\\]\n**Output:** 12\n**Explanation:** Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).\n\n**Constraints:**\n\n*   `1 <= nums.length <= 4 * 104`\n*   `1 <= nums[i] <= 104`", "java": "\n    ```java\nimport java.util.*;\n\nclass MajorityChecker {\n    Map<Integer, List<Integer>> positions;\n    int[] arr;\n\n    public MajorityChecker(int[] arr) {\n        this.arr = arr;\n        positions = new HashMap<>();\n        for(int i = 0; i < arr.length; i++) {\n            positions.computeIfAbsent(arr[i], x -> new ArrayList<>()).add(i);\n        }\n    }\n\n    public int query(int left, int right, int threshold) {\n        Random rnd = new Random();\n        for(int i = 0; i < 20; i++) {\n            int randomIndex = rnd.nextInt(right - left + 1) + left;\n            int num = positions.get(arr[randomIndex]).size();\n            if (num >= threshold) {\n                int lb = Collections.binarySearch(positions.get(arr[randomIndex]), left);\n                int ub = Collections.binarySearch(positions.get(arr[randomIndex]), right + 1);\n                if(lb < 0) lb = ~lb;\n                if(ub < 0) ub = ~ub;\n                if(ub - lb >= threshold) return arr[randomIndex];\n            }\n        }\n        return -1;\n    }\n}  \n```\n    \n    The MajorityChecker class utilizes an unordered_map (in C++) / HashMap (in Java) / defaultdict (in Python) / Map (in JS) to store the positions of each element in the array. When initializing the class, the positions map is built accordingly. When querying the majority element, we use the Boyer-Moore Majority Vote algorithm with randomization:\n\n1. Select a random index within the range of the subarray.\n2. Check if the selected element occurs threshold times or more in the whole array (using the size of the stored positions).\n3. If it occurs threshold times or more, check if it occurs threshold times or more in the subarray (using the lower_bound and upper_bound functions).\n4. If it occurs threshold times or more within the subarray, return the element as majority.\n5. Repeat steps 1-4 for 20 iterations. If no majority element is found, return -1 as no majority found.\n\nThe lower_bound and upper_bound functions help to find the first index at which the target is greater than or equal to the existing element and the first index which is greater than the target, respectively.\n\nThe algorithm works effectively as the majority element occurs more than half of the times, so the probability of picking it randomly in the 20 iterations is very high.\n    ", "c++": "\n    ```cpp\nclass MajorityChecker {\npublic:\n    MajorityChecker(vector<int>& arr) {\n        for(int i = 0; i < arr.size(); i++) {\n            positions[arr[i]].push_back(i);\n        }\n    }\n    \n    int query(int left, int right, int threshold) {\n        for(int i = 0; i < 20; i++) {\n            int randomIndex = rand() % (right - left + 1) + left;\n            int num = positions[arr[randomIndex]].size();\n            if (num >= threshold) {\n                auto lb = lower_bound(positions[arr[randomIndex]].begin(), positions[arr[randomIndex]].end(), left);\n                auto ub = upper_bound(positions[arr[randomIndex]].begin(), positions[arr[randomIndex]].end(), right);\n                if(ub - lb >= threshold) return arr[randomIndex];\n            }\n        }\n        return -1;\n    }\nprivate:\n    unordered_map<int, vector<int>> positions;\n};\n```\n    \n    The MajorityChecker class utilizes an unordered_map (in C++) / HashMap (in Java) / defaultdict (in Python) / Map (in JS) to store the positions of each element in the array. When initializing the class, the positions map is built accordingly. When querying the majority element, we use the Boyer-Moore Majority Vote algorithm with randomization:\n\n1. Select a random index within the range of the subarray.\n2. Check if the selected element occurs threshold times or more in the whole array (using the size of the stored positions).\n3. If it occurs threshold times or more, check if it occurs threshold times or more in the subarray (using the lower_bound and upper_bound functions).\n4. If it occurs threshold times or more within the subarray, return the element as majority.\n5. Repeat steps 1-4 for 20 iterations. If no majority element is found, return -1 as no majority found.\n\nThe lower_bound and upper_bound functions help to find the first index at which the target is greater than or equal to the existing element and the first index which is greater than the target, respectively.\n\nThe algorithm works effectively as the majority element occurs more than half of the times, so the probability of picking it randomly in the 20 iterations is very high.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\nfrom random import randint\n\nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.positions = defaultdict(list)\n        for i, num in enumerate(arr):\n            self.positions[num].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for _ in range(20):\n            randomIndex = randint(left, right)\n            num = self.arr[randomIndex]\n            lb = self.lower_bound(self.positions[num], left)\n            ub = self.upper_bound(self.positions[num], right)\n            if ub - lb >= threshold:\n                return num\n        return -1\n\n    def lower_bound(self, nums, target):\n        l, r = 0, len(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid\n        return l\n\n    def upper_bound(self, nums, target):\n        l, r = 0, len(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] <= target:\n                l = mid + 1\n            else:\n                r = mid\n        return l\n```\n    \n    The MajorityChecker class utilizes an unordered_map (in C++) / HashMap (in Java) / defaultdict (in Python) / Map (in JS) to store the positions of each element in the array. When initializing the class, the positions map is built accordingly. When querying the majority element, we use the Boyer-Moore Majority Vote algorithm with randomization:\n\n1. Select a random index within the range of the subarray.\n2. Check if the selected element occurs threshold times or more in the whole array (using the size of the stored positions).\n3. If it occurs threshold times or more, check if it occurs threshold times or more in the subarray (using the lower_bound and upper_bound functions).\n4. If it occurs threshold times or more within the subarray, return the element as majority.\n5. Repeat steps 1-4 for 20 iterations. If no majority element is found, return -1 as no majority found.\n\nThe lower_bound and upper_bound functions help to find the first index at which the target is greater than or equal to the existing element and the first index which is greater than the target, respectively.\n\nThe algorithm works effectively as the majority element occurs more than half of the times, so the probability of picking it randomly in the 20 iterations is very high.\n    ", "javascript": "\n    ```javascript\nclass MajorityChecker {\n    constructor(arr) {\n        this.arr = arr;\n        this.positions = new Map();\n        for(let i = 0; i < arr.length; i++) {\n            if (!this.positions.has(arr[i])) this.positions.set(arr[i], []);\n            this.positions.get(arr[i]).push(i);\n        }\n    }\n\n    query(left, right, threshold) {\n        for(let i = 0; i < 20; i++) {\n            let randomIndex = Math.floor(Math.random() * (right - left + 1)) + left;\n            let num = this.positions.get(this.arr[randomIndex]).length;\n            if (num >= threshold) {\n                let lb = this.lower_bound(this.positions.get(this.arr[randomIndex]), left);\n                let ub = this.upper_bound(this.positions.get(this.arr[randomIndex]), right);\n                if(ub - lb >= threshold) return this.arr[randomIndex];\n            }\n        }\n        return -1;\n    }\n\n    lower_bound(nums, target) {\n        let l = 0, r = nums.length;\n        while (l < r) {\n            let mid = Math.floor((l + r) / 2);\n            if (nums[mid] < target) l = mid + 1;\n            else r = mid;\n        }\n        return l;\n    }\n\n    upper_bound(nums, target) {\n        let l = 0, r = nums.length;\n        while (l < r) {\n            let mid = Math.floor((l + r) / 2);\n            if (nums[mid] <= target) l = mid + 1;\n            else r = mid;\n        }\n        return l;\n    }\n}\n```\n    \n    The MajorityChecker class utilizes an unordered_map (in C++) / HashMap (in Java) / defaultdict (in Python) / Map (in JS) to store the positions of each element in the array. When initializing the class, the positions map is built accordingly. When querying the majority element, we use the Boyer-Moore Majority Vote algorithm with randomization:\n\n1. Select a random index within the range of the subarray.\n2. Check if the selected element occurs threshold times or more in the whole array (using the size of the stored positions).\n3. If it occurs threshold times or more, check if it occurs threshold times or more in the subarray (using the lower_bound and upper_bound functions).\n4. If it occurs threshold times or more within the subarray, return the element as majority.\n5. Repeat steps 1-4 for 20 iterations. If no majority element is found, return -1 as no majority found.\n\nThe lower_bound and upper_bound functions help to find the first index at which the target is greater than or equal to the existing element and the first index which is greater than the target, respectively.\n\nThe algorithm works effectively as the majority element occurs more than half of the times, so the probability of picking it randomly in the 20 iterations is very high.\n    "}
{"id": 1277, "slug": "count-square-submatrices-with-all-ones", "title": "Count Square Submatrices with All Ones", "difficulty": "Medium", "content": "Given a `m * n` matrix of ones and zeros, return how many **square** submatrices have all ones.\n\n**Example 1:**\n\n**Input:** matrix =\n\\[\n  \\[0,1,1,1\\],\n  \\[1,1,1,1\\],\n  \\[0,1,1,1\\]\n\\]\n**Output:** 15\n**Explanation:** \nThere are **10** squares of side 1.\nThere are **4** squares of side 2.\nThere is  **1** square of side 3.\nTotal number of squares = 10 + 4 + 1 = **15**.\n\n**Example 2:**\n\n**Input:** matrix = \n\\[\n  \\[1,0,1\\],\n  \\[1,1,0\\],\n  \\[1,1,0\\]\n\\]\n**Output:** 7\n**Explanation:** \nThere are **6** squares of side 1.  \nThere is **1** square of side 2. \nTotal number of squares = 6 + 1 = **7**.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 300`\n*   `1 <= arr[0].length <= 300`\n*   `0 <= arr[i][j] <= 1`", "java": "\n    ```java\nimport java.util.*;\n\npublic String largestMultipleOfThree(int[] digits) {\n    int sum = 0, count[] = new int[3];\n    \n    for (int d : digits) {\n        sum += d;\n        count[d % 3]++;\n    }\n\n    if (sum % 3 == 1) {\n        if (count[1] >= 1) count[1]--; \n        else count[2] -= 2;\n    }\n    else if (sum % 3 == 2) {\n        if (count[2] >= 1) count[2]--;\n        else count[1] -= 2;\n    }\n\n    StringBuilder res = new StringBuilder();\n    for (int i = 0; i <= 9; ++i) {\n        int n = count[i % 3];\n        while (n-- > 0) res.append(i);\n    }\n\n    if (res.length() != 0 && res.charAt(res.length() - 1) == '0') return \"0\";\n    return res.reverse().toString();\n}\n```\n    \n    1. Calculate the sum of all digits in the input array, and maintain a count of each digit's frequency based on its value modulo 3.\n2. If the sum modulo 3 is 1, remove either 1 element with value modulo 3 equals to 1 or remove 2 elements with value modulo 3 equals to 2.\n3. If the sum modulo 3 is 2, remove either 1 element with value modulo 3 equals to 2 or remove 2 elements with value modulo 3 equals to 1.\n4. Build the result string by iterating from 0 to 9, appending the digits remaining in 'count' array in descending order.\n5. If the result string is non-empty and its last character is '0', return \"0\" since there are no unnecessary leading zeros.\n6. Otherwise, reverse the result string and return it as the final answer.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <string>\n\nstd::string largestMultipleOfThree(std::vector<int>& digits) {\n    int sum = 0, count[3] = {0};\n    \n    for (int d : digits) {\n        sum += d;\n        count[d % 3]++;\n    }\n\n    if (sum % 3 == 1) {\n        if (count[1] >= 1) count[1]--; \n        else count[2] -= 2;\n    }\n    else if (sum % 3 == 2) {\n        if (count[2] >= 1) count[2]--;\n        else count[1] -= 2;\n    }\n\n    std::string res = \"\";\n    for (int i = 0; i <= 9; ++i) {\n        int n = count[i % 3];\n        while (n--) res += std::to_string(i);\n    }\n\n    if (!res.empty() && res.back() == '0') return \"0\";\n    std::reverse(res.begin(), res.end());\n    return res;\n}\n```\n    \n    1. Calculate the sum of all digits in the input array, and maintain a count of each digit's frequency based on its value modulo 3.\n2. If the sum modulo 3 is 1, remove either 1 element with value modulo 3 equals to 1 or remove 2 elements with value modulo 3 equals to 2.\n3. If the sum modulo 3 is 2, remove either 1 element with value modulo 3 equals to 2 or remove 2 elements with value modulo 3 equals to 1.\n4. Build the result string by iterating from 0 to 9, appending the digits remaining in 'count' array in descending order.\n5. If the result string is non-empty and its last character is '0', return \"0\" since there are no unnecessary leading zeros.\n6. Otherwise, reverse the result string and return it as the final answer.\n    ", "python": "\n    ```python\ndef largest_multiple_of_three(digits):\n    count = [0] * 3\n    num_sum = sum(digits)\n    \n    for d in digits:\n        count[d % 3] += 1\n\n    if num_sum % 3 == 1:\n        if count[1] >= 1:\n            count[1] -= 1\n        else:\n            count[2] -= 2\n    elif num_sum % 3 == 2:\n        if count[2] >= 1:\n            count[2] -= 1\n        else:\n            count[1] -= 2\n\n    res = \"\"\n    for i in range(10):\n        res += str(i) * count[i % 3]\n    \n    if res and res[-1] == \"0\":\n        return \"0\"\n    return res[::-1]\n```\n    \n    1. Calculate the sum of all digits in the input array, and maintain a count of each digit's frequency based on its value modulo 3.\n2. If the sum modulo 3 is 1, remove either 1 element with value modulo 3 equals to 1 or remove 2 elements with value modulo 3 equals to 2.\n3. If the sum modulo 3 is 2, remove either 1 element with value modulo 3 equals to 2 or remove 2 elements with value modulo 3 equals to 1.\n4. Build the result string by iterating from 0 to 9, appending the digits remaining in 'count' array in descending order.\n5. If the result string is non-empty and its last character is '0', return \"0\" since there are no unnecessary leading zeros.\n6. Otherwise, reverse the result string and return it as the final answer.\n    ", "javascript": "\n    ```javascript\nfunction largestMultipleOfThree(digits) {\n    let sum = 0, count = [0, 0, 0];\n\n    for (let d of digits) {\n        sum += d;\n        count[d % 3]++;\n    }\n\n    if (sum % 3 === 1) {\n        if (count[1] >= 1) count[1]--; \n        else count[2] -= 2;\n    }\n    else if (sum % 3 === 2) {\n        if (count[2] >= 1) count[2]--;\n        else count[1] -= 2;\n    }\n\n    let res = \"\";\n    for (let i = 0; i <= 9; ++i) {\n        let n = count[i % 3];\n        while (n--) res += i;\n    }\n\n    if (res.length !== 0 && res[res.length - 1] === '0') return \"0\";\n    return res.split(\"\").reverse().join(\"\");\n}\n```\n    \n    1. Calculate the sum of all digits in the input array, and maintain a count of each digit's frequency based on its value modulo 3.\n2. If the sum modulo 3 is 1, remove either 1 element with value modulo 3 equals to 1 or remove 2 elements with value modulo 3 equals to 2.\n3. If the sum modulo 3 is 2, remove either 1 element with value modulo 3 equals to 2 or remove 2 elements with value modulo 3 equals to 1.\n4. Build the result string by iterating from 0 to 9, appending the digits remaining in 'count' array in descending order.\n5. If the result string is non-empty and its last character is '0', return \"0\" since there are no unnecessary leading zeros.\n6. Otherwise, reverse the result string and return it as the final answer.\n    "}
{"id": 1289, "slug": "minimum-falling-path-sum-ii", "title": "Minimum Falling Path Sum II", "difficulty": "Hard", "content": "Given an `n x n` integer matrix `grid`, return _the minimum sum of a **falling path with non-zero shifts**_.\n\nA **falling path with non-zero shifts** is a choice of exactly one element from each row of `grid` such that no two elements chosen in adjacent rows are in the same column.\n\n**Example 1:**\n\n**Input:** arr = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** 13\n**Explanation:** \nThe possible falling paths are:\n\\[1,5,9\\], \\[1,5,7\\], \\[1,6,7\\], \\[1,6,8\\],\n\\[2,4,8\\], \\[2,4,9\\], \\[2,6,7\\], \\[2,6,8\\],\n\\[3,4,8\\], \\[3,4,9\\], \\[3,5,7\\], \\[3,5,9\\]\nThe falling path with the smallest sum is \\[1,5,7\\], so the answer is 13.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[7\\]\\]\n**Output:** 7\n\n**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `1 <= n <= 200`\n*   `-99 <= grid[i][j] <= 99`", "java": "\n    ```java\npublic String dayOfTheWeek(int day, int month, int year) {\n    String[] days = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n    if (month < 3) {\n        month += 12;\n        year -= 1;\n    }\n    int k = year % 100;\n    int j = year / 100;\n    int dayOfWeek = (day + 13 * (month + 1) / 5 + k + k / 4 + 5 * j + j / 4) % 7;\n    return days[dayOfWeek];\n}\n```\n    \n    This algorithm is based on Zeller's Congruence. First, we create an array of week days. If the month is smaller than 3 (meaning January or February), we add 12 to the month and reduce the year by 1. Then, we calculate k and j, which are the year%100 and year/100, respectively. Finally, the day of the week is calculated by a formula considering the day, month, k, j, and some constants, and the output is the corresponding day string from our week days array.\n    ", "c++": "\n    ```cpp\n#include <array>\n#include <string>\n\nstd::string dayOfTheWeek(int day, int month, int year) {\n    std::array<std::string, 7> days = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n    if (month < 3) {\n        month += 12;\n        year -= 1;\n    }\n    int k = year % 100;\n    int j = year / 100;\n    int dayOfWeek = (day + 13 * (month + 1) / 5 + k + k / 4 + 5 * j + j / 4) % 7;\n    return days[dayOfWeek];\n}\n```\n    \n    This algorithm is based on Zeller's Congruence. First, we create an array of week days. If the month is smaller than 3 (meaning January or February), we add 12 to the month and reduce the year by 1. Then, we calculate k and j, which are the year%100 and year/100, respectively. Finally, the day of the week is calculated by a formula considering the day, month, k, j, and some constants, and the output is the corresponding day string from our week days array.\n    ", "python": "\n    ```python\ndef day_of_the_week(day, month, year):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    if month < 3:\n        month += 12\n        year -= 1\n    k = year % 100\n    j = year // 100\n    day_of_week = (day + 13 * (month + 1) // 5 + k + k // 4 + 5 * j + j // 4) % 7\n    return days[day_of_week]\n```\n    \n    This algorithm is based on Zeller's Congruence. First, we create an array of week days. If the month is smaller than 3 (meaning January or February), we add 12 to the month and reduce the year by 1. Then, we calculate k and j, which are the year%100 and year/100, respectively. Finally, the day of the week is calculated by a formula considering the day, month, k, j, and some constants, and the output is the corresponding day string from our week days array.\n    ", "javascript": "\n    ```javascript\nfunction dayOfTheWeek(day, month, year) {\n    const days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n    if (month < 3) {\n        month += 12;\n        year -= 1;\n    }\n    const k = year % 100;\n    const j = Math.floor(year / 100);\n    const dayOfWeek = (day + Math.floor(13 * (month + 1) / 5) + k + Math.floor(k / 4) + 5 * j + Math.floor(j / 4)) % 7;\n    return days[dayOfWeek];\n}\n```\n    \n    This algorithm is based on Zeller's Congruence. First, we create an array of week days. If the month is smaller than 3 (meaning January or February), we add 12 to the month and reduce the year by 1. Then, we calculate k and j, which are the year%100 and year/100, respectively. Finally, the day of the week is calculated by a formula considering the day, month, k, j, and some constants, and the output is the corresponding day string from our week days array.\n    "}
{"id": 1301, "slug": "number-of-paths-with-max-score", "title": "Number of Paths with Max Score", "difficulty": "Hard", "content": "You are given a square `board` of characters. You can move on the board starting at the bottom right square marked with the character `'S'`.\n\nYou need to reach the top left square marked with the character `'E'`. The rest of the squares are labeled either with a numeric character `1, 2, ..., 9` or with an obstacle `'X'`. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.\n\nReturn a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, **taken modulo `10^9 + 7`**.\n\nIn case there is no path, return `[0, 0]`.\n\n**Example 1:**\n\n**Input:** board = \\[\"E23\",\"2X2\",\"12S\"\\]\n**Output:** \\[7,1\\]\n\n**Example 2:**\n\n**Input:** board = \\[\"E12\",\"1X1\",\"21S\"\\]\n**Output:** \\[4,2\\]\n\n**Example 3:**\n\n**Input:** board = \\[\"E11\",\"XXX\",\"11S\"\\]\n**Output:** \\[0,0\\]\n\n**Constraints:**\n\n*   `2 <= board.length == board[i].length <= 100`", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    private static final int MOD = 1000000007;\n\n    public List<Integer> pathsWithMaxScore(List<String> board) {\n        int n = board.size();\n        int[][] dp = new int[n][n];\n        int[][] cnt = new int[n][n];\n        \n        board.set(0, \"0\" + board.get(0).substring(1));\n        board.set(n-1, board.get(n-1).substring(0, n - 1) + \"0\");\n        cnt[n-1][n-1] = 1;\n        \n        for (int i = n-1; i >= 0; i--) {\n            for (int j = n-1; j >= 0; j--) {\n                if (board.get(i).charAt(j) != 'X') {\n                    int[][] neighbors = {{i-1, j}, {i, j-1}, {i-1, j-1}};\n                    for (int[] neighbor : neighbors) {\n                        int x = neighbor[0], y = neighbor[1];\n                        if(x >= 0 && y >= 0) {\n                            if (dp[i][j] < dp[x][y] + board.get(i).charAt(j) - '0') {\n                                dp[i][j] = dp[x][y] + board.get(i).charAt(j) - '0';\n                                cnt[i][j] = cnt[x][y];\n                            } else if (dp[i][j] == dp[x][y] + board.get(i).charAt(j) - '0') {\n                                cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return Arrays.asList(dp[0][0], cnt[0][0]);\n    }\n}\n```\n\n    \n    We can use dynamic programming to solve this problem. We create two matrices, `dp` and `cnt`, where `dp[i][j]` represents the maximum sum of numeric characters that can be collected starting from (i, j) and `cnt[i][j]` represents the count of paths that can achieve that maximum sum.\n\nWe start from the bottom right corner (start position labeled 'S') and work our way up to the top left corner (end position labeled 'E') by checking for up, left, and up-left neighbors.\n\nIf the current cell (i, j) is not an obstacle ('X'), we iterate through its non-obstacle neighbors (x, y):\n- If `dp[i][j] < dp[x][y] + board[i][j] - '0'`, we update the maximum sum value at `dp[i][j]` and assign the count of paths to `cnt[i][j]` from the current neighbor, `cnt[x][y]`.\n- If `dp[i][j] == dp[x][y] + board[i][j] - '0'`, we increase the count of paths at `cnt[i][j]` by adding the count of paths from the current neighbor, `cnt[x][y]`, mod `10^9 + 7` to prevent integer overflow.\n\nOnce the iterations complete, we return the maximum sum and count of paths at the top left corner, `dp[0][0]` and `cnt[0][0]`. If there is no path, the values will remain 0, and we'll return `[0, 0]`.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\nconst int MOD = 1000000007;\n\nvector<int> pathsWithMaxScore(vector<string>& board) {\n    int n = board.size();\n    vector<vector<int>> dp(n, vector<int>(n, 0)), cnt(n, vector<int>(n, 0));\n    \n    board[0][0] = '0';\n    board[n-1][n-1] = '0';\n    cnt[n-1][n-1] = 1;\n    \n    for (int i = n-1; i >= 0; i--) {\n        for (int j = n-1; j >= 0; j--) {\n            if (board[i][j] != 'X') {\n                vector<pair<int, int>> neighbors = {{i-1, j}, {i, j-1}, {i-1, j-1}};\n                for (auto neighbor : neighbors) {\n                    int x = neighbor.first, y = neighbor.second;\n                    if(x>=0 && y>=0) {\n                        if (dp[i][j] < dp[x][y] + board[i][j] - '0') {\n                            dp[i][j] = dp[x][y] + board[i][j] - '0';\n                            cnt[i][j] = cnt[x][y];\n                        } else if (dp[i][j] == dp[x][y] + board[i][j] - '0') {\n                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return {dp[0][0], cnt[0][0]};\n}\n```\n\n    \n    We can use dynamic programming to solve this problem. We create two matrices, `dp` and `cnt`, where `dp[i][j]` represents the maximum sum of numeric characters that can be collected starting from (i, j) and `cnt[i][j]` represents the count of paths that can achieve that maximum sum.\n\nWe start from the bottom right corner (start position labeled 'S') and work our way up to the top left corner (end position labeled 'E') by checking for up, left, and up-left neighbors.\n\nIf the current cell (i, j) is not an obstacle ('X'), we iterate through its non-obstacle neighbors (x, y):\n- If `dp[i][j] < dp[x][y] + board[i][j] - '0'`, we update the maximum sum value at `dp[i][j]` and assign the count of paths to `cnt[i][j]` from the current neighbor, `cnt[x][y]`.\n- If `dp[i][j] == dp[x][y] + board[i][j] - '0'`, we increase the count of paths at `cnt[i][j]` by adding the count of paths from the current neighbor, `cnt[x][y]`, mod `10^9 + 7` to prevent integer overflow.\n\nOnce the iterations complete, we return the maximum sum and count of paths at the top left corner, `dp[0][0]` and `cnt[0][0]`. If there is no path, the values will remain 0, and we'll return `[0, 0]`.\n    ", "python": "\n    ```python\nfrom typing import List\n\nMOD = 10**9 + 7\n\ndef pathsWithMaxScore(board: List[str]) -> List[int]:\n    n = len(board)\n    dp = [[0] * n for _ in range(n)]\n    cnt = [[0] * n for _ in range(n)]\n\n    board[0] = list(board[0])\n    board[0][0] = '0'\n    board[n-1] = list(board[n-1])\n    board[n-1][n-1] = '0'\n    cnt[n-1][n-1] = 1\n\n    for i in range(n-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            if board[i][j] != 'X':\n                neighbors = [(i-1, j), (i, j-1), (i-1, j-1)]\n                for x, y in neighbors:\n                    if x >= 0 and y >= 0:\n                        if dp[i][j] < dp[x][y] + int(board[i][j]):\n                            dp[i][j] = dp[x][y] + int(board[i][j])\n                            cnt[i][j] = cnt[x][y]\n                        elif dp[i][j] == dp[x][y] + int(board[i][j]):\n                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD\n\n    return [dp[0][0], cnt[0][0]]\n```\n\n    \n    We can use dynamic programming to solve this problem. We create two matrices, `dp` and `cnt`, where `dp[i][j]` represents the maximum sum of numeric characters that can be collected starting from (i, j) and `cnt[i][j]` represents the count of paths that can achieve that maximum sum.\n\nWe start from the bottom right corner (start position labeled 'S') and work our way up to the top left corner (end position labeled 'E') by checking for up, left, and up-left neighbors.\n\nIf the current cell (i, j) is not an obstacle ('X'), we iterate through its non-obstacle neighbors (x, y):\n- If `dp[i][j] < dp[x][y] + board[i][j] - '0'`, we update the maximum sum value at `dp[i][j]` and assign the count of paths to `cnt[i][j]` from the current neighbor, `cnt[x][y]`.\n- If `dp[i][j] == dp[x][y] + board[i][j] - '0'`, we increase the count of paths at `cnt[i][j]` by adding the count of paths from the current neighbor, `cnt[x][y]`, mod `10^9 + 7` to prevent integer overflow.\n\nOnce the iterations complete, we return the maximum sum and count of paths at the top left corner, `dp[0][0]` and `cnt[0][0]`. If there is no path, the values will remain 0, and we'll return `[0, 0]`.\n    ", "javascript": "\n    ```javascript\nconst MOD = 1000000007;\n\nfunction pathsWithMaxScore(board) {\n    const n = board.length;\n    const dp = Array.from({length: n}, () => Array(n).fill(0));\n    const cnt = Array.from({length: n}, () => Array(n).fill(0));\n\n    board[0] = '0' + board[0].slice(1);\n    board[n - 1] = board[n - 1].slice(0, -1) + '0';\n    cnt[n - 1][n - 1] = 1;\n\n    for (let i = n-1; i >= 0; i--) {\n        for (let j = n-1; j >= 0; j--) {\n            if (board[i][j] !== 'X') {\n                const neighbors = [[i-1, j], [i, j-1], [i-1, j-1]];\n                for (const [x, y] of neighbors) {\n                    if (x >= 0 && y >= 0) {\n                        if (dp[i][j] < dp[x][y] + parseInt(board[i][j])) {\n                            dp[i][j] = dp[x][y] + parseInt(board[i][j]);\n                            cnt[i][j] = cnt[x][y];\n                        } else if (dp[i][j] === dp[x][y] + parseInt(board[i][j])) {\n                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return [dp[0][0], cnt[0][0]];\n}\n```\n\n    \n    We can use dynamic programming to solve this problem. We create two matrices, `dp` and `cnt`, where `dp[i][j]` represents the maximum sum of numeric characters that can be collected starting from (i, j) and `cnt[i][j]` represents the count of paths that can achieve that maximum sum.\n\nWe start from the bottom right corner (start position labeled 'S') and work our way up to the top left corner (end position labeled 'E') by checking for up, left, and up-left neighbors.\n\nIf the current cell (i, j) is not an obstacle ('X'), we iterate through its non-obstacle neighbors (x, y):\n- If `dp[i][j] < dp[x][y] + board[i][j] - '0'`, we update the maximum sum value at `dp[i][j]` and assign the count of paths to `cnt[i][j]` from the current neighbor, `cnt[x][y]`.\n- If `dp[i][j] == dp[x][y] + board[i][j] - '0'`, we increase the count of paths at `cnt[i][j]` by adding the count of paths from the current neighbor, `cnt[x][y]`, mod `10^9 + 7` to prevent integer overflow.\n\nOnce the iterations complete, we return the maximum sum and count of paths at the top left corner, `dp[0][0]` and `cnt[0][0]`. If there is no path, the values will remain 0, and we'll return `[0, 0]`.\n    "}
{"id": 1312, "slug": "minimum-insertion-steps-to-make-a-string-palindrome", "title": "Minimum Insertion Steps to Make a String Palindrome", "difficulty": "Hard", "content": "Given a string `s`. In one step you can insert any character at any index of the string.\n\nReturn _the minimum number of steps_ to make `s` palindrome.\n\nA **Palindrome String** is one that reads the same backward as well as forward.\n\n**Example 1:**\n\n**Input:** s =  \"zzazz \"\n**Output:** 0\n**Explanation:** The string  \"zzazz \" is already palindrome we do not need any insertions.\n\n**Example 2:**\n\n**Input:** s =  \"mbadm \"\n**Output:** 2\n**Explanation:** String can be  \"mbdadbm \" or  \"mdbabdm \".\n\n**Example 3:**\n\n**Input:** s =  \"leetcode \"\n**Output:** 5\n**Explanation:** Inserting 5 characters the string becomes  \"leetcodocteel \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `s` consists of lowercase English letters.", "java": "\n    ```java\npublic int extractArtifacts(int n, int[][] artifacts, int[][] dig) {\n    Map<Integer, Set<Integer>> artifactCells = new HashMap<>();\n    Map<Integer, Integer> artifactCount = new HashMap<>();\n    for (int i = 0; i < artifacts.length; i++) {\n        for (int r = artifacts[i][0]; r <= artifacts[i][2]; r++) {\n            for (int c = artifacts[i][1]; c <= artifacts[i][3]; c++) {\n                int cell = r * n + c;\n                artifactCells.computeIfAbsent(cell, k -> new HashSet<>()).add(i);\n                artifactCount.put(i, artifactCount.getOrDefault(i, 0) + 1);\n            }\n        }\n    }\n    \n    int ans = 0;\n    for (int[] d : dig) {\n        int cell = d[0] * n + d[1];\n        Set<Integer> artifactsInCell = artifactCells.remove(cell);\n        if (artifactsInCell != null) {\n            for (int artifactId : artifactsInCell) {\n                int remaining = artifactCount.get(artifactId) - 1;\n                artifactCount.put(artifactId, remaining);\n                if (remaining == 0) ans++;\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    1. For each artifact, iterate through its grid positions and store the positions in an unordered_map or HashMap (artifact_cells) with the key being the cell value (row * n + column) and the value being a set containing the artifact ID. Also, maintain a count of the number of cells for each artifact in another unordered_map or HashMap (artifact_count).\n\n2. Iterate through the dig array and for each cell, check if it contains any artifacts using the artifact_cells. If so, decrement the count of the corresponding artifacts in the artifact_count, and remove the cell from the artifact_cells.\n\n3. If the count of an artifact reaches 0, increment the result (ans) by 1, as the whole artifact has been uncovered and can be extracted now.\n\n4. Return the final count (ans) after iterating through all the dig cells. This represents the number of artifacts that can be extracted.\n    ", "c++": "\n    ```cpp\nint extractArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\n    unordered_map<int, set<pair<int, int>>> artifact_cells;\n    unordered_map<int, int> artifact_count;\n    for (int i = 0; i < artifacts.size(); i++) {\n        for (int r = artifacts[i][0]; r <= artifacts[i][2]; r++) {\n            for (int c = artifacts[i][1]; c <= artifacts[i][3]; c++) {\n                artifact_cells[r * n + c].insert({i, r * n + c});\n                artifact_count[i]++;\n            }\n        }\n    }\n    \n    int ans = 0;\n    for (const auto& d : dig) {\n        int cell = d[0] * n + d[1];\n        for (const auto& p : artifact_cells[cell]) {\n            artifact_count[p.first]--;\n            if (artifact_count[p.first] == 0) ans++;\n        }\n        artifact_cells.erase(cell);\n    }\n    return ans;\n}\n```\n    \n    1. For each artifact, iterate through its grid positions and store the positions in an unordered_map or HashMap (artifact_cells) with the key being the cell value (row * n + column) and the value being a set containing the artifact ID. Also, maintain a count of the number of cells for each artifact in another unordered_map or HashMap (artifact_count).\n\n2. Iterate through the dig array and for each cell, check if it contains any artifacts using the artifact_cells. If so, decrement the count of the corresponding artifacts in the artifact_count, and remove the cell from the artifact_cells.\n\n3. If the count of an artifact reaches 0, increment the result (ans) by 1, as the whole artifact has been uncovered and can be extracted now.\n\n4. Return the final count (ans) after iterating through all the dig cells. This represents the number of artifacts that can be extracted.\n    ", "python": "\n    ```python\ndef extract_artifacts(n, artifacts, dig):\n    artifact_cells = {}\n    artifact_count = {}\n\n    for i, (r1, c1, r2, c2) in enumerate(artifacts):\n        for r in range(r1, r2 + 1):\n            for c in range(c1, c2 + 1):\n                cell = r * n + c\n                if cell not in artifact_cells:\n                    artifact_cells[cell] = set()\n                artifact_cells[cell].add(i)\n                artifact_count[i] = artifact_count.get(i, 0) + 1\n\n    ans = 0\n    for r, c in dig:\n        cell = r * n + c\n        if cell in artifact_cells:\n            for artifact_id in artifact_cells[cell]:\n                artifact_count[artifact_id] -= 1\n                if artifact_count[artifact_id] == 0:\n                    ans += 1\n            del artifact_cells[cell]\n\n    return ans\n```\n    \n    1. For each artifact, iterate through its grid positions and store the positions in an unordered_map or HashMap (artifact_cells) with the key being the cell value (row * n + column) and the value being a set containing the artifact ID. Also, maintain a count of the number of cells for each artifact in another unordered_map or HashMap (artifact_count).\n\n2. Iterate through the dig array and for each cell, check if it contains any artifacts using the artifact_cells. If so, decrement the count of the corresponding artifacts in the artifact_count, and remove the cell from the artifact_cells.\n\n3. If the count of an artifact reaches 0, increment the result (ans) by 1, as the whole artifact has been uncovered and can be extracted now.\n\n4. Return the final count (ans) after iterating through all the dig cells. This represents the number of artifacts that can be extracted.\n    ", "javascript": "\n    ```javascript\nfunction extractArtifacts(n, artifacts, dig) {\n    const artifactCells = new Map();\n    const artifactCount = new Map();\n\n    for (let i = 0; i < artifacts.length; i++) {\n        for (let r = artifacts[i][0]; r <= artifacts[i][2]; r++) {\n            for (let c = artifacts[i][1]; c <= artifacts[i][3]; c++) {\n                const cell = r * n + c;\n                if (!artifactCells.has(cell)) {\n                    artifactCells.set(cell, new Set());\n                }\n                artifactCells.get(cell).add(i);\n                artifactCount.set(i, (artifactCount.get(i) || 0) + 1);\n            }\n        }\n    }\n    \n    let ans = 0;\n    for (const [r, c] of dig) {\n        const cell = r * n + c;\n        if (artifactCells.has(cell)) {\n            for (const artifactId of artifactCells.get(cell)) {\n                const remaining = artifactCount.get(artifactId) - 1;\n                artifactCount.set(artifactId, remaining);\n                if (remaining === 0) ans++;\n            }\n            artifactCells.delete(cell);\n        }\n    }\n    return ans;\n}\n```\n    \n    1. For each artifact, iterate through its grid positions and store the positions in an unordered_map or HashMap (artifact_cells) with the key being the cell value (row * n + column) and the value being a set containing the artifact ID. Also, maintain a count of the number of cells for each artifact in another unordered_map or HashMap (artifact_count).\n\n2. Iterate through the dig array and for each cell, check if it contains any artifacts using the artifact_cells. If so, decrement the count of the corresponding artifacts in the artifact_count, and remove the cell from the artifact_cells.\n\n3. If the count of an artifact reaches 0, increment the result (ans) by 1, as the whole artifact has been uncovered and can be extracted now.\n\n4. Return the final count (ans) after iterating through all the dig cells. This represents the number of artifacts that can be extracted.\n    "}
{"id": 1320, "slug": "minimum-distance-to-type-a-word-using-two-fingers", "title": "Minimum Distance to Type a Word Using Two Fingers", "difficulty": "Hard", "content": "You have a keyboard layout as shown above in the **X-Y** plane, where each English uppercase letter is located at some coordinate.\n\n*   For example, the letter `'A'` is located at coordinate `(0, 0)`, the letter `'B'` is located at coordinate `(0, 1)`, the letter `'P'` is located at coordinate `(2, 3)` and the letter `'Z'` is located at coordinate `(4, 1)`.\n\nGiven the string `word`, return _the minimum total **distance** to type such string using only two fingers_.\n\nThe **distance** between coordinates `(x1, y1)` and `(x2, y2)` is `|x1 - x2| + |y1 - y2|`.\n\n**Note** that the initial positions of your two fingers are considered free so do not count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.\n\n**Example 1:**\n\n**Input:** word =  \"CAKE \"\n**Output:** 3\n**Explanation:** Using two fingers, one optimal way to type  \"CAKE \" is: \nFinger 1 on letter 'C' -> cost = 0 \nFinger 1 on letter 'A' -> cost = Distance from letter 'C' to letter 'A' = 2 \nFinger 2 on letter 'K' -> cost = 0 \nFinger 2 on letter 'E' -> cost = Distance from letter 'K' to letter 'E' = 1 \nTotal distance = 3\n\n**Example 2:**\n\n**Input:** word =  \"HAPPY \"\n**Output:** 6\n**Explanation:** Using two fingers, one optimal way to type  \"HAPPY \" is:\nFinger 1 on letter 'H' -> cost = 0\nFinger 1 on letter 'A' -> cost = Distance from letter 'H' to letter 'A' = 2\nFinger 2 on letter 'P' -> cost = 0\nFinger 2 on letter 'P' -> cost = Distance from letter 'P' to letter 'P' = 0\nFinger 1 on letter 'Y' -> cost = Distance from letter 'A' to letter 'Y' = 4\nTotal distance = 6\n\n**Constraints:**\n\n*   `2 <= word.length <= 300`\n*   `word` consists of uppercase English letters.", "java": "\n    ```java\nimport java.util.Stack;\n\npublic String removeDuplicates(String s, int k) {\n    Stack<Pair<Character, Integer>> st = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (!st.isEmpty() && st.peek().getKey() == c) {\n            st.peek().setValue(st.peek().getValue() + 1);\n            if (st.peek().getValue() == k) st.pop();\n        } else {\n            st.push(new Pair<>(c, 1));\n        }\n    }\n    StringBuilder result = new StringBuilder();\n    while (!st.isEmpty()) {\n        Pair<Character, Integer> top = st.pop();\n        for (int i = 0; i < top.getValue(); i++) {\n            result.insert(0, top.getKey());\n        }\n    }\n    return result.toString();\n}\n```\n    \n    The algorithm initializes an empty stack for storing input string characters and their counts. It iterates through the input string, checking each character. If the top of the stack contains the same character, its count is incremented by 1. If the count becomes equal to k, remove that character from the stack, as we've found k adjacent and equal letters to remove. If the top of the stack does not contain the same character, push the character and the count 1 to the stack.\n\nOnce the input string has been processed, build the resulting string by concatenating characters from the stack with their respective counts.\n\nThe time complexity of this algorithm is O(n), as it iterates over each character in the input string once, and the space complexity is O(n), as it uses a stack to store elements. \n    ", "c++": "\n    ```cpp\n#include <string>\n#include <stack>\n\nstd::string removeDuplicates(std::string s, int k) {\n    std::stack<std::pair<char, int>> st;\n    for (char c : s) {\n        if (!st.empty() && st.top().first == c) {\n            st.top().second++;\n            if (st.top().second == k) st.pop();\n        } else {\n            st.push({c, 1});\n        }\n    }\n    std::string result = \"\";\n    while (!st.empty()) {\n        result = std::string(st.top().second, st.top().first) + result;\n        st.pop();\n    }\n    return result;\n}\n```\n    \n    The algorithm initializes an empty stack for storing input string characters and their counts. It iterates through the input string, checking each character. If the top of the stack contains the same character, its count is incremented by 1. If the count becomes equal to k, remove that character from the stack, as we've found k adjacent and equal letters to remove. If the top of the stack does not contain the same character, push the character and the count 1 to the stack.\n\nOnce the input string has been processed, build the resulting string by concatenating characters from the stack with their respective counts.\n\nThe time complexity of this algorithm is O(n), as it iterates over each character in the input string once, and the space complexity is O(n), as it uses a stack to store elements. \n    ", "python": "\n    ```python\ndef removeDuplicates(s: str, k: int) -> str:\n    stack = []\n    for c in s:\n        if stack and stack[-1][0] == c:\n            stack[-1][1] += 1\n            if stack[-1][1] == k:\n                stack.pop()\n        else:\n            stack.append([c, 1])\n    return ''.join(c * n for c, n in stack)\n```\n    \n    The algorithm initializes an empty stack for storing input string characters and their counts. It iterates through the input string, checking each character. If the top of the stack contains the same character, its count is incremented by 1. If the count becomes equal to k, remove that character from the stack, as we've found k adjacent and equal letters to remove. If the top of the stack does not contain the same character, push the character and the count 1 to the stack.\n\nOnce the input string has been processed, build the resulting string by concatenating characters from the stack with their respective counts.\n\nThe time complexity of this algorithm is O(n), as it iterates over each character in the input string once, and the space complexity is O(n), as it uses a stack to store elements. \n    ", "javascript": "\n    ```javascript\nfunction removeDuplicates(s, k) {\n    let stack = [];\n    for (let c of s) {\n        if (stack.length > 0 && stack[stack.length - 1][0] === c) {\n            stack[stack.length - 1][1]++;\n            if (stack[stack.length - 1][1] === k) stack.pop();\n        } else {\n            stack.push([c, 1]);\n        }\n    }\n    return stack.map(([c, n]) => c.repeat(n)).join('');\n}\n```\n    \n    The algorithm initializes an empty stack for storing input string characters and their counts. It iterates through the input string, checking each character. If the top of the stack contains the same character, its count is incremented by 1. If the count becomes equal to k, remove that character from the stack, as we've found k adjacent and equal letters to remove. If the top of the stack does not contain the same character, push the character and the count 1 to the stack.\n\nOnce the input string has been processed, build the resulting string by concatenating characters from the stack with their respective counts.\n\nThe time complexity of this algorithm is O(n), as it iterates over each character in the input string once, and the space complexity is O(n), as it uses a stack to store elements. \n    "}
{"id": 1326, "slug": "minimum-number-of-taps-to-open-to-water-a-garden", "title": "Minimum Number of Taps to Open to Water a Garden", "difficulty": "Hard", "content": "There is a one-dimensional garden on the x-axis. The garden starts at the point `0` and ends at the point `n`. (i.e The length of the garden is `n`).\n\nThere are `n + 1` taps located at points `[0, 1, ..., n]` in the garden.\n\nGiven an integer `n` and an integer array `ranges` of length `n + 1` where `ranges[i]` (0-indexed) means the `i-th` tap can water the area `[i - ranges[i], i + ranges[i]]` if it was open.\n\nReturn _the minimum number of taps_ that should be open to water the whole garden, If the garden cannot be watered return **\\-1**.\n\n**Example 1:**\n\n**Input:** n = 5, ranges = \\[3,4,1,1,0,0\\]\n**Output:** 1\n**Explanation:** The tap at point 0 can cover the interval \\[-3,3\\]\nThe tap at point 1 can cover the interval \\[-3,5\\]\nThe tap at point 2 can cover the interval \\[1,3\\]\nThe tap at point 3 can cover the interval \\[2,4\\]\nThe tap at point 4 can cover the interval \\[4,4\\]\nThe tap at point 5 can cover the interval \\[5,5\\]\nOpening Only the second tap will water the whole garden \\[0,5\\]\n\n**Example 2:**\n\n**Input:** n = 3, ranges = \\[0,0,0,0\\]\n**Output:** -1\n**Explanation:** Even if you activate all the four taps you cannot water the whole garden.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\n*   `ranges.length == n + 1`\n*   `0 <= ranges[i] <= 100`", "java": "\n    ```java\npublic int sumOfFlooredPairs(int[] nums) {\n    int mod = 1000000007;\n    int maxVal = Integer.MIN_VALUE;\n    for (int num : nums) {\n        maxVal = Math.max(maxVal, num);\n    }\n    int[] count = new int[maxVal + 1];\n    long[] prefSum = new long[maxVal + 1];\n\n    for (int num : nums) {\n        count[num]++;\n    }\n\n    for (int i = 1; i <= maxVal; i++) {\n        prefSum[i] = (prefSum[i - 1] + count[i]) % mod;\n    }\n\n    long res = 0;\n    for (int x = 1; x <= maxVal; x++) {\n        for (int k = 1, nx = x; nx <= maxVal; k++, nx += x) {\n            res = (res + ((prefSum[nx] - prefSum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod;\n        }\n    }\n    return (int) res;\n}\n```\n    \n    The algorithm first calculates the maximum value present in the array named maxVal. Then it initializes two other arrays: count and prefSum of size (maxVal + 1). The count array stores the frequency count of numbers in the input array, and prefSum stores the prefix sum of count array modulo mod (10^9 + 7).\n\nThe main logic is implemented using nested loops. The outer loop iterates through each unique number (x) in the input array, and the inner loop generates multiples of that number (nx) within the range of the maximum value. For each nx, calculate the result as the product of count[x], k, and the sum of the prefSum values within the range (nx - x) and nx modulo mod. The final result is obtained by summing these products modulo mod for every possible pair of numbers in the input array.\n\nThe time complexity of the algorithm is O(maxVal^2) where maxVal is the maximum value in the input array nums. The space complexity is O(maxVal) due to the count and prefSum arrays.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nint sumOfFlooredPairs(std::vector<int>& nums) {\n    int mod = 1e9 + 7;\n    int maxVal = *max_element(nums.begin(), nums.end());\n    std::vector<int> count(maxVal + 1, 0);\n    std::vector<long long> prefSum(maxVal + 1, 0);\n\n    for (int num : nums) {\n        count[num]++;\n    }\n\n    for (int i = 1; i <= maxVal; i++) {\n        prefSum[i] = (prefSum[i - 1] + count[i]) % mod;\n    }\n\n    long long res = 0;\n    for (int x = 1; x <= maxVal; x++) {\n        for (int k = 1, nx = x; nx <= maxVal; k++, nx += x) {\n            res = (res + ((prefSum[nx] - prefSum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm first calculates the maximum value present in the array named maxVal. Then it initializes two other arrays: count and prefSum of size (maxVal + 1). The count array stores the frequency count of numbers in the input array, and prefSum stores the prefix sum of count array modulo mod (10^9 + 7).\n\nThe main logic is implemented using nested loops. The outer loop iterates through each unique number (x) in the input array, and the inner loop generates multiples of that number (nx) within the range of the maximum value. For each nx, calculate the result as the product of count[x], k, and the sum of the prefSum values within the range (nx - x) and nx modulo mod. The final result is obtained by summing these products modulo mod for every possible pair of numbers in the input array.\n\nThe time complexity of the algorithm is O(maxVal^2) where maxVal is the maximum value in the input array nums. The space complexity is O(maxVal) due to the count and prefSum arrays.\n    ", "python": "\n    ```python\ndef sum_of_floored_pairs(nums):\n    mod = 10**9 + 7\n    max_val = max(nums)\n    count = [0] * (max_val + 1)\n    pref_sum = [0] * (max_val + 1)\n\n    for num in nums:\n        count[num] += 1\n\n    for i in range(1, max_val + 1):\n        pref_sum[i] = (pref_sum[i - 1] + count[i]) % mod\n\n    res = 0\n    for x in range(1, max_val + 1):\n        nx = x\n        k = 1\n        while nx <= max_val:\n            res = (res + ((pref_sum[nx] - pref_sum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod\n            k += 1\n            nx += x\n    return res\n```\n    \n    The algorithm first calculates the maximum value present in the array named maxVal. Then it initializes two other arrays: count and prefSum of size (maxVal + 1). The count array stores the frequency count of numbers in the input array, and prefSum stores the prefix sum of count array modulo mod (10^9 + 7).\n\nThe main logic is implemented using nested loops. The outer loop iterates through each unique number (x) in the input array, and the inner loop generates multiples of that number (nx) within the range of the maximum value. For each nx, calculate the result as the product of count[x], k, and the sum of the prefSum values within the range (nx - x) and nx modulo mod. The final result is obtained by summing these products modulo mod for every possible pair of numbers in the input array.\n\nThe time complexity of the algorithm is O(maxVal^2) where maxVal is the maximum value in the input array nums. The space complexity is O(maxVal) due to the count and prefSum arrays.\n    ", "javascript": "\n    ```javascript\nfunction sumOfFlooredPairs(nums) {\n    const mod = 1e9 + 7;\n    const maxVal = Math.max(...nums);\n    const count = Array(maxVal + 1).fill(0);\n    const prefSum = Array(maxVal + 1).fill(0);\n\n    for (let num of nums) {\n        count[num]++;\n    }\n\n    for (let i = 1; i <= maxVal; i++) {\n        prefSum[i] = (prefSum[i - 1] + count[i]) % mod;\n    }\n\n    let res = 0;\n    for (let x = 1; x <= maxVal; x++) {\n        for (let k = 1, nx = x; nx <= maxVal; k++, nx += x) {\n            res = (res + ((prefSum[nx] - prefSum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm first calculates the maximum value present in the array named maxVal. Then it initializes two other arrays: count and prefSum of size (maxVal + 1). The count array stores the frequency count of numbers in the input array, and prefSum stores the prefix sum of count array modulo mod (10^9 + 7).\n\nThe main logic is implemented using nested loops. The outer loop iterates through each unique number (x) in the input array, and the inner loop generates multiples of that number (nx) within the range of the maximum value. For each nx, calculate the result as the product of count[x], k, and the sum of the prefSum values within the range (nx - x) and nx modulo mod. The final result is obtained by summing these products modulo mod for every possible pair of numbers in the input array.\n\nThe time complexity of the algorithm is O(maxVal^2) where maxVal is the maximum value in the input array nums. The space complexity is O(maxVal) due to the count and prefSum arrays.\n    "}
{"id": 1335, "slug": "minimum-difficulty-of-a-job-schedule", "title": "Minimum Difficulty of a Job Schedule", "difficulty": "Hard", "content": "You want to schedule a list of jobs in `d` days. Jobs are dependent (i.e To work on the `ith` job, you have to finish all the jobs `j` where `0 <= j < i`).\n\nYou have to finish **at least** one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the `d` days. The difficulty of a day is the maximum difficulty of a job done on that day.\n\nYou are given an integer array `jobDifficulty` and an integer `d`. The difficulty of the `ith` job is `jobDifficulty[i]`.\n\nReturn _the minimum difficulty of a job schedule_. If you cannot find a schedule for the jobs return `-1`.\n\n**Example 1:**\n\n**Input:** jobDifficulty = \\[6,5,4,3,2,1\\], d = 2\n**Output:** 7\n**Explanation:** First day you can finish the first 5 jobs, total difficulty = 6.\nSecond day you can finish the last job, total difficulty = 1.\nThe difficulty of the schedule = 6 + 1 = 7 \n\n**Example 2:**\n\n**Input:** jobDifficulty = \\[9,9,9\\], d = 4\n**Output:** -1\n**Explanation:** If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.\n\n**Example 3:**\n\n**Input:** jobDifficulty = \\[1,1,1\\], d = 3\n**Output:** 3\n**Explanation:** The schedule is one job per day. total difficulty will be 3.\n\n**Constraints:**\n\n*   `1 <= jobDifficulty.length <= 300`\n*   `0 <= jobDifficulty[i] <= 1000`\n*   `1 <= d <= 10`", "java": "\n    ```java\npublic int maxCandies(int[] candies, int k) {\n    int left = 1;\n    int right = 0;\n\n    for (int candy : candies) {\n        right = Math.max(right, candy);\n    }\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        int count = 0;\n        for (int candy : candies) {\n            count += candy / mid;\n        }\n        if (count >= k) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return right;\n}\n```\n    \n    We can use binary search to find the maximum number of candies. Initialize two pointers `left` and `right` with values 1 and the maximum value in the candies array, respectively. \n\nWhile `left` is smaller or equal to `right`, calculate the middle value `mid`, which is the current number of candies to be distributed per child. Then calculate the number of children that can be given `mid` candies by dividing each `candies[i]` by `mid` and summing the values. \n\nIf the sum is greater or equal to `k`, it means that we can give the current `mid` value of candies to `k` children or more, so we can try increasing the candy count by setting `left` to `mid + 1`. If the sum is less than `k`, it means we cannot give `mid` candies to `k` children, so we set `right` to `mid - 1`.\n\nThe binary search ends when `left` is greater than `right`, and we return the value of `right`, which is the maximum number of candies per child that can be distributed to `k` children.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxCandies(const std::vector<int>& candies, int k) {\n    int left = 1;\n    int right = *std::max_element(candies.begin(), candies.end());\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        int count = 0;\n        for (int candy : candies) {\n            count += candy / mid;\n        }\n        if (count >= k) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return right;\n}\n```\n    \n    We can use binary search to find the maximum number of candies. Initialize two pointers `left` and `right` with values 1 and the maximum value in the candies array, respectively. \n\nWhile `left` is smaller or equal to `right`, calculate the middle value `mid`, which is the current number of candies to be distributed per child. Then calculate the number of children that can be given `mid` candies by dividing each `candies[i]` by `mid` and summing the values. \n\nIf the sum is greater or equal to `k`, it means that we can give the current `mid` value of candies to `k` children or more, so we can try increasing the candy count by setting `left` to `mid + 1`. If the sum is less than `k`, it means we cannot give `mid` candies to `k` children, so we set `right` to `mid - 1`.\n\nThe binary search ends when `left` is greater than `right`, and we return the value of `right`, which is the maximum number of candies per child that can be distributed to `k` children.\n    ", "python": "\n    ```python\ndef max_candies(candies, k):\n    left, right = 1, max(candies)\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        count = sum(candy // mid for candy in candies)\n        if count >= k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right\n```\n    \n    We can use binary search to find the maximum number of candies. Initialize two pointers `left` and `right` with values 1 and the maximum value in the candies array, respectively. \n\nWhile `left` is smaller or equal to `right`, calculate the middle value `mid`, which is the current number of candies to be distributed per child. Then calculate the number of children that can be given `mid` candies by dividing each `candies[i]` by `mid` and summing the values. \n\nIf the sum is greater or equal to `k`, it means that we can give the current `mid` value of candies to `k` children or more, so we can try increasing the candy count by setting `left` to `mid + 1`. If the sum is less than `k`, it means we cannot give `mid` candies to `k` children, so we set `right` to `mid - 1`.\n\nThe binary search ends when `left` is greater than `right`, and we return the value of `right`, which is the maximum number of candies per child that can be distributed to `k` children.\n    ", "javascript": "\n    ```javascript\nfunction maxCandies(candies, k) {\n    let left = 1;\n    let right = Math.max(...candies);\n\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        let count = candies.reduce((acc, candy) => acc + Math.floor(candy / mid), 0);\n        if (count >= k) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return right;\n}\n```\n    \n    We can use binary search to find the maximum number of candies. Initialize two pointers `left` and `right` with values 1 and the maximum value in the candies array, respectively. \n\nWhile `left` is smaller or equal to `right`, calculate the middle value `mid`, which is the current number of candies to be distributed per child. Then calculate the number of children that can be given `mid` candies by dividing each `candies[i]` by `mid` and summing the values. \n\nIf the sum is greater or equal to `k`, it means that we can give the current `mid` value of candies to `k` children or more, so we can try increasing the candy count by setting `left` to `mid + 1`. If the sum is less than `k`, it means we cannot give `mid` candies to `k` children, so we set `right` to `mid - 1`.\n\nThe binary search ends when `left` is greater than `right`, and we return the value of `right`, which is the maximum number of candies per child that can be distributed to `k` children.\n    "}
{"id": 1340, "slug": "jump-game-v", "title": "Jump Game V", "difficulty": "Hard", "content": "Given an array of integers `arr` and an integer `d`. In one step you can jump from index `i` to index:\n\n*   `i + x` where: `i + x < arr.length` and `0 < x <= d`.\n*   `i - x` where: `i - x >= 0` and `0 < x <= d`.\n\nIn addition, you can only jump from index `i` to index `j` if `arr[i] > arr[j]` and `arr[i] > arr[k]` for all indices `k` between `i` and `j` (More formally `min(i, j) < k < max(i, j)`).\n\nYou can choose any index of the array and start jumping. Return _the maximum number of indices_ you can visit.\n\nNotice that you can not jump outside of the array at any time.\n\n**Example 1:**\n\n**Input:** arr = \\[6,4,14,6,8,13,9,7,10,6,12\\], d = 2\n**Output:** 4\n**Explanation:** You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.\nNote that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.\nSimilarly You cannot jump from index 3 to index 2 or index 1.\n\n**Example 2:**\n\n**Input:** arr = \\[3,3,3,3,3\\], d = 3\n**Output:** 1\n**Explanation:** You can start at any index. You always cannot jump to any index.\n\n**Example 3:**\n\n**Input:** arr = \\[7,6,5,4,3,2,1\\], d = 1\n**Output:** 7\n**Explanation:** Start at index 0. You can visit all the indicies. \n\n**Constraints:**\n\n*   `1 <= arr.length <= 1000`\n*   `1 <= arr[i] <= 105`\n*   `1 <= d <= arr.length`", "java": "\n    ```java\nimport java.util.concurrent.locks.*;\n\nclass DiningPhilosophers {\n    private final ReentrantLock[] locks = new ReentrantLock[5];\n    private final Condition[] notBusy = new Condition[5];\n\n    public DiningPhilosophers() {\n        for (int i = 0; i < 5; i++) {\n            locks[i] = new ReentrantLock();\n            notBusy[i] = locks[i].newCondition();\n        }\n    }\n\n    public void wantsToEat(int philosopher,\n                            Runnable pickLeftFork,\n                            Runnable pickRightFork,\n                            Runnable eat,\n                            Runnable putLeftFork,\n                            Runnable putRightFork) throws InterruptedException {\n        int leftFork = philosopher;\n        int rightFork = (philosopher + 1) % 5;\n\n        locks[leftFork].lock();\n        try {\n            while (!locks[rightFork].tryLock()) {\n                notBusy[leftFork].await();\n            }\n            pickLeftFork.run();\n\n            try {\n                pickRightFork.run();\n                eat.run();\n                putRightFork.run();\n            } finally {\n                locks[rightFork].unlock();\n            }\n            notBusy[rightFork].signalAll();\n\n            putLeftFork.run();\n        } finally {\n            locks[leftFork].unlock();\n        }\n        notBusy[leftFork].signalAll();\n    }\n}\n```\n    \n    The algorithm uses one mutex for each fork and a condition variable for each philosopher to manage the synchronization of accessing forks. When a philosopher starts to eat, they first lock the mutex of the left fork and indicate that the corresponding fork is busy. After that, they try to lock the mutex of the right fork. If they are able to lock the right mutex, they can eat. After eating, they release the mutex of the right fork and indicate that it is not busy. Finally, the mutex of the left fork is unlocked.\n\nTo avoid deadlocks, a philosopher will only proceed with eating if they can lock the mutex of the right fork while holding the mutex of the left fork. If they can't lock the right mutex, they will wait using a condition variable until the right mutex is available. After eating, the philosopher will signal to other philosophers that they have finished eating and the forks are available.\n\nThe main idea of this approach is to ensure that a philosopher is always able to acquire both forks without causing deadlocks or starving. By waiting on the condition variable until both forks are available, we prevent deadlocks and ensure fairness among the philosophers. This behavior is obtained by having each philosopher try to grab its left fork first and then its right fork, only eating once it has acquired both. This ensures that philosophers will not deadlock by all grabbing one fork and waiting for another.\n    ", "c++": "\n    ```cpp\n#include <mutex>\n#include <condition_variable>\n\nclass DiningPhilosophers {\n    std::mutex forks[5];\n    std::condition_variable not_busy[5];\n\npublic:\n    void wantsToEat(int philosopher,\n                    std::function<void()> pickLeftFork,\n                    std::function<void()> pickRightFork,\n                    std::function<void()> eat,\n                    std::function<void()> putLeftFork,\n                    std::function<void()> putRightFork) {\n        int left_fork = philosopher;\n        int right_fork = (philosopher + 1) % 5;\n\n        {\n            std::unique_lock<std::mutex> lock(forks[left_fork]);\n            not_busy[left_fork].wait(lock, [&] { return !forks[right_fork].try_lock(); });\n            pickLeftFork();\n\n            std::unique_lock<std::mutex> right_lock(forks[right_fork], std::adopt_lock);\n            pickRightFork();\n            eat();\n\n            putRightFork();\n            right_lock.unlock();\n            not_busy[right_fork].notify_all();\n        }\n\n        putLeftFork();\n        not_busy[left_fork].notify_all();\n    }\n};\n```\n    \n    The algorithm uses one mutex for each fork and a condition variable for each philosopher to manage the synchronization of accessing forks. When a philosopher starts to eat, they first lock the mutex of the left fork and indicate that the corresponding fork is busy. After that, they try to lock the mutex of the right fork. If they are able to lock the right mutex, they can eat. After eating, they release the mutex of the right fork and indicate that it is not busy. Finally, the mutex of the left fork is unlocked.\n\nTo avoid deadlocks, a philosopher will only proceed with eating if they can lock the mutex of the right fork while holding the mutex of the left fork. If they can't lock the right mutex, they will wait using a condition variable until the right mutex is available. After eating, the philosopher will signal to other philosophers that they have finished eating and the forks are available.\n\nThe main idea of this approach is to ensure that a philosopher is always able to acquire both forks without causing deadlocks or starving. By waiting on the condition variable until both forks are available, we prevent deadlocks and ensure fairness among the philosophers. This behavior is obtained by having each philosopher try to grab its left fork first and then its right fork, only eating once it has acquired both. This ensures that philosophers will not deadlock by all grabbing one fork and waiting for another.\n    ", "python": "\n    ```python\nimport threading\n\nclass DiningPhilosophers:\n    def __init__(self):\n        self.forks = [threading.Lock() for _ in range(5)]\n        self.not_busy = [threading.Condition(self.forks[i]) for i in range(5)]\n\n    def wantsToEat(self, philosopher: int, pickLeftFork: 'Callable[[], None]', pickRightFork: 'Callable[[], None]', eat: 'Callable[[], None]', putLeftFork: 'Callable[[], None]', putRightFork: 'Callable[[], None]') -> None:\n        left_fork = philosopher\n        right_fork = (philosopher + 1) % 5\n\n        with self.forks[left_fork]:\n            with self.not_busy[left_fork]:\n                while not self.forks[right_fork].acquire(blocking=False):\n                    self.not_busy[left_fork].wait()\n            pickLeftFork()\n\n            with self.forks[right_fork]:\n                pickRightFork()\n                eat()\n                putRightFork()\n                self.forks[right_fork].release()\n                with self.not_busy[right_fork]:\n                    self.not_busy[right_fork].notify_all()\n\n            putLeftFork()\n            self.not_busy[left_fork].notify_all()\n```\n    \n    The algorithm uses one mutex for each fork and a condition variable for each philosopher to manage the synchronization of accessing forks. When a philosopher starts to eat, they first lock the mutex of the left fork and indicate that the corresponding fork is busy. After that, they try to lock the mutex of the right fork. If they are able to lock the right mutex, they can eat. After eating, they release the mutex of the right fork and indicate that it is not busy. Finally, the mutex of the left fork is unlocked.\n\nTo avoid deadlocks, a philosopher will only proceed with eating if they can lock the mutex of the right fork while holding the mutex of the left fork. If they can't lock the right mutex, they will wait using a condition variable until the right mutex is available. After eating, the philosopher will signal to other philosophers that they have finished eating and the forks are available.\n\nThe main idea of this approach is to ensure that a philosopher is always able to acquire both forks without causing deadlocks or starving. By waiting on the condition variable until both forks are available, we prevent deadlocks and ensure fairness among the philosophers. This behavior is obtained by having each philosopher try to grab its left fork first and then its right fork, only eating once it has acquired both. This ensures that philosophers will not deadlock by all grabbing one fork and waiting for another.\n    ", "javascript": "\n    ```javascript\nclass DiningPhilosophers {\n    constructor() {\n        this.forks = Array.from({ length: 5 }, () => new Mutex());\n        this.notBusy = Array.from({ length: 5 }, (_, i) => new ConditionVariable(this.forks[i]));\n    }\n\n    async wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork) {\n        const leftFork = philosopher;\n        const rightFork = (philosopher + 1) % 5;\n\n        await this.forks[leftFork].lock();\n        try {\n            await this.notBusy[leftFork].wait(async () => !(await this.forks[rightFork].tryLock()));\n            pickLeftFork();\n\n            try {\n                await this.forks[rightFork].lock();\n                pickRightFork();\n                eat();\n                putRightFork();\n                this.forks[rightFork].unlock();\n                this.notBusy[rightFork].signalAll();\n\n                putLeftFork();\n            } finally {\n                this.forks[leftFork].unlock();\n            }\n        } finally {\n            this.notBusy[leftFork].signalAll();\n        }\n    }\n}\n```\n    \n    The algorithm uses one mutex for each fork and a condition variable for each philosopher to manage the synchronization of accessing forks. When a philosopher starts to eat, they first lock the mutex of the left fork and indicate that the corresponding fork is busy. After that, they try to lock the mutex of the right fork. If they are able to lock the right mutex, they can eat. After eating, they release the mutex of the right fork and indicate that it is not busy. Finally, the mutex of the left fork is unlocked.\n\nTo avoid deadlocks, a philosopher will only proceed with eating if they can lock the mutex of the right fork while holding the mutex of the left fork. If they can't lock the right mutex, they will wait using a condition variable until the right mutex is available. After eating, the philosopher will signal to other philosophers that they have finished eating and the forks are available.\n\nThe main idea of this approach is to ensure that a philosopher is always able to acquire both forks without causing deadlocks or starving. By waiting on the condition variable until both forks are available, we prevent deadlocks and ensure fairness among the philosophers. This behavior is obtained by having each philosopher try to grab its left fork first and then its right fork, only eating once it has acquired both. This ensures that philosophers will not deadlock by all grabbing one fork and waiting for another.\n    "}
{"id": 1349, "slug": "maximum-students-taking-exam", "title": "Maximum Students Taking Exam", "difficulty": "Hard", "content": "Given a `m * n` matrix `seats` that represent seats distributions in a classroom. If a seat is broken, it is denoted by `'#'` character otherwise it is denoted by a `'.'` character.\n\nStudents can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting directly in front or behind him. Return the **maximum** number of students that can take the exam together without any cheating being possible..\n\nStudents must be placed in seats in good condition.\n\n**Example 1:**\n\n**Input:** seats = \\[\\[ \"# \", \". \", \"# \", \"# \", \". \", \"# \"\\],\n                \\[ \". \", \"# \", \"# \", \"# \", \"# \", \". \"\\],\n                \\[ \"# \", \". \", \"# \", \"# \", \". \", \"# \"\\]\\]\n**Output:** 4\n**Explanation:** Teacher can place 4 students in available seats so they don't cheat on the exam. \n\n**Example 2:**\n\n**Input:** seats = \\[\\[ \". \", \"# \"\\],\n                \\[ \"# \", \"# \"\\],\n                \\[ \"# \", \". \"\\],\n                \\[ \"# \", \"# \"\\],\n                \\[ \". \", \"# \"\\]\\]\n**Output:** 3\n**Explanation:** Place all students in available seats. \n\n**Example 3:**\n\n**Input:** seats = \\[\\[ \"# \", \". \", \"**.** \", \". \", \"# \"\\],\n                \\[ \"**.** \", \"# \", \"**.** \", \"# \", \"**.** \"\\],\n                \\[ \"**.** \", \". \", \"# \", \". \", \"**.** \"\\],\n                \\[ \"**.** \", \"# \", \"**.** \", \"# \", \"**.** \"\\],\n                \\[ \"# \", \". \", \"**.** \", \". \", \"# \"\\]\\]\n**Output:** 10\n**Explanation:** Place students in available seats in column 1, 3 and 5.\n\n**Constraints:**\n\n*   `seats` contains only characters `'.' and``'#'.`\n*   `m == seats.length`\n*   `n == seats[i].length`\n*   `1 <= m <= 8`\n*   `1 <= n <= 8`", "java": "\n    ```java\nclass Solution {\n    public boolean checkStraightLine(int[][] coordinates) {\n        int dx = coordinates[1][0] - coordinates[0][0];\n        int dy = coordinates[1][1] - coordinates[0][1];\n\n        for(int i = 2; i < coordinates.length; i++) {\n            int x = coordinates[i][0] - coordinates[0][0];\n            int y = coordinates[i][1] - coordinates[0][1];\n            if(dx * y != dy * x) return false;\n        }\n\n        return true;\n    }\n}\n```\n    \n    The algorithm checks if the given points make a straight line in the XY plane. It calculates the slope (delta y / delta x) between the first two points in the array, and then iterates through the rest of the points comparing their slopes against the calculated slope. This is done by checking if `(dx * y) == (dy * x)` for each point. If any point has a different slope, return false (meaning the points don't make a straight line). If all points have the same slope, return true (meaning the points make a straight line).\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool checkStraightLine(vector<vector<int>>& coordinates) {\n    int dx = coordinates[1][0] - coordinates[0][0];\n    int dy = coordinates[1][1] - coordinates[0][1];\n\n    for(int i = 2; i < coordinates.size(); ++i) {\n        int x = coordinates[i][0] - coordinates[0][0];\n        int y = coordinates[i][1] - coordinates[0][1];\n        if(dx * y != dy * x) return false;\n    }\n\n    return true;\n}\n```\n    \n    The algorithm checks if the given points make a straight line in the XY plane. It calculates the slope (delta y / delta x) between the first two points in the array, and then iterates through the rest of the points comparing their slopes against the calculated slope. This is done by checking if `(dx * y) == (dy * x)` for each point. If any point has a different slope, return false (meaning the points don't make a straight line). If all points have the same slope, return true (meaning the points make a straight line).\n    ", "python": "\n    ```python\nfrom typing import List\n\ndef checkStraightLine(coordinates: List[List[int]]) -> bool:\n    dx = coordinates[1][0] - coordinates[0][0]\n    dy = coordinates[1][1] - coordinates[0][1]\n\n    for x, y in coordinates[2:]:\n        if dx * (y - coordinates[0][1]) != dy * (x - coordinates[0][0]):\n            return False\n\n    return True\n```\n    \n    The algorithm checks if the given points make a straight line in the XY plane. It calculates the slope (delta y / delta x) between the first two points in the array, and then iterates through the rest of the points comparing their slopes against the calculated slope. This is done by checking if `(dx * y) == (dy * x)` for each point. If any point has a different slope, return false (meaning the points don't make a straight line). If all points have the same slope, return true (meaning the points make a straight line).\n    ", "javascript": "\n    ```javascript\nvar checkStraightLine = function(coordinates) {\n    let dx = coordinates[1][0] - coordinates[0][0];\n    let dy = coordinates[1][1] - coordinates[0][1];\n\n    for(let i = 2; i < coordinates.length; i++) {\n        let x = coordinates[i][0] - coordinates[0][0];\n        let y = coordinates[i][1] - coordinates[0][1];\n        if(dx * y != dy * x) return false;\n    }\n\n    return true;\n};\n```\n    \n    The algorithm checks if the given points make a straight line in the XY plane. It calculates the slope (delta y / delta x) between the first two points in the array, and then iterates through the rest of the points comparing their slopes against the calculated slope. This is done by checking if `(dx * y) == (dy * x)` for each point. If any point has a different slope, return false (meaning the points don't make a straight line). If all points have the same slope, return true (meaning the points make a straight line).\n    "}
{"id": 1359, "slug": "count-all-valid-pickup-and-delivery-options", "title": "Count All Valid Pickup and Delivery Options", "difficulty": "Hard", "content": "Given `n` orders, each order consist in pickup and delivery services.\n\nCount all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i).\n\nSince the answer may be too large, return it modulo 10^9 + 7.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** 1\n**Explanation:** Unique order (P1, D1), Delivery 1 always is after of Pickup 1.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 6\n**Explanation:** All possible orders: \n(P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).\nThis is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.\n\n**Example 3:**\n\n**Input:** n = 3\n**Output:** 90\n\n**Constraints:**\n\n*   `1 <= n <= 500`\n\nGiven 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such that : p\\[0\\] = start, p\\[i\\] and p\\[i+1\\] differ by only one bit for all 0 <= i < 2^n - 1.", "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic static ArrayList<Integer> circularPermutation(int n, int start) {\n    ArrayList<Integer> result = new ArrayList<>(1 << n);\n    for (int i = 0; i < (1 << n); ++i) {\n        result.add(start ^ (i ^ (i >> 1)));\n    }\n    return result;\n}\n```\n\n    \n    The algorithm is based on the Gray Code sequence generation, which guarantees only one bit difference between consecutive elements.\n\n1. Initialize a list or an array called result with the size of 2^n.\n2. Iterate through the range 0 to 2^n - 1.\n3. For each i in the range, calculate the Gray Code with the formula `i ^ (i >> 1)`.\n4. XOR the Gray Code with the given start value and store it in the result array.\n5. Return the result array.\n\nThis algorithm generates a sequence that fulfills the given requirements of having a one-bit difference between consecutive elements and it starts with the provided start value.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> circularPermutation(int n, int start) {\n    std::vector<int> result(1 << n);\n    for (int i = 0; i < (1 << n); ++i) {\n        result[i] = start ^ (i ^ (i >> 1));\n    }\n    return result;\n}\n```\n\n    \n    The algorithm is based on the Gray Code sequence generation, which guarantees only one bit difference between consecutive elements.\n\n1. Initialize a list or an array called result with the size of 2^n.\n2. Iterate through the range 0 to 2^n - 1.\n3. For each i in the range, calculate the Gray Code with the formula `i ^ (i >> 1)`.\n4. XOR the Gray Code with the given start value and store it in the result array.\n5. Return the result array.\n\nThis algorithm generates a sequence that fulfills the given requirements of having a one-bit difference between consecutive elements and it starts with the provided start value.\n    ", "python": "\n    ```python\ndef circular_permutation(n, start):\n    result = [start ^ (i ^ (i >> 1)) for i in range(1 << n)]\n    return result\n```\n\n    \n    The algorithm is based on the Gray Code sequence generation, which guarantees only one bit difference between consecutive elements.\n\n1. Initialize a list or an array called result with the size of 2^n.\n2. Iterate through the range 0 to 2^n - 1.\n3. For each i in the range, calculate the Gray Code with the formula `i ^ (i >> 1)`.\n4. XOR the Gray Code with the given start value and store it in the result array.\n5. Return the result array.\n\nThis algorithm generates a sequence that fulfills the given requirements of having a one-bit difference between consecutive elements and it starts with the provided start value.\n    ", "javascript": "\n    ```javascript\nfunction circularPermutation(n, start) {\n    let result = new Array(1 << n);\n    for (let i = 0; i < (1 << n); ++i) {\n        result[i] = start ^ (i ^ (i >> 1));\n    }\n    return result;\n}\n```\n\n    \n    The algorithm is based on the Gray Code sequence generation, which guarantees only one bit difference between consecutive elements.\n\n1. Initialize a list or an array called result with the size of 2^n.\n2. Iterate through the range 0 to 2^n - 1.\n3. For each i in the range, calculate the Gray Code with the formula `i ^ (i >> 1)`.\n4. XOR the Gray Code with the given start value and store it in the result array.\n5. Return the result array.\n\nThis algorithm generates a sequence that fulfills the given requirements of having a one-bit difference between consecutive elements and it starts with the provided start value.\n    "}
{"id": 1372, "slug": "longest-zigzag-path-in-a-binary-tree", "title": "Longest ZigZag Path in a Binary Tree", "difficulty": "Medium", "content": "You are given the `root` of a binary tree.\n\nA ZigZag path for a binary tree is defined as follow:\n\n*   Choose **any** node in the binary tree and a direction (right or left).\n*   If the current direction is right, move to the right child of the current node; otherwise, move to the left child.\n*   Change the direction from right to left or from left to right.\n*   Repeat the second and third steps until you can't move in the tree.\n\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\n\nReturn _the longest **ZigZag** path contained in that tree_.\n\n**Example 1:**\n\n**Input:** root = \\[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1\\]\n**Output:** 3\n**Explanation:** Longest ZigZag path in blue nodes (right -> left -> right).\n\n**Example 2:**\n\n**Input:** root = \\[1,1,1,null,1,null,null,1,1,null,1\\]\n**Output:** 4\n**Explanation:** Longest ZigZag path in blue nodes (left -> right -> left -> right).\n\n**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** 0\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 5 * 104]`.\n*   `1 <= Node.val <= 100`", "java": "\n    ```java\npublic class Main {\n    public boolean isGoodArray(int[] nums) {\n        int gcd = nums[0];\n        for (int num : nums) {\n            gcd = gcd(gcd, num);\n            if (gcd == 1) {\n                return true;\n            }\n        }\n        return gcd == 1;\n    }\n    private int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}\n```\n\n    \n    The algorithm checks if it is possible to get a sum of 1 from the given array by using any possible subset and multiplicand. It can be achieved by finding out the greatest common divisor (GCD) among the array elements. If the GCD is 1, it means the array is good, and we return true; otherwise, we return false. For efficiency, we use __gcd() function and std namespace in C++, reduce() and gcd() function in Python, and user-defined gcd() function (recursive) in Java and JavaScript. The algorithm's complexity is O(n), where n is the number of elements in the given array.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool isGoodArray(vector<int>& nums) {\n    int gcd = nums[0];\n    for (int num : nums) {\n        gcd = __gcd(gcd, num);\n        if (gcd == 1) {\n            return true;\n        }\n    }\n    return gcd == 1;\n}\n```\n\n    \n    The algorithm checks if it is possible to get a sum of 1 from the given array by using any possible subset and multiplicand. It can be achieved by finding out the greatest common divisor (GCD) among the array elements. If the GCD is 1, it means the array is good, and we return true; otherwise, we return false. For efficiency, we use __gcd() function and std namespace in C++, reduce() and gcd() function in Python, and user-defined gcd() function (recursive) in Java and JavaScript. The algorithm's complexity is O(n), where n is the number of elements in the given array.\n    ", "python": "\n    ```python\nfrom math import gcd\nfrom functools import reduce\n\ndef is_good_array(nums):\n    gcd_value = reduce(gcd, nums)\n    return gcd_value == 1\n```\n\n    \n    The algorithm checks if it is possible to get a sum of 1 from the given array by using any possible subset and multiplicand. It can be achieved by finding out the greatest common divisor (GCD) among the array elements. If the GCD is 1, it means the array is good, and we return true; otherwise, we return false. For efficiency, we use __gcd() function and std namespace in C++, reduce() and gcd() function in Python, and user-defined gcd() function (recursive) in Java and JavaScript. The algorithm's complexity is O(n), where n is the number of elements in the given array.\n    ", "javascript": "\n    ```javascript\nfunction isGoodArray(nums) {\n    let gcd = (a, b) => b === 0 ? a : gcd(b, a % b);\n    let gcdValue = nums.reduce((a, b) => gcd(a, b));\n    return gcdValue === 1;\n}\n```\n\n    \n    The algorithm checks if it is possible to get a sum of 1 from the given array by using any possible subset and multiplicand. It can be achieved by finding out the greatest common divisor (GCD) among the array elements. If the GCD is 1, it means the array is good, and we return true; otherwise, we return false. For efficiency, we use __gcd() function and std namespace in C++, reduce() and gcd() function in Python, and user-defined gcd() function (recursive) in Java and JavaScript. The algorithm's complexity is O(n), where n is the number of elements in the given array.\n    "}
{"id": 1388, "slug": "pizza-with-3n-slices", "title": "Pizza With 3n Slices", "difficulty": "Hard", "content": "There is a pizza with `3n` slices of varying size, you and your friends will take slices of pizza as follows:\n\n*   You will pick **any** pizza slice.\n*   Your friend Alice will pick the next slice in the anti-clockwise direction of your pick.\n*   Your friend Bob will pick the next slice in the clockwise direction of your pick.\n*   Repeat until there are no more slices of pizzas.\n\nGiven an integer array `slices` that represent the sizes of the pizza slices in a clockwise direction, return _the maximum possible sum of slice sizes that you can pick_.\n\n**Example 1:**\n\n**Input:** slices = \\[1,2,3,4,5,6\\]\n**Output:** 10\n**Explanation:** Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.\n\n**Example 2:**\n\n**Input:** slices = \\[8,9,8,6,1,1\\]\n**Output:** 16\n**Explanation:** Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.\n\n**Constraints:**\n\n*   `3 * n == slices.length`\n*   `1 <= slices.length <= 500`\n*   `1 <= slices[i] <= 1000`", "java": "\n    ```java\npublic int maxSumDivThree(int[] nums) {\n    int[] dp = new int[3];\n    for (int num : nums) {\n        int[] temp = Arrays.copyOf(dp, 3);\n        for (int s : temp) {\n            dp[(s + num) % 3] = Math.max(dp[(s + num) % 3], s + num);\n        }\n    }\n    return dp[0];\n}\n```\n    \n    1. Initialize a dynamic programming array `dp` having 3 elements with all 0's. This will store the maximum sum for % 3 == 0, % 3 == 1, and % 3 == 2.\n2. Iterate through the input array `nums`.\n3. For each number, create a temporary copy of the current `dp` state, as we want to make changes to the original `dp` array based on the original state.\n4. For each number, iterate through the temporary copy of `dp` (temp). Calculate `(s + num) % 3` for the current number and the sum, and update the respective position in `dp` array with the maximum sum.\n5. The answer will be stored at `dp[0]`, which is the maximum sum that is divisible by three.\n    ", "c++": "\n    ```cpp\nint maxSumDivThree(vector<int>& nums) {\n    vector<int> dp(3, 0);\n    for (int num : nums) {\n        vector<int> temp(dp);\n        for (int s : temp) {\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num);\n        }\n    }\n    return dp[0];\n}\n```\n    \n    1. Initialize a dynamic programming array `dp` having 3 elements with all 0's. This will store the maximum sum for % 3 == 0, % 3 == 1, and % 3 == 2.\n2. Iterate through the input array `nums`.\n3. For each number, create a temporary copy of the current `dp` state, as we want to make changes to the original `dp` array based on the original state.\n4. For each number, iterate through the temporary copy of `dp` (temp). Calculate `(s + num) % 3` for the current number and the sum, and update the respective position in `dp` array with the maximum sum.\n5. The answer will be stored at `dp[0]`, which is the maximum sum that is divisible by three.\n    ", "python": "\n    ```python\ndef maxSumDivThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        temp = dp[:]\n        for s in temp:\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num)\n    return dp[0]\n```\n    \n    1. Initialize a dynamic programming array `dp` having 3 elements with all 0's. This will store the maximum sum for % 3 == 0, % 3 == 1, and % 3 == 2.\n2. Iterate through the input array `nums`.\n3. For each number, create a temporary copy of the current `dp` state, as we want to make changes to the original `dp` array based on the original state.\n4. For each number, iterate through the temporary copy of `dp` (temp). Calculate `(s + num) % 3` for the current number and the sum, and update the respective position in `dp` array with the maximum sum.\n5. The answer will be stored at `dp[0]`, which is the maximum sum that is divisible by three.\n    ", "javascript": "\n    ```javascript\nfunction maxSumDivThree(nums) {\n    let dp = [0, 0, 0];\n    for (let num of nums) {\n        let temp = [...dp];\n        for (let s of temp) {\n            dp[(s + num) % 3] = Math.max(dp[(s + num) % 3], s + num);\n        }\n    }\n    return dp[0];\n}\n```\n    \n    1. Initialize a dynamic programming array `dp` having 3 elements with all 0's. This will store the maximum sum for % 3 == 0, % 3 == 1, and % 3 == 2.\n2. Iterate through the input array `nums`.\n3. For each number, create a temporary copy of the current `dp` state, as we want to make changes to the original `dp` array based on the original state.\n4. For each number, iterate through the temporary copy of `dp` (temp). Calculate `(s + num) % 3` for the current number and the sum, and update the respective position in `dp` array with the maximum sum.\n5. The answer will be stored at `dp[0]`, which is the maximum sum that is divisible by three.\n    "}
{"id": 1395, "slug": "count-number-of-teams", "title": "Count Number of Teams", "difficulty": "Medium", "content": "There are `n` soldiers standing in a line. Each soldier is assigned a **unique** `rating` value.\n\nYou have to form a team of 3 soldiers amongst them under the following rules:\n\n*   Choose 3 soldiers with index (`i`, `j`, `k`) with rating (`rating[i]`, `rating[j]`, `rating[k]`).\n*   A team is valid if: (`rating[i] < rating[j] < rating[k]`) or (`rating[i] > rating[j] > rating[k]`) where (`0 <= i < j < k < n`).\n\nReturn the number of teams you can form given the conditions. (soldiers can be part of multiple teams).\n\n**Example 1:**\n\n**Input:** rating = \\[2,5,3,4,1\\]\n**Output:** 3\n**Explanation:** We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). \n\n**Example 2:**\n\n**Input:** rating = \\[2,1,3\\]\n**Output:** 0\n**Explanation:** We can't form any team given the conditions.\n\n**Example 3:**\n\n**Input:** rating = \\[1,2,3,4\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `n == rating.length`\n*   `3 <= n <= 1000`\n*   `1 <= rating[i] <= 105`\n*   All the integers in `rating` are **unique**.\n\nIn one second, you can either: - Move vertically by one unit, - Move horizontally by one unit, or - Move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in one second). You have to visit the points in the same order as they appear in the array. You are allowed to pass through points, but they do not count as visited unless you stop on them.", "java": "\n    ```java\npublic int minTimeToVisitAllPoints(int[][] points) {\n    int time = 0;\n    for(int i = 1; i < points.length; ++i) {\n        int dx = Math.abs(points[i][0] - points[i-1][0]);\n        int dy = Math.abs(points[i][1] - points[i-1][1]);\n        time += Math.max(dx, dy);\n    }\n    return time;\n}\n```\n\n    \n    The algorithm calculates the minimum time to visit all the points by iterating through the given points, and for each pair of consecutive points, finding the difference in their x and y coordinates (dx and dy). Since moving diagonally is the fastest way to cover a unit of distance vertically and horizontally, the time needed to move between two points is the maximum of dx and dy.\n\nIn each language, the code follows the same logic: iterate through the points, calculate the difference in x and y coordinates, and add the maximum of those differences to the total time. The primary differences are in syntax and the specific functions used to calculate the absolute value and maximum value.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <cmath>\n\nint minTimeToVisitAllPoints(std::vector<std::vector<int>>& points) {\n    int time = 0;\n    for(int i = 1; i < points.size(); ++i) {\n        int dx = abs(points[i][0] - points[i-1][0]);\n        int dy = abs(points[i][1] - points[i-1][1]);\n        time += std::max(dx, dy);\n    }\n    return time;\n}\n```\n\n    \n    The algorithm calculates the minimum time to visit all the points by iterating through the given points, and for each pair of consecutive points, finding the difference in their x and y coordinates (dx and dy). Since moving diagonally is the fastest way to cover a unit of distance vertically and horizontally, the time needed to move between two points is the maximum of dx and dy.\n\nIn each language, the code follows the same logic: iterate through the points, calculate the difference in x and y coordinates, and add the maximum of those differences to the total time. The primary differences are in syntax and the specific functions used to calculate the absolute value and maximum value.\n    ", "python": "\n    ```python\ndef minTimeToVisitAllPoints(points: List[List[int]]) -> int:\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i-1][0])\n        dy = abs(points[i][1] - points[i-1][1])\n        time += max(dx, dy)\n    return time\n```\n\n    \n    The algorithm calculates the minimum time to visit all the points by iterating through the given points, and for each pair of consecutive points, finding the difference in their x and y coordinates (dx and dy). Since moving diagonally is the fastest way to cover a unit of distance vertically and horizontally, the time needed to move between two points is the maximum of dx and dy.\n\nIn each language, the code follows the same logic: iterate through the points, calculate the difference in x and y coordinates, and add the maximum of those differences to the total time. The primary differences are in syntax and the specific functions used to calculate the absolute value and maximum value.\n    ", "javascript": "\n    ```javascript\nfunction minTimeToVisitAllPoints(points) {\n    let time = 0;\n    for(let i = 1; i < points.length; ++i) {\n        let dx = Math.abs(points[i][0] - points[i-1][0]);\n        let dy = Math.abs(points[i][1] - points[i-1][1]);\n        time += Math.max(dx, dy);\n    }\n    return time;\n}\n```\n\n    \n    The algorithm calculates the minimum time to visit all the points by iterating through the given points, and for each pair of consecutive points, finding the difference in their x and y coordinates (dx and dy). Since moving diagonally is the fastest way to cover a unit of distance vertically and horizontally, the time needed to move between two points is the maximum of dx and dy.\n\nIn each language, the code follows the same logic: iterate through the points, calculate the difference in x and y coordinates, and add the maximum of those differences to the total time. The primary differences are in syntax and the specific functions used to calculate the absolute value and maximum value.\n    "}
{"id": 1397, "slug": "find-all-good-strings", "title": "Find All Good Strings", "difficulty": "Hard", "content": "Given the strings `s1` and `s2` of size `n` and the string `evil`, return _the number of **good** strings_.\n\nA **good** string has size `n`, it is alphabetically greater than or equal to `s1`, it is alphabetically smaller than or equal to `s2`, and it does not contain the string `evil` as a substring. Since the answer can be a huge number, return this **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 2, s1 =  \"aa \", s2 =  \"da \", evil =  \"b \"\n**Output:** 51 \n**Explanation:** There are 25 good strings starting with 'a':  \"aa \", \"ac \", \"ad \",..., \"az \". Then there are 25 good strings starting with 'c':  \"ca \", \"cc \", \"cd \",..., \"cz \" and finally there is one good string starting with 'd':  \"da \". \n\n**Example 2:**\n\n**Input:** n = 8, s1 =  \"leetcode \", s2 =  \"leetgoes \", evil =  \"leet \"\n**Output:** 0 \n**Explanation:** All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix  \"leet \", therefore, there is not any good string.\n\n**Example 3:**\n\n**Input:** n = 2, s1 =  \"gx \", s2 =  \"gz \", evil =  \"x \"\n**Output:** 2\n\n**Constraints:**\n\n*   `s1.length == n`\n*   `s2.length == n`\n*   `s1 <= s2`\n*   `1 <= n <= 500`\n*   `1 <= evil.length <= 50`\n*   All strings consist of lowercase English letters.", "java": "\n    ```java\nimport java.util.*;\n\npublic List<List<String>> suggestedProducts(String[] products, String searchWord) {\n    Arrays.sort(products);\n    \n    List<List<String>> result = new ArrayList<>();\n    String currentPrefix = \"\";\n    \n    for (char letter : searchWord.toCharArray()) {\n        currentPrefix += letter;\n        \n        int index = Arrays.binarySearch(products, currentPrefix);\n        if (index < 0) {\n            index = -index - 1;\n        }\n        \n        List<String> suggestions = new ArrayList<>();\n        for (int i = 0; i < 3 && index < products.length && products[index].startsWith(currentPrefix); i++) {\n            suggestions.add(products[index]);\n            index++;\n        }\n        \n        result.add(suggestions);\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n1. Sort the `products` lexicographically.\n2. Initialize an empty result list and an empty `currentPrefix` string.\n3. Iterate through each letter of `searchWord`, appending the letter to `currentPrefix`.\n4. Use a binary search to find the starting position of the suggested products with the common prefix `currentPrefix`.\n5. Initialize an empty suggestions list.\n6. Iterate from the starting position and add at most 3 product names to the suggestions list that have the common prefix with `currentPrefix`. Stop adding product names either when there are no more products with the common prefix or 3 suggestions are added.\n7. Add the suggestions list to the result list.\n8. Return the result list after iterating through all the characters of `searchWord`.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::vector<std::string>> suggestedProducts(std::vector<std::string>& products, std::string searchWord) {\n    std::sort(products.begin(), products.end());\n    \n    std::vector<std::vector<std::string>> result;\n    std::string currentPrefix;\n    \n    for (char letter : searchWord) {\n        currentPrefix += letter;\n        \n        auto it = std::lower_bound(products.begin(), products.end(), currentPrefix);\n        std::vector<std::string> suggestions;\n        \n        for (int i = 0; i < 3 && it != products.end() && it->substr(0, currentPrefix.size()) == currentPrefix; ++i) {\n            suggestions.push_back(*it);\n            ++it;\n        }\n        \n        result.push_back(suggestions);\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n1. Sort the `products` lexicographically.\n2. Initialize an empty result list and an empty `currentPrefix` string.\n3. Iterate through each letter of `searchWord`, appending the letter to `currentPrefix`.\n4. Use a binary search to find the starting position of the suggested products with the common prefix `currentPrefix`.\n5. Initialize an empty suggestions list.\n6. Iterate from the starting position and add at most 3 product names to the suggestions list that have the common prefix with `currentPrefix`. Stop adding product names either when there are no more products with the common prefix or 3 suggestions are added.\n7. Add the suggestions list to the result list.\n8. Return the result list after iterating through all the characters of `searchWord`.\n    ", "python": "\n    ```python\nfrom bisect import bisect_left\n\ndef suggestedProducts(products, searchWord):\n    products.sort()\n    result = []\n    current_prefix = \"\"\n    \n    for letter in searchWord:\n        current_prefix += letter\n        index = bisect_left(products, current_prefix)\n        suggestions = []\n        \n        for i in range(3):\n            if index < len(products) and products[index].startswith(current_prefix):\n                suggestions.append(products[index])\n                index += 1\n            else:\n                break\n        \n        result.append(suggestions)\n    \n    return result\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n1. Sort the `products` lexicographically.\n2. Initialize an empty result list and an empty `currentPrefix` string.\n3. Iterate through each letter of `searchWord`, appending the letter to `currentPrefix`.\n4. Use a binary search to find the starting position of the suggested products with the common prefix `currentPrefix`.\n5. Initialize an empty suggestions list.\n6. Iterate from the starting position and add at most 3 product names to the suggestions list that have the common prefix with `currentPrefix`. Stop adding product names either when there are no more products with the common prefix or 3 suggestions are added.\n7. Add the suggestions list to the result list.\n8. Return the result list after iterating through all the characters of `searchWord`.\n    ", "javascript": "\n    ```javascript\nfunction suggestedProducts(products, searchWord) {\n    products.sort();\n    \n    let result = [];\n    let currentPrefix = \"\";\n    \n    for (let letter of searchWord) {\n        currentPrefix += letter;\n        \n        let index = products.findIndex(product => product.startsWith(currentPrefix));\n        \n        let suggestions = [];\n        for (let i = 0; i < 3 && index < products.length && products[index].startsWith(currentPrefix); i++) {\n            suggestions.push(products[index]);\n            index++;\n        }\n        \n        result.push(suggestions);\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n1. Sort the `products` lexicographically.\n2. Initialize an empty result list and an empty `currentPrefix` string.\n3. Iterate through each letter of `searchWord`, appending the letter to `currentPrefix`.\n4. Use a binary search to find the starting position of the suggested products with the common prefix `currentPrefix`.\n5. Initialize an empty suggestions list.\n6. Iterate from the starting position and add at most 3 product names to the suggestions list that have the common prefix with `currentPrefix`. Stop adding product names either when there are no more products with the common prefix or 3 suggestions are added.\n7. Add the suggestions list to the result list.\n8. Return the result list after iterating through all the characters of `searchWord`.\n    "}
{"id": 1402, "slug": "reducing-dishes", "title": "Reducing Dishes", "difficulty": "Hard", "content": "A chef has collected data on the `satisfaction` level of his `n` dishes. Chef can cook any dish in 1 unit of time.\n\n**Like-time coefficient** of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. `time[i] * satisfaction[i]`.\n\nReturn _the maximum sum of **like-time coefficient** that the chef can obtain after dishes preparation_.\n\nDishes can be prepared in **any** order and the chef can discard some dishes to get this maximum value.\n\n**Example 1:**\n\n**Input:** satisfaction = \\[-1,-8,0,5,-9\\]\n**Output:** 14\n**Explanation:** After Removing the second and last dish, the maximum total **like-time coefficient** will be equal to (-1\\*1 + 0\\*2 + 5\\*3 = 14).\nEach dish is prepared in one unit of time.\n\n**Example 2:**\n\n**Input:** satisfaction = \\[4,3,2\\]\n**Output:** 20\n**Explanation:** Dishes can be prepared in any order, (2\\*1 + 3\\*2 + 4\\*3 = 20)\n\n**Example 3:**\n\n**Input:** satisfaction = \\[-1,-4,-5\\]\n**Output:** 0\n**Explanation:** People do not like the dishes. No dish is prepared.\n\n**Constraints:**\n\n*   `n == satisfaction.length`\n*   `1 <= n <= 500`\n*   `-1000 <= satisfaction[i] <= 1000`", "java": "\n    ```java\npublic int countSquares(int[][] matrix) {\n    int m = matrix.length, n = matrix[0].length, ans = 0;\n    int[][] dp = new int[m][n];\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i == 0 || j == 0) dp[i][j] = matrix[i][j];\n            else if(matrix[i][j] == 1) dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\n            ans += dp[i][j];\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a dynamic programming approach. For each cell of the input matrix, we create a `dp` matrix that will store the size of the square that ends at the current cell `[i, j]`. If the current cell contains 1, we need to check the values of the neighbors, i.e., cells `[i-1, j-1]`, `[i-1, j]`, and `[i, j-1]`. To form a square of size `k`, all three neighboring cells must have squares of size `k-1`. Thus, we set the current cell in `dp` to the minimum of the neighboring cells plus one (`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`).\n\nFor each cell, we then add its value in the `dp` matrix to the result (`ans += dp[i][j]`). Finally, we return the total number of squares found.\n    ", "c++": "\n    ```cpp\nint countSquares(vector<vector<int>>& matrix) {\n    int m = matrix.size(), n = matrix[0].size(), ans = 0;\n    vector<vector<int>> dp(m, vector<int>(n, 0));\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i == 0 || j == 0) dp[i][j] = matrix[i][j];\n            else if(matrix[i][j]) dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;\n            ans += dp[i][j];\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a dynamic programming approach. For each cell of the input matrix, we create a `dp` matrix that will store the size of the square that ends at the current cell `[i, j]`. If the current cell contains 1, we need to check the values of the neighbors, i.e., cells `[i-1, j-1]`, `[i-1, j]`, and `[i, j-1]`. To form a square of size `k`, all three neighboring cells must have squares of size `k-1`. Thus, we set the current cell in `dp` to the minimum of the neighboring cells plus one (`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`).\n\nFor each cell, we then add its value in the `dp` matrix to the result (`ans += dp[i][j]`). Finally, we return the total number of squares found.\n    ", "python": "\n    ```python\ndef countSquares(matrix: List[List[int]]) -> int:\n    m, n, ans = len(matrix), len(matrix[0]), 0\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = matrix[i][j]\n            elif matrix[i][j]:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n            ans += dp[i][j]\n    return ans\n```\n    \n    The algorithm uses a dynamic programming approach. For each cell of the input matrix, we create a `dp` matrix that will store the size of the square that ends at the current cell `[i, j]`. If the current cell contains 1, we need to check the values of the neighbors, i.e., cells `[i-1, j-1]`, `[i-1, j]`, and `[i, j-1]`. To form a square of size `k`, all three neighboring cells must have squares of size `k-1`. Thus, we set the current cell in `dp` to the minimum of the neighboring cells plus one (`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`).\n\nFor each cell, we then add its value in the `dp` matrix to the result (`ans += dp[i][j]`). Finally, we return the total number of squares found.\n    ", "javascript": "\n    ```javascript\nfunction countSquares(matrix) {\n    const m = matrix.length, n = matrix[0].length;\n    let ans = 0, dp = Array.from({length: m}, () => Array(n));\n    for(let i = 0; i < m; i++) {\n        for(let j = 0; j < n; j++) {\n            if(i === 0 || j === 0) dp[i][j] = matrix[i][j];\n            else if(matrix[i][j]) dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;\n            ans += dp[i][j];\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a dynamic programming approach. For each cell of the input matrix, we create a `dp` matrix that will store the size of the square that ends at the current cell `[i, j]`. If the current cell contains 1, we need to check the values of the neighbors, i.e., cells `[i-1, j-1]`, `[i-1, j]`, and `[i, j-1]`. To form a square of size `k`, all three neighboring cells must have squares of size `k-1`. Thus, we set the current cell in `dp` to the minimum of the neighboring cells plus one (`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`).\n\nFor each cell, we then add its value in the `dp` matrix to the result (`ans += dp[i][j]`). Finally, we return the total number of squares found.\n    "}
{"id": 1411, "slug": "number-of-ways-to-paint-n-3-grid", "title": "Number of Ways to Paint N \u00d7 3 Grid", "difficulty": "Hard", "content": "You have a `grid` of size `n x 3` and you want to paint each cell of the grid with exactly one of the three colors: **Red**, **Yellow,** or **Green** while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).\n\nGiven `n` the number of rows of the grid, return _the number of ways_ you can paint this `grid`. As the answer may grow large, the answer **must be** computed modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** 12\n**Explanation:** There are 12 possible way to paint the grid as shown.\n\n**Example 2:**\n\n**Input:** n = 5000\n**Output:** 30228214\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `1 <= n <= 5000`", "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic int getDecimalValue(ListNode head) {\n    int num = 0;\n    while (head != null) {\n        num = (num << 1) | head.val;\n        head = head.next;\n    }\n    return num;\n}\n```\n    \n    The algorithm iterates through the singly-linked list, starting at the head node. The binary number represented by the linked list is constructed by shifting the current value of `num` one bit to the left and performing a bitwise OR operation with the value of the current node. This process continues until the end of the linked list is reached. After the last node, `num` contains the decimal representation of the binary number, so the function returns it.\n    ", "c++": "\n    ```cpp\nclass ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nint getDecimalValue(ListNode* head) {\n    int num = 0;\n    while (head) {\n        num = (num << 1) | head->val;\n        head = head->next;\n    }\n    return num;\n}\n```\n    \n    The algorithm iterates through the singly-linked list, starting at the head node. The binary number represented by the linked list is constructed by shifting the current value of `num` one bit to the left and performing a bitwise OR operation with the value of the current node. This process continues until the end of the linked list is reached. After the last node, `num` contains the decimal representation of the binary number, so the function returns it.\n    ", "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef getDecimalValue(head: ListNode) -> int:\n    num = 0\n    while head:\n        num = (num << 1) | head.val\n        head = head.next\n    return num\n```\n    \n    The algorithm iterates through the singly-linked list, starting at the head node. The binary number represented by the linked list is constructed by shifting the current value of `num` one bit to the left and performing a bitwise OR operation with the value of the current node. This process continues until the end of the linked list is reached. After the last node, `num` contains the decimal representation of the binary number, so the function returns it.\n    ", "javascript": "\n    ```javascript\nclass ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction getDecimalValue(head) {\n    let num = 0;\n    while (head) {\n        num = (num << 1) | head.val;\n        head = head.next;\n    }\n    return num;\n}\n```\n    \n    The algorithm iterates through the singly-linked list, starting at the head node. The binary number represented by the linked list is constructed by shifting the current value of `num` one bit to the left and performing a bitwise OR operation with the value of the current node. This process continues until the end of the linked list is reached. After the last node, `num` contains the decimal representation of the binary number, so the function returns it.\n    "}
{"id": 1434, "slug": "number-of-ways-to-wear-different-hats-to-each-other", "title": "Number of Ways to Wear Different Hats to Each Other", "difficulty": "Hard", "content": "There are `n` people and `40` types of hats labeled from `1` to `40`.\n\nGiven a 2D integer array `hats`, where `hats[i]` is a list of all hats preferred by the `ith` person.\n\nReturn _the number of ways that the `n` people wear different hats to each other_.\n\nSince the answer may be too large, return it modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** hats = \\[\\[3,4\\],\\[4,5\\],\\[5\\]\\]\n**Output:** 1\n**Explanation:** There is only one way to choose hats given the conditions. \nFirst person choose hat 3, Second person choose hat 4 and last one hat 5.\n\n**Example 2:**\n\n**Input:** hats = \\[\\[3,5,1\\],\\[3,5\\]\\]\n**Output:** 4\n**Explanation:** There are 4 ways to choose hats:\n(3,5), (5,3), (1,3) and (1,5)\n\n**Example 3:**\n\n**Input:** hats = \\[\\[1,2,3,4\\],\\[1,2,3,4\\],\\[1,2,3,4\\],\\[1,2,3,4\\]\\]\n**Output:** 24\n**Explanation:** Each person can choose hats labeled from 1 to 4.\nNumber of Permutations of (1,2,3,4) = 24.\n\n**Constraints:**\n\n*   `n == hats.length`\n*   `1 <= n <= 10`\n*   `1 <= hats[i].length <= 40`\n*   `1 <= hats[i][j] <= 40`\n*   `hats[i]` contains a list of **unique** integers.", "java": "\n    ```java\npublic class Solution {\n    public String freqAlphabets(String s) {\n        StringBuilder result = new StringBuilder();\n        int i = 0;\n        while (i < s.length()) {\n            if (i + 2 < s.length() && s.charAt(i + 2) == '#') {\n                result.append((char) ('a' + (s.charAt(i) - '0') * 10 + (s.charAt(i + 1) - '0') - 10));\n                i += 3;\n            } else {\n                result.append((char) ('a' + s.charAt(i) - '1'));\n                i++;\n            }\n        }\n        return result.toString();\n    }\n}\n```\n    \n    The algorithm iterates through the given input string `s`. When it encounters a '#' symbol, it means the 2 characters before the '#' form a two-digit number that maps to a character. We take that 2-digit number, convert it to an English lowercase character using ASCII by adding the number to the ASCII code of 'a', and append the character to the result string. If there is no '#' symbol, we simply consider the single-digit number and map it to a character. Finally, we return the mapped string.\n    ", "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring freqAlphabets(string s) {\n    string result = \"\";\n    for (int i = 0; i < s.length(); i++) {\n        if (i + 2 < s.length() && s[i + 2] == '#') {\n            result += ('a' + (s[i] - '0') * 10 + (s[i + 1] - '0') - 10);\n            i += 2;\n        } else {\n            result += ('a' + s[i] - '1');\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the given input string `s`. When it encounters a '#' symbol, it means the 2 characters before the '#' form a two-digit number that maps to a character. We take that 2-digit number, convert it to an English lowercase character using ASCII by adding the number to the ASCII code of 'a', and append the character to the result string. If there is no '#' symbol, we simply consider the single-digit number and map it to a character. Finally, we return the mapped string.\n    ", "python": "\n    ```python\ndef freqAlphabets(s):\n    result = []\n    i = 0\n    while i < len(s):\n        if i + 2 < len(s) and s[i + 2] == '#':\n            result.append(chr(ord('a') + int(s[i:i + 2]) - 1))\n            i += 3\n        else:\n            result.append(chr(ord('a') + int(s[i]) - 1))\n            i += 1\n    return ''.join(result)\n```\n    \n    The algorithm iterates through the given input string `s`. When it encounters a '#' symbol, it means the 2 characters before the '#' form a two-digit number that maps to a character. We take that 2-digit number, convert it to an English lowercase character using ASCII by adding the number to the ASCII code of 'a', and append the character to the result string. If there is no '#' symbol, we simply consider the single-digit number and map it to a character. Finally, we return the mapped string.\n    ", "javascript": "\n    ```javascript\nfunction freqAlphabets(s) {\n    let result = [];\n    for (let i = 0; i < s.length;) {\n        if (i + 2 < s.length && s[i + 2] === \"#\") {\n            result.push(String.fromCharCode(\"a\".charCodeAt(0) + parseInt(s.substring(i, i + 2)) - 1));\n            i += 3;\n        } else {\n            result.push(String.fromCharCode(\"a\".charCodeAt(0) + parseInt(s[i]) - 1));\n            i++;\n        }\n    }\n    return result.join('');\n}\n```\n    \n    The algorithm iterates through the given input string `s`. When it encounters a '#' symbol, it means the 2 characters before the '#' form a two-digit number that maps to a character. We take that 2-digit number, convert it to an English lowercase character using ASCII by adding the number to the ASCII code of 'a', and append the character to the result string. If there is no '#' symbol, we simply consider the single-digit number and map it to a character. Finally, we return the mapped string.\n    "}
{"id": 1444, "slug": "number-of-ways-of-cutting-a-pizza", "title": "Number of Ways of Cutting a Pizza", "difficulty": "Hard", "content": "Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.\n\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\n\n_Return the number of ways of cutting the pizza such that each piece contains **at least** one apple._ Since the answer can be a huge number, return this modulo 10^9 + 7.\n\n**Example 1:**\n\n**Input:** pizza = \\[ \"A.. \", \"AAA \", \"... \"\\], k = 3\n**Output:** 3 \n**Explanation:** The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n\n**Example 2:**\n\n**Input:** pizza = \\[ \"A.. \", \"AA. \", \"... \"\\], k = 3\n**Output:** 1\n\n**Example 3:**\n\n**Input:** pizza = \\[ \"A.. \", \"A.. \", \"... \"\\], k = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= rows, cols <= 50`\n*   `rows == pizza.length`\n*   `cols == pizza[i].length`\n*   `1 <= k <= 10`\n*   `pizza` consists of characters `'A'` and `'.'` only.", "java": "\n    ```java\nint numberOfSteps(int num) {\n    int steps = 0;\n    while (num != 0) {\n        steps += (num % 2 == 0) ? 1 : 2;\n        num >>= 1;\n    }\n    return steps - 1;\n}\n```\n    \n    The algorithm initializes a `steps` variable to count the number of steps taken. It then iterates through a loop as long as the value of `num` is not zero. Inside the loop, if `num` is even, add one step; if `num` is odd, add two steps (subtracting one, getting an even number, then dividing by 2). The loop uses bit manipulation to divide `num` by 2 (shifting right by 1). Finally, we return the total steps minus one since we considered one extra step when subtracting an odd number.\n    ", "c++": "\n    ```cpp\nint numberOfSteps(int num) {\n    int steps = 0;\n    while (num) {\n        steps += (num % 2 == 0) ? 1 : 2;\n        num >>= 1;\n    }\n    return steps - 1;\n}\n```\n    \n    The algorithm initializes a `steps` variable to count the number of steps taken. It then iterates through a loop as long as the value of `num` is not zero. Inside the loop, if `num` is even, add one step; if `num` is odd, add two steps (subtracting one, getting an even number, then dividing by 2). The loop uses bit manipulation to divide `num` by 2 (shifting right by 1). Finally, we return the total steps minus one since we considered one extra step when subtracting an odd number.\n    ", "python": "\n    ```python\ndef number_of_steps(num):\n    steps = 0\n    while num:\n        steps += 1 if num % 2 == 0 else 2\n        num >>= 1\n    return steps - 1\n```\n    \n    The algorithm initializes a `steps` variable to count the number of steps taken. It then iterates through a loop as long as the value of `num` is not zero. Inside the loop, if `num` is even, add one step; if `num` is odd, add two steps (subtracting one, getting an even number, then dividing by 2). The loop uses bit manipulation to divide `num` by 2 (shifting right by 1). Finally, we return the total steps minus one since we considered one extra step when subtracting an odd number.\n    ", "javascript": "\n    ```javascript\nfunction numberOfSteps(num) {\n    let steps = 0;\n    while (num) {\n        steps += (num % 2 === 0) ? 1 : 2;\n        num >>= 1;\n    }\n    return steps - 1;\n}\n```\n    \n    The algorithm initializes a `steps` variable to count the number of steps taken. It then iterates through a loop as long as the value of `num` is not zero. Inside the loop, if `num` is even, add one step; if `num` is odd, add two steps (subtracting one, getting an even number, then dividing by 2). The loop uses bit manipulation to divide `num` by 2 (shifting right by 1). Finally, we return the total steps minus one since we considered one extra step when subtracting an odd number.\n    "}
{"id": 1449, "slug": "form-largest-integer-with-digits-that-add-up-to-target", "title": "Form Largest Integer With Digits That Add up to Target", "difficulty": "Hard", "content": "Given an array of integers `cost` and an integer `target`, return _the **maximum** integer you can paint under the following rules_:\n\n*   The cost of painting a digit `(i + 1)` is given by `cost[i]` (**0-indexed**).\n*   The total cost used must be equal to `target`.\n*   The integer does not have `0` digits.\n\nSince the answer may be very large, return it as a string. If there is no way to paint any integer given the condition, return `\"0 \"`.\n\n**Example 1:**\n\n**Input:** cost = \\[4,3,2,5,6,7,2,5,5\\], target = 9\n**Output:**  \"7772 \"\n**Explanation:** The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost( \"7772 \") = 2\\*3+ 3\\*1 = 9. You could also paint  \"977 \", but  \"7772 \" is the largest number.\n**Digit    cost**\n  1  ->   4\n  2  ->   3\n  3  ->   2\n  4  ->   5\n  5  ->   6\n  6  ->   7\n  7  ->   2\n  8  ->   5\n  9  ->   5\n\n**Example 2:**\n\n**Input:** cost = \\[7,6,5,5,5,6,8,7,8\\], target = 12\n**Output:**  \"85 \"\n**Explanation:** The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost( \"85 \") = 7 + 5 = 12.\n\n**Example 3:**\n\n**Input:** cost = \\[2,4,6,2,4,6,4,4,4\\], target = 5\n**Output:**  \"0 \"\n**Explanation:** It is impossible to paint any integer with total cost equal to target.\n\n**Constraints:**\n\n*   `cost.length == 9`\n*   `1 <= cost[i], target <= 5000`", "java": "\n    ```java\npublic String largestNumber(int[] cost, int target) {\n    String[] dp = new String[target + 1];\n    dp[0] = \"\";\n\n    for (int i = 0; i < 9; ++i) {\n        for (int j = cost[i]; j <= target; ++j) {\n            if (dp[j - cost[i]] != null && dp[j - cost[i]].length() < j - cost[i]\n                    && (dp[j] == null || dp[j - cost[i]].length() + 1 > dp[j].length())) {\n                dp[j] = dp[j - cost[i]] + (char) ('1' + i);\n            }\n        }\n    }\n\n    return dp[target] == null ? \"0\" : dp[target];\n}\n```\n    \n    To solve this problem, we use a dynamic programming approach. We create an array `dp` where `dp[i]` keeps the maximum integer using the total cost `i`. To find the value of `dp[i]`, we keep track of the maximum integer up to the cost `i - cost[j]` for each of the paint costs and add the digit `j + 1`. Then, we compare the lengths of the integers at `dp[i - cost[j]]` and `dp[i]` to determine which one generates the maximum integer. At the end, we return `dp[target]`. If there is no solution, the default value will be an empty string which is changed to \"0\" before returning.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string largestNumber(std::vector<int>& cost, int target) {\n    std::vector<std::string> dp(target + 1, \"\");\n\n    for (int i = 0; i < 9; ++i) {\n        for (int j = cost[i]; j <= target; ++j) {\n            if (dp[j - cost[i]].size() < j - cost[i] && dp[j - cost[i]].size() + 1 > dp[j].size()) {\n                dp[j] = dp[j - cost[i]] + std::to_string(i + 1);\n            }\n        }\n    }\n\n    return dp[target].empty() ? \"0\" : dp[target];\n}\n```\n    \n    To solve this problem, we use a dynamic programming approach. We create an array `dp` where `dp[i]` keeps the maximum integer using the total cost `i`. To find the value of `dp[i]`, we keep track of the maximum integer up to the cost `i - cost[j]` for each of the paint costs and add the digit `j + 1`. Then, we compare the lengths of the integers at `dp[i - cost[j]]` and `dp[i]` to determine which one generates the maximum integer. At the end, we return `dp[target]`. If there is no solution, the default value will be an empty string which is changed to \"0\" before returning.\n    ", "python": "\n    ```python\ndef largestNumber(cost, target):\n    dp = [\"\" for _ in range(target + 1)]\n    dp[0] = \"\"\n\n    for i in range(9):\n        for j in range(cost[i], target + 1):\n            if dp[j - cost[i]] != None and len(dp[j - cost[i]]) < j - cost[i] \\\n               and (dp[j] == None or len(dp[j - cost[i]]) + 1 > len(dp[j])):\n                dp[j] = dp[j - cost[i]] + str(i + 1)\n\n    return dp[target] if dp[target] else \"0\"\n```\n    \n    To solve this problem, we use a dynamic programming approach. We create an array `dp` where `dp[i]` keeps the maximum integer using the total cost `i`. To find the value of `dp[i]`, we keep track of the maximum integer up to the cost `i - cost[j]` for each of the paint costs and add the digit `j + 1`. Then, we compare the lengths of the integers at `dp[i - cost[j]]` and `dp[i]` to determine which one generates the maximum integer. At the end, we return `dp[target]`. If there is no solution, the default value will be an empty string which is changed to \"0\" before returning.\n    ", "javascript": "\n    ```javascript\nfunction largestNumber(cost, target) {\n    const dp = new Array(target + 1).fill(\"\");\n    dp[0] = \"\";\n\n    for (let i = 0; i < 9; ++i) {\n        for (let j = cost[i]; j <= target; ++j) {\n            if (dp[j - cost[i]].length < j - cost[i] && dp[j - cost[i]].length + 1 > dp[j].length) {\n                dp[j] = dp[j - cost[i]] + (i + 1).toString();\n            }\n        }\n    }\n\n    return dp[target] || \"0\";\n}\n```\n    \n    To solve this problem, we use a dynamic programming approach. We create an array `dp` where `dp[i]` keeps the maximum integer using the total cost `i`. To find the value of `dp[i]`, we keep track of the maximum integer up to the cost `i - cost[j]` for each of the paint costs and add the digit `j + 1`. Then, we compare the lengths of the integers at `dp[i - cost[j]]` and `dp[i]` to determine which one generates the maximum integer. At the end, we return `dp[target]`. If there is no solution, the default value will be an empty string which is changed to \"0\" before returning.\n    "}
{"id": 1458, "slug": "max-dot-product-of-two-subsequences", "title": "Max Dot Product of Two Subsequences", "difficulty": "Hard", "content": "Given two arrays `nums1` and `nums2`.\n\nReturn the maximum dot product between **non-empty** subsequences of nums1 and nums2 with the same length.\n\nA subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `[2,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,5,3]` is not).\n\n**Example 1:**\n\n**Input:** nums1 = \\[2,1,-2,5\\], nums2 = \\[3,0,-6\\]\n**Output:** 18\n**Explanation:** Take subsequence \\[2,-2\\] from nums1 and subsequence \\[3,-6\\] from nums2.\nTheir dot product is (2\\*3 + (-2)\\*(-6)) = 18.\n\n**Example 2:**\n\n**Input:** nums1 = \\[3,-2\\], nums2 = \\[2,-6,7\\]\n**Output:** 21\n**Explanation:** Take subsequence \\[3\\] from nums1 and subsequence \\[7\\] from nums2.\nTheir dot product is (3\\*7) = 21.\n\n**Example 3:**\n\n**Input:** nums1 = \\[-1,-1\\], nums2 = \\[1,1\\]\n**Output:** -1\n**Explanation:** Take subsequence \\[-1\\] from nums1 and subsequence \\[1\\] from nums2.\nTheir dot product is -1.\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 500`\n*   `-1000 <= nums1[i], nums2[i] <= 1000`", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int[] sortByBits(int[] arr) {\n    Integer[] boxedArr = Arrays.stream(arr).boxed().toArray(Integer[]::new);\n    Arrays.sort(boxedArr, new Comparator<Integer>() {\n        @Override\n        public int compare(Integer a, Integer b) {\n            int count_a = Integer.bitCount(a);\n            int count_b = Integer.bitCount(b);\n            \n            if (count_a == count_b) {\n                return a - b;\n            }\n            return count_a - count_b;\n        }\n    });\n\n    return Arrays.stream(boxedArr).mapToInt(Integer::intValue).toArray();\n}\n```\n\n    \n    The basic algorithm for solving this problem is to use a sorting algorithm that takes a custom comparator function. This custom comparator function is responsible for sorting the integers based on the number of 1's in their binary representation.\n\nFor C++, the `sort()` function and `__builtin_popcount()` function from the `<algorithm>` header are used. The comparator function `compare()` sorts the elements based on the number of 1's and if equal, by ascending value.\n\nFor Java, the boxed Integer array is created and the `Arrays.sort()` method is used with a custom anonymous Comparator. The `Integer.bitCount()` method is used to get the number of 1's.\n\nFor Python, a lambda function is passed as the `key` argument for the `sorted()` function, where it returns a tuple that contains the number of 1's (calculated using the `bin()` function and `count()` method) and the value itself for sorting purposes.\n\nFor JavaScript, a custom function `countOnes()` is implemented to count the number of 1's in each number. The `arr.sort()` method is used with an anonymous comparator function that calculates the difference in 1's and the difference in value if the number of 1's is the same.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n\nbool compare(int a, int b) {\n    int count_a = __builtin_popcount(a);\n    int count_b = __builtin_popcount(b);\n    \n    if (count_a == count_b) {\n        return a < b;\n    }\n    return count_a < count_b;\n}\n\nvector<int> sortByBits(vector<int>& arr) {\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n```\n\n    \n    The basic algorithm for solving this problem is to use a sorting algorithm that takes a custom comparator function. This custom comparator function is responsible for sorting the integers based on the number of 1's in their binary representation.\n\nFor C++, the `sort()` function and `__builtin_popcount()` function from the `<algorithm>` header are used. The comparator function `compare()` sorts the elements based on the number of 1's and if equal, by ascending value.\n\nFor Java, the boxed Integer array is created and the `Arrays.sort()` method is used with a custom anonymous Comparator. The `Integer.bitCount()` method is used to get the number of 1's.\n\nFor Python, a lambda function is passed as the `key` argument for the `sorted()` function, where it returns a tuple that contains the number of 1's (calculated using the `bin()` function and `count()` method) and the value itself for sorting purposes.\n\nFor JavaScript, a custom function `countOnes()` is implemented to count the number of 1's in each number. The `arr.sort()` method is used with an anonymous comparator function that calculates the difference in 1's and the difference in value if the number of 1's is the same.\n    ", "python": "\n    ```python\ndef sortByBits(arr):\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))\n```\n\n    \n    The basic algorithm for solving this problem is to use a sorting algorithm that takes a custom comparator function. This custom comparator function is responsible for sorting the integers based on the number of 1's in their binary representation.\n\nFor C++, the `sort()` function and `__builtin_popcount()` function from the `<algorithm>` header are used. The comparator function `compare()` sorts the elements based on the number of 1's and if equal, by ascending value.\n\nFor Java, the boxed Integer array is created and the `Arrays.sort()` method is used with a custom anonymous Comparator. The `Integer.bitCount()` method is used to get the number of 1's.\n\nFor Python, a lambda function is passed as the `key` argument for the `sorted()` function, where it returns a tuple that contains the number of 1's (calculated using the `bin()` function and `count()` method) and the value itself for sorting purposes.\n\nFor JavaScript, a custom function `countOnes()` is implemented to count the number of 1's in each number. The `arr.sort()` method is used with an anonymous comparator function that calculates the difference in 1's and the difference in value if the number of 1's is the same.\n    ", "javascript": "\n    ```javascript\nfunction sortByBits(arr) {\n    function countOnes(n) {\n        let count = 0;\n        while (n > 0) {\n            count += n & 1;\n            n >>= 1;\n        }\n        return count;\n    }\n\n    return arr.sort((a, b) => {\n        let diff = countOnes(a) - countOnes(b);\n        return diff !== 0 ? diff : a - b;\n    });\n}\n```\n\n    \n    The basic algorithm for solving this problem is to use a sorting algorithm that takes a custom comparator function. This custom comparator function is responsible for sorting the integers based on the number of 1's in their binary representation.\n\nFor C++, the `sort()` function and `__builtin_popcount()` function from the `<algorithm>` header are used. The comparator function `compare()` sorts the elements based on the number of 1's and if equal, by ascending value.\n\nFor Java, the boxed Integer array is created and the `Arrays.sort()` method is used with a custom anonymous Comparator. The `Integer.bitCount()` method is used to get the number of 1's.\n\nFor Python, a lambda function is passed as the `key` argument for the `sorted()` function, where it returns a tuple that contains the number of 1's (calculated using the `bin()` function and `count()` method) and the value itself for sorting purposes.\n\nFor JavaScript, a custom function `countOnes()` is implemented to count the number of 1's in each number. The `arr.sort()` method is used with an anonymous comparator function that calculates the difference in 1's and the difference in value if the number of 1's is the same.\n    "}
{"id": 1463, "slug": "cherry-pickup-ii", "title": "Cherry Pickup II", "difficulty": "Hard", "content": "You are given a `rows x cols` matrix `grid` representing a field of cherries where `grid[i][j]` represents the number of cherries that you can collect from the `(i, j)` cell.\n\nYou have two robots that can collect cherries for you:\n\n*   **Robot #1** is located at the **top-left corner** `(0, 0)`, and\n*   **Robot #2** is located at the **top-right corner** `(0, cols - 1)`.\n\nReturn _the maximum number of cherries collection using both robots by following the rules below_:\n\n*   From a cell `(i, j)`, robots can move to cell `(i + 1, j - 1)`, `(i + 1, j)`, or `(i + 1, j + 1)`.\n*   When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.\n*   When both robots stay in the same cell, only one takes the cherries.\n*   Both robots cannot move outside of the grid at any moment.\n*   Both robots should reach the bottom row in `grid`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[3,1,1\\],\\[2,5,1\\],\\[1,5,5\\],\\[2,1,1\\]\\]\n**Output:** 24\n**Explanation:** Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\nCherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\nTotal of cherries: 12 + 12 = 24.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0,0,0,0,1\\],\\[2,0,0,0,0,3,0\\],\\[2,0,9,0,0,0,0\\],\\[0,3,0,5,4,0,0\\],\\[1,0,2,3,0,0,6\\]\\]\n**Output:** 28\n**Explanation:** Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\nCherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\nTotal of cherries: 17 + 11 = 28.\n\n**Constraints:**\n\n*   `rows == grid.length`\n*   `cols == grid[i].length`\n*   `2 <= rows, cols <= 70`\n*   `0 <= grid[i][j] <= 100`", "java": "\n    ```java\nimport java.util.*;\n\npublic int[] kWeakestRows(int[][] mat, int k) {\n    int m = mat.length;\n    int[] result = new int[k];\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\n\n    for (int i = 0; i < m; ++i) {\n        int soldiers = 0;\n        for (int val : mat[i]) {\n            if (val == 1) {\n                soldiers++;\n            } else {\n                break;\n            }\n        }\n        pq.add(new int[]{soldiers, i});\n    }\n\n    for (int i = 0; i < k; ++i) {\n        result[i] = pq.poll()[1];\n    }\n    return result;\n}\n```\n\n    \n    The given problem can be solved by iterating through the matrix and counting the number of 1's (soldiers) in each row. We create a list `soldier_row` (or priority queue in java) of pairs (or arrays) such that pairs first element is the count of 1's and second element is the row index.\n\nThen we sort the list `soldier_row` (not needed in java, as priority queue handles that internally). While sorting, if there is a tie for the number of soldiers, the row index will be the tiebreaker.\n\nFinally, we create an output list by taking indices of the first `k` weakest rows from the sorted list and return that list as our answer.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nvector<int> kWeakestRows(vector<vector<int>>& mat, int k) {\n    vector<pair<int, int>> soldier_row;\n    for (int i = 0; i < mat.size(); ++i) {\n        int soldiers = count(mat[i].begin(), mat[i].end(), 1);\n        soldier_row.push_back({soldiers, i});\n    }\n\n    sort(soldier_row.begin(), soldier_row.end());\n    \n    vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(soldier_row[i].second);\n    }\n    return result;\n}\n```\n\n    \n    The given problem can be solved by iterating through the matrix and counting the number of 1's (soldiers) in each row. We create a list `soldier_row` (or priority queue in java) of pairs (or arrays) such that pairs first element is the count of 1's and second element is the row index.\n\nThen we sort the list `soldier_row` (not needed in java, as priority queue handles that internally). While sorting, if there is a tie for the number of soldiers, the row index will be the tiebreaker.\n\nFinally, we create an output list by taking indices of the first `k` weakest rows from the sorted list and return that list as our answer.\n    ", "python": "\n    ```python\nfrom typing import List\nimport heapq\n\ndef kWeakestRows(mat: List[List[int]], k: int) -> List[int]:\n    soldier_rows = [(row.count(1), i) for i, row in enumerate(mat)]\n    heapq.heapify(soldier_rows)\n    return [heapq.heappop(soldier_rows)[1] for _ in range(k)]\n```\n\n    \n    The given problem can be solved by iterating through the matrix and counting the number of 1's (soldiers) in each row. We create a list `soldier_row` (or priority queue in java) of pairs (or arrays) such that pairs first element is the count of 1's and second element is the row index.\n\nThen we sort the list `soldier_row` (not needed in java, as priority queue handles that internally). While sorting, if there is a tie for the number of soldiers, the row index will be the tiebreaker.\n\nFinally, we create an output list by taking indices of the first `k` weakest rows from the sorted list and return that list as our answer.\n    ", "javascript": "\n    ```javascript\nfunction kWeakestRows(mat, k) {\n    const soldierRows = mat.map((row, i) => [row.reduce((count, val) => count + val, 0), i]);\n    soldierRows.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n    return soldierRows.slice(0, k).map(row => row[1]);\n}\n```\n\n    \n    The given problem can be solved by iterating through the matrix and counting the number of 1's (soldiers) in each row. We create a list `soldier_row` (or priority queue in java) of pairs (or arrays) such that pairs first element is the count of 1's and second element is the row index.\n\nThen we sort the list `soldier_row` (not needed in java, as priority queue handles that internally). While sorting, if there is a tie for the number of soldiers, the row index will be the tiebreaker.\n\nFinally, we create an output list by taking indices of the first `k` weakest rows from the sorted list and return that list as our answer.\n    "}
{"id": 1473, "slug": "paint-house-iii", "title": "Paint House III", "difficulty": "Hard", "content": "There is a row of `m` houses in a small city, each house must be painted with one of the `n` colors (labeled from `1` to `n`), some houses that have been painted last summer should not be painted again.\n\nA neighborhood is a maximal group of continuous houses that are painted with the same color.\n\n*   For example: `houses = [1,2,2,3,3,2,1,1]` contains `5` neighborhoods `[{1}, {2,2}, {3,3}, {2}, {1,1}]`.\n\nGiven an array `houses`, an `m x n` matrix `cost` and an integer `target` where:\n\n*   `houses[i]`: is the color of the house `i`, and `0` if the house is not painted yet.\n*   `cost[i][j]`: is the cost of paint the house `i` with the color `j + 1`.\n\nReturn _the minimum cost of painting all the remaining houses in such a way that there are exactly_ `target` _neighborhoods_. If it is not possible, return `-1`.\n\n**Example 1:**\n\n**Input:** houses = \\[0,0,0,0,0\\], cost = \\[\\[1,10\\],\\[10,1\\],\\[10,1\\],\\[1,10\\],\\[5,1\\]\\], m = 5, n = 2, target = 3\n**Output:** 9\n**Explanation:** Paint houses of this way \\[1,2,2,1,1\\]\nThis array contains target = 3 neighborhoods, \\[{1}, {2,2}, {1,1}\\].\nCost of paint all houses (1 + 1 + 1 + 1 + 5) = 9.\n\n**Example 2:**\n\n**Input:** houses = \\[0,2,1,2,0\\], cost = \\[\\[1,10\\],\\[10,1\\],\\[10,1\\],\\[1,10\\],\\[5,1\\]\\], m = 5, n = 2, target = 3\n**Output:** 11\n**Explanation:** Some houses are already painted, Paint the houses of this way \\[2,2,1,2,2\\]\nThis array contains target = 3 neighborhoods, \\[{2,2}, {1}, {2,2}\\]. \nCost of paint the first and last house (10 + 1) = 11.\n\n**Example 3:**\n\n**Input:** houses = \\[3,1,2,3\\], cost = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\], m = 4, n = 3, target = 3\n**Output:** -1\n**Explanation:** Houses are already painted with a total of 4 neighborhoods \\[{3},{1},{2},{3}\\] different of target = 3.\n\n**Constraints:**\n\n*   `m == houses.length == cost.length`\n*   `n == cost[i].length`\n*   `1 <= m <= 100`\n*   `1 <= n <= 20`\n*   `1 <= target <= m`\n*   `0 <= houses[i] <= n`\n*   `1 <= cost[i][j] <= 104`", "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int findTheLongestSubstring(String s) {\n    Map<Integer, Integer> map = new HashMap<>();\n    map.put(0, -1);\n    int res = 0, n = s.length(), i, j = 0;\n    for (i = 0; i < n; i++) {\n        switch (s.charAt(i)) {\n            case 'a': j ^= 1; break;\n            case 'e': j ^= 2; break;\n            case 'i': j ^= 4; break;\n            case 'o': j ^= 8; break;\n            case 'u': j ^= 16; break;\n        }\n        map.putIfAbsent(j, i);\n        res = Math.max(res, i - map.get(j));\n    }\n    return res;\n}\n```\n    \n    The algorithm uses XOR to find a bitmask where each vowel corresponds to a bit (1 for odd occurrences, 0 for even occurrences). It loops through the input string and does bitwise XOR with an encoded version of the current character.\n\nEach XOR operation computes the even and odd occurrences for each vowel thus far. It records the first index of the bitmask in the position mapping. The difference between the current index and the value in the position map for the bitmask will give the length of the longest substring with even vowel occurrences. It updates the answer with the maximum substring length found.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint findTheLongestSubstring(string s) {\n    unordered_map<int, int> mp;\n    mp[0] = -1;\n    int res = 0, n = s.length(), i, j = 0;\n    for (i = 0; i < n; ++i) {\n        if (s[i] == 'a') j ^= 1;\n        else if (s[i] == 'e') j ^= 2;\n        else if (s[i] == 'i') j ^= 4;\n        else if (s[i] == 'o') j ^= 8;\n        else if (s[i] == 'u') j ^= 16;\n        if(!mp.count(j)) mp[j] = i;\n        res = max(res, i - mp[j]);\n    }\n    return res;\n}\n```\n    \n    The algorithm uses XOR to find a bitmask where each vowel corresponds to a bit (1 for odd occurrences, 0 for even occurrences). It loops through the input string and does bitwise XOR with an encoded version of the current character.\n\nEach XOR operation computes the even and odd occurrences for each vowel thus far. It records the first index of the bitmask in the position mapping. The difference between the current index and the value in the position map for the bitmask will give the length of the longest substring with even vowel occurrences. It updates the answer with the maximum substring length found.\n    ", "python": "\n    ```python\ndef findTheLongestSubstring(s: str) -> int:\n    pos = {-1: 0}\n    ans = cur = 0\n    for i, c in enumerate(s):\n        cur ^= 1 << (\"aeiou\".find(c) + 1) >> 1\n        if cur not in pos:\n            pos[cur] = i + 1\n        ans = max(ans, i + 1 - pos[cur])\n    return ans\n```\n    \n    The algorithm uses XOR to find a bitmask where each vowel corresponds to a bit (1 for odd occurrences, 0 for even occurrences). It loops through the input string and does bitwise XOR with an encoded version of the current character.\n\nEach XOR operation computes the even and odd occurrences for each vowel thus far. It records the first index of the bitmask in the position mapping. The difference between the current index and the value in the position map for the bitmask will give the length of the longest substring with even vowel occurrences. It updates the answer with the maximum substring length found.\n    ", "javascript": "\n    ```javascript\nfunction findTheLongestSubstring(s) {\n    const pos = new Map();\n    pos.set(0, -1);\n    let ans = 0, n = s.length, i, cur = 0;\n    for (i = 0; i < n; ++i) {\n        switch (s.charAt(i)) {\n            case 'a': cur ^= 1; break;\n            case 'e': cur ^= 2; break;\n            case 'i': cur ^= 4; break;\n            case 'o': cur ^= 8; break;\n            case 'u': cur ^= 16; break;\n        }\n        if(!pos.has(cur)) pos.set(cur, i);\n        ans = Math.max(ans, i - pos.get(cur));\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses XOR to find a bitmask where each vowel corresponds to a bit (1 for odd occurrences, 0 for even occurrences). It loops through the input string and does bitwise XOR with an encoded version of the current character.\n\nEach XOR operation computes the even and odd occurrences for each vowel thus far. It records the first index of the bitmask in the position mapping. The difference between the current index and the value in the position map for the bitmask will give the length of the longest substring with even vowel occurrences. It updates the answer with the maximum substring length found.\n    "}
{"id": 1477, "slug": "find-two-non-overlapping-sub-arrays-each-with-target-sum", "title": "Find Two Non-overlapping Sub-arrays Each With Target Sum", "difficulty": "Medium", "content": "You are given an array of integers `arr` and an integer `target`.\n\nYou have to find **two non-overlapping sub-arrays** of `arr` each with a sum equal `target`. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is **minimum**.\n\nReturn _the minimum sum of the lengths_ of the two required sub-arrays, or return `-1` if you cannot find such two sub-arrays.\n\n**Example 1:**\n\n**Input:** arr = \\[3,2,2,4,3\\], target = 3\n**Output:** 2\n**Explanation:** Only two sub-arrays have sum = 3 (\\[3\\] and \\[3\\]). The sum of their lengths is 2.\n\n**Example 2:**\n\n**Input:** arr = \\[7,3,4,7\\], target = 7\n**Output:** 2\n**Explanation:** Although we have three non-overlapping sub-arrays of sum = 7 (\\[7\\], \\[3,4\\] and \\[7\\]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.\n\n**Example 3:**\n\n**Input:** arr = \\[4,3,2,6,2,3,4\\], target = 6\n**Output:** -1\n**Explanation:** We have only one sub-array of sum = 6.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `1 <= arr[i] <= 1000`\n*   `1 <= target <= 108`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass ProductOfNumbers {\n    private List<Integer> products;\n\n    public ProductOfNumbers() {\n        products = new ArrayList<>();\n        products.add(1);\n    }\n\n    public void add(int num) {\n        if (num == 0) {\n            products.clear();\n            products.add(1);\n        } else {\n            products.add(products.get(products.size() - 1) * num);\n        }\n    }\n\n    public int getProduct(int k) {\n        if (k >= products.size()) {\n            return 0;\n        } else {\n            return products.get(products.size() - 1) / products.get(products.size() - k - 1);\n        }\n    }\n}\n```\n\n    \n    The algorithm maintains a growing list or vector of the cumulative products. When a new number is added, it either clears the list and starts over if the number is 0, or it adds the product of the last element and the new number to the end of the list. When the product of the last k numbers is requested, it returns the last element of the list divided by the element at the (size - k - 1) position in the list. If the list is shorter than the requested k, it returns 0 as the product will always contain a 0 in that case. The algorithm ensures that the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing. The complexity is O(1) for both `add` and `getProduct` operations.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nclass ProductOfNumbers {\npublic:\n    vector<int> products;\n\n    ProductOfNumbers() {\n        products.push_back(1);\n    }\n\n    void add(int num) {\n        if (num == 0) {\n            products.clear();\n            products.push_back(1);\n        } else {\n            products.push_back(products.back() * num);\n        }\n    }\n\n    int getProduct(int k) {\n        if (k >= products.size()) {\n            return 0;\n        } else {\n            return products.back() / products[products.size() - k - 1];\n        }\n    }\n};\n```\n\n    \n    The algorithm maintains a growing list or vector of the cumulative products. When a new number is added, it either clears the list and starts over if the number is 0, or it adds the product of the last element and the new number to the end of the list. When the product of the last k numbers is requested, it returns the last element of the list divided by the element at the (size - k - 1) position in the list. If the list is shorter than the requested k, it returns 0 as the product will always contain a 0 in that case. The algorithm ensures that the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing. The complexity is O(1) for both `add` and `getProduct` operations.\n    ", "python": "\n    ```python\nclass ProductOfNumbers:\n    def __init__(self):\n        self.products = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.products = [1]\n        else:\n            self.products.append(self.products[-1] * num)\n\n    def getProduct(self, k: int) -> int:\n        if k >= len(self.products):\n            return 0\n        else:\n            return self.products[-1] // self.products[-k - 1]\n```\n\n    \n    The algorithm maintains a growing list or vector of the cumulative products. When a new number is added, it either clears the list and starts over if the number is 0, or it adds the product of the last element and the new number to the end of the list. When the product of the last k numbers is requested, it returns the last element of the list divided by the element at the (size - k - 1) position in the list. If the list is shorter than the requested k, it returns 0 as the product will always contain a 0 in that case. The algorithm ensures that the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing. The complexity is O(1) for both `add` and `getProduct` operations.\n    ", "javascript": "\n    ```javascript\nclass ProductOfNumbers {\n    constructor() {\n        this.products = [1];\n    }\n\n    add(num) {\n        if (num === 0) {\n            this.products = [1];\n        } else {\n            this.products.push(this.products[this.products.length - 1] * num);\n        }\n    }\n\n    getProduct(k) {\n        if (k >= this.products.length) {\n            return 0;\n        } else {\n            return this.products[this.products.length - 1] / this.products[this.products.length - k - 1];\n        }\n    }\n}\n```\n\n    \n    The algorithm maintains a growing list or vector of the cumulative products. When a new number is added, it either clears the list and starts over if the number is 0, or it adds the product of the last element and the new number to the end of the list. When the product of the last k numbers is requested, it returns the last element of the list divided by the element at the (size - k - 1) position in the list. If the list is shorter than the requested k, it returns 0 as the product will always contain a 0 in that case. The algorithm ensures that the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing. The complexity is O(1) for both `add` and `getProduct` operations.\n    "}
{"id": 1478, "slug": "allocate-mailboxes", "title": "Allocate Mailboxes", "difficulty": "Hard", "content": "Given the array `houses` where `houses[i]` is the location of the `ith` house along a street and an integer `k`, allocate `k` mailboxes in the street.\n\nReturn _the **minimum** total distance between each house and its nearest mailbox_.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n**Example 1:**\n\n**Input:** houses = \\[1,4,8,10,20\\], k = 3\n**Output:** 5\n**Explanation:** Allocate mailboxes in position 3, 9 and 20.\nMinimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 \n\n**Example 2:**\n\n**Input:** houses = \\[2,3,5,12,18\\], k = 2\n**Output:** 9\n**Explanation:** Allocate mailboxes in position 3 and 14.\nMinimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9.\n\n**Constraints:**\n\n*   `1 <= k <= houses.length <= 100`\n*   `1 <= houses[i] <= 104`\n*   All the integers of `houses` are **unique**.", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxEvents(int[][] events) {\n    Arrays.sort(events, (a, b) -> a[1] - b[1]);\n\n    int count = 0;\n    int lastDay = -1;\n\n    for (int[] event : events) {\n        if (event[0] > lastDay) {\n            count++;\n            lastDay = event[1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The idea is to sort the events by end day. After sorting, iterate through the events and use a variable `lastDay` to keep track of the last day an event was attended. If the current event's start day is greater than the `lastDay`, increment the `count` (number of attended events) and set `lastDay` as the current event's end day. This greedy approach ensures we attend the events that end early and maximize the number of total attended events.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxEvents(std::vector<std::vector<int>>& events) {\n    std::sort(events.begin(), events.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    int count = 0;\n    int lastDay = -1;\n\n    for (const auto& event : events) {\n        if (event[0] > lastDay) {\n            ++count;\n            lastDay = event[1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The idea is to sort the events by end day. After sorting, iterate through the events and use a variable `lastDay` to keep track of the last day an event was attended. If the current event's start day is greater than the `lastDay`, increment the `count` (number of attended events) and set `lastDay` as the current event's end day. This greedy approach ensures we attend the events that end early and maximize the number of total attended events.\n    ", "python": "\n    ```python\ndef max_events(events):\n    events.sort(key=lambda x: x[1])\n\n    count = 0\n    last_day = -1\n\n    for event in events:\n        if event[0] > last_day:\n            count += 1\n            last_day = event[1]\n\n    return count\n```\n    \n    The idea is to sort the events by end day. After sorting, iterate through the events and use a variable `lastDay` to keep track of the last day an event was attended. If the current event's start day is greater than the `lastDay`, increment the `count` (number of attended events) and set `lastDay` as the current event's end day. This greedy approach ensures we attend the events that end early and maximize the number of total attended events.\n    ", "javascript": "\n    ```javascript\nfunction maxEvents(events) {\n    events.sort((a, b) => a[1] - b[1]);\n\n    let count = 0;\n    let lastDay = -1;\n\n    for (const event of events) {\n        if (event[0] > lastDay) {\n            count++;\n            lastDay = event[1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The idea is to sort the events by end day. After sorting, iterate through the events and use a variable `lastDay` to keep track of the last day an event was attended. If the current event's start day is greater than the `lastDay`, increment the `count` (number of attended events) and set `lastDay` as the current event's end day. This greedy approach ensures we attend the events that end early and maximize the number of total attended events.\n    "}
{"id": 1483, "slug": "kth-ancestor-of-a-tree-node", "title": "Kth Ancestor of a Tree Node", "difficulty": "Hard", "content": "You are given a tree with `n` nodes numbered from `0` to `n - 1` in the form of a parent array `parent` where `parent[i]` is the parent of `ith` node. The root of the tree is node `0`. Find the `kth` ancestor of a given node.\n\nThe `kth` ancestor of a tree node is the `kth` node in the path from that node to the root node.\n\nImplement the `TreeAncestor` class:\n\n*   `TreeAncestor(int n, int[] parent)` Initializes the object with the number of nodes in the tree and the parent array.\n*   `int getKthAncestor(int node, int k)` return the `kth` ancestor of the given node `node`. If there is no such ancestor, return `-1`.\n\n**Example 1:**\n\n**Input**\n\\[ \"TreeAncestor \",  \"getKthAncestor \",  \"getKthAncestor \",  \"getKthAncestor \"\\]\n\\[\\[7, \\[-1, 0, 0, 1, 1, 2, 2\\]\\], \\[3, 1\\], \\[5, 2\\], \\[6, 3\\]\\]\n**Output**\n\\[null, 1, 0, -1\\]\n\n**Explanation**\nTreeAncestor treeAncestor = new TreeAncestor(7, \\[-1, 0, 0, 1, 1, 2, 2\\]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor\n\n**Constraints:**\n\n*   `1 <= k <= n <= 5 * 104`\n*   `parent.length == n`\n*   `parent[0] == -1`\n*   `0 <= parent[i] < n` for all `0 < i < n`\n*   `0 <= node < n`\n*   There will be at most `5 * 104` queries.", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Solution {\n    public String rankTeams(String[] votes) {\n        int teams = votes[0].length();\n        int[][] ranks = new int[26][teams];\n\n        for (String vote : votes) {\n            for (int i = 0; i < teams; ++i) {\n                ranks[vote.charAt(i) - 'A'][i]++;\n            }\n        }\n\n        Character[] result = new Character[teams];\n        for (int i = 0; i < teams; ++i) {\n            result[i] = votes[0].charAt(i);\n        }\n\n        Arrays.sort(result, new Comparator<Character>() {\n            public int compare(Character a, Character b) {\n                for (int i = 0; i < teams; ++i) {\n                    if (ranks[a - 'A'][i] != ranks[b - 'A'][i]) {\n                        return ranks[b - 'A'][i] - ranks[a - 'A'][i];\n                    }\n                }\n                return a.compareTo(b);\n            }\n        });\n\n        StringBuilder sb = new StringBuilder();\n        for (Character ch : result) {\n            sb.append(ch);\n        }\n        return sb.toString();\n    }\n}\n```\n\n    \n    1. Count the rank positions of each team in a 2D array (index 0-25 represent the team letter). The array stores the votes count for each position.\n2. Sort the given team letters in lexicographical order, so it can be later used for the stable sort.\n3. For each position and its votes count, sort the teams based on the number of votes they received in descending order. If two or more teams tie, use the next position's votes count, and so on. If they tie after considering all positions, sort them based on their team letter.\n4. Convert the sorted team letters back into a string.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <string>\n#include <vector>\n\nstd::string rankTeams(std::vector<std::string>& votes) {\n    int teams = votes[0].size();\n    std::vector<std::vector<int>> ranks(26, std::vector<int>(teams, 0));\n\n    for (const std::string& vote : votes) {\n        for (int i = 0; i < teams; ++i) {\n            ranks[vote[i] - 'A'][i]++;\n        }\n    }\n\n    std::string result = votes[0];\n    std::sort(result.begin(), result.end(), [&](char a, char b) {\n        for (int i = 0; i < teams; ++i) {\n            if (ranks[a - 'A'][i] != ranks[b - 'A'][i]) {\n                return ranks[a - 'A'][i] > ranks[b - 'A'][i];\n            }\n        }\n        return a < b;\n    });\n\n    return result;\n}\n```\n\n    \n    1. Count the rank positions of each team in a 2D array (index 0-25 represent the team letter). The array stores the votes count for each position.\n2. Sort the given team letters in lexicographical order, so it can be later used for the stable sort.\n3. For each position and its votes count, sort the teams based on the number of votes they received in descending order. If two or more teams tie, use the next position's votes count, and so on. If they tie after considering all positions, sort them based on their team letter.\n4. Convert the sorted team letters back into a string.\n    ", "python": "\n    ```python\ndef rank_teams(votes):\n    teams = len(votes[0])\n    ranks = [[0] * teams for _ in range(26)]\n\n    for vote in votes:\n        for i in range(teams):\n            ranks[ord(vote[i]) - ord('A')][i] += 1\n\n    result = list(votes[0])\n    result.sort(key=lambda ch: tuple([-ranks[ord(ch) - ord('A')][i] for i in range(teams)] + [ch]))\n    return ''.join(result)\n```\n\n    \n    1. Count the rank positions of each team in a 2D array (index 0-25 represent the team letter). The array stores the votes count for each position.\n2. Sort the given team letters in lexicographical order, so it can be later used for the stable sort.\n3. For each position and its votes count, sort the teams based on the number of votes they received in descending order. If two or more teams tie, use the next position's votes count, and so on. If they tie after considering all positions, sort them based on their team letter.\n4. Convert the sorted team letters back into a string.\n    ", "javascript": "\n    ```javascript\nfunction rankTeams(votes) {\n    const teams = votes[0].length;\n    const ranks = Array.from({ length: 26 }, () => Array(teams).fill(0));\n\n    for (const vote of votes) {\n        for (let i = 0; i < teams; ++i) {\n            ranks[vote.charCodeAt(i) - \"A\".charCodeAt(0)][i]++;\n        }\n    }\n\n    const result = [...votes[0]];\n    result.sort((a, b) => {\n        for (let i = 0; i < teams; ++i) {\n            if (ranks[a.charCodeAt(0) - \"A\".charCodeAt(0)][i] !== ranks[b.charCodeAt(0) - \"A\".charCodeAt(0)][i]) {\n                return ranks[b.charCodeAt(0) - \"A\".charCodeAt(0)][i] - ranks[a.charCodeAt(0) - \"A\".charCodeAt(0)][i];\n            }\n        }\n        return a.localeCompare(b);\n    });\n\n    return result.join(\"\");\n}\n```\n\n    \n    1. Count the rank positions of each team in a 2D array (index 0-25 represent the team letter). The array stores the votes count for each position.\n2. Sort the given team letters in lexicographical order, so it can be later used for the stable sort.\n3. For each position and its votes count, sort the teams based on the number of votes they received in descending order. If two or more teams tie, use the next position's votes count, and so on. If they tie after considering all positions, sort them based on their team letter.\n4. Convert the sorted team letters back into a string.\n    "}
{"id": 1493, "slug": "longest-subarray-of-1s-after-deleting-one-element", "title": "Longest Subarray of 1's After Deleting One Element", "difficulty": "Medium", "content": "Given a binary array `nums`, you should delete one element from it.\n\nReturn _the size of the longest non-empty subarray containing only_ `1`_'s in the resulting array_. Return `0` if there is no such subarray.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,0,1\\]\n**Output:** 3\n**Explanation:** After deleting the number in position 2, \\[1,1,1\\] contains 3 numbers with value of 1's.\n\n**Example 2:**\n\n**Input:** nums = \\[0,1,1,1,0,1,1,0,1\\]\n**Output:** 5\n**Explanation:** After deleting the number in position 4, \\[0,1,1,1,1,1,0,1\\] longest subarray with value of 1's is \\[1,1,1,1,1\\].\n\n**Example 3:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** 2\n**Explanation:** You must delete one element.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic double frogPosition(int n, int[][] edges, int t, int target) {\n    List<Integer>[] graph = new ArrayList[n + 1];\n    for (int i = 0; i <= n; i++) {\n        graph[i] = new ArrayList<>();\n    }\n    for (int[] edge : edges) {\n        graph[edge[0]].add(edge[1]);\n        graph[edge[1]].add(edge[0]);\n    }\n    return dfs(1, -1, t, target, graph);\n}\n\nprivate double dfs(int node, int parent, int t, int target, List<Integer>[] graph) {\n    if (t == 0) {\n        return node == target ? 1.0 : 0.0;\n    }\n    double probability = 0.0;\n    for (int neighbor : graph[node]) {\n        if (neighbor != parent) {\n            probability += dfs(neighbor, node, t - 1, target, graph);\n        }\n    }\n    return probability / (graph[node].size() - (parent == -1 ? 0 : 1));\n}\n```\n\n    \n    The algorithm can be solved using Depth-First Search. To set up the environment, we first create an adjacency list called `graph` to represent the tree. We then perform the DFS from the first vertex, passing the parent, remaining time, target vertex, and graph as arguments.\n\nInside the helper function `dfs`, we have a base case when there are no more remaining seconds. In that case, we return 1.0 if the current node matches the target, otherwise, we return 0.0.\n\nNext, we traverse the neighbors of the current node, skipping the parent node to avoid cycles. We perform DFS for each neighbor, subtracting one from the remaining time. As we recurse back, we accumulate the probability from each DFS call and divide it by the number of neighbors minus one (the parent). This correctly calculates the probability of reaching the target vertex after a certain period of time.\n\nFinally, we return the probability from the DFS call.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\ndouble dfs(int node, int parent, int t, int target, vector<vector<int>>& graph) {\n    if (t == 0) {\n        return node == target ? 1.0 : 0.0;\n    }\n    double probability = 0.0;\n    for (int neighbor : graph[node]) {\n        if (neighbor != parent) {\n            probability += dfs(neighbor, node, t - 1, target, graph);\n        }\n    }\n    return probability / (graph[node].size() - (parent == -1 ? 0 : 1));\n}\n\ndouble frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\n    vector<vector<int>> graph(n + 1);\n    for (vector<int>& edge : edges) {\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }\n    return dfs(1, -1, t, target, graph);\n}\n```\n\n    \n    The algorithm can be solved using Depth-First Search. To set up the environment, we first create an adjacency list called `graph` to represent the tree. We then perform the DFS from the first vertex, passing the parent, remaining time, target vertex, and graph as arguments.\n\nInside the helper function `dfs`, we have a base case when there are no more remaining seconds. In that case, we return 1.0 if the current node matches the target, otherwise, we return 0.0.\n\nNext, we traverse the neighbors of the current node, skipping the parent node to avoid cycles. We perform DFS for each neighbor, subtracting one from the remaining time. As we recurse back, we accumulate the probability from each DFS call and divide it by the number of neighbors minus one (the parent). This correctly calculates the probability of reaching the target vertex after a certain period of time.\n\nFinally, we return the probability from the DFS call.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\n\ndef frogPosition(n, edges, t, target):\n    graph = defaultdict(list)\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n    return dfs(1, -1, t, target, graph)\n\ndef dfs(node, parent, t, target, graph):\n    if t == 0:\n        return 1.0 if node == target else 0.0\n    probability = 0.0\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            probability += dfs(neighbor, node, t - 1, target, graph)\n    return probability / (len(graph[node]) - (0 if parent == -1 else 1))\n```\n\n    \n    The algorithm can be solved using Depth-First Search. To set up the environment, we first create an adjacency list called `graph` to represent the tree. We then perform the DFS from the first vertex, passing the parent, remaining time, target vertex, and graph as arguments.\n\nInside the helper function `dfs`, we have a base case when there are no more remaining seconds. In that case, we return 1.0 if the current node matches the target, otherwise, we return 0.0.\n\nNext, we traverse the neighbors of the current node, skipping the parent node to avoid cycles. We perform DFS for each neighbor, subtracting one from the remaining time. As we recurse back, we accumulate the probability from each DFS call and divide it by the number of neighbors minus one (the parent). This correctly calculates the probability of reaching the target vertex after a certain period of time.\n\nFinally, we return the probability from the DFS call.\n    ", "javascript": "\n    ```javascript\nfunction frogPosition(n, edges, t, target) {\n    const graph = Array.from({ length: n + 1 }, () => []);\n    for (const edge of edges) {\n        graph[edge[0]].push(edge[1]);\n        graph[edge[1]].push(edge[0]);\n    }\n    return dfs(1, -1, t, target, graph);\n}\n\nfunction dfs(node, parent, t, target, graph) {\n    if (t === 0) {\n        return node === target ? 1.0 : 0.0;\n    }\n    let probability = 0.0;\n    for (const neighbor of graph[node]) {\n        if (neighbor !== parent) {\n            probability += dfs(neighbor, node, t - 1, target, graph);\n        }\n    }\n    return probability / (graph[node].length - (parent === -1 ? 0 : 1));\n}\n```\n\n    \n    The algorithm can be solved using Depth-First Search. To set up the environment, we first create an adjacency list called `graph` to represent the tree. We then perform the DFS from the first vertex, passing the parent, remaining time, target vertex, and graph as arguments.\n\nInside the helper function `dfs`, we have a base case when there are no more remaining seconds. In that case, we return 1.0 if the current node matches the target, otherwise, we return 0.0.\n\nNext, we traverse the neighbors of the current node, skipping the parent node to avoid cycles. We perform DFS for each neighbor, subtracting one from the remaining time. As we recurse back, we accumulate the probability from each DFS call and divide it by the number of neighbors minus one (the parent). This correctly calculates the probability of reaching the target vertex after a certain period of time.\n\nFinally, we return the probability from the DFS call.\n    "}
{"id": 1510, "slug": "stone-game-iv", "title": "Stone Game IV", "difficulty": "Hard", "content": "Alice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there are `n` stones in a pile. On each player's turn, that player makes a _move_ consisting of removing **any** non-zero **square number** of stones in the pile.\n\nAlso, if a player cannot make a move, he/she loses the game.\n\nGiven a positive integer `n`, return `true` if and only if Alice wins the game otherwise return `false`, assuming both players play optimally.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** true\n**Explanation:** Alice can remove 1 stone winning the game because Bob doesn't have any moves.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** false\n**Explanation:** Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** true\n**Explanation:** n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0).\n\n**Constraints:**\n\n*   `1 <= n <= 105`", "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int findLucky(int[] arr) {\n    HashMap<Integer, Integer> freq = new HashMap<>();\n\n    for (int n : arr) {\n        freq.put(n, freq.getOrDefault(n, 0) + 1);\n    }\n\n    int lucky = -1;\n    for (int key : freq.keySet()) {\n        if (key == freq.get(key)) {\n            lucky = Math.max(lucky, key);\n        }\n    }\n\n    return lucky;\n}\n```\n    \n    The algorithm starts by initializing an empty hash map called `freq` to store the frequencies of each integer in the array. Then, it iterates over the array and updates the frequencies in the hash map accordingly.\n\nAfter populating the hash map, the algorithm initializes a variable `lucky` with a value of -1. It then iterates over the key-value pairs in the hash map, checking if the key (the integer from the array) is equal to its value (the frequency). If an integer in the array has a frequency equal to its value, the algorithm updates the `lucky` variable to be the maximum of its current value and the integer in question.\n\nFinally, the `lucky` variable is returned as the largest lucky integer in the array. If no lucky integer is present, the initial value of -1 will be returned.\n    ", "c++": "\n    ```cpp\n#include <unordered_map>\n\nint findLucky(std::vector<int>& arr) {\n    std::unordered_map<int, int> freq;\n\n    for (int n : arr) {\n        freq[n]++;\n    }\n\n    int lucky = -1;\n    for (auto &pair : freq) {\n        if (pair.first == pair.second) {\n            lucky = std::max(lucky, pair.first);\n        }\n    }\n\n    return lucky;\n}\n```\n    \n    The algorithm starts by initializing an empty hash map called `freq` to store the frequencies of each integer in the array. Then, it iterates over the array and updates the frequencies in the hash map accordingly.\n\nAfter populating the hash map, the algorithm initializes a variable `lucky` with a value of -1. It then iterates over the key-value pairs in the hash map, checking if the key (the integer from the array) is equal to its value (the frequency). If an integer in the array has a frequency equal to its value, the algorithm updates the `lucky` variable to be the maximum of its current value and the integer in question.\n\nFinally, the `lucky` variable is returned as the largest lucky integer in the array. If no lucky integer is present, the initial value of -1 will be returned.\n    ", "python": "\n    ```python\ndef find_lucky(arr):\n    freq = {}\n\n    for n in arr:\n        if n in freq:\n            freq[n] += 1\n        else:\n            freq[n] = 1\n\n    lucky = -1\n    for key, value in freq.items():\n        if key == value:\n            lucky = max(lucky, key)\n\n    return lucky\n```\n    \n    The algorithm starts by initializing an empty hash map called `freq` to store the frequencies of each integer in the array. Then, it iterates over the array and updates the frequencies in the hash map accordingly.\n\nAfter populating the hash map, the algorithm initializes a variable `lucky` with a value of -1. It then iterates over the key-value pairs in the hash map, checking if the key (the integer from the array) is equal to its value (the frequency). If an integer in the array has a frequency equal to its value, the algorithm updates the `lucky` variable to be the maximum of its current value and the integer in question.\n\nFinally, the `lucky` variable is returned as the largest lucky integer in the array. If no lucky integer is present, the initial value of -1 will be returned.\n    ", "javascript": "\n    ```javascript\nfunction findLucky(arr) {\n    let freq = {};\n\n    for (let n of arr) {\n        if (n in freq) {\n            freq[n]++;\n        } else {\n            freq[n] = 1;\n        }\n    }\n\n    let lucky = -1;\n    for (let key in freq) {\n        let value = freq[key];\n        if (parseInt(key) === value) {\n            lucky = Math.max(lucky, key);\n        }\n    }\n\n    return lucky;\n}\n```\n    \n    The algorithm starts by initializing an empty hash map called `freq` to store the frequencies of each integer in the array. Then, it iterates over the array and updates the frequencies in the hash map accordingly.\n\nAfter populating the hash map, the algorithm initializes a variable `lucky` with a value of -1. It then iterates over the key-value pairs in the hash map, checking if the key (the integer from the array) is equal to its value (the frequency). If an integer in the array has a frequency equal to its value, the algorithm updates the `lucky` variable to be the maximum of its current value and the integer in question.\n\nFinally, the `lucky` variable is returned as the largest lucky integer in the array. If no lucky integer is present, the initial value of -1 will be returned.\n    "}
{"id": 1524, "slug": "number-of-sub-arrays-with-odd-sum", "title": "Number of Sub-arrays With Odd Sum", "difficulty": "Medium", "content": "Given an array of integers `arr`, return _the number of subarrays with an **odd** sum_.\n\nSince the answer can be very large, return it modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** arr = \\[1,3,5\\]\n**Output:** 4\n**Explanation:** All subarrays are \\[\\[1\\],\\[1,3\\],\\[1,3,5\\],\\[3\\],\\[3,5\\],\\[5\\]\\]\nAll sub-arrays sum are \\[1,4,9,3,8,5\\].\nOdd sums are \\[1,9,3,5\\] so the answer is 4.\n\n**Example 2:**\n\n**Input:** arr = \\[2,4,6\\]\n**Output:** 0\n**Explanation:** All subarrays are \\[\\[2\\],\\[2,4\\],\\[2,4,6\\],\\[4\\],\\[4,6\\],\\[6\\]\\]\nAll sub-arrays sum are \\[2,6,12,4,10,6\\].\nAll sub-arrays have even sum and the answer is 0.\n\n**Example 3:**\n\n**Input:** arr = \\[1,2,3,4,5,6,7\\]\n**Output:** 16\n\n**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `1 <= arr[i] <= 100`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> stringMatching(String[] words) {\n    List<String> result = new ArrayList<>();\n    for (String word1 : words) {\n        for (String word2 : words) {\n            if (!word1.equals(word2) && word2.contains(word1)) {\n                result.add(word1);\n                break;\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    The given algorithm is a simple brute-force approach to find substrings. We iterate through each word (word1) in the given list of words, and then for each word1, we iterate through the list of words again (word2) to compare with word1. If word1 is different from word2 and word1 is a substring of word2, we add word1 to the resulting list and break the inner loop to avoid adding duplicates. Finally, we return the list of strings which are a substring of another word in the given list of words.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include<string>\n\nstd::vector<std::string> stringMatching(std::vector<std::string>& words) {\n    std::vector<std::string> result;\n    for (const auto& word1 : words) {\n        for (const auto& word2 : words) {\n            if (word1 != word2 && word2.find(word1) != std::string::npos) {\n                result.push_back(word1);\n                break;\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    The given algorithm is a simple brute-force approach to find substrings. We iterate through each word (word1) in the given list of words, and then for each word1, we iterate through the list of words again (word2) to compare with word1. If word1 is different from word2 and word1 is a substring of word2, we add word1 to the resulting list and break the inner loop to avoid adding duplicates. Finally, we return the list of strings which are a substring of another word in the given list of words.\n    ", "python": "\n    ```python\ndef stringMatching(words):\n    result = []\n    for word1 in words:\n        for word2 in words:\n            if word1 != word2 and word1 in word2:\n                result.append(word1)\n                break\n    return result\n```\n    \n    The given algorithm is a simple brute-force approach to find substrings. We iterate through each word (word1) in the given list of words, and then for each word1, we iterate through the list of words again (word2) to compare with word1. If word1 is different from word2 and word1 is a substring of word2, we add word1 to the resulting list and break the inner loop to avoid adding duplicates. Finally, we return the list of strings which are a substring of another word in the given list of words.\n    ", "javascript": "\n    ```javascript\nfunction stringMatching(words) {\n    const result = [];\n    for (const word1 of words) {\n        for (const word2 of words) {\n            if (word1 !== word2 && word2.includes(word1)) {\n                result.push(word1);\n                break;\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    The given algorithm is a simple brute-force approach to find substrings. We iterate through each word (word1) in the given list of words, and then for each word1, we iterate through the list of words again (word2) to compare with word1. If word1 is different from word2 and word1 is a substring of word2, we add word1 to the resulting list and break the inner loop to avoid adding duplicates. Finally, we return the list of strings which are a substring of another word in the given list of words.\n    "}
{"id": 1525, "slug": "number-of-good-ways-to-split-a-string", "title": "Number of Good Ways to Split a String", "difficulty": "Medium", "content": "You are given a string `s`.\n\nA split is called **good** if you can split `s` into two non-empty strings `sleft` and `sright` where their concatenation is equal to `s` (i.e., `sleft + sright = s`) and the number of distinct letters in `sleft` and `sright` is the same.\n\nReturn _the number of **good splits** you can make in `s`_.\n\n**Example 1:**\n\n**Input:** s =  \"aacaba \"\n**Output:** 2\n**Explanation:** There are 5 ways to split ` \"aacaba \"` and 2 of them are good. \n( \"a \",  \"acaba \") Left string and right string contains 1 and 3 different letters respectively.\n( \"aa \",  \"caba \") Left string and right string contains 1 and 3 different letters respectively.\n( \"aac \",  \"aba \") Left string and right string contains 2 and 2 different letters respectively (good split).\n( \"aaca \",  \"ba \") Left string and right string contains 2 and 2 different letters respectively (good split).\n( \"aacab \",  \"a \") Left string and right string contains 3 and 1 different letters respectively.\n\n**Example 2:**\n\n**Input:** s =  \"abcd \"\n**Output:** 1\n**Explanation:** Split the string as follows ( \"ab \",  \"cd \").\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of only lowercase English letters.", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> processQueries(int[] queries, int m) {\n    List<Integer> nums = new ArrayList<>();\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < m; i++) {\n        nums.add(i + 1);\n    }\n    for (int q : queries) {\n        int pos = nums.indexOf(q);\n        result.add(pos);\n        nums.remove(pos);\n        nums.add(0, q);\n    }\n    return result;\n}\n```\n    \n    The algorithm starts by initializing a list `nums` of values from 1 to `m` and an empty result list.\n\nFor each query `q` in the queries list:\n1. Find the position `pos` of `q` in the `nums` list.\n2. Add `pos` to the result list.\n3. Remove `q` from its current position in the `nums` list.\n4. Insert `q` at the beginning of the `nums` list.\n\nFinally, return the result list.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> processQueries(std::vector<int> &queries, int m) {\n    std::vector<int> nums(m), result;\n    for (int i = 0; i < m; ++i) {\n        nums[i] = i + 1;\n    }\n    for (int q : queries) {\n        int pos = std::find(nums.begin(), nums.end(), q) - nums.begin();\n        result.push_back(pos);\n        nums.erase(nums.begin() + pos);\n        nums.insert(nums.begin(), q);\n    }\n    return result;\n}\n```\n    \n    The algorithm starts by initializing a list `nums` of values from 1 to `m` and an empty result list.\n\nFor each query `q` in the queries list:\n1. Find the position `pos` of `q` in the `nums` list.\n2. Add `pos` to the result list.\n3. Remove `q` from its current position in the `nums` list.\n4. Insert `q` at the beginning of the `nums` list.\n\nFinally, return the result list.\n    ", "python": "\n    ```python\ndef process_queries(queries, m):\n    nums = list(range(1, m+1))\n    result = []\n    for q in queries:\n        pos = nums.index(q)\n        result.append(pos)\n        del nums[pos]\n        nums.insert(0, q)\n    return result\n```\n    \n    The algorithm starts by initializing a list `nums` of values from 1 to `m` and an empty result list.\n\nFor each query `q` in the queries list:\n1. Find the position `pos` of `q` in the `nums` list.\n2. Add `pos` to the result list.\n3. Remove `q` from its current position in the `nums` list.\n4. Insert `q` at the beginning of the `nums` list.\n\nFinally, return the result list.\n    ", "javascript": "\n    ```javascript\nfunction processQueries(queries, m) {\n    const nums = Array.from({ length: m }, (_, i) => i + 1);\n    const result = [];\n    for (const q of queries) {\n        const pos = nums.indexOf(q);\n        result.push(pos);\n        nums.splice(pos, 1);\n        nums.unshift(q);\n    }\n    return result;\n}\n```\n    \n    The algorithm starts by initializing a list `nums` of values from 1 to `m` and an empty result list.\n\nFor each query `q` in the queries list:\n1. Find the position `pos` of `q` in the `nums` list.\n2. Add `pos` to the result list.\n3. Remove `q` from its current position in the `nums` list.\n4. Insert `q` at the beginning of the `nums` list.\n\nFinally, return the result list.\n    "}
{"id": 1526, "slug": "minimum-number-of-increments-on-subarrays-to-form-a-target-array", "title": "Minimum Number of Increments on Subarrays to Form a Target Array", "difficulty": "Hard", "content": "You are given an integer array `target`. You have an integer array `initial` of the same size as `target` with all elements initially zeros.\n\nIn one operation you can choose **any** subarray from `initial` and increment each value by one.\n\nReturn _the minimum number of operations to form a_ `target` _array from_ `initial`.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n**Example 1:**\n\n**Input:** target = \\[1,2,3,2,1\\]\n**Output:** 3\n**Explanation:** We need at least 3 operations to form the target array from the initial array.\n\\[**0,0,0,0,0**\\] increment 1 from index 0 to 4 (inclusive).\n\\[1,**1,1,1**,1\\] increment 1 from index 1 to 3 (inclusive).\n\\[1,2,**2**,2,1\\] increment 1 at index 2.\n\\[1,2,3,2,1\\] target array is formed.\n\n**Example 2:**\n\n**Input:** target = \\[3,1,1,2\\]\n**Output:** 4\n**Explanation:** \\[**0,0,0,0**\\] -> \\[1,1,1,**1**\\] -> \\[**1**,1,1,2\\] -> \\[**2**,1,1,2\\] -> \\[3,1,1,2\\]\n\n**Example 3:**\n\n**Input:** target = \\[3,1,5,4,2\\]\n**Output:** 7\n**Explanation:** \\[**0,0,0,0,0**\\] -> \\[**1**,1,1,1,1\\] -> \\[**2**,1,1,1,1\\] -> \\[3,1,**1,1,1**\\] -> \\[3,1,**2,2**,2\\] -> \\[3,1,**3,3**,2\\] -> \\[3,1,**4**,4,2\\] -> \\[3,1,5,4,2\\].\n\n**Constraints:**\n\n*   `1 <= target.length <= 105`\n*   `1 <= target[i] <= 105`", "java": "\n    ```java\nimport java.util.HashMap;\n\npublic String entityParser(String text) {\n    HashMap<String, Character> entities = new HashMap<String, Character>();\n    entities.put(\"&quot;\", '\\\"');\n    entities.put(\"&apos;\", '\\'');\n    entities.put(\"&amp;\", '&');\n    entities.put(\"&gt;\", '>');\n    entities.put(\"&lt;\", '<');\n    entities.put(\"&frasl;\", '/');\n    \n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < text.length(); ++i) {\n        if (text.charAt(i) == '&') {\n            StringBuilder temp = new StringBuilder();\n            for (int j = i; j < text.length() && j < i + 7; ++j) {\n                temp.append(text.charAt(j));\n                Character c = entities.get(temp.toString());\n                if (c != null) {\n                    result.append(c);\n                    i = j;\n                    break;\n                }\n            }\n            if (temp.charAt(temp.length() - 1) != ';') result.append(text.charAt(i));\n        } else {\n            result.append(text.charAt(i));\n        }\n    }\n    return result.toString();\n}\n```\n\n    \n    1. Initialize a dictionary or hashmap named `entities` with keys as the HTML entity representation and values as the corresponding plaintext characters.\n2. Initialize an empty string or character list named `result` to store the parsed text.\n3. Loop through each character of the input `text`.\n4. If the character is '&', try to match it as an entity in the dictionary.\n5. If a match is found within the next 7 characters, append the decoded entity character to the `result` and update the loop counter `i` to skip the matched entity.\n6. If no match is found, append the character to `result` as is.\n7. After the loop, return the `result` as the parsed text.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nstring entityParser(string text) {\n    unordered_map<string, char> entities{\n        {\"&quot;\", '\\\"'},\n        {\"&apos;\", '\\''},\n        {\"&amp;\", '&'},\n        {\"&gt;\", '>'},\n        {\"&lt;\", '<'},\n        {\"&frasl;\", '/'}\n    };\n    string result;\n    for (int i = 0; i < text.size(); ++i) {\n        if (text[i] == '&') {\n            string temp;\n            for (int j = i; j < text.size() && j < i + 7; ++j) {\n                temp.push_back(text[j]);\n                if (entities.find(temp) != entities.end()) {\n                    result.push_back(entities[temp]);\n                    i = j;\n                    break;\n                }\n            }\n            if (temp.back() != ';') result.push_back(text[i]);\n        } else {\n            result.push_back(text[i]);\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize a dictionary or hashmap named `entities` with keys as the HTML entity representation and values as the corresponding plaintext characters.\n2. Initialize an empty string or character list named `result` to store the parsed text.\n3. Loop through each character of the input `text`.\n4. If the character is '&', try to match it as an entity in the dictionary.\n5. If a match is found within the next 7 characters, append the decoded entity character to the `result` and update the loop counter `i` to skip the matched entity.\n6. If no match is found, append the character to `result` as is.\n7. After the loop, return the `result` as the parsed text.\n    ", "python": "\n    ```python\ndef entityParser(text: str) -> str:\n    entities = {\n        \"&quot;\": '\\\"',\n        \"&apos;\": '\\'',\n        \"&amp;\": '&',\n        \"&gt;\": '>',\n        \"&lt;\": '<',\n        \"&frasl;\": '/'\n    }\n\n    result, i = [], 0\n    while i < len(text):\n        if text[i] == '&':\n            temp = ''\n            for j in range(i, min(i+7, len(text))):\n                temp += text[j]\n                if temp in entities:\n                    result.append(entities[temp])\n                    i = j\n                    break\n            else:\n                result.append(text[i])\n        else:\n            result.append(text[i])\n        i += 1\n    return ''.join(result)\n```\n\n    \n    1. Initialize a dictionary or hashmap named `entities` with keys as the HTML entity representation and values as the corresponding plaintext characters.\n2. Initialize an empty string or character list named `result` to store the parsed text.\n3. Loop through each character of the input `text`.\n4. If the character is '&', try to match it as an entity in the dictionary.\n5. If a match is found within the next 7 characters, append the decoded entity character to the `result` and update the loop counter `i` to skip the matched entity.\n6. If no match is found, append the character to `result` as is.\n7. After the loop, return the `result` as the parsed text.\n    ", "javascript": "\n    ```javascript\nfunction entityParser(text) {\n    const entities = {\n        \"&quot;\": '\\\"',\n        \"&apos;\": '\\'',\n        \"&amp;\": '&',\n        \"&gt;\": '>',\n        \"&lt;\": '<',\n        \"&frasl;\": '/'\n    };\n\n    let result = '';\n    for (let i = 0; i < text.length; ++i) {\n        if (text[i] === '&') {\n            let temp = '';\n            for (let j = i; j < text.length && j < i + 7; ++j) {\n                temp += text[j];\n                if (temp in entities) {\n                    result += entities[temp];\n                    i = j;\n                    break;\n                }\n            }\n            if (temp[temp.length - 1] !== ';') result += text[i];\n        } else {\n            result += text[i];\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize a dictionary or hashmap named `entities` with keys as the HTML entity representation and values as the corresponding plaintext characters.\n2. Initialize an empty string or character list named `result` to store the parsed text.\n3. Loop through each character of the input `text`.\n4. If the character is '&', try to match it as an entity in the dictionary.\n5. If a match is found within the next 7 characters, append the decoded entity character to the `result` and update the loop counter `i` to skip the matched entity.\n6. If no match is found, append the character to `result` as is.\n7. After the loop, return the `result` as the parsed text.\n    "}
{"id": 1531, "slug": "string-compression-ii", "title": "String Compression II", "difficulty": "Hard", "content": "[Run-length encoding](http://en.wikipedia.org/wiki/Run-length_encoding) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string `\"aabccc \"` we replace `\"aa \"` by `\"a2 \"` and replace `\"ccc \"` by `\"c3 \"`. Thus the compressed string becomes `\"a2bc3 \"`.\n\nNotice that in this problem, we are not adding `'1'` after single characters.\n\nGiven a string `s` and an integer `k`. You need to delete **at most** `k` characters from `s` such that the run-length encoded version of `s` has minimum length.\n\nFind the _minimum length of the run-length encoded version of_ `s` _after deleting at most_ `k` _characters_.\n\n**Example 1:**\n\n**Input:** s =  \"aaabcccd \", k = 2\n**Output:** 4\n**Explanation:** Compressing s without deleting anything will give us  \"a3bc3d \" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s =  \"abcccd \" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be  \"a3c3 \" of length 4.\n\n**Example 2:**\n\n**Input:** s =  \"aabbaa \", k = 2\n**Output:** 2\n**Explanation:** If we delete both 'b' characters, the resulting compressed string would be  \"a4 \" of length 2.\n\n**Example 3:**\n\n**Input:** s =  \"aaaaaaaaaaa \", k = 0\n**Output:** 3\n**Explanation:** Since k is zero, we cannot delete anything. The compressed string is  \"a11 \" of length 3.\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `0 <= k <= s.length`\n*   `s` contains only lowercase English letters.", "java": "\n    ```java\nimport java.util.*;\n\npublic int numberWays(List<List<Integer>> hats) {\n    final int kMod = 1000000007;\n    final int kMaxHats = 40;\n    \n    int num_people = hats.size();\n    List<List<Integer>> people_with_hat = new ArrayList<>();\n    \n    for (int i = 0; i < kMaxHats; ++i) {\n        people_with_hat.add(new ArrayList<>());\n    }\n\n    for (int i = 0; i < num_people; ++i) {\n        for (int hat : hats.get(i)) {\n            people_with_hat.get(hat - 1).add(i);\n        }\n    }\n\n    int[][] dp = new int[1 << num_people][kMaxHats + 1];\n    dp[0][0] = 1;\n\n    for (int hat = 0; hat < kMaxHats; ++hat) {\n        for (int mask = (1 << num_people) - 1; mask >= 0; --mask) {\n            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod;\n            for (int person : people_with_hat.get(hat)) {\n                if ((mask & (1 << person)) == 0) {\n                    dp[mask | (1 << person)][hat + 1] = (dp[mask | (1 << person)][hat + 1] + dp[mask][hat]) % kMod;\n                }\n            }\n        }\n    }\n\n    return dp[(1 << num_people) - 1][kMaxHats];\n}\n```\n    \n    We create an array `people_with_hat` to store the indexes of people who prefer each hat. Then, we use dynamic programming to find the number of ways that the n people wear different hats to each other.\n\nOur DP state is `dp[mask][hat]`, which represents the number of ways to assign hats 1 through hat to people, such that people with index `i` (0-indexed) gets a hat if the `i`-th bit of `mask` is set. We initialize `dp[0][0] = 1`.\n\nWe iterate through each hat (0-indexed array) and, for each mask from (1<<num_people)-1 to 0, we try two options:\n1. Assign the current hat to no one - add `dp[mask][hat]` to `dp[mask][hat+1]`.\n2. Assign the current hat to one of the people who prefer it, if the `i`-th bit of `mask` (0-indexed) is unset. In this case, we set the `i`-th bit of the mask and update `dp[mask | (1<<person)][hat+1]`.\n\nFinally, we return the value in `dp[(1<<num_people) - 1][kMaxHats]`, which represents the number of ways of assigning all hats to the given people with their preferences.\n\nNotice that we are using modulo 109 + 7 to avoid integer overflow.\n    ", "c++": "\n    ```cpp\n#include<vector>\n\nint numberWays(std::vector<std::vector<int>>& hats) {\n    const int kMod = 1000000007;\n    const int kMaxHats = 40;\n    \n    int num_people = hats.size();\n    std::vector<std::vector<int>> people_with_hat(kMaxHats);\n    std::vector<std::vector<int>> dp(1<<num_people, std::vector<int>(kMaxHats+1, 0));\n    \n    for(int i = 0; i < num_people; ++i) {\n        for(int hat : hats[i]) {\n            people_with_hat[hat - 1].push_back(i);\n        }\n    }\n    \n    dp[0][0] = 1;\n    \n    for(int hat = 0; hat < kMaxHats; ++hat) {\n        for(int mask = (1<<num_people) - 1; mask >= 0; --mask) {\n            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod;\n            for(int person : people_with_hat[hat]) {\n                if((mask & (1<<person)) == 0) {\n                    dp[mask | (1<<person)][hat + 1] = (dp[mask | (1<<person)][hat + 1] + dp[mask][hat]) % kMod;\n                }\n            }\n        }\n    }\n    \n    return dp[(1<<num_people) - 1][kMaxHats];\n}\n```\n    \n    We create an array `people_with_hat` to store the indexes of people who prefer each hat. Then, we use dynamic programming to find the number of ways that the n people wear different hats to each other.\n\nOur DP state is `dp[mask][hat]`, which represents the number of ways to assign hats 1 through hat to people, such that people with index `i` (0-indexed) gets a hat if the `i`-th bit of `mask` is set. We initialize `dp[0][0] = 1`.\n\nWe iterate through each hat (0-indexed array) and, for each mask from (1<<num_people)-1 to 0, we try two options:\n1. Assign the current hat to no one - add `dp[mask][hat]` to `dp[mask][hat+1]`.\n2. Assign the current hat to one of the people who prefer it, if the `i`-th bit of `mask` (0-indexed) is unset. In this case, we set the `i`-th bit of the mask and update `dp[mask | (1<<person)][hat+1]`.\n\nFinally, we return the value in `dp[(1<<num_people) - 1][kMaxHats]`, which represents the number of ways of assigning all hats to the given people with their preferences.\n\nNotice that we are using modulo 109 + 7 to avoid integer overflow.\n    ", "python": "\n    ```python\ndef number_ways(hats):\n    kMod = 1000000007\n    kMaxHats = 40\n\n    num_people = len(hats)\n    people_with_hat = [[] for _ in range(kMaxHats)]\n\n    for i in range(num_people):\n        for hat in hats[i]:\n            people_with_hat[hat - 1].append(i)\n\n    dp = [[0] * (kMaxHats + 1) for _ in range(1 << num_people)]\n    dp[0][0] = 1\n\n    for hat in range(kMaxHats):\n        for mask in reversed(range(1 << num_people)):\n            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod\n            for person in people_with_hat[hat]:\n                if mask & (1 << person) == 0:\n                    dp[mask | (1 << person)][hat + 1] = (dp[mask | (1 << person)][hat + 1] + dp[mask][hat]) % kMod\n\n    return dp[(1 << num_people) - 1][kMaxHats]\n```\n    \n    We create an array `people_with_hat` to store the indexes of people who prefer each hat. Then, we use dynamic programming to find the number of ways that the n people wear different hats to each other.\n\nOur DP state is `dp[mask][hat]`, which represents the number of ways to assign hats 1 through hat to people, such that people with index `i` (0-indexed) gets a hat if the `i`-th bit of `mask` is set. We initialize `dp[0][0] = 1`.\n\nWe iterate through each hat (0-indexed array) and, for each mask from (1<<num_people)-1 to 0, we try two options:\n1. Assign the current hat to no one - add `dp[mask][hat]` to `dp[mask][hat+1]`.\n2. Assign the current hat to one of the people who prefer it, if the `i`-th bit of `mask` (0-indexed) is unset. In this case, we set the `i`-th bit of the mask and update `dp[mask | (1<<person)][hat+1]`.\n\nFinally, we return the value in `dp[(1<<num_people) - 1][kMaxHats]`, which represents the number of ways of assigning all hats to the given people with their preferences.\n\nNotice that we are using modulo 109 + 7 to avoid integer overflow.\n    ", "javascript": "\n    ```javascript\nfunction numberWays(hats) {\n    const kMod = 1000000007;\n    const kMaxHats = 40;\n\n    const num_people = hats.length;\n    const people_with_hat = Array.from({length: kMaxHats}, () => []);\n\n    for (let i = 0; i < num_people; ++i) {\n        for (const hat of hats[i]) {\n            people_with_hat[hat - 1].push(i);\n        }\n    }\n\n    const dp = Array.from({length: 1 << num_people}, () => Array(kMaxHats + 1).fill(0));\n    dp[0][0] = 1;\n\n    for (let hat = 0; hat < kMaxHats; ++hat) {\n        for (let mask = (1 << num_people) - 1; mask >= 0; --mask) {\n            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod;\n            for (const person of people_with_hat[hat]) {\n                if ((mask & (1 << person)) === 0) {\n                    dp[mask | (1 << person)][hat + 1] = (dp[mask | (1 << person)][hat + 1] + dp[mask][hat]) % kMod;\n                }\n            }\n        }\n    }\n\n    return dp[(1 << num_people) - 1][kMaxHats];\n}\n```\n    \n    We create an array `people_with_hat` to store the indexes of people who prefer each hat. Then, we use dynamic programming to find the number of ways that the n people wear different hats to each other.\n\nOur DP state is `dp[mask][hat]`, which represents the number of ways to assign hats 1 through hat to people, such that people with index `i` (0-indexed) gets a hat if the `i`-th bit of `mask` is set. We initialize `dp[0][0] = 1`.\n\nWe iterate through each hat (0-indexed array) and, for each mask from (1<<num_people)-1 to 0, we try two options:\n1. Assign the current hat to no one - add `dp[mask][hat]` to `dp[mask][hat+1]`.\n2. Assign the current hat to one of the people who prefer it, if the `i`-th bit of `mask` (0-indexed) is unset. In this case, we set the `i`-th bit of the mask and update `dp[mask | (1<<person)][hat+1]`.\n\nFinally, we return the value in `dp[(1<<num_people) - 1][kMaxHats]`, which represents the number of ways of assigning all hats to the given people with their preferences.\n\nNotice that we are using modulo 109 + 7 to avoid integer overflow.\n    "}
{"id": 1537, "slug": "get-the-maximum-score", "title": "Get the Maximum Score", "difficulty": "Hard", "content": "You are given two **sorted** arrays of distinct integers `nums1` and `nums2.`\n\nA **valid path** is defined as follows:\n\n*   Choose array `nums1` or `nums2` to traverse (from index-0).\n*   Traverse the current array from left to right.\n*   If you are reading any value that is present in `nums1` and `nums2` you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).\n\nThe **score** is defined as the sum of uniques values in a valid path.\n\nReturn _the maximum score you can obtain of all possible **valid paths**_. Since the answer may be too large, return it modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[2,4,5,8,10\\], nums2 = \\[4,6,8,9\\]\n**Output:** 30\n**Explanation:** Valid paths:\n\\[2,4,5,8,10\\], \\[2,4,5,8,9\\], \\[2,4,6,8,9\\], \\[2,4,6,8,10\\],  (starting from nums1)\n\\[4,6,8,9\\], \\[4,5,8,10\\], \\[4,5,8,9\\], \\[4,6,8,10\\]    (starting from nums2)\nThe maximum is obtained with the path in green **\\[2,4,6,8,10\\]**.\n\n**Example 2:**\n\n**Input:** nums1 = \\[1,3,5,7,9\\], nums2 = \\[3,5,100\\]\n**Output:** 109\n**Explanation:** Maximum sum is obtained with the path **\\[1,3,5,100\\]**.\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,2,3,4,5\\], nums2 = \\[6,7,8,9,10\\]\n**Output:** 40\n**Explanation:** There are no common elements between nums1 and nums2.\nMaximum sum is obtained with the path \\[6,7,8,9,10\\].\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 105`\n*   `1 <= nums1[i], nums2[i] <= 107`\n*   `nums1` and `nums2` are strictly increasing.", "java": "\n    ```java\npublic int maxScore(String s) {\n    int left_zeros = 0, right_ones = 0, max_score = 0;\n    for(char c : s.toCharArray()) if(c == '1') right_ones++;      \n        \n    for(int i = 0; i < s.length() - 1; i++) {\n        if(s.charAt(i) == '0') left_zeros++;\n        else right_ones--;\n        max_score = Math.max(max_score, left_zeros + right_ones);\n    }\n    return max_score;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize three variables: `left_zeros` to count zeros in the left substring, `right_ones` to count ones in the right substring, and `max_score` to store the maximum score after checking all possible splits.\n2. Count the total number of ones in the whole string and store it in `right_ones`.\n3. Iterate through the string (excluding the last character since both substrings should be non-empty) and for each character i, do the following:\n   a. If the character is '0', increment `left_zeros`. Else, decrement `right_ones` as the character '1' is moving from the right substring to the left substring.\n   b. Calculate the score by adding `left_zeros` and `right_ones`, and update `max_score` if it is less than the current score.\n4. Return the `max_score` after the iteration is complete.\n    ", "c++": "\n    ```cpp\nint maxScore(string s) {\n    int left_zeros = 0, right_ones = 0, max_score = 0;\n    for(char c : s) if(c == '1') right_ones++;\n        \n    for(int i = 0; i < s.size() - 1; i++) {\n        if(s[i] == '0') left_zeros++;\n        else right_ones--;\n        max_score = max(max_score, left_zeros + right_ones);\n    }\n    return max_score;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize three variables: `left_zeros` to count zeros in the left substring, `right_ones` to count ones in the right substring, and `max_score` to store the maximum score after checking all possible splits.\n2. Count the total number of ones in the whole string and store it in `right_ones`.\n3. Iterate through the string (excluding the last character since both substrings should be non-empty) and for each character i, do the following:\n   a. If the character is '0', increment `left_zeros`. Else, decrement `right_ones` as the character '1' is moving from the right substring to the left substring.\n   b. Calculate the score by adding `left_zeros` and `right_ones`, and update `max_score` if it is less than the current score.\n4. Return the `max_score` after the iteration is complete.\n    ", "python": "\n    ```python\ndef maxScore(s):\n    left_zeros, right_ones, max_score = 0, s.count('1'), 0\n    for i in range(len(s) - 1):\n        if s[i] == '0': left_zeros += 1\n        else: right_ones -= 1\n        max_score = max(max_score, left_zeros + right_ones)\n    return max_score\n```\n    \n    The algorithm works as follows:\n1. Initialize three variables: `left_zeros` to count zeros in the left substring, `right_ones` to count ones in the right substring, and `max_score` to store the maximum score after checking all possible splits.\n2. Count the total number of ones in the whole string and store it in `right_ones`.\n3. Iterate through the string (excluding the last character since both substrings should be non-empty) and for each character i, do the following:\n   a. If the character is '0', increment `left_zeros`. Else, decrement `right_ones` as the character '1' is moving from the right substring to the left substring.\n   b. Calculate the score by adding `left_zeros` and `right_ones`, and update `max_score` if it is less than the current score.\n4. Return the `max_score` after the iteration is complete.\n    ", "javascript": "\n    ```javascript\nfunction maxScore(s) {\n    let left_zeros = 0, right_ones = 0, max_score = 0;\n    for(let c of s) if(c === '1') right_ones++;\n        \n    for(let i = 0; i < s.length - 1; i++) {\n        if(s[i] === '0') left_zeros++;\n        else right_ones--;\n        max_score = Math.max(max_score, left_zeros + right_ones);\n    }\n    return max_score;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize three variables: `left_zeros` to count zeros in the left substring, `right_ones` to count ones in the right substring, and `max_score` to store the maximum score after checking all possible splits.\n2. Count the total number of ones in the whole string and store it in `right_ones`.\n3. Iterate through the string (excluding the last character since both substrings should be non-empty) and for each character i, do the following:\n   a. If the character is '0', increment `left_zeros`. Else, decrement `right_ones` as the character '1' is moving from the right substring to the left substring.\n   b. Calculate the score by adding `left_zeros` and `right_ones`, and update `max_score` if it is less than the current score.\n4. Return the `max_score` after the iteration is complete.\n    "}
{"id": 1547, "slug": "minimum-cost-to-cut-a-stick", "title": "Minimum Cost to Cut a Stick", "difficulty": "Hard", "content": "Given a wooden stick of length `n` units. The stick is labelled from `0` to `n`. For example, a stick of length **6** is labelled as follows:\n\nGiven an integer array `cuts` where `cuts[i]` denotes a position you should perform a cut at.\n\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\n\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\n\nReturn _the minimum total cost_ of the cuts.\n\n**Example 1:**\n\n**Input:** n = 7, cuts = \\[1,3,4,5\\]\n**Output:** 16\n**Explanation:** Using cuts order = \\[1, 3, 4, 5\\] as in the input leads to the following scenario:\n \nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be \\[3, 5, 1, 4\\] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).\n\n**Example 2:**\n\n**Input:** n = 9, cuts = \\[5,6,1,4,2\\]\n**Output:** 22\n**Explanation:** If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost <= 25, for example, the order \\[4, 6, 5, 2, 1\\] has total cost = 22 which is the minimum possible.\n\n**Constraints:**\n\n*   `2 <= n <= 106`\n*   `1 <= cuts.length <= min(n - 1, 100)`\n*   `1 <= cuts[i] <= n - 1`\n*   All the integers in `cuts` array are **distinct**.", "java": "\n    ```java\nimport java.util.*;\n\npublic String destCity(List<List<String>> paths) {\n    Set<String> startingCities = new HashSet<>();\n    for (List<String> path : paths)\n        startingCities.add(path.get(0));\n\n    for (List<String> path : paths) {\n        if (!startingCities.contains(path.get(1)))\n            return path.get(1);\n    }\n\n    return \"\";\n}\n```\n    \n    We start by creating a set `starting_cities` that will contain all the cities that have a direct path _outgoing_ from them. Then, for each path, we add the city where the path starts to our set.\n\nOnce we have the set, we iterate through the given paths again, checking if the destination city of each path (cityBi) is present in the set `starting_cities`. If a city is not present in the set, that means it doesn't have any outgoing path, and we return that city as the destination city.\n\nThe algorithm has a time complexity of O(n), where n is the number of paths, since we iterate through the paths twice. \n    ", "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <unordered_set>\n\nstd::string destCity(std::vector<std::vector<std::string>>& paths) {\n    std::unordered_set<std::string> starting_cities;\n    for (const auto& path : paths)\n        starting_cities.insert(path[0]);\n\n    for (const auto& path : paths) {\n        if (starting_cities.find(path[1]) == starting_cities.end())\n            return path[1];\n    }\n\n    return \"\";\n}\n```\n    \n    We start by creating a set `starting_cities` that will contain all the cities that have a direct path _outgoing_ from them. Then, for each path, we add the city where the path starts to our set.\n\nOnce we have the set, we iterate through the given paths again, checking if the destination city of each path (cityBi) is present in the set `starting_cities`. If a city is not present in the set, that means it doesn't have any outgoing path, and we return that city as the destination city.\n\nThe algorithm has a time complexity of O(n), where n is the number of paths, since we iterate through the paths twice. \n    ", "python": "\n    ```python\ndef destCity(paths):\n    starting_cities = set()\n    \n    for path in paths:\n        starting_cities.add(path[0])\n\n    for path in paths:\n        if path[1] not in starting_cities:\n            return path[1]\n\n    return \"\"\n```\n    \n    We start by creating a set `starting_cities` that will contain all the cities that have a direct path _outgoing_ from them. Then, for each path, we add the city where the path starts to our set.\n\nOnce we have the set, we iterate through the given paths again, checking if the destination city of each path (cityBi) is present in the set `starting_cities`. If a city is not present in the set, that means it doesn't have any outgoing path, and we return that city as the destination city.\n\nThe algorithm has a time complexity of O(n), where n is the number of paths, since we iterate through the paths twice. \n    ", "javascript": "\n    ```javascript\nfunction destCity(paths) {\n    const startingCities = new Set();\n\n    for (const path of paths)\n        startingCities.add(path[0]);\n\n    for (const path of paths) {\n        if (!startingCities.has(path[1]))\n            return path[1];\n    }\n\n    return \"\";\n}\n```\n    \n    We start by creating a set `starting_cities` that will contain all the cities that have a direct path _outgoing_ from them. Then, for each path, we add the city where the path starts to our set.\n\nOnce we have the set, we iterate through the given paths again, checking if the destination city of each path (cityBi) is present in the set `starting_cities`. If a city is not present in the set, that means it doesn't have any outgoing path, and we return that city as the destination city.\n\nThe algorithm has a time complexity of O(n), where n is the number of paths, since we iterate through the paths twice. \n    "}
{"id": 1548, "slug": "the-most-similar-path-in-a-graph", "title": "The Most Similar Path in a Graph", "difficulty": "Hard", "content": "We have `n` cities and `m` bi-directional `roads` where `roads[i] = [ai, bi]` connects city `ai` with city `bi`. Each city has a name consisting of exactly three upper-case English letters given in the string array `names`. Starting at any city `x`, you can reach any city `y` where `y != x` (i.e., the cities and the roads are forming an undirected connected graph).\n\nYou will be given a string array `targetPath`. You should find a path in the graph of the **same length** and with the **minimum edit distance** to `targetPath`.\n\nYou need to return _the order of the nodes in the path with the minimum edit distance_. The path should be of the same length of `targetPath` and should be valid (i.e., there should be a direct road between `ans[i]` and `ans[i + 1]`). If there are multiple answers return any one of them.\n\nThe **edit distance** is defined as follows:\n\n**Example 1:**\n\n**Input:** n = 5, roads = \\[\\[0,2\\],\\[0,3\\],\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[2,4\\]\\], names = \\[ \"ATL \", \"PEK \", \"LAX \", \"DXB \", \"HND \"\\], targetPath = \\[ \"ATL \", \"DXB \", \"HND \", \"LAX \"\\]\n**Output:** \\[0,2,4,2\\]\n**Explanation:** \\[0,2,4,2\\], \\[0,3,0,2\\] and \\[0,3,1,2\\] are accepted answers.\n\\[0,2,4,2\\] is equivalent to \\[ \"ATL \", \"LAX \", \"HND \", \"LAX \"\\] which has edit distance = 1 with targetPath.\n\\[0,3,0,2\\] is equivalent to \\[ \"ATL \", \"DXB \", \"ATL \", \"LAX \"\\] which has edit distance = 1 with targetPath.\n\\[0,3,1,2\\] is equivalent to \\[ \"ATL \", \"DXB \", \"PEK \", \"LAX \"\\] which has edit distance = 1 with targetPath.\n\n**Example 2:**\n\n**Input:** n = 4, roads = \\[\\[1,0\\],\\[2,0\\],\\[3,0\\],\\[2,1\\],\\[3,1\\],\\[3,2\\]\\], names = \\[ \"ATL \", \"PEK \", \"LAX \", \"DXB \"\\], targetPath = \\[ \"ABC \", \"DEF \", \"GHI \", \"JKL \", \"MNO \", \"PQR \", \"STU \", \"VWX \"\\]\n**Output:** \\[0,1,0,1,0,1,0,1\\]\n**Explanation:** Any path in this graph has edit distance = 8 with targetPath.\n\n**Example 3:**\n\n**Input:** n = 6, roads = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\], names = \\[ \"ATL \", \"PEK \", \"LAX \", \"ATL \", \"DXB \", \"HND \"\\], targetPath = \\[ \"ATL \", \"DXB \", \"HND \", \"DXB \", \"ATL \", \"LAX \", \"PEK \"\\]\n**Output:** \\[3,4,5,4,3,2,1\\]\n**Explanation:** \\[3,4,5,4,3,2,1\\] is the only path with edit distance = 0 with targetPath.\nIt's equivalent to \\[ \"ATL \", \"DXB \", \"HND \", \"DXB \", \"ATL \", \"LAX \", \"PEK \"\\]\n\n**Constraints:**\n\n*   `2 <= n <= 100`\n*   `m == roads.length`\n*   `n - 1 <= m <= (n * (n - 1) / 2)`\n*   `0 <= ai, bi <= n - 1`\n*   `ai != bi`\n*   The graph is guaranteed to be **connected** and each pair of nodes may have **at most one** direct road.\n*   `names.length == n`\n*   `names[i].length == 3`\n*   `names[i]` consists of upper-case English letters.\n*   There can be two cities with **the same** name.\n*   `1 <= targetPath.length <= 100`\n*   `targetPath[i].length == 3`\n*   `targetPath[i]` consists of upper-case English letters.\n\n**Follow up:** If each node can be visited only once in the path, What should you change in your solution?", "java": "\n    ```java\npublic boolean kLengthApart(int[] nums, int k) {\n    int last_one = -1;\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] == 1) {\n            if (last_one != -1 && i - last_one <= k) {\n                return false;\n            }\n            last_one = i;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the binary array `nums`. As it iterates, it keeps track of the position of the last 1 it encountered in the array, which is initially set to -1. When it finds a 1 in the array, it checks if the distance between this 1 and the previous 1 is greater than or equal to `k` (i.e., the distance should be more than `k`). If yes, it updates the last 1's position. If not, the function returns false. If the loop completes without finding any two 1s closer than `k` places from each other, the function returns true.\n    ", "c++": "\n    ```cpp\nbool kLengthApart(vector<int>& nums, int k) {\n    int last_one = -1;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] == 1) {\n            if (last_one != -1 && i - last_one <= k) {\n                return false;\n            }\n            last_one = i;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the binary array `nums`. As it iterates, it keeps track of the position of the last 1 it encountered in the array, which is initially set to -1. When it finds a 1 in the array, it checks if the distance between this 1 and the previous 1 is greater than or equal to `k` (i.e., the distance should be more than `k`). If yes, it updates the last 1's position. If not, the function returns false. If the loop completes without finding any two 1s closer than `k` places from each other, the function returns true.\n    ", "python": "\n    ```python\ndef kLengthApart(nums, k):\n    last_one = -1\n    for i, num in enumerate(nums):\n        if num == 1:\n            if last_one != -1 and i - last_one <= k:\n                return False\n            last_one = i\n    return True\n```\n    \n    The algorithm iterates through the binary array `nums`. As it iterates, it keeps track of the position of the last 1 it encountered in the array, which is initially set to -1. When it finds a 1 in the array, it checks if the distance between this 1 and the previous 1 is greater than or equal to `k` (i.e., the distance should be more than `k`). If yes, it updates the last 1's position. If not, the function returns false. If the loop completes without finding any two 1s closer than `k` places from each other, the function returns true.\n    ", "javascript": "\n    ```javascript\nfunction kLengthApart(nums, k) {\n    let last_one = -1;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === 1) {\n            if (last_one !== -1 && i - last_one <= k) {\n                return false;\n            }\n            last_one = i;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the binary array `nums`. As it iterates, it keeps track of the position of the last 1 it encountered in the array, which is initially set to -1. When it finds a 1 in the array, it checks if the distance between this 1 and the previous 1 is greater than or equal to `k` (i.e., the distance should be more than `k`). If yes, it updates the last 1's position. If not, the function returns false. If the loop completes without finding any two 1s closer than `k` places from each other, the function returns true.\n    "}
{"id": 1553, "slug": "minimum-number-of-days-to-eat-n-oranges", "title": "Minimum Number of Days to Eat N Oranges", "difficulty": "Hard", "content": "There are `n` oranges in the kitchen and you decided to eat some of these oranges every day as follows:\n\n*   Eat one orange.\n*   If the number of remaining oranges `n` is divisible by `2` then you can eat `n / 2` oranges.\n*   If the number of remaining oranges `n` is divisible by `3` then you can eat `2 * (n / 3)` oranges.\n\nYou can only choose one of the actions per day.\n\nGiven the integer `n`, return _the minimum number of days to eat_ `n` _oranges_.\n\n**Example 1:**\n\n**Input:** n = 10\n**Output:** 4\n**Explanation:** You have 10 oranges.\nDay 1: Eat 1 orange,  10 - 1 = 9.  \nDay 2: Eat 6 oranges, 9 - 2\\*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)\nDay 3: Eat 2 oranges, 3 - 2\\*(3/3) = 3 - 2 = 1. \nDay 4: Eat the last orange  1 - 1  = 0.\nYou need at least 4 days to eat the 10 oranges.\n\n**Example 2:**\n\n**Input:** n = 6\n**Output:** 3\n**Explanation:** You have 6 oranges.\nDay 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).\nDay 2: Eat 2 oranges, 3 - 2\\*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)\nDay 3: Eat the last orange  1 - 1  = 0.\nYou need at least 3 days to eat the 6 oranges.\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 109`", "java": "\n    ```java\npublic int countTriplets(int[] arr) {\n    int n = arr.length;\n    int[] XOR = new int[n+1];\n    \n    for (int i = 0; i < n; i++) {\n        XOR[i+1] = XOR[i] ^ arr[i];\n    }\n    \n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int k = i+1; k < n; k++) {\n            if(XOR[i] == XOR[k+1]) count += k-i;\n        }\n    }\n    return count;\n}\n```\n    \n    1. Calculate the prefix xor array `XOR` by iterating through the array `arr` and performing bitwise-xor operation. Initialize an array `XOR` of size n+1 with the first element as 0. Then for each element i, update XOR[i+1] with XOR[i] ^ arr[i].\n2. Initialize a counter variable `count`.\n3. Iterate through the array with nested loops. The outer loop iterates from index 0 to n-1, i.e., i = 0 to n-1.\n4. In the inner loop, iterate from index i+1 to n-1, i.e., k = i+1 to n-1.\n5. Check if XOR[i] is equal to XOR[k+1]. If it is true, increment count by k-i.\n6. Return the count.\n    ", "c++": "\n    ```cpp\nint countTriplets(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> XOR(n+1, 0);\n    \n    for (int i = 0; i < n; i++) {\n        XOR[i+1] = XOR[i] ^ arr[i];\n    }\n    \n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int k = i+1; k < n; k++) {\n            if(XOR[i] == XOR[k+1]) count += k-i;\n        }\n    }\n    return count;\n}\n```\n    \n    1. Calculate the prefix xor array `XOR` by iterating through the array `arr` and performing bitwise-xor operation. Initialize an array `XOR` of size n+1 with the first element as 0. Then for each element i, update XOR[i+1] with XOR[i] ^ arr[i].\n2. Initialize a counter variable `count`.\n3. Iterate through the array with nested loops. The outer loop iterates from index 0 to n-1, i.e., i = 0 to n-1.\n4. In the inner loop, iterate from index i+1 to n-1, i.e., k = i+1 to n-1.\n5. Check if XOR[i] is equal to XOR[k+1]. If it is true, increment count by k-i.\n6. Return the count.\n    ", "python": "\n    ```python\ndef countTriplets(arr):\n    n = len(arr)\n    XOR = [0] * (n + 1)\n    \n    for i in range(n):\n        XOR[i+1] = XOR[i] ^ arr[i]\n    \n    count = 0\n    for i in range(n):\n        for k in range(i+1, n):\n            if XOR[i] == XOR[k+1]:\n                count += k-i\n    return count\n```\n    \n    1. Calculate the prefix xor array `XOR` by iterating through the array `arr` and performing bitwise-xor operation. Initialize an array `XOR` of size n+1 with the first element as 0. Then for each element i, update XOR[i+1] with XOR[i] ^ arr[i].\n2. Initialize a counter variable `count`.\n3. Iterate through the array with nested loops. The outer loop iterates from index 0 to n-1, i.e., i = 0 to n-1.\n4. In the inner loop, iterate from index i+1 to n-1, i.e., k = i+1 to n-1.\n5. Check if XOR[i] is equal to XOR[k+1]. If it is true, increment count by k-i.\n6. Return the count.\n    ", "javascript": "\n    ```javascript\nfunction countTriplets(arr) {\n    let n = arr.length;\n    let XOR = new Array(n + 1).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        XOR[i+1] = XOR[i] ^ arr[i];\n    }\n    \n    let count = 0;\n    for (let i = 0; i < n; i++) {\n        for (let k = i+1; k < n; k++) {\n            if (XOR[i] === XOR[k+1]) {\n                count += (k-i);\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    1. Calculate the prefix xor array `XOR` by iterating through the array `arr` and performing bitwise-xor operation. Initialize an array `XOR` of size n+1 with the first element as 0. Then for each element i, update XOR[i+1] with XOR[i] ^ arr[i].\n2. Initialize a counter variable `count`.\n3. Iterate through the array with nested loops. The outer loop iterates from index 0 to n-1, i.e., i = 0 to n-1.\n4. In the inner loop, iterate from index i+1 to n-1, i.e., k = i+1 to n-1.\n5. Check if XOR[i] is equal to XOR[k+1]. If it is true, increment count by k-i.\n6. Return the count.\n    "}
{"id": 1563, "slug": "stone-game-v", "title": "Stone Game V", "difficulty": "Hard", "content": "There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nIn each round of the game, Alice divides the row into **two non-empty rows** (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.\n\nThe game ends when there is only **one stone remaining**. Alice's is initially **zero**.\n\nReturn _the maximum score that Alice can obtain_.\n\n**Example 1:**\n\n**Input:** stoneValue = \\[6,2,3,4,5,5\\]\n**Output:** 18\n**Explanation:** In the first round, Alice divides the row to \\[6,2,3\\], \\[4,5,5\\]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.\nIn the second round Alice divides the row to \\[6\\], \\[2,3\\]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).\nThe last round Alice has only one choice to divide the row which is \\[2\\], \\[3\\]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.\n\n**Example 2:**\n\n**Input:** stoneValue = \\[7,7,7,7,7,7,7\\]\n**Output:** 28\n\n**Example 3:**\n\n**Input:** stoneValue = \\[4\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= stoneValue.length <= 500`\n*   `1 <= stoneValue[i] <= 106`", "java": "\n    ```java\nimport java.awt.geom.Point2D;\nimport java.util.List;\n\npublic int maxNumberOfDarts(List<List<Integer>> darts, int r) {\n    int n = darts.size();\n    int maxDarts = 1;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double dist = Point2D.distance(darts.get(j).get(0), darts.get(j).get(1), darts.get(i).get(0), darts.get(i).get(1));\n            if (dist > 2.0 * r) continue;\n\n            double angle = Math.acos(dist / (2.0 * r));\n            for (int k = 0; k < 2; k++) {\n                double locAngle = angle * (k == 0 ? 1 : -1);\n                double cx = darts.get(i).get(0) + r * (darts.get(j).get(0) - darts.get(i).get(0)) / dist * Math.cos(locAngle) - r * (darts.get(j).get(1) - darts.get(i).get(1)) / dist * Math.sin(locAngle);\n                double cy = darts.get(i).get(1) + r * (darts.get(j).get(0) - darts.get(i).get(0)) / dist * Math.sin(locAngle) + r * (darts.get(j).get(1) - darts.get(i).get(1)) / dist * Math.cos(locAngle);\n\n                int cnt = 0;\n                for (int l = 0; l < n; l++) {\n                    double newDist = Point2D.distance(darts.get(l).get(0), darts.get(l).get(1), cx, cy);\n                    if (newDist <= r + 1e-5) cnt++;\n                }\n\n                maxDarts = Math.max(maxDarts, cnt);\n            }\n        }\n    }\n\n    return maxDarts;\n}\n```\n    \n    For each dart pair (i, j), we calculate the distance between them, and check if it's smaller than or equal to the diameter (2*r) of the dartboard. If so, find the two possible centers (c1, c2) of the dartboard using trigonometry (getting the angle between the chord connecting two darts and the radius, and the angle between the radius and the wall), where i-th and j-th darts lie on the edge.\n\nThen, for both possible centers of the dartboard, count how many darts in the array have a distance less than or equal to r and choose the highest value among all possible combinations of dart pairs and possible centers. This value is the maximum number of darts that can fit on the dartboard.\n    ", "c++": "\n    ```cpp\n#include <cmath>\n#include <vector>\n\nint maxNumberOfDarts(vector<vector<int>>& darts, int r) {\n    int n = darts.size();\n    int max_darts = 1;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double dist = hypot(darts[j][0] - darts[i][0], darts[j][1] - darts[i][1]);\n            if (dist > 2.0 * r) continue;\n\n            double angle = acos(dist / (2.0 * r));\n            for (int k = 0; k < 2; k++) {\n                double loc_angle = angle * (k == 0 ? 1 : -1);\n                double cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle);\n                double cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle);\n\n                int cnt = 0;\n                for (int l = 0; l < n; l++) {\n                    double new_dist = hypot(darts[l][0] - cx, darts[l][1] - cy);\n                    if (new_dist <= r + 1e-5) cnt++;\n                }\n\n                max_darts = max(max_darts, cnt);\n            }\n        }\n    }\n\n    return max_darts;\n}\n```\n    \n    For each dart pair (i, j), we calculate the distance between them, and check if it's smaller than or equal to the diameter (2*r) of the dartboard. If so, find the two possible centers (c1, c2) of the dartboard using trigonometry (getting the angle between the chord connecting two darts and the radius, and the angle between the radius and the wall), where i-th and j-th darts lie on the edge.\n\nThen, for both possible centers of the dartboard, count how many darts in the array have a distance less than or equal to r and choose the highest value among all possible combinations of dart pairs and possible centers. This value is the maximum number of darts that can fit on the dartboard.\n    ", "python": "\n    ```python\nfrom math import acos, cos, sin, sqrt\n\ndef max_number_of_darts(darts, r):\n    n = len(darts)\n    max_darts = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = sqrt((darts[j][0] - darts[i][0])**2 + (darts[j][1] - darts[i][1])**2)\n            if dist > 2.0 * r: continue\n\n            angle = acos(dist / (2.0 * r))\n            for k in range(2):\n                loc_angle = angle * (1 if k == 0 else -1)\n                cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle)\n                cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle)\n\n                cnt = 0\n                for l in range(n):\n                    new_dist = sqrt((darts[l][0] - cx)**2 + (darts[l][1] - cy)**2)\n                    if new_dist <= r + 1e-5: cnt += 1\n\n                max_darts = max(max_darts, cnt)\n\n    return max_darts\n```\n    \n    For each dart pair (i, j), we calculate the distance between them, and check if it's smaller than or equal to the diameter (2*r) of the dartboard. If so, find the two possible centers (c1, c2) of the dartboard using trigonometry (getting the angle between the chord connecting two darts and the radius, and the angle between the radius and the wall), where i-th and j-th darts lie on the edge.\n\nThen, for both possible centers of the dartboard, count how many darts in the array have a distance less than or equal to r and choose the highest value among all possible combinations of dart pairs and possible centers. This value is the maximum number of darts that can fit on the dartboard.\n    ", "javascript": "\n    ```javascript\nfunction maxNumberOfDarts(darts, r) {\n    const n = darts.length;\n    let maxDarts = 1;\n\n    function distance(x1, y1, x2, y2) {\n        return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);\n    }\n\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            const dist = distance(darts[j][0], darts[j][1], darts[i][0], darts[i][1]);\n            if (dist > 2.0 * r) continue;\n\n            const angle = Math.acos(dist / (2.0 * r));\n            for (let k = 0; k < 2; k++) {\n                const locAngle = angle * (k === 0 ? 1 : -1);\n                const cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * Math.cos(locAngle) - r * (darts[j][1] - darts[i][1]) / dist * Math.sin(locAngle);\n                const cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * Math.sin(locAngle) + r * (darts[j][1] - darts[i][1]) / dist * Math.cos(locAngle);\n\n                let cnt = 0;\n                for (let l = 0; l < n; l++) {\n                    const newDist = distance(darts[l][0], darts[l][1], cx, cy);\n                    if (newDist <= r + 1e-5) cnt++;\n                }\n\n                maxDarts = Math.max(maxDarts, cnt);\n            }\n        }\n    }\n\n    return maxDarts;\n}\n```\n    \n    For each dart pair (i, j), we calculate the distance between them, and check if it's smaller than or equal to the diameter (2*r) of the dartboard. If so, find the two possible centers (c1, c2) of the dartboard using trigonometry (getting the angle between the chord connecting two darts and the radius, and the angle between the radius and the wall), where i-th and j-th darts lie on the edge.\n\nThen, for both possible centers of the dartboard, count how many darts in the array have a distance less than or equal to r and choose the highest value among all possible combinations of dart pairs and possible centers. This value is the maximum number of darts that can fit on the dartboard.\n    "}
{"id": 1567, "slug": "maximum-length-of-subarray-with-positive-product", "title": "Maximum Length of Subarray With Positive Product", "difficulty": "Medium", "content": "Given an array of integers `nums`, find the maximum length of a subarray where the product of all its elements is positive.\n\nA subarray of an array is a consecutive sequence of zero or more values taken out of that array.\n\nReturn _the maximum length of a subarray with positive product_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,-2,-3,4\\]\n**Output:** 4\n**Explanation:** The array nums already has a positive product of 24.\n\n**Example 2:**\n\n**Input:** nums = \\[0,1,-2,-3,-4\\]\n**Output:** 3\n**Explanation:** The longest subarray with positive product is \\[1,-2,-3\\] which has a product of 6.\nNotice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.\n\n**Example 3:**\n\n**Input:** nums = \\[-1,-2,-3,0,1\\]\n**Output:** 2\n**Explanation:** The longest subarray with positive product is \\[-1,-2\\] or \\[-2,-3\\].\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`", "java": "\n    ```java\npublic int maxVowels(String s, int k) {\n    int max_count = 0, count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        count += isVowel(s.charAt(i)) ? 1 : 0;\n        if (i >= k)\n            count -= isVowel(s.charAt(i - k)) ? 1 : 0;\n        max_count = Math.max(max_count, count);\n    }\n    return max_count;\n}\n\nprivate boolean isVowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n```\n\n    \n    1. Initialize `max_count` and `count` variables to store the maximum count of consecutive vowels and the current count of vowels within the window of size `k`.\n2. Iterate through each character in the input string `s`.\n3. For each character, check if the character is a vowel. If it's a vowel, increment the `count` variable.\n4. If the current index `i` is greater than or equal to `k`, then check if the character (`s[i - k]`) that is outside of the current `k`-sized window is a vowel. If it's a vowel, decrement the `count` variable.\n5. At each iteration, update the `max_count` variable to store the maximum value of `count`.\n6. Return the value of `max_count` after the loop.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <algorithm>\n\nint maxVowels(std::string s, int k) {\n    int max_count = 0, count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        count += (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u');\n        if (i >= k)\n            count -= (s[i - k] == 'a' || s[i - k] == 'e' || s[i - k] == 'i' || s[i - k] == 'o' || s[i - k] == 'u');\n        max_count = std::max(max_count, count);\n    }\n    return max_count;\n}\n```\n\n    \n    1. Initialize `max_count` and `count` variables to store the maximum count of consecutive vowels and the current count of vowels within the window of size `k`.\n2. Iterate through each character in the input string `s`.\n3. For each character, check if the character is a vowel. If it's a vowel, increment the `count` variable.\n4. If the current index `i` is greater than or equal to `k`, then check if the character (`s[i - k]`) that is outside of the current `k`-sized window is a vowel. If it's a vowel, decrement the `count` variable.\n5. At each iteration, update the `max_count` variable to store the maximum value of `count`.\n6. Return the value of `max_count` after the loop.\n    ", "python": "\n    ```python\ndef max_vowels(s, k):\n    max_count = count = 0\n    for i, c in enumerate(s):\n        count += int(c in 'aeiou')\n        if i >= k:\n            count -= int(s[i - k] in 'aeiou')\n        max_count = max(max_count, count)\n    return max_count\n```\n\n    \n    1. Initialize `max_count` and `count` variables to store the maximum count of consecutive vowels and the current count of vowels within the window of size `k`.\n2. Iterate through each character in the input string `s`.\n3. For each character, check if the character is a vowel. If it's a vowel, increment the `count` variable.\n4. If the current index `i` is greater than or equal to `k`, then check if the character (`s[i - k]`) that is outside of the current `k`-sized window is a vowel. If it's a vowel, decrement the `count` variable.\n5. At each iteration, update the `max_count` variable to store the maximum value of `count`.\n6. Return the value of `max_count` after the loop.\n    ", "javascript": "\n    ```javascript\nfunction maxVowels(s, k) {\n    let max_count = 0, count = 0;\n    for (let i = 0; i < s.length; i++) {\n        count += isVowel(s[i]) ? 1 : 0;\n        if (i >= k)\n            count -= isVowel(s[i - k]) ? 1 : 0;\n        max_count = Math.max(max_count, count);\n    }\n    return max_count;\n}\n\nfunction isVowel(c) {\n    return c === 'a' || c === 'e' || c === 'i' || c === 'o' || c === 'u';\n}\n```\n\n    \n    1. Initialize `max_count` and `count` variables to store the maximum count of consecutive vowels and the current count of vowels within the window of size `k`.\n2. Iterate through each character in the input string `s`.\n3. For each character, check if the character is a vowel. If it's a vowel, increment the `count` variable.\n4. If the current index `i` is greater than or equal to `k`, then check if the character (`s[i - k]`) that is outside of the current `k`-sized window is a vowel. If it's a vowel, decrement the `count` variable.\n5. At each iteration, update the `max_count` variable to store the maximum value of `count`.\n6. Return the value of `max_count` after the loop.\n    "}
{"id": 1569, "slug": "number-of-ways-to-reorder-array-to-get-same-bst", "title": "Number of Ways to Reorder Array to Get Same BST", "difficulty": "Hard", "content": "Given an array `nums` that represents a permutation of integers from `1` to `n`. We are going to construct a binary search tree (BST) by inserting the elements of `nums` in order into an initially empty BST. Find the number of different ways to reorder `nums` so that the constructed BST is identical to that formed from the original array `nums`.\n\n*   For example, given `nums = [2,1,3]`, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array `[2,3,1]` also yields the same BST but `[3,2,1]` yields a different BST.\n\nReturn _the number of ways to reorder_ `nums` _such that the BST formed is identical to the original BST formed from_ `nums`.\n\nSince the answer may be very large, **return it modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** nums = \\[2,1,3\\]\n**Output:** 1\n**Explanation:** We can reorder nums to be \\[2,3,1\\] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.\n\n**Example 2:**\n\n**Input:** nums = \\[3,4,5,1,2\\]\n**Output:** 5\n**Explanation:** The following 5 arrays will yield the same BST: \n\\[3,1,2,4,5\\]\n\\[3,1,4,2,5\\]\n\\[3,1,4,5,2\\]\n\\[3,4,1,2,5\\]\n\\[3,4,1,5,2\\]\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 0\n**Explanation:** There are no other orderings of nums that will yield the same BST.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= nums.length`\n*   All integers in `nums` are **distinct**.", "java": "\n    ```java\npublic int maxDotProduct(int[] nums1, int[] nums2) {\n    int n = nums1.length, m = nums2.length;\n    int[][] dp = new int[n + 1][m + 1];\n    for (int i = 0; i <= n; ++i) {\n        Arrays.fill(dp[i], Integer.MIN_VALUE);\n    }\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            dp[i][j] = Math.max(dp[i][j], Math.max(dp[i - 1][j], Math.max(dp[i][j - 1], Math.max(dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1]))));\n        }\n    }\n    return dp[n][m];\n}\n```\n    \n    The algorithm iterates over both input arrays with nested loops, creating a two-dimensional DP table. For each cell (i, j) in the table, it finds the maximum between multiple alternatives:\n1. Previous value at dp[i][j]\n2. Value at dp[i-1][j]\n3. Value at dp[i][j-1]\n4. Value at (dp[i-1][j-1] + nums1[i-1] * nums2[j-1]) (i.e., including a dot product at the current position)\n5. Value at (nums1[i-1] * nums2[j-1]) (i.e., starting a new subsequence at the current position)\n\nAfter filling the DP table, dp[n][m] contains the maximum dot product between the two input arrays.\n    ", "c++": "\n    ```cpp\nint maxDotProduct(vector<int>& nums1, vector<int>& nums2) {\n    int n = nums1.size(), m = nums2.size();\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MIN));\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            dp[i][j] = max({dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1]});\n        }\n    }\n    return dp[n][m];\n}\n```\n    \n    The algorithm iterates over both input arrays with nested loops, creating a two-dimensional DP table. For each cell (i, j) in the table, it finds the maximum between multiple alternatives:\n1. Previous value at dp[i][j]\n2. Value at dp[i-1][j]\n3. Value at dp[i][j-1]\n4. Value at (dp[i-1][j-1] + nums1[i-1] * nums2[j-1]) (i.e., including a dot product at the current position)\n5. Value at (nums1[i-1] * nums2[j-1]) (i.e., starting a new subsequence at the current position)\n\nAfter filling the DP table, dp[n][m] contains the maximum dot product between the two input arrays.\n    ", "python": "\n    ```python\ndef maxDotProduct(nums1, nums2):\n    n, m = len(nums1), len(nums2)\n    dp = [[float('-inf') for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1])\n    return dp[n][m]\n```\n    \n    The algorithm iterates over both input arrays with nested loops, creating a two-dimensional DP table. For each cell (i, j) in the table, it finds the maximum between multiple alternatives:\n1. Previous value at dp[i][j]\n2. Value at dp[i-1][j]\n3. Value at dp[i][j-1]\n4. Value at (dp[i-1][j-1] + nums1[i-1] * nums2[j-1]) (i.e., including a dot product at the current position)\n5. Value at (nums1[i-1] * nums2[j-1]) (i.e., starting a new subsequence at the current position)\n\nAfter filling the DP table, dp[n][m] contains the maximum dot product between the two input arrays.\n    ", "javascript": "\n    ```javascript\nfunction maxDotProduct(nums1, nums2) {\n    const n = nums1.length, m = nums2.length;\n    const dp = Array.from(Array(n + 1), () => Array(m + 1).fill(Number.MIN_SAFE_INTEGER));\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 1; j <= m; ++j) {\n            dp[i][j] = Math.max(dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1]);\n        }\n    }\n    return dp[n][m];\n}\n```\n    \n    The algorithm iterates over both input arrays with nested loops, creating a two-dimensional DP table. For each cell (i, j) in the table, it finds the maximum between multiple alternatives:\n1. Previous value at dp[i][j]\n2. Value at dp[i-1][j]\n3. Value at dp[i][j-1]\n4. Value at (dp[i-1][j-1] + nums1[i-1] * nums2[j-1]) (i.e., including a dot product at the current position)\n5. Value at (nums1[i-1] * nums2[j-1]) (i.e., starting a new subsequence at the current position)\n\nAfter filling the DP table, dp[n][m] contains the maximum dot product between the two input arrays.\n    "}
{"id": 1575, "slug": "count-all-possible-routes", "title": "Count All Possible Routes", "difficulty": "Hard", "content": "You are given an array of **distinct** positive integers locations where `locations[i]` represents the position of city `i`. You are also given integers `start`, `finish` and `fuel` representing the starting city, ending city, and the initial amount of fuel you have, respectively.\n\nAt each step, if you are at city `i`, you can pick any city `j` such that `j != i` and `0 <= j < locations.length` and move to city `j`. Moving from city `i` to city `j` reduces the amount of fuel you have by `|locations[i] - locations[j]|`. Please notice that `|x|` denotes the absolute value of `x`.\n\nNotice that `fuel` **cannot** become negative at any point in time, and that you are **allowed** to visit any city more than once (including `start` and `finish`).\n\nReturn _the count of all possible routes from_ `start` _to_ `finish`. Since the answer may be too large, return it modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** locations = \\[2,3,6,8,4\\], start = 1, finish = 3, fuel = 5\n**Output:** 4\n**Explanation:** The following are all possible routes, each uses 5 units of fuel:\n1 -> 3\n1 -> 2 -> 3\n1 -> 4 -> 3\n1 -> 4 -> 2 -> 3\n\n**Example 2:**\n\n**Input:** locations = \\[4,3,1\\], start = 1, finish = 0, fuel = 6\n**Output:** 5\n**Explanation:** The following are all possible routes:\n1 -> 0, used fuel = 1\n1 -> 2 -> 0, used fuel = 5\n1 -> 2 -> 1 -> 0, used fuel = 5\n1 -> 0 -> 1 -> 0, used fuel = 3\n1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n\n**Example 3:**\n\n**Input:** locations = \\[5,2,1\\], start = 0, finish = 2, fuel = 3\n**Output:** 0\n**Explanation:** It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.\n\n**Constraints:**\n\n*   `2 <= locations.length <= 100`\n*   `1 <= locations[i] <= 109`\n*   All integers in `locations` are **distinct**.\n*   `0 <= start, finish < locations.length`\n*   `1 <= fuel <= 200`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {\n    Arrays.sort(horizontalCuts);\n    Arrays.sort(verticalCuts);\n    \n    int maxH = Math.max(horizontalCuts[0], h - horizontalCuts[horizontalCuts.length - 1]);\n    int maxV = Math.max(verticalCuts[0], w - verticalCuts[verticalCuts.length - 1]);\n    \n    for (int i = 1; i < horizontalCuts.length; ++i) {\n        maxH = Math.max(maxH, horizontalCuts[i] - horizontalCuts[i - 1]);\n    }\n    \n    for (int i = 1; i < verticalCuts.length; ++i) {\n        maxV = Math.max(maxV, verticalCuts[i] - verticalCuts[i - 1]);\n    }\n    \n    return (int)((long)maxH * maxV % 1000000007);\n}\n```\n    \n    1. Sort both horizontalCuts and verticalCuts arrays in ascending order.\n2. Calculate the initial values of maxH and maxV as the maximum of the first cut distance and the distance from the last cut to the cake's edge.\n3. Loop through each cut in both arrays (starting from index 1), updating maxH and maxV to be the maximum value between their current value and the difference between the current cut and the previous cut. This will give us the largest distance between cuts for both horizontal and vertical directions.\n4. Return the product of maxH and maxV modulo 10^9 + 7.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxArea(int h, int w, vector<int>& horizontalCuts, vector<int>& verticalCuts) {\n    sort(horizontalCuts.begin(), horizontalCuts.end());\n    sort(verticalCuts.begin(), verticalCuts.end());\n    \n    int maxH = max(horizontalCuts[0], h - horizontalCuts.back());\n    int maxV = max(verticalCuts[0], w - verticalCuts.back());\n    \n    for (int i = 1; i < horizontalCuts.size(); ++i) {\n        maxH = max(maxH, horizontalCuts[i] - horizontalCuts[i - 1]);\n    }\n    \n    for (int i = 1; i < verticalCuts.size(); ++i) {\n        maxV = max(maxV, verticalCuts[i] - verticalCuts[i - 1]);\n    }\n    \n    return (long long)maxH * maxV % 1000000007;\n}\n```\n    \n    1. Sort both horizontalCuts and verticalCuts arrays in ascending order.\n2. Calculate the initial values of maxH and maxV as the maximum of the first cut distance and the distance from the last cut to the cake's edge.\n3. Loop through each cut in both arrays (starting from index 1), updating maxH and maxV to be the maximum value between their current value and the difference between the current cut and the previous cut. This will give us the largest distance between cuts for both horizontal and vertical directions.\n4. Return the product of maxH and maxV modulo 10^9 + 7.\n    ", "python": "\n    ```python\ndef maxArea(h, w, horizontalCuts, verticalCuts):\n    horizontalCuts.sort()\n    verticalCuts.sort()\n\n    maxH = max(horizontalCuts[0], h - horizontalCuts[-1])\n    maxV = max(verticalCuts[0], w - verticalCuts[-1])\n\n    for i in range(1, len(horizontalCuts)):\n        maxH = max(maxH, horizontalCuts[i] - horizontalCuts[i - 1])\n\n    for i in range(1, len(verticalCuts)):\n        maxV = max(maxV, verticalCuts[i] - verticalCuts[i - 1])\n\n    return (maxH * maxV) % (10**9 + 7)\n```\n    \n    1. Sort both horizontalCuts and verticalCuts arrays in ascending order.\n2. Calculate the initial values of maxH and maxV as the maximum of the first cut distance and the distance from the last cut to the cake's edge.\n3. Loop through each cut in both arrays (starting from index 1), updating maxH and maxV to be the maximum value between their current value and the difference between the current cut and the previous cut. This will give us the largest distance between cuts for both horizontal and vertical directions.\n4. Return the product of maxH and maxV modulo 10^9 + 7.\n    ", "javascript": "\n    ```javascript\nfunction maxArea(h, w, horizontalCuts, verticalCuts) {\n    horizontalCuts.sort((a, b) => a - b);\n    verticalCuts.sort((a, b) => a - b);\n\n    let maxH = Math.max(horizontalCuts[0], h - horizontalCuts[horizontalCuts.length - 1]);\n    let maxV = Math.max(verticalCuts[0], w - verticalCuts[verticalCuts.length - 1]);\n\n    for (let i = 1; i < horizontalCuts.length; ++i) {\n        maxH = Math.max(maxH, horizontalCuts[i] - horizontalCuts[i - 1]);\n    }\n\n    for (let i = 1; i < verticalCuts.length; ++i) {\n        maxV = Math.max(maxV, verticalCuts[i] - verticalCuts[i - 1]);\n    }\n\n    return BigInt(maxH) * BigInt(maxV) % 1000000007n;\n}\n```\n    \n    1. Sort both horizontalCuts and verticalCuts arrays in ascending order.\n2. Calculate the initial values of maxH and maxV as the maximum of the first cut distance and the distance from the last cut to the cake's edge.\n3. Loop through each cut in both arrays (starting from index 1), updating maxH and maxV to be the maximum value between their current value and the difference between the current cut and the previous cut. This will give us the largest distance between cuts for both horizontal and vertical directions.\n4. Return the product of maxH and maxV modulo 10^9 + 7.\n    "}
{"id": 1611, "slug": "minimum-one-bit-operations-to-make-integers-zero", "title": "Minimum One Bit Operations to Make Integers Zero", "difficulty": "Hard", "content": "Given an integer `n`, you must transform it into `0` using the following operations any number of times:\n\n*   Change the rightmost (`0th`) bit in the binary representation of `n`.\n*   Change the `ith` bit in the binary representation of `n` if the `(i-1)th` bit is set to `1` and the `(i-2)th` through `0th` bits are set to `0`.\n\nReturn _the minimum number of operations to transform_ `n` _into_ `0`_._\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** The binary representation of 3 is  \"11 \".\n \"11 \" ->  \"01 \" with the 2nd operation since the 0th bit is 1.\n \"01 \" ->  \"00 \" with the 1st operation.\n\n**Example 2:**\n\n**Input:** n = 6\n**Output:** 4\n**Explanation:** The binary representation of 6 is  \"110 \".\n \"110 \" ->  \"010 \" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.\n \"010 \" ->  \"011 \" with the 1st operation.\n \"011 \" ->  \"001 \" with the 2nd operation since the 0th bit is 1.\n \"001 \" ->  \"000 \" with the 1st operation.\n\n**Constraints:**\n\n*   `0 <= n <= 109`", "java": "\n    ```java\nimport java.util.*;\n\npublic String[] getFolderNames(String[] names) {\n    HashMap<String, Integer> nameCount = new HashMap<String, Integer>();\n    String[] ans = new String[names.length];\n\n    for (int i = 0; i < names.length; i++) {\n        String name = names[i];\n        if (nameCount.get(name) == null) {\n            ans[i] = name;\n            nameCount.put(name, 1);\n        } else {\n            int k = nameCount.get(name);\n            String newName = \"\";\n            while (nameCount.get(name + \"(\" + k + \")\") != null) {\n                k++;\n            }\n            newName = name + \"(\" + k + \")\";\n            ans[i] = newName;\n            nameCount.put(newName, 1);\n            nameCount.put(name, k + 1);\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm holds an unordered_map (hash_map in Java, dictionary in Python, object in JS) named `nameCount` that stores the count of each name used. For each name in the `names` array, it checks if the name exists in `nameCount`. If not, it puts the name in the resulting array `ans` and initializes its count in `nameCount` by 1. If the name is already in `nameCount`, the algorithm creates a candidate name by adding the current count value in the form of (k), then checks if this name is also in the `nameCount`. If so, it increases the count (k) until finding a unique name. The new name is added to the result array, and its count value is set to 1 in `nameCount`, and the count value in (k+1) is updated. Finally, the function returns the `ans` array containing the unique folder names. \n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<std::string> getFolderNames(std::vector<std::string> &names) {\n    std::unordered_map<std::string, int> nameCount;\n    std::vector<std::string> ans;\n\n    for (const auto &name : names) {\n        if (nameCount[name] == 0) {\n            ans.push_back(name);\n            nameCount[name] = 1;\n        } else {\n            int k = nameCount[name];\n            while (nameCount[name + \"(\" + std::to_string(k) + \")\"] != 0) {\n                k++;\n            }\n            ans.push_back(name + \"(\" + std::to_string(k) + \")\");\n            nameCount[name + \"(\" + std::to_string(k) + \")\"] = 1;\n            nameCount[name] = k + 1;\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm holds an unordered_map (hash_map in Java, dictionary in Python, object in JS) named `nameCount` that stores the count of each name used. For each name in the `names` array, it checks if the name exists in `nameCount`. If not, it puts the name in the resulting array `ans` and initializes its count in `nameCount` by 1. If the name is already in `nameCount`, the algorithm creates a candidate name by adding the current count value in the form of (k), then checks if this name is also in the `nameCount`. If so, it increases the count (k) until finding a unique name. The new name is added to the result array, and its count value is set to 1 in `nameCount`, and the count value in (k+1) is updated. Finally, the function returns the `ans` array containing the unique folder names. \n    ", "python": "\n    ```python\ndef get_folder_names(names):\n    name_count = {}\n    ans = []\n\n    for name in names:\n        if name not in name_count:\n            ans.append(name)\n            name_count[name] = 1\n        else:\n            k = name_count[name]\n            new_name = f\"{name}({k})\"\n            while new_name in name_count:\n                k += 1\n                new_name = f\"{name}({k})\"\n            ans.append(new_name)\n            name_count[new_name] = 1\n            name_count[name] = k + 1\n\n    return ans\n```\n    \n    The algorithm holds an unordered_map (hash_map in Java, dictionary in Python, object in JS) named `nameCount` that stores the count of each name used. For each name in the `names` array, it checks if the name exists in `nameCount`. If not, it puts the name in the resulting array `ans` and initializes its count in `nameCount` by 1. If the name is already in `nameCount`, the algorithm creates a candidate name by adding the current count value in the form of (k), then checks if this name is also in the `nameCount`. If so, it increases the count (k) until finding a unique name. The new name is added to the result array, and its count value is set to 1 in `nameCount`, and the count value in (k+1) is updated. Finally, the function returns the `ans` array containing the unique folder names. \n    ", "javascript": "\n    ```javascript\nfunction getFolderNames(names) {\n    const nameCount = {};\n    const ans = [];\n\n    for (let name of names) {\n        if (nameCount[name] === undefined) {\n            ans.push(name);\n            nameCount[name] = 1;\n        } else {\n            let k = nameCount[name];\n            let newName = `${name}(${k})`;\n            while (nameCount[newName] !== undefined) {\n                k++;\n                newName = `${name}(${k})`;\n            }\n            ans.push(newName);\n            nameCount[newName] = 1;\n            nameCount[name] = k + 1;\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm holds an unordered_map (hash_map in Java, dictionary in Python, object in JS) named `nameCount` that stores the count of each name used. For each name in the `names` array, it checks if the name exists in `nameCount`. If not, it puts the name in the resulting array `ans` and initializes its count in `nameCount` by 1. If the name is already in `nameCount`, the algorithm creates a candidate name by adding the current count value in the form of (k), then checks if this name is also in the `nameCount`. If so, it increases the count (k) until finding a unique name. The new name is added to the result array, and its count value is set to 1 in `nameCount`, and the count value in (k+1) is updated. Finally, the function returns the `ans` array containing the unique folder names. \n    "}
{"id": 1617, "slug": "count-subtrees-with-max-distance-between-cities", "title": "Count Subtrees With Max Distance Between Cities", "difficulty": "Hard", "content": "There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**.\n\nA **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`.\n\nReturn _an array of size_ `n-1` _where the_ `dth` _element **(1-indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to_ `d`.\n\n**Notice** that the **distance** between the two cities is the number of edges in the path between them.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** \\[3,4,0\\]\n**Explanation:**\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\]\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** \\[2,1\\]\n\n**Constraints:**\n\n*   `2 <= n <= 15`\n*   `edges.length == n-1`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   All pairs `(ui, vi)` are distinct.", "java": "\n    ```java\npublic boolean winnerSquareGame(int n) {\n    boolean[] dp = new boolean[n + 1];\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j * j <= i; j++) {\n            if (!dp[i - j * j]) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a boolean array `dp` of size `(n + 1)` to store if the current player can win with the remaining stones at position `i`. Each entry `dp[i]` is set to `false` initially.\n\nWe iterate through all possible numbers of stones from `1` to `n`. For each stone `i`, we iterate through all possible square numbers `j` less than or equal to `i`. Inside the inner loop, we check if the current player, when playing optimally, can win using the stones `i - j*j`. If the current player cannot win (`dp[i - j * j]` is false), it means the current player can win using the square number `j` and we set `dp[i]` to `true`.\n\nThe result for Alice winning the game is the value of `dp[n]`.\n    ", "c++": "\n    ```cpp\nbool winnerSquareGame(int n) {\n    vector<bool> dp(n + 1, false);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j * j <= i; ++j) {\n            if (!dp[i - j * j]) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a boolean array `dp` of size `(n + 1)` to store if the current player can win with the remaining stones at position `i`. Each entry `dp[i]` is set to `false` initially.\n\nWe iterate through all possible numbers of stones from `1` to `n`. For each stone `i`, we iterate through all possible square numbers `j` less than or equal to `i`. Inside the inner loop, we check if the current player, when playing optimally, can win using the stones `i - j*j`. If the current player cannot win (`dp[i - j * j]` is false), it means the current player can win using the square number `j` and we set `dp[i]` to `true`.\n\nThe result for Alice winning the game is the value of `dp[n]`.\n    ", "python": "\n    ```python\ndef winnerSquareGame(n: int) -> bool:\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    return dp[n]\n```\n    \n    We use dynamic programming to solve this problem. We create a boolean array `dp` of size `(n + 1)` to store if the current player can win with the remaining stones at position `i`. Each entry `dp[i]` is set to `false` initially.\n\nWe iterate through all possible numbers of stones from `1` to `n`. For each stone `i`, we iterate through all possible square numbers `j` less than or equal to `i`. Inside the inner loop, we check if the current player, when playing optimally, can win using the stones `i - j*j`. If the current player cannot win (`dp[i - j * j]` is false), it means the current player can win using the square number `j` and we set `dp[i]` to `true`.\n\nThe result for Alice winning the game is the value of `dp[n]`.\n    ", "javascript": "\n    ```javascript\nfunction winnerSquareGame(n) {\n    const dp = new Array(n + 1).fill(false);\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j * j <= i; j++) {\n            if (!dp[i - j * j]) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a boolean array `dp` of size `(n + 1)` to store if the current player can win with the remaining stones at position `i`. Each entry `dp[i]` is set to `false` initially.\n\nWe iterate through all possible numbers of stones from `1` to `n`. For each stone `i`, we iterate through all possible square numbers `j` less than or equal to `i`. Inside the inner loop, we check if the current player, when playing optimally, can win using the stones `i - j*j`. If the current player cannot win (`dp[i - j * j]` is false), it means the current player can win using the square number `j` and we set `dp[i]` to `true`.\n\nThe result for Alice winning the game is the value of `dp[n]`.\n    "}
{"id": 1621, "slug": "number-of-sets-of-k-non-overlapping-line-segments", "title": "Number of Sets of K Non-Overlapping Line Segments", "difficulty": "Medium", "content": "Given `n` points on a 1-D plane, where the `ith` point (from `0` to `n-1`) is at `x = i`, find the number of ways we can draw **exactly** `k` **non-overlapping** line segments such that each segment covers two or more points. The endpoints of each segment must have **integral coordinates**. The `k` line segments **do not** have to cover all `n` points, and they are **allowed** to share endpoints.\n\nReturn _the number of ways we can draw_ `k` _non-overlapping line segments__._ Since this number can be huge, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 4, k = 2\n**Output:** 5\n**Explanation:** The two line segments are shown in red and blue.\nThe image above shows the 5 different ways {(0,2),(2,3)}, {(0,1),(1,3)}, {(0,1),(2,3)}, {(1,2),(2,3)}, {(0,1),(1,2)}.\n\n**Example 2:**\n\n**Input:** n = 3, k = 1\n**Output:** 3\n**Explanation:** The 3 ways are {(0,1)}, {(0,2)}, {(1,2)}.\n\n**Example 3:**\n\n**Input:** n = 30, k = 7\n**Output:** 796297179\n**Explanation:** The total number of possible ways to draw 7 line segments is 3796297200. Taking this number modulo 109 + 7 gives us 796297179.\n\n**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `1 <= k <= n-1`", "java": "\n    ```java\nimport java.util.Arrays;\n\nclass Solution {\n    public int numSubseq(int[] nums, int target) {\n        int n = nums.length;\n        int mod = 1000000007;\n\n        Arrays.sort(nums);\n\n        long[] power = new long[n];\n        power[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            power[i] = (power[i - 1] * 2) % mod;\n        }\n\n        int ans = 0;\n        int r = n;\n\n        for (int l = 0; l < n; ++l) {\n            while (r > l && nums[l] + nums[r - 1] > target) {\n                --r;\n            }\n\n            ans = (ans + (int)power[r - l]) % mod;\n        }\n\n        return ans;\n    }\n}\n```\n\n    \n    1. Sort the nums array in ascending order.\n2. Initialize an array `power` of length n, with `power[0] = 1`, and `power[i] = (power[i - 1] * 2) % mod` for `1 <= i < n`.\n3. Initialize variables `ans` to store the number of valid subsequences and `r` to point at the end of the nums array.\n4. Iterate from the left side of the nums array with variable `l`. In each iteration:\n   a. Move the pointer `r` to the left as long as the sum of nums[l] and nums[r - 1] is greater than the target.\n   b. Add `power[r - l]` to the answer (modulo mod).\n5. Return the final answer (modulo mod).\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint numSubseq(std::vector<int>& nums, int target) {\n    int n = nums.size();\n    int mod = 1e9 + 7;\n\n    std::sort(nums.begin(), nums.end());\n\n    std::vector<long long> power(n, 1);\n    for (int i = 1; i < n; ++i) {\n        power[i] = (power[i - 1] * 2) % mod;\n    }\n\n    int ans = 0;\n    int r = n;\n    for (int l = 0; l < n; ++l) {\n        while (r > l && nums[l] + nums[r - 1] > target) {\n            --r;\n        }\n\n        ans = (ans + power[r - l]) % mod;\n    }\n\n    return ans;\n}\n```\n\n    \n    1. Sort the nums array in ascending order.\n2. Initialize an array `power` of length n, with `power[0] = 1`, and `power[i] = (power[i - 1] * 2) % mod` for `1 <= i < n`.\n3. Initialize variables `ans` to store the number of valid subsequences and `r` to point at the end of the nums array.\n4. Iterate from the left side of the nums array with variable `l`. In each iteration:\n   a. Move the pointer `r` to the left as long as the sum of nums[l] and nums[r - 1] is greater than the target.\n   b. Add `power[r - l]` to the answer (modulo mod).\n5. Return the final answer (modulo mod).\n    ", "python": "\n    ```python\ndef numSubseq(nums, target):\n    nums.sort()\n    n = len(nums)\n    mod = 10**9 + 7\n\n    power = [1] * n\n    for i in range(1, n):\n        power[i] = (power[i - 1] * 2) % mod\n\n    ans = 0\n    r = n\n    for l in range(n):\n        while r > l and nums[l] + nums[r - 1] > target:\n            r -= 1\n\n        ans = (ans + power[r - l]) % mod\n\n    return ans\n```\n\n    \n    1. Sort the nums array in ascending order.\n2. Initialize an array `power` of length n, with `power[0] = 1`, and `power[i] = (power[i - 1] * 2) % mod` for `1 <= i < n`.\n3. Initialize variables `ans` to store the number of valid subsequences and `r` to point at the end of the nums array.\n4. Iterate from the left side of the nums array with variable `l`. In each iteration:\n   a. Move the pointer `r` to the left as long as the sum of nums[l] and nums[r - 1] is greater than the target.\n   b. Add `power[r - l]` to the answer (modulo mod).\n5. Return the final answer (modulo mod).\n    ", "javascript": "\n    ```javascript\nfunction numSubseq(nums, target) {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    const mod = 1e9 + 7;\n\n    const power = new Array(n).fill(1);\n    for (let i = 1; i < n; ++i) {\n        power[i] = (power[i - 1] * 2) % mod;\n    }\n\n    let ans = 0;\n    let r = n;\n    for (let l = 0; l < n; ++l) {\n        while (r > l && nums[l] + nums[r - 1] > target) {\n            --r;\n        }\n\n        ans = (ans + power[r - l]) % mod;\n    }\n\n    return ans;\n}\n```\n\n    \n    1. Sort the nums array in ascending order.\n2. Initialize an array `power` of length n, with `power[0] = 1`, and `power[i] = (power[i - 1] * 2) % mod` for `1 <= i < n`.\n3. Initialize variables `ans` to store the number of valid subsequences and `r` to point at the end of the nums array.\n4. Iterate from the left side of the nums array with variable `l`. In each iteration:\n   a. Move the pointer `r` to the left as long as the sum of nums[l] and nums[r - 1] is greater than the target.\n   b. Add `power[r - l]` to the answer (modulo mod).\n5. Return the final answer (modulo mod).\n    "}
{"id": 1626, "slug": "best-team-with-no-conflicts", "title": "Best Team With No Conflicts", "difficulty": "Medium", "content": "You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the **sum** of scores of all the players in the team.\n\nHowever, the basketball team is not allowed to have **conflicts**. A **conflict** exists if a younger player has a **strictly higher** score than an older player. A conflict does **not** occur between players of the same age.\n\nGiven two lists, `scores` and `ages`, where each `scores[i]` and `ages[i]` represents the score and age of the `ith` player, respectively, return _the highest overall score of all possible basketball teams_.\n\n**Example 1:**\n\n**Input:** scores = \\[1,3,5,10,15\\], ages = \\[1,2,3,4,5\\]\n**Output:** 34\n**Explanation:** You can choose all the players.\n\n**Example 2:**\n\n**Input:** scores = \\[4,5,6,5\\], ages = \\[2,1,2,1\\]\n**Output:** 16\n**Explanation:** It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n\n**Example 3:**\n\n**Input:** scores = \\[1,2,3,5\\], ages = \\[8,9,10,1\\]\n**Output:** 6\n**Explanation:** It is best to choose the first 3 players. \n\n**Constraints:**\n\n*   `1 <= scores.length, ages.length <= 1000`\n*   `scores.length == ages.length`\n*   `1 <= scores[i] <= 106`\n*   `1 <= ages[i] <= 1000`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic boolean canMakeArithmeticProgression(int[] arr) {\n    Arrays.sort(arr);\n    int difference = arr[1] - arr[0];\n    for (int i = 2; i < arr.length; i++) {\n        if (arr[i] - arr[i - 1] != difference) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    1. Sort the array in ascending order.\n2. Calculate the difference between the first two elements.\n3. Iterate through the rest of the array and check whether the difference between the consecutive elements remains the same as the initial difference.\n4. If the difference is the same for all consecutive elements, return true, otherwise return false.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nbool canMakeArithmeticProgression(vector<int>& arr) {\n    sort(arr.begin(), arr.end());\n    int difference = arr[1] - arr[0];\n    for (int i = 2; i < arr.size(); i++) {\n        if (arr[i] - arr[i - 1] != difference) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    1. Sort the array in ascending order.\n2. Calculate the difference between the first two elements.\n3. Iterate through the rest of the array and check whether the difference between the consecutive elements remains the same as the initial difference.\n4. If the difference is the same for all consecutive elements, return true, otherwise return false.\n    ", "python": "\n    ```python\ndef can_make_arithmetic_progression(arr):\n    arr.sort()\n    difference = arr[1] - arr[0]\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i - 1] != difference:\n            return False\n    return True\n```\n    \n    1. Sort the array in ascending order.\n2. Calculate the difference between the first two elements.\n3. Iterate through the rest of the array and check whether the difference between the consecutive elements remains the same as the initial difference.\n4. If the difference is the same for all consecutive elements, return true, otherwise return false.\n    ", "javascript": "\n    ```javascript\nfunction canMakeArithmeticProgression(arr) {\n    arr.sort((a, b) => a - b);\n    const difference = arr[1] - arr[0];\n    for (let i = 2; i < arr.length; i++) {\n        if (arr[i] - arr[i - 1] !== difference) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    1. Sort the array in ascending order.\n2. Calculate the difference between the first two elements.\n3. Iterate through the rest of the array and check whether the difference between the consecutive elements remains the same as the initial difference.\n4. If the difference is the same for all consecutive elements, return true, otherwise return false.\n    "}
{"id": 1638, "slug": "count-substrings-that-differ-by-one-character", "title": "Count Substrings That Differ by One Character", "difficulty": "Medium", "content": "Given two strings `s` and `t`, find the number of ways you can choose a non-empty substring of `s` and replace a **single character** by a different character such that the resulting substring is a substring of `t`. In other words, find the number of substrings in `s` that differ from some substring in `t` by **exactly** one character.\n\nFor example, the underlined substrings in `\"computer \"` and `\"computation \"` only differ by the `'e'`/`'a'`, so this is a valid way.\n\nReturn _the number of substrings that satisfy the condition above._\n\nA **substring** is a contiguous sequence of characters within a string.\n\n**Example 1:**\n\n**Input:** s =  \"aba \", t =  \"baba \"\n**Output:** 6\n**Explanation:** The following are the pairs of substrings from s and t that differ by exactly 1 character:\n( \"aba \",  \"baba \")\n( \"aba \",  \"baba \")\n( \"aba \",  \"baba \")\n( \"aba \",  \"baba \")\n( \"aba \",  \"baba \")\n( \"aba \",  \"baba \")\nThe underlined portions are the substrings that are chosen from s and t.\n\n\u200b\u200b**Example 2:**\n\n**Input:** s =  \"ab \", t =  \"bb \"\n**Output:** 3\n**Explanation:** The following are the pairs of substrings from s and t that differ by 1 character:\n( \"ab \",  \"bb \")\n( \"ab \",  \"bb \")\n( \"ab \",  \"bb \")\n\u200b\u200b\u200b\u200bThe underlined portions are the substrings that are chosen from s and t.\n\n**Constraints:**\n\n*   `1 <= s.length, t.length <= 100`\n*   `s` and `t` consist of lowercase English letters only.", "java": "\n    ```java\npublic double getMinDistSum(int[][] positions) {\n    double x = 0;\n    double y = 0;\n    int n = positions.length;\n    for (int i = 0; i < n; i++) {\n        x += positions[i][0];\n        y += positions[i][1];\n    }\n    x /= n;\n    y /= n;\n    return x;\n}\n```\n    \n    The algorithm above calculates the centroid of all the customers' positions by this logic:\n1. Initialize `x` and `y` to 0. These represent the sum of individual positions' x and y values, respectively.\n2. Iterate through the input positions array and accumulate the x and y values.\n3. Divide the accumulated x and y values by the number of input positions to find the average (centroid) position.\n\nHowever, the solution above does not consider the Euclidean distance, and the return statement has a mistake as it only returns `x`. The solution needs to be improved by incorporating the geometric median calculation.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\ndouble getMinDistSum(std::vector<std::vector<int>>& positions) {\n    double x = 0;\n    double y = 0;\n    for (const auto& pos : positions) {\n        x += pos[0];\n        y += pos[1];\n    }\n    int n = positions.size();\n    x /= n;\n    y /= n;\n    return x;\n}\n```\n    \n    The algorithm above calculates the centroid of all the customers' positions by this logic:\n1. Initialize `x` and `y` to 0. These represent the sum of individual positions' x and y values, respectively.\n2. Iterate through the input positions array and accumulate the x and y values.\n3. Divide the accumulated x and y values by the number of input positions to find the average (centroid) position.\n\nHowever, the solution above does not consider the Euclidean distance, and the return statement has a mistake as it only returns `x`. The solution needs to be improved by incorporating the geometric median calculation.\n    ", "python": "\n    ```python\ndef get_min_dist_sum(positions: List[List[int]]) -> float:\n    x, y = 0, 0\n    n = len(positions)\n    for pos in positions:\n        x += pos[0]\n        y += pos[1]\n    x /= n\n    y /= n\n    return x\n```\n    \n    The algorithm above calculates the centroid of all the customers' positions by this logic:\n1. Initialize `x` and `y` to 0. These represent the sum of individual positions' x and y values, respectively.\n2. Iterate through the input positions array and accumulate the x and y values.\n3. Divide the accumulated x and y values by the number of input positions to find the average (centroid) position.\n\nHowever, the solution above does not consider the Euclidean distance, and the return statement has a mistake as it only returns `x`. The solution needs to be improved by incorporating the geometric median calculation.\n    ", "javascript": "\n    ```javascript\nfunction getMinDistSum(positions) {\n    let x = 0;\n    let y = 0;\n    const n = positions.length;\n    for (let i = 0; i < n; i++) {\n        x += positions[i][0];\n        y += positions[i][1];\n    }\n    x /= n;\n    y /= n;\n    return x;\n}\n```\n    \n    The algorithm above calculates the centroid of all the customers' positions by this logic:\n1. Initialize `x` and `y` to 0. These represent the sum of individual positions' x and y values, respectively.\n2. Iterate through the input positions array and accumulate the x and y values.\n3. Divide the accumulated x and y values by the number of input positions to find the average (centroid) position.\n\nHowever, the solution above does not consider the Euclidean distance, and the return statement has a mistake as it only returns `x`. The solution needs to be improved by incorporating the geometric median calculation.\n    "}
{"id": 1643, "slug": "kth-smallest-instructions", "title": "Kth Smallest Instructions", "difficulty": "Hard", "content": "Bob is standing at cell `(0, 0)`, and he wants to reach `destination`: `(row, column)`. He can only travel **right** and **down**. You are going to help Bob by providing **instructions** for him to reach `destination`.\n\nThe **instructions** are represented as a string, where each character is either:\n\n*   `'H'`, meaning move horizontally (go **right**), or\n*   `'V'`, meaning move vertically (go **down**).\n\nMultiple **instructions** will lead Bob to `destination`. For example, if `destination` is `(2, 3)`, both `\"HHHVV \"` and `\"HVHVH \"` are valid **instructions**.\n\nHowever, Bob is very picky. Bob has a lucky number `k`, and he wants the `kth` **lexicographically smallest instructions** that will lead him to `destination`. `k` is **1-indexed**.\n\nGiven an integer array `destination` and an integer `k`, return _the_ `kth` _**lexicographically smallest instructions** that will take Bob to_ `destination`.\n\n**Example 1:**\n\n**Input:** destination = \\[2,3\\], k = 1\n**Output:**  \"HHHVV \"\n**Explanation:** All the instructions that reach (2, 3) in lexicographic order are as follows:\n\\[ \"HHHVV \",  \"HHVHV \",  \"HHVVH \",  \"HVHHV \",  \"HVHVH \",  \"HVVHH \",  \"VHHHV \",  \"VHHVH \",  \"VHVHH \",  \"VVHHH \"\\].\n\n**Example 2:**\n\n**Input:** destination = \\[2,3\\], k = 2\n**Output:**  \"HHVHV \"\n\n**Example 3:**\n\n**Input:** destination = \\[2,3\\], k = 3\n**Output:**  \"HHVVH \"\n\n**Constraints:**\n\n*   `destination.length == 2`\n*   `1 <= row, column <= 15`\n*   `1 <= k <= nCr(row + column, row)`, where `nCr(a, b)` denotes `a` choose `b`\u200b\u200b\u200b\u200b\u200b.", "java": "\n    ```java\nimport java.util.*;\n\npublic int[] countSubTrees(int n, int[][] edges, String labels) {\n    ArrayList<ArrayList<Integer>> g = new ArrayList<>();\n    for (int i = 0; i < n; ++i) g.add(new ArrayList<>());\n    for (int[] edge : edges) g.get(edge[1]).add(edge[0]);\n    int[] ans = new int[n];\n    int[] count = new int[26];\n    dfs(0, g, labels, ans, count);\n    return ans;\n}\n\nprivate void dfs(int node, ArrayList<ArrayList<Integer>> g, String labels, int[] ans, int[] count) {\n    int pre = count[labels.charAt(node) - 'a'];\n    count[labels.charAt(node) - 'a']++;\n    ans[node] = count[labels.charAt(node) - 'a'] - pre;\n    for (int child : g.get(node)) dfs(child, g, labels, ans, count);\n    count[labels.charAt(node) - 'a'] = pre;\n}\n```\n    \n    The algorithm consists of performing a depth-first search (DFS) traversal on the given tree starting from the root node (i.e. node 0). While traversing the tree, maintain a count array to keep track of the labels of the visited nodes. When visiting a node, store the current count of the node's label and increment the count, then visit its child nodes. Calculate the answer for the current node by subtracting the previous count from the updated count. After visiting all the children of a node, restore the previous count of the node's label so that it has the correct count when visiting the siblings in the higher level of the tree traversal. Finally, return the answer vector containing the count of nodes with the same label for each node in their corresponding subtree.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid dfs(int node, const vector<vector<int>>& g, const string& labels, vector<int>& ans, vector<int> &count) {\n    int pre = count[labels[node] - 'a'];\n    count[labels[node] - 'a']++;\n    ans[node] = count[labels[node] - 'a'] - pre;\n    \n    for (auto child : g[node]) {\n        dfs(child, g, labels, ans, count);\n    }\n    \n    count[labels[node] - 'a'] = pre;\n}\n\nvector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n    vector<vector<int>> g(n);\n    for (const auto& edge : edges) {\n        g[edge[1]].push_back(edge[0]);\n    }\n    vector<int> ans(n);\n    vector<int> count(26);\n    dfs(0, g, labels, ans, count);\n    \n    return ans;\n}\n```\n    \n    The algorithm consists of performing a depth-first search (DFS) traversal on the given tree starting from the root node (i.e. node 0). While traversing the tree, maintain a count array to keep track of the labels of the visited nodes. When visiting a node, store the current count of the node's label and increment the count, then visit its child nodes. Calculate the answer for the current node by subtracting the previous count from the updated count. After visiting all the children of a node, restore the previous count of the node's label so that it has the correct count when visiting the siblings in the higher level of the tree traversal. Finally, return the answer vector containing the count of nodes with the same label for each node in their corresponding subtree.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\n\ndef dfs(node, tree, labels, ans, count):\n    prev_count = count[labels[node]]\n    count[labels[node]] += 1\n    ans[node] = count[labels[node]] - prev_count\n\n    for child in tree[node]:\n        dfs(child, tree, labels, ans, count)\n\n    count[labels[node]] = prev_count\n\ndef countSubTrees(n, edges, labels):\n    tree = defaultdict(list)\n    for edge in edges:\n        tree[edge[1]].append(edge[0])\n\n    ans = [0] * n\n    count = defaultdict(int)\n    dfs(0, tree, labels, ans, count)\n\n    return ans\n```\n    \n    The algorithm consists of performing a depth-first search (DFS) traversal on the given tree starting from the root node (i.e. node 0). While traversing the tree, maintain a count array to keep track of the labels of the visited nodes. When visiting a node, store the current count of the node's label and increment the count, then visit its child nodes. Calculate the answer for the current node by subtracting the previous count from the updated count. After visiting all the children of a node, restore the previous count of the node's label so that it has the correct count when visiting the siblings in the higher level of the tree traversal. Finally, return the answer vector containing the count of nodes with the same label for each node in their corresponding subtree.\n    ", "javascript": "\n    ```javascript\nfunction dfs(node, tree, labels, ans, count) {\n  const prevCount = count[labels[node]];\n  count[labels[node]]++;\n  ans[node] = count[labels[node]] - prevCount;\n\n  for (const child of tree[node]) {\n    dfs(child, tree, labels, ans, count);\n  }\n\n  count[labels[node]] = prevCount;\n}\n\nfunction countSubTrees(n, edges, labels) {\n  const tree = new Array(n).fill(0).map(() => []);\n  for (const edge of edges) {\n    tree[edge[1]].push(edge[0]);\n  }\n\n  const ans = new Array(n).fill(0);\n  const count = new Array(26).fill(0);\n  dfs(0, tree, labels, ans, count);\n\n  return ans;\n}\n```\n    \n    The algorithm consists of performing a depth-first search (DFS) traversal on the given tree starting from the root node (i.e. node 0). While traversing the tree, maintain a count array to keep track of the labels of the visited nodes. When visiting a node, store the current count of the node's label and increment the count, then visit its child nodes. Calculate the answer for the current node by subtracting the previous count from the updated count. After visiting all the children of a node, restore the previous count of the node's label so that it has the correct count when visiting the siblings in the higher level of the tree traversal. Finally, return the answer vector containing the count of nodes with the same label for each node in their corresponding subtree.\n    "}
{"id": 1653, "slug": "minimum-deletions-to-make-string-balanced", "title": "Minimum Deletions to Make String Balanced", "difficulty": "Medium", "content": "You are given a string `s` consisting only of characters `'a'` and `'b'`\u200b\u200b\u200b\u200b.\n\nYou can delete any number of characters in `s` to make `s` **balanced**. `s` is **balanced** if there is no pair of indices `(i,j)` such that `i < j` and `s[i] = 'b'` and `s[j]= 'a'`.\n\nReturn _the **minimum** number of deletions needed to make_ `s` _**balanced**_.\n\n**Example 1:**\n\n**Input:** s =  \"aababbab \"\n**Output:** 2\n**Explanation:** You can either:\nDelete the characters at 0-indexed positions 2 and 6 ( \"aababbab \" ->  \"aaabbb \"), or\nDelete the characters at 0-indexed positions 3 and 6 ( \"aababbab \" ->  \"aabbbb \").\n\n**Example 2:**\n\n**Input:** s =  \"bbaaaaabb \"\n**Output:** 2\n**Explanation:** The only solution is to delete the first two characters.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is `'a'` or `'b'`\u200b\u200b.", "java": "\n    ```java\npublic int dfs(TreeNode root, int distance, List<Integer> depths) {\n    if (root == null) return 0;\n    if (root.left == null && root.right == null) {\n        depths.add(0);\n        return 1;\n    }\n    List<Integer> left = new ArrayList<>(), right = new ArrayList<>();\n    int count = dfs(root.left, distance, left) + dfs(root.right, distance, right);\n    for (int l : left) {\n        for (int r : right) {\n            if (l + r + 2 <= distance) count++;\n        }\n    }\n    for (int l : left) depths.add(l + 1);\n    for (int r : right) depths.add(r + 1);\n    return count;\n}\n\npublic int countPairs(TreeNode root, int distance) {\n    List<Integer> depths = new ArrayList<>();\n    return dfs(root, distance, depths);\n}\n```\n    \n    We use a Depth First Search (DFS) based algorithm to calculate the number of good leaf node pairs in the binary tree. Start by defining the DFS helper function that takes the root, distance, and depths (list to store depths).\n\n1. If the root does not exist, return 0.\n2. If both the left and right children of the root do not exist, then it is a leaf node. Append 0 to the depths list and return 1.\n3. Create left and right lists for storing depths from left and right subtrees respectively.\n4. Calculate count by recursively calling the dfs() function for left and right subtrees.\n5. Now, iterate through each of the left and right lists to calculate the number of good leaf node pairs.\n6. If the sum of two values (l and r) from the depths list plus 2 is less than or equal to the distance, increment the count.\n7. Update the depths list by increasing the depth of left and right lists elements by 1.\n8. Return the total count.\n9. In the main function (countPairs), initialize an empty depths list and call the dfs() function. Return the number of good leaf node pairs.\n    ", "c++": "\n    ```cpp\nint dfs(TreeNode* root, int distance, vector<int>& depths) {\n    if (!root) return 0;\n    if (!root->left && !root->right) {\n        depths.push_back(0);\n        return 1;\n    }\n    vector<int> left, right;\n    int count = dfs(root->left, distance, left) + dfs(root->right, distance, right);\n    for (int l : left) {\n        for (int r : right) {\n            if (l + r + 2 <= distance) count++;\n        }\n    }\n    for (int l : left) depths.push_back(l + 1);\n    for (int r : right) depths.push_back(r + 1);\n    return count;\n}\n\nint countPairs(TreeNode* root, int distance) {\n    vector<int> depths;\n    return dfs(root, distance, depths);\n}\n```\n    \n    We use a Depth First Search (DFS) based algorithm to calculate the number of good leaf node pairs in the binary tree. Start by defining the DFS helper function that takes the root, distance, and depths (list to store depths).\n\n1. If the root does not exist, return 0.\n2. If both the left and right children of the root do not exist, then it is a leaf node. Append 0 to the depths list and return 1.\n3. Create left and right lists for storing depths from left and right subtrees respectively.\n4. Calculate count by recursively calling the dfs() function for left and right subtrees.\n5. Now, iterate through each of the left and right lists to calculate the number of good leaf node pairs.\n6. If the sum of two values (l and r) from the depths list plus 2 is less than or equal to the distance, increment the count.\n7. Update the depths list by increasing the depth of left and right lists elements by 1.\n8. Return the total count.\n9. In the main function (countPairs), initialize an empty depths list and call the dfs() function. Return the number of good leaf node pairs.\n    ", "python": "\n    ```python\ndef dfs(root, distance, depths):\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        depths.append(0)\n        return 1\n    left, right = [], []\n    count = dfs(root.left, distance, left) + dfs(root.right, distance, right)\n    for l in left:\n        for r in right:\n            if l + r + 2 <= distance:\n                count += 1\n    depths.extend(l + 1 for l in left)\n    depths.extend(r + 1 for r in right)\n    return count\n\ndef countPairs(root, distance):\n    depths = []\n    return dfs(root, distance, depths)\n```\n    \n    We use a Depth First Search (DFS) based algorithm to calculate the number of good leaf node pairs in the binary tree. Start by defining the DFS helper function that takes the root, distance, and depths (list to store depths).\n\n1. If the root does not exist, return 0.\n2. If both the left and right children of the root do not exist, then it is a leaf node. Append 0 to the depths list and return 1.\n3. Create left and right lists for storing depths from left and right subtrees respectively.\n4. Calculate count by recursively calling the dfs() function for left and right subtrees.\n5. Now, iterate through each of the left and right lists to calculate the number of good leaf node pairs.\n6. If the sum of two values (l and r) from the depths list plus 2 is less than or equal to the distance, increment the count.\n7. Update the depths list by increasing the depth of left and right lists elements by 1.\n8. Return the total count.\n9. In the main function (countPairs), initialize an empty depths list and call the dfs() function. Return the number of good leaf node pairs.\n    ", "javascript": "\n    ```javascript\nfunction dfs(root, distance, depths) {\n    if (!root) return 0;\n    if (!root.left && !root.right) {\n        depths.push(0);\n        return 1;\n    }\n    let left = [], right = [];\n    let count = dfs(root.left, distance, left) + dfs(root.right, distance, right);\n    for (let l of left) {\n        for (let r of right) {\n            if (l + r + 2 <= distance) count++;\n        }\n    }\n    depths.push(...left.map(l => l + 1), ...right.map(r => r + 1));\n    return count;\n}\n\nfunction countPairs(root, distance) {\n    let depths = [];\n    return dfs(root, distance, depths);\n}\n```\n    \n    We use a Depth First Search (DFS) based algorithm to calculate the number of good leaf node pairs in the binary tree. Start by defining the DFS helper function that takes the root, distance, and depths (list to store depths).\n\n1. If the root does not exist, return 0.\n2. If both the left and right children of the root do not exist, then it is a leaf node. Append 0 to the depths list and return 1.\n3. Create left and right lists for storing depths from left and right subtrees respectively.\n4. Calculate count by recursively calling the dfs() function for left and right subtrees.\n5. Now, iterate through each of the left and right lists to calculate the number of good leaf node pairs.\n6. If the sum of two values (l and r) from the depths list plus 2 is less than or equal to the distance, increment the count.\n7. Update the depths list by increasing the depth of left and right lists elements by 1.\n8. Return the total count.\n9. In the main function (countPairs), initialize an empty depths list and call the dfs() function. Return the number of good leaf node pairs.\n    "}
{"id": 1659, "slug": "maximize-grid-happiness", "title": "Maximize Grid Happiness", "difficulty": "Hard", "content": "You are given four integers, `m`, `n`, `introvertsCount`, and `extrovertsCount`. You have an `m x n` grid, and there are two types of people: introverts and extroverts. There are `introvertsCount` introverts and `extrovertsCount` extroverts.\n\nYou should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you **do not** have to have all the people living in the grid.\n\nThe **happiness** of each person is calculated as follows:\n\n*   Introverts **start** with `120` happiness and **lose** `30` happiness for each neighbor (introvert or extrovert).\n*   Extroverts **start** with `40` happiness and **gain** `20` happiness for each neighbor (introvert or extrovert).\n\nNeighbors live in the directly adjacent cells north, east, south, and west of a person's cell.\n\nThe **grid happiness** is the **sum** of each person's happiness. Return _the **maximum possible grid happiness**._\n\n**Example 1:**\n\n**Input:** m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\n**Output:** 240\n**Explanation:** Assume the grid is 1-indexed with coordinates (row, column).\nWe can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (0 \\* 30) (0 neighbors) = 120\n- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 \\* 20) (1 neighbor) = 60\n- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 \\* 20) (1 neighbor) = 60\nThe grid happiness is 120 + 60 + 60 = 240.\nThe above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.\n\n**Example 2:**\n\n**Input:** m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\n**Output:** 260\n**Explanation:** Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (1 \\* 30) (1 neighbor) = 90\n- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 \\* 20) (2 neighbors) = 80\n- Introvert at (3,1) happiness: 120 (starting happiness) - (1 \\* 30) (1 neighbor) = 90\nThe grid happiness is 90 + 80 + 90 = 260.\n\n**Example 3:**\n\n**Input:** m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\n**Output:** 240\n\n**Constraints:**\n\n*   `1 <= m, n <= 5`\n*   `0 <= introvertsCount, extrovertsCount <= min(m * n, 6)`", "java": "\n    ```java\nimport java.util.*;\n\npublic int maxSum(int[] nums1, int[] nums2) {\n    int mod = 1000000007;\n    int m = nums1.length, n = nums2.length;\n    long[] dp1 = new long[m + 1], dp2 = new long[n + 1];\n    int i = m - 1, j = n - 1;\n    while (i >= 0 || j >= 0) {\n        long a = i >= 0 ? dp1[i] + nums1[i] : Long.MIN_VALUE;\n        long b = j >= 0 ? dp2[j] + nums2[j] : Long.MIN_VALUE;\n        Set<Integer> seen = new HashSet<>();\n        if (a > b) {\n            dp1[i--] = a % mod;\n            seen.add(nums1[i + 1]);\n        } else {\n            dp2[j--] = b % mod;\n            seen.add(nums2[j + 1]);\n        }\n    }\n    return (int) Math.max(dp1[0], dp2[0]) % mod;\n}\n```\n    \n    The algorithm used to solve this problem is dynamic programming. We create two dp arrays, dp1 and dp2, for nums1 and nums2 respectively. We loop in reverse through both nums1 and nums2, and for each step, we calculate the current sum with the current nums1[i] or nums2[j]. We track the uniques values using the 'seen' set. We'll update the dp array with the maximum sum at each step. Finally, we return the maximum value of the two dp arrays modulo 10^9 + 7.\n\nAt each step, the time complexity is O(1), and we need to perform a total of m + n steps where m and n are the sizes of nums1 and nums2. So, the total time complexity is O(m+n).\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <set>\nusing namespace std;\n\nint maxSum(vector<int>& nums1, vector<int>& nums2) {\n    int mod = 1e9 + 7;\n    int m = nums1.size(), n = nums2.size();\n    long dp1[m + 1] = {0}, dp2[n + 1] = {0};\n    int i = m - 1, j = n - 1;\n    while (i >= 0 || j >= 0) {\n        long a = i >= 0 ? dp1[i] + nums1[i] : LONG_MIN;\n        long b = j >= 0 ? dp2[j] + nums2[j] : LONG_MIN;\n        set<int> seen;\n        if (a > b) {\n            dp1[i--] = a % mod;\n            seen.insert(nums1[i + 1]);\n        } else {\n            dp2[j--] = b % mod;\n            seen.insert(nums2[j + 1]);\n        }\n    }\n    return max(dp1[0], dp2[0]) % mod;\n}\n```\n    \n    The algorithm used to solve this problem is dynamic programming. We create two dp arrays, dp1 and dp2, for nums1 and nums2 respectively. We loop in reverse through both nums1 and nums2, and for each step, we calculate the current sum with the current nums1[i] or nums2[j]. We track the uniques values using the 'seen' set. We'll update the dp array with the maximum sum at each step. Finally, we return the maximum value of the two dp arrays modulo 10^9 + 7.\n\nAt each step, the time complexity is O(1), and we need to perform a total of m + n steps where m and n are the sizes of nums1 and nums2. So, the total time complexity is O(m+n).\n    ", "python": "\n    ```python\ndef maxSum(nums1, nums2):\n    mod = 10**9 + 7\n    m, n = len(nums1), len(nums2)\n    dp1, dp2 = [0] * (m + 1), [0] * (n + 1)\n    i, j = m - 1, n - 1\n    while i >= 0 or j >= 0:\n        a = dp1[i] + nums1[i] if i >= 0 else float('-inf')\n        b = dp2[j] + nums2[j] if j >= 0 else float('-inf')\n        seen = set()\n        if a > b:\n            dp1[i] = a % mod\n            i -= 1\n            seen.add(nums1[i + 1])\n        else:\n            dp2[j] = b % mod\n            j -= 1\n            seen.add(nums2[j + 1])\n    return max(dp1[0], dp2[0]) % mod\n```\n    \n    The algorithm used to solve this problem is dynamic programming. We create two dp arrays, dp1 and dp2, for nums1 and nums2 respectively. We loop in reverse through both nums1 and nums2, and for each step, we calculate the current sum with the current nums1[i] or nums2[j]. We track the uniques values using the 'seen' set. We'll update the dp array with the maximum sum at each step. Finally, we return the maximum value of the two dp arrays modulo 10^9 + 7.\n\nAt each step, the time complexity is O(1), and we need to perform a total of m + n steps where m and n are the sizes of nums1 and nums2. So, the total time complexity is O(m+n).\n    ", "javascript": "\n    ```javascript\nfunction maxSum(nums1, nums2) {\n    const mod = 1e9 + 7;\n    const m = nums1.length, n = nums2.length;\n    const dp1 = new Array(m + 1).fill(0), dp2 = new Array(n + 1).fill(0);\n    let i = m - 1, j = n - 1;\n    while (i >= 0 || j >= 0) {\n        const a = i >= 0 ? dp1[i] + nums1[i] : Number.MIN_SAFE_INTEGER;\n        const b = j >= 0 ? dp2[j] + nums2[j] : Number.MIN_SAFE_INTEGER;\n        const seen = new Set();\n        if (a > b) {\n            dp1[i--] = a % mod;\n            seen.add(nums1[i + 1]);\n        } else {\n            dp2[j--] = b % mod;\n            seen.add(nums2[j + 1]);\n        }\n    }\n    return Math.max(dp1[0], dp2[0]) % mod;\n}\n```\n    \n    The algorithm used to solve this problem is dynamic programming. We create two dp arrays, dp1 and dp2, for nums1 and nums2 respectively. We loop in reverse through both nums1 and nums2, and for each step, we calculate the current sum with the current nums1[i] or nums2[j]. We track the uniques values using the 'seen' set. We'll update the dp array with the maximum sum at each step. Finally, we return the maximum value of the two dp arrays modulo 10^9 + 7.\n\nAt each step, the time complexity is O(1), and we need to perform a total of m + n steps where m and n are the sizes of nums1 and nums2. So, the total time complexity is O(m+n).\n    "}
{"id": 1668, "slug": "maximum-repeating-substring", "title": "Maximum Repeating Substring", "difficulty": "Easy", "content": "For a string `sequence`, a string `word` is **`k`\\-repeating** if `word` concatenated `k` times is a substring of `sequence`. The `word`'s **maximum `k`\\-repeating value** is the highest value `k` where `word` is `k`\\-repeating in `sequence`. If `word` is not a substring of `sequence`, `word`'s maximum `k`\\-repeating value is `0`.\n\nGiven strings `sequence` and `word`, return _the **maximum `k`\\-repeating value** of `word` in `sequence`_.\n\n**Example 1:**\n\n**Input:** sequence =  \"ababc \", word =  \"ab \"\n**Output:** 2\n**Explanation: ** \"abab \" is a substring in  \"ababc \".\n\n**Example 2:**\n\n**Input:** sequence =  \"ababc \", word =  \"ba \"\n**Output:** 1\n**Explanation: ** \"ba \" is a substring in  \"ababc \".  \"baba \" is not a substring in  \"ababc \".\n\n**Example 3:**\n\n**Input:** sequence =  \"ababc \", word =  \"ac \"\n**Output:** 0\n**Explanation: ** \"ac \" is not a substring in  \"ababc \". \n\n**Constraints:**\n\n*   `1 <= sequence.length <= 100`\n*   `1 <= word.length <= 100`\n*   `sequence` and `word` contains only lowercase English letters.", "java": "\n    ```java\nint longestAwesomeSubstring(String s) {\n    int n = s.length();\n    int maxLen = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            String substr = s.substring(i, j);\n            if (isAwesome(substr)) {\n                maxLen = Math.max(maxLen, j - i);\n            }\n        }\n    }\n    return maxLen;\n}\n\nboolean isAwesome(String s) {\n    int odd_count = 0;\n    int[] freq = new int[26];\n    for (char c : s.toCharArray()) {\n        freq[c - 'a']++;\n    }\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] % 2 == 1) {\n            odd_count++;\n        }\n    }\n    return (odd_count <= 1);\n}\n```\n    \n    The algorithm starts by checking all possible substrings of the given string s. For each substring, it checks whether it's an awesome substring or not by calling the isAwesome function.\nThe isAwesome function calculates the frequency of each character in the string and counts the number of characters that have an odd frequency. If there are more than one characters with odd frequency, it returns false, otherwise, it returns true.\nFinally, the algorithm returns the length of the longest awesome substring found.\n    ", "c++": "\n    ```cpp\nint longestAwesomeSubstring(std::string s) {\n    int n = s.length();\n    int maxLen = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            std::string substr = s.substr(i, j - i);\n            if (isAwesome(substr)) {\n                maxLen = std::max(maxLen, j - i);\n            }\n        }\n    }\n    return maxLen;\n}\n\nbool isAwesome(std::string s) {\n    int odd_count = 0;\n    int freq[26] = {0};\n    for (char c : s) {\n        freq[c - 'a']++;\n    }\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] % 2 == 1) {\n            odd_count++;\n        }\n    }\n    return (odd_count <= 1);\n}\n```\n    \n    The algorithm starts by checking all possible substrings of the given string s. For each substring, it checks whether it's an awesome substring or not by calling the isAwesome function.\nThe isAwesome function calculates the frequency of each character in the string and counts the number of characters that have an odd frequency. If there are more than one characters with odd frequency, it returns false, otherwise, it returns true.\nFinally, the algorithm returns the length of the longest awesome substring found.\n    ", "python": "\n    ```python\ndef longestAwesomeSubstring(s):\n    n = len(s)\n    maxLen = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substr = s[i:j]\n            if isAwesome(substr):\n                maxLen = max(maxLen, j - i)\n    return maxLen\n\ndef isAwesome(s):\n    odd_count = 0\n    freq = [0] * 26\n    for c in s:\n        freq[ord(c) - ord('a')] += 1\n    for i in range(26):\n        if freq[i] % 2 == 1:\n            odd_count += 1\n    return odd_count <= 1\n```\n    \n    The algorithm starts by checking all possible substrings of the given string s. For each substring, it checks whether it's an awesome substring or not by calling the isAwesome function.\nThe isAwesome function calculates the frequency of each character in the string and counts the number of characters that have an odd frequency. If there are more than one characters with odd frequency, it returns false, otherwise, it returns true.\nFinally, the algorithm returns the length of the longest awesome substring found.\n    ", "javascript": "\n    ```javascript\nfunction longestAwesomeSubstring(s) {\n    let n = s.length;\n    let maxLen = 0;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j <= n; ++j) {\n            let substr = s.substring(i, j);\n            if (isAwesome(substr)) {\n                maxLen = Math.max(maxLen, j - i);\n            }\n        }\n    }\n    return maxLen;\n}\n\nfunction isAwesome(s) {\n    let odd_count = 0;\n    let freq = new Array(26).fill(0);\n    for (let c of s) {\n        freq[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    for (let i = 0; i < 26; i++) {\n        if (freq[i] % 2 == 1) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}\n```\n    \n    The algorithm starts by checking all possible substrings of the given string s. For each substring, it checks whether it's an awesome substring or not by calling the isAwesome function.\nThe isAwesome function calculates the frequency of each character in the string and counts the number of characters that have an odd frequency. If there are more than one characters with odd frequency, it returns false, otherwise, it returns true.\nFinally, the algorithm returns the length of the longest awesome substring found.\n    "}
{"id": 1682, "slug": "longest-palindromic-subsequence-ii", "title": "Longest Palindromic Subsequence II", "difficulty": "Medium", "content": "A subsequence of a string `s` is considered a **good palindromic subsequence** if:\n\n*   It is a subsequence of `s`.\n*   It is a palindrome (has the same value if reversed).\n*   It has an **even** length.\n*   No two consecutive characters are equal, except the two middle ones.\n\nFor example, if `s = \"abcabcabb \"`, then `\"abba \"` is considered a **good palindromic subsequence**, while `\"bcb \"` (not even length) and `\"bbbb \"` (has equal consecutive characters) are not.\n\nGiven a string `s`, return _the **length** of the **longest good palindromic subsequence** in_ `s`.\n\n**Example 1:**\n\n**Input:** s =  \"bbabab \"\n**Output:** 4\n**Explanation:** The longest good palindromic subsequence of s is  \"baab \".\n\n**Example 2:**\n\n**Input:** s =  \"dcbccacdb \"\n**Output:** 4\n**Explanation:** The longest good palindromic subsequence of s is  \"dccd \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 250`\n*   `s` consists of lowercase English letters.", "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> mostVisited(int n, int[] rounds) {\n    int[] visited = new int[n + 1];\n    for (int i = 1; i < rounds.length; ++i) {\n        for (int start = rounds[i - 1], end = rounds[i]; start != end; start = start % n + 1) {\n            ++visited[start];\n        }\n    }\n    ++visited[rounds[rounds.length - 1]];\n\n    int maxVisits = Arrays.stream(visited).max().getAsInt();\n    List<Integer> result = new ArrayList<>();\n\n    for (int i = 1; i <= n; ++i) {\n        if (visited[i] == maxVisits) {\n            result.add(i);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm initializes an array `visited` that counts the visits for each sector. We iterate over the given `rounds` array, and for each consecutive pair of sectors (i.e., from `rounds[i - 1]` to `rounds[i]`), we increment the count of visits for each sector in between (inclusive of the starting sector). After updating the visit count for each round, we find the maximum number of visits (`maxVisits`). Lastly, we iterate over the `visited` array and create a list of all sectors with maximum visits (`result`). The function returns the `result` list.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> mostVisited(int n, vector<int>& rounds) {\n    vector<int> visited(n + 1, 0);\n    \n    for (int i = 1; i < rounds.size(); i++) {\n        int start = rounds[i - 1], end = rounds[i];\n        while (start != end) {\n            visited[start]++;\n            start = start % n + 1;\n        }\n    }\n    visited[rounds.back()]++;\n    \n    int maxVisits = *max_element(visited.begin(), visited.end());\n    vector<int> result;\n    \n    for (int i = 1; i <= n; i++) {\n        if (visited[i] == maxVisits)\n            result.push_back(i);\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm initializes an array `visited` that counts the visits for each sector. We iterate over the given `rounds` array, and for each consecutive pair of sectors (i.e., from `rounds[i - 1]` to `rounds[i]`), we increment the count of visits for each sector in between (inclusive of the starting sector). After updating the visit count for each round, we find the maximum number of visits (`maxVisits`). Lastly, we iterate over the `visited` array and create a list of all sectors with maximum visits (`result`). The function returns the `result` list.\n    ", "python": "\n    ```python\ndef most_visited(n, rounds):\n    visited = [0] * (n + 1)\n    \n    for i in range(1, len(rounds)):\n        start, end = rounds[i - 1], rounds[i]\n        while start != end:\n            visited[start] += 1\n            start = (start % n) + 1\n    visited[rounds[-1]] += 1\n    \n    max_visits = max(visited);\n    return [i for i in range(1, n + 1) if visited[i] == max_visits]\n```\n    \n    The algorithm initializes an array `visited` that counts the visits for each sector. We iterate over the given `rounds` array, and for each consecutive pair of sectors (i.e., from `rounds[i - 1]` to `rounds[i]`), we increment the count of visits for each sector in between (inclusive of the starting sector). After updating the visit count for each round, we find the maximum number of visits (`maxVisits`). Lastly, we iterate over the `visited` array and create a list of all sectors with maximum visits (`result`). The function returns the `result` list.\n    ", "javascript": "\n    ```javascript\nfunction mostVisited(n, rounds) {\n    const visited = new Array(n + 1).fill(0);\n    \n    for (let i = 1; i < rounds.length; ++i) {\n        for (let start = rounds[i - 1], end = rounds[i]; start !== end; start = start % n + 1) {\n            ++visited[start];\n        }\n    }\n    ++visited[rounds[rounds.length - 1]];\n    \n    const maxVisits = Math.max(...visited);\n    const result = [];\n    \n    for (let i = 1; i <= n; ++i) {\n        if (visited[i] === maxVisits) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm initializes an array `visited` that counts the visits for each sector. We iterate over the given `rounds` array, and for each consecutive pair of sectors (i.e., from `rounds[i - 1]` to `rounds[i]`), we increment the count of visits for each sector in between (inclusive of the starting sector). After updating the visit count for each round, we find the maximum number of visits (`maxVisits`). Lastly, we iterate over the `visited` array and create a list of all sectors with maximum visits (`result`). The function returns the `result` list.\n    "}
{"id": 1690, "slug": "stone-game-vii", "title": "Stone Game VII", "difficulty": "Medium", "content": "Alice and Bob take turns playing a game, with **Alice starting first**.\n\nThere are `n` stones arranged in a row. On each player's turn, they can **remove** either the leftmost stone or the rightmost stone from the row and receive points equal to the **sum** of the remaining stones' values in the row. The winner is the one with the higher score when there are no stones left to remove.\n\nBob found that he will always lose this game (poor Bob, he always loses), so he decided to **minimize the score's difference**. Alice's goal is to **maximize the difference** in the score.\n\nGiven an array of integers `stones` where `stones[i]` represents the value of the `ith` stone **from the left**, return _the **difference** in Alice and Bob's score if they both play **optimally**._\n\n**Example 1:**\n\n**Input:** stones = \\[5,3,1,4,2\\]\n**Output:** 6\n**Explanation:** \n- Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = \\[5,3,1,4\\].\n- Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = \\[3,1,4\\].\n- Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = \\[1,4\\].\n- Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = \\[4\\].\n- Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = \\[\\].\nThe score difference is 18 - 12 = 6.\n\n**Example 2:**\n\n**Input:** stones = \\[7,90,5,1,100,10,10,2\\]\n**Output:** 122\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `2 <= n <= 1000`\n*   `1 <= stones[i] <= 1000`", "java": "\n    ```java\npublic int getMaxLen(int[] nums) {\n    int maxLength = 0, currentLen = 0, currentNegLen = 0;\n    \n    for (int num : nums) {\n        if (num > 0) {\n            ++currentLen;\n            if (currentNegLen > 0) ++currentNegLen;\n        } else if (num < 0) {\n            int tmp = currentLen;\n            currentLen = currentNegLen;\n            currentNegLen = tmp + 1;\n        } else {\n            currentLen = 0;\n            currentNegLen = 0;\n        }\n        maxLength = Math.max(maxLength, currentLen);\n    }\n    \n    return maxLength;\n}\n```\n    \n    The algorithm iterates through the array, maintaining two lengths: `currentLen` for the length of the current subarray with a positive product, and `currentNegLen` for the length of the current subarray with a negative product.\n\n1. If the current number is positive, increment `currentLen`, and increment `currentNegLen` if it is greater than zero.\n2. If the current number is negative, swap `currentLen` and `currentNegLen`, and increment `currentNegLen` by 1.\n3. If the current number is zero, reset both `currentLen` and `currentNegLen` to zero.\n\nAt each step, update the maximum length with the value of `currentLen`.\n\nAfter iterating through the array, the maximum length found during the iterations is returned.\n    ", "c++": "\n    ```cpp\nint getMaxLen(vector<int>& nums) {\n    int maxLength = 0, currentLen = 0, currentNegLen = 0;\n    \n    for (int num : nums) {\n        if (num > 0) {\n            ++currentLen;\n            if (currentNegLen > 0) ++currentNegLen;\n        } else if (num < 0) {\n            int tmp = currentLen;\n            currentLen = currentNegLen;\n            currentNegLen = tmp + 1;\n        } else {\n            currentLen = 0;\n            currentNegLen = 0;\n        }\n        maxLength = max(maxLength, currentLen);\n    }\n    \n    return maxLength;\n}\n```\n    \n    The algorithm iterates through the array, maintaining two lengths: `currentLen` for the length of the current subarray with a positive product, and `currentNegLen` for the length of the current subarray with a negative product.\n\n1. If the current number is positive, increment `currentLen`, and increment `currentNegLen` if it is greater than zero.\n2. If the current number is negative, swap `currentLen` and `currentNegLen`, and increment `currentNegLen` by 1.\n3. If the current number is zero, reset both `currentLen` and `currentNegLen` to zero.\n\nAt each step, update the maximum length with the value of `currentLen`.\n\nAfter iterating through the array, the maximum length found during the iterations is returned.\n    ", "python": "\n    ```python\ndef getMaxLen(nums):\n    maxLength = currentLen = currentNegLen = 0\n    \n    for num in nums:\n        if num > 0:\n            currentLen += 1\n            if currentNegLen > 0:\n                currentNegLen += 1\n        elif num < 0:\n            currentLen, currentNegLen = currentNegLen, currentLen + 1\n        else:\n            currentLen = currentNegLen = 0\n        maxLength = max(maxLength, currentLen)\n    \n    return maxLength\n```\n    \n    The algorithm iterates through the array, maintaining two lengths: `currentLen` for the length of the current subarray with a positive product, and `currentNegLen` for the length of the current subarray with a negative product.\n\n1. If the current number is positive, increment `currentLen`, and increment `currentNegLen` if it is greater than zero.\n2. If the current number is negative, swap `currentLen` and `currentNegLen`, and increment `currentNegLen` by 1.\n3. If the current number is zero, reset both `currentLen` and `currentNegLen` to zero.\n\nAt each step, update the maximum length with the value of `currentLen`.\n\nAfter iterating through the array, the maximum length found during the iterations is returned.\n    ", "javascript": "\n    ```javascript\nfunction getMaxLen(nums) {\n    let maxLength = 0, currentLen = 0, currentNegLen = 0;\n    \n    for (const num of nums) {\n        if (num > 0) {\n            ++currentLen;\n            if (currentNegLen > 0) ++currentNegLen;\n        } else if (num < 0) {\n            [currentLen, currentNegLen] = [currentNegLen, currentLen + 1];\n        } else {\n            currentLen = 0;\n            currentNegLen = 0;\n        }\n        maxLength = Math.max(maxLength, currentLen);\n    }\n    \n    return maxLength;\n}\n```\n    \n    The algorithm iterates through the array, maintaining two lengths: `currentLen` for the length of the current subarray with a positive product, and `currentNegLen` for the length of the current subarray with a negative product.\n\n1. If the current number is positive, increment `currentLen`, and increment `currentNegLen` if it is greater than zero.\n2. If the current number is negative, swap `currentLen` and `currentNegLen`, and increment `currentNegLen` by 1.\n3. If the current number is zero, reset both `currentLen` and `currentNegLen` to zero.\n\nAt each step, update the maximum length with the value of `currentLen`.\n\nAfter iterating through the array, the maximum length found during the iterations is returned.\n    "}
{"id": 1692, "slug": "count-ways-to-distribute-candies", "title": "Count Ways to Distribute Candies", "difficulty": "Hard", "content": "There are `n` **unique** candies (labeled `1` through `n`) and `k` bags. You are asked to distribute **all** the candies into the bags such that every bag has **at least** one candy.\n\nThere can be multiple ways to distribute the candies. Two ways are considered **different** if the candies in one bag in the first way are not all in the same bag in the second way. The order of the bags and the order of the candies within each bag do not matter.\n\nFor example, `(1), (2,3)` and `(2), (1,3)` are considered different because candies `2` and `3` in the bag `(2,3)` in the first way are not in the same bag in the second way (they are split between the bags `(2)` and `(1,3)`). However, `(1), (2,3)` and `(3,2), (1)` are considered the same because the candies in each bag are all in the same bags in both ways.\n\nGiven two integers, `n` and `k`, return _the **number** of different ways to distribute the candies_. As the answer may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 3, k = 2\n**Output:** 3\n**Explanation:** You can distribute 3 candies into 2 bags in 3 ways:\n(1), (2,3)\n(1,2), (3)\n(1,3), (2)\n\n**Example 2:**\n\n**Input:** n = 4, k = 2\n**Output:** 7\n**Explanation:** You can distribute 4 candies into 2 bags in 7 ways:\n(1), (2,3,4)\n(1,2), (3,4)\n(1,3), (2,4)\n(1,4), (2,3)\n(1,2,3), (4)\n(1,2,4), (3)\n(1,3,4), (2)\n\n**Example 3:**\n\n**Input:** n = 20, k = 5\n**Output:** 206085257\n**Explanation:** You can distribute 20 candies into 5 bags in 1881780996 ways. 1881780996 modulo 109 + 7 = 206085257.\n\n**Constraints:**\n\n*   `1 <= k <= n <= 1000`", "java": "\n    ```java\npublic int numTrees(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - 1 - j];\n            dp[i] %= 1000000007;\n        }\n    }\n\n    return dp[n];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a function `numTrees(i)` that returns the number of possible binary search trees with `i` nodes. We iterate through each possible number of nodes `i` from 2 to `n`. For each of these, we iterate through all possible left sub-tree sizes `j` (from 0 to i-1). Now, the total number of possible right sub-trees for the current `i` will be `i - 1 - j`. \n\nThus, the total number of possible BSTs for the current `i` will be the Cartesian product of the possible left sub-trees and possible right sub-trees. Hence, we can update `dp[i]` as `dp[i] += dp[j] * dp[i - 1 - j]`. \n\nWe continue doing this for all values of `i` until we reach `n`. The final answer will be `dp[n]`, the number of possible BSTs with `n` nodes. Note that we take the answer modulo 10^9 + 7 as the result can be quite large.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nint numTrees(int n) {\n    std::vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            dp[i] += dp[j] * dp[i - 1 - j];\n            dp[i] %= 1000000007;\n        }\n    }\n\n    return dp[n];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a function `numTrees(i)` that returns the number of possible binary search trees with `i` nodes. We iterate through each possible number of nodes `i` from 2 to `n`. For each of these, we iterate through all possible left sub-tree sizes `j` (from 0 to i-1). Now, the total number of possible right sub-trees for the current `i` will be `i - 1 - j`. \n\nThus, the total number of possible BSTs for the current `i` will be the Cartesian product of the possible left sub-trees and possible right sub-trees. Hence, we can update `dp[i]` as `dp[i] += dp[j] * dp[i - 1 - j]`. \n\nWe continue doing this for all values of `i` until we reach `n`. The final answer will be `dp[n]`, the number of possible BSTs with `n` nodes. Note that we take the answer modulo 10^9 + 7 as the result can be quite large.\n    ", "python": "\n    ```python\ndef numTrees(n: int) -> int:\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - 1 - j]\n            dp[i] %= (10**9 + 7)\n\n    return dp[n]\n```\n    \n    The problem can be solved using dynamic programming. We can define a function `numTrees(i)` that returns the number of possible binary search trees with `i` nodes. We iterate through each possible number of nodes `i` from 2 to `n`. For each of these, we iterate through all possible left sub-tree sizes `j` (from 0 to i-1). Now, the total number of possible right sub-trees for the current `i` will be `i - 1 - j`. \n\nThus, the total number of possible BSTs for the current `i` will be the Cartesian product of the possible left sub-trees and possible right sub-trees. Hence, we can update `dp[i]` as `dp[i] += dp[j] * dp[i - 1 - j]`. \n\nWe continue doing this for all values of `i` until we reach `n`. The final answer will be `dp[n]`, the number of possible BSTs with `n` nodes. Note that we take the answer modulo 10^9 + 7 as the result can be quite large.\n    ", "javascript": "\n    ```javascript\nfunction numTrees(n) {\n    const dp = Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (let i = 2; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - 1 - j];\n            dp[i] %= 1000000007;\n        }\n    }\n\n    return dp[n];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a function `numTrees(i)` that returns the number of possible binary search trees with `i` nodes. We iterate through each possible number of nodes `i` from 2 to `n`. For each of these, we iterate through all possible left sub-tree sizes `j` (from 0 to i-1). Now, the total number of possible right sub-trees for the current `i` will be `i - 1 - j`. \n\nThus, the total number of possible BSTs for the current `i` will be the Cartesian product of the possible left sub-trees and possible right sub-trees. Hence, we can update `dp[i]` as `dp[i] += dp[j] * dp[i - 1 - j]`. \n\nWe continue doing this for all values of `i` until we reach `n`. The final answer will be `dp[n]`, the number of possible BSTs with `n` nodes. Note that we take the answer modulo 10^9 + 7 as the result can be quite large.\n    "}
{"id": 1696, "slug": "jump-game-vi", "title": "Jump Game VI", "difficulty": "Medium", "content": "You are given a **0-indexed** integer array `nums` and an integer `k`.\n\nYou are initially standing at index `0`. In one move, you can jump at most `k` steps forward without going outside the boundaries of the array. That is, you can jump from index `i` to any index in the range `[i + 1, min(n - 1, i + k)]` **inclusive**.\n\nYou want to reach the last index of the array (index `n - 1`). Your **score** is the **sum** of all `nums[j]` for each index `j` you visited in the array.\n\nReturn _the **maximum score** you can get_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,\\-1,-2,4,-7,3\\], k = 2\n**Output:** 7\n**Explanation:** You can choose your jumps forming the subsequence \\[1,-1,4,3\\] (underlined above). The sum is 7.\n\n**Example 2:**\n\n**Input:** nums = \\[10,-5,-2,4,0,3\\], k = 3\n**Output:** 17\n**Explanation:** You can choose your jumps forming the subsequence \\[10,4,3\\] (underlined above). The sum is 17.\n\n**Example 3:**\n\n**Input:** nums = \\[1,-5,-20,4,-1,3,-6,-3\\], k = 2\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length, k <= 105`\n*   `-104 <= nums[i] <= 104`", "java": "\n    ```java\nimport java.util.Arrays;\n\nclass Solution {\n    public boolean isPrintable(int[][] targetGrid) {\n        int m = targetGrid.length, n = targetGrid[0].length;\n        int[] top = new int[61], bottom = new int[61], left = new int[61], right = new int[61];\n        boolean[][] vis = new boolean[m][n];\n\n        Arrays.fill(top, m);\n        Arrays.fill(bottom, -1);\n        Arrays.fill(left, n);\n        Arrays.fill(right, -1);\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int c = targetGrid[i][j];\n                top[c] = Math.min(top[c], i);\n                bottom[c] = Math.max(bottom[c], i);\n                left[c] = Math.min(left[c], j);\n                right[c] = Math.max(right[c], j);\n            }\n        }\n\n        for (int color = 1; color <= 60; ++color) {\n            for (int i = top[color]; i <= bottom[color]; ++i) {\n                for (int j = left[color]; j <= right[color]; ++j) {\n                    if (!vis[i][j] && !dfs(i * n + j, targetGrid, vis, top, bottom, left, right)) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    private boolean dfs(int x, int[][] targetGrid, boolean[][] vis, int[] top, int[] bottom, int[] left, int[] right) {\n        int n = targetGrid[0].length;\n        int i = x / n, j = x % n;\n        if (vis[i][j]) return true;\n        int c = targetGrid[i][j];\n        if (i < top[c] || i > bottom[c] || j < left[c] || j > right[c]) return false;\n        vis[i][j] = true;\n        for (int k = 1; k <= 60; ++k) {\n            if (k == c) continue;\n            if (i >= top[k] && i <= bottom[k] && j >= left[k] && j <= right[k]) return false;\n            if (!dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k], targetGrid, vis, top, bottom, left, right)) return false;\n        }\n        return true;\n    }\n}\n```\n\n    \n    We create separate bounds (top, bottom, left, and right) for each color, calculating the boundaries of the rectangle for that color. Then, for each cell in the grid that hasn't been visited, we perform a depth-first search (DFS) from it. The DFS checks if a cell belongs to the current color's boundary; if not, it returns False, causing backtracking in the search.\n\nIn each step of the DFS, we skip the current color and check if the cell on the search path belongs to another color's rectangle. If yes, we return False. Otherwise, we continue the DFS with the next cell in the sequence. \n\nFinally, we iterate through all the colors and their rectangles, looking for unvisited cells. If a DFS at any cell location returns False, we can't print the grid, so the overall function returns False. Else, we return True, indicating it's possible to print the matrix targetGrid with the given constraints.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool isPrintable(vector<vector<int>>& targetGrid) {\n    int m = targetGrid.size(), n = targetGrid[0].size();\n    vector<int> top(61, m), bottom(61, -1), left(61, n), right(61, -1);\n    vector<vector<bool>> vis(m, vector<bool>(n, false));\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int c = targetGrid[i][j];\n            top[c] = min(top[c], i);\n            bottom[c] = max(bottom[c], i);\n            left[c] = min(left[c], j);\n            right[c] = max(right[c], j);\n        }\n    }\n\n    function<bool(int)> dfs = [&](int x) {\n        int i = x / n, j = x % n;\n        if (vis[i][j]) return true;\n        int c = targetGrid[i][j];\n        if (i < top[c] || i > bottom[c] || j < left[c] || j > right[c]) return false;\n        vis[i][j] = true;\n        for (int k = 1; k <= 60; ++k) {\n            if (k == c) continue;\n            if (i >= top[k] && i <= bottom[k] && j >= left[k] && j <= right[k]) return false;\n            if (!dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k])) return false;\n        }\n        return true;\n    };\n\n    for (int color = 1; color <= 60; ++color) {\n        for (int i = top[color]; i <= bottom[color]; ++i) {\n            for (int j = left[color]; j <= right[color]; ++j) {\n                if (!vis[i][j] && !dfs(i * n + j)) return false;\n            }\n        }\n    }\n\n    return true;\n}\n```\n\n    \n    We create separate bounds (top, bottom, left, and right) for each color, calculating the boundaries of the rectangle for that color. Then, for each cell in the grid that hasn't been visited, we perform a depth-first search (DFS) from it. The DFS checks if a cell belongs to the current color's boundary; if not, it returns False, causing backtracking in the search.\n\nIn each step of the DFS, we skip the current color and check if the cell on the search path belongs to another color's rectangle. If yes, we return False. Otherwise, we continue the DFS with the next cell in the sequence. \n\nFinally, we iterate through all the colors and their rectangles, looking for unvisited cells. If a DFS at any cell location returns False, we can't print the grid, so the overall function returns False. Else, we return True, indicating it's possible to print the matrix targetGrid with the given constraints.\n    ", "python": "\n    ```python\ndef isPrintable(targetGrid):\n    m, n = len(targetGrid), len(targetGrid[0])\n    top, bottom, left, right = [m]*61, [-1]*61, [n]*61, [-1]*61\n    vis = [[False]*n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            c = targetGrid[i][j]\n            top[c] = min(top[c], i)\n            bottom[c] = max(bottom[c], i)\n            left[c] = min(left[c], j)\n            right[c] = max(right[c], j)\n\n    def dfs(x):\n        i, j = x // n, x % n\n        if vis[i][j]: return True\n        c = targetGrid[i][j]\n        if i < top[c] or i > bottom[c] or j < left[c] or j > right[c]: return False\n        vis[i][j] = True\n        for k in range(1, 61):\n            if k == c: continue\n            if i >= top[k] and i <= bottom[k] and j >= left[k] and j <= right[k]: return False\n            if not dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k]): return False\n        return True\n\n    for color in range(1, 61):\n        for i in range(top[color], bottom[color] + 1):\n            for j in range(left[color], right[color] + 1):\n                if not vis[i][j] and not dfs(i * n + j): return False\n\n    return True\n```\n\n    \n    We create separate bounds (top, bottom, left, and right) for each color, calculating the boundaries of the rectangle for that color. Then, for each cell in the grid that hasn't been visited, we perform a depth-first search (DFS) from it. The DFS checks if a cell belongs to the current color's boundary; if not, it returns False, causing backtracking in the search.\n\nIn each step of the DFS, we skip the current color and check if the cell on the search path belongs to another color's rectangle. If yes, we return False. Otherwise, we continue the DFS with the next cell in the sequence. \n\nFinally, we iterate through all the colors and their rectangles, looking for unvisited cells. If a DFS at any cell location returns False, we can't print the grid, so the overall function returns False. Else, we return True, indicating it's possible to print the matrix targetGrid with the given constraints.\n    ", "javascript": "\n    ```javascript\nvar isPrintable = function(targetGrid) {\n    const m = targetGrid.length, n = targetGrid[0].length;\n    const top = Array(61).fill(m), bottom = Array(61).fill(-1), left = Array(61).fill(n), right = Array(61).fill(-1);\n    const vis = Array.from({ length: m }, () => Array(n).fill(false));\n\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            const c = targetGrid[i][j];\n            top[c] = Math.min(top[c], i);\n            bottom[c] = Math.max(bottom[c], i);\n            left[c] = Math.min(left[c], j);\n            right[c] = Math.max(right[c], j);\n        }\n    }\n\n    const dfs = (x) => {\n        const i = Math.floor(x / n), j = x % n;\n        if (vis[i][j]) return true;\n        const c = targetGrid[i][j];\n        if (i < top[c] || i > bottom[c] || j < left[c] || j > right[c]) return false;\n        vis[i][j] = true;\n        for (let k = 1; k <= 60; ++k) {\n            if (k === c) continue;\n            if (i >= top[k] && i <= bottom[k] && j >= left[k] && j <= right[k]) return false;\n            if (!dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k])) return false;\n        }\n        return true;\n    };\n\n    for (let color = 1; color <= 60; ++color) {\n        for (let i = top[color]; i <= bottom[color]; ++i) {\n            for (let j = left[color]; j <= right[color]; ++j) {\n                if (!vis[i][j] && !dfs(i * n + j)) return false;\n            }\n        }\n    }\n    \n    return true;\n};\n```\n\n    \n    We create separate bounds (top, bottom, left, and right) for each color, calculating the boundaries of the rectangle for that color. Then, for each cell in the grid that hasn't been visited, we perform a depth-first search (DFS) from it. The DFS checks if a cell belongs to the current color's boundary; if not, it returns False, causing backtracking in the search.\n\nIn each step of the DFS, we skip the current color and check if the cell on the search path belongs to another color's rectangle. If yes, we return False. Otherwise, we continue the DFS with the next cell in the sequence. \n\nFinally, we iterate through all the colors and their rectangles, looking for unvisited cells. If a DFS at any cell location returns False, we can't print the grid, so the overall function returns False. Else, we return True, indicating it's possible to print the matrix targetGrid with the given constraints.\n    "}
{"id": 1714, "slug": "sum-of-special-evenly-spaced-elements-in-array", "title": "Sum Of Special Evenly-Spaced Elements In Array", "difficulty": "Hard", "content": "You are given a **0-indexed** integer array `nums` consisting of `n` non-negative integers.\n\nYou are also given an array `queries`, where `queries[i] = [xi, yi]`. The answer to the `ith` query is the sum of all `nums[j]` where `xi <= j < n` and `(j - xi)` is divisible by `yi`.\n\nReturn _an array_ `answer` _where_ `answer.length == queries.length` _and_ `answer[i]` _is the answer to the_ `ith` _query **modulo**_ `109 + 7`.\n\n**Example 1:**\n\n**Input:** nums = \\[0,1,2,3,4,5,6,7\\], queries = \\[\\[0,3\\],\\[5,1\\],\\[4,2\\]\\]\n**Output:** \\[9,18,10\\]\n**Explanation:** The answers of the queries are as follows:\n1) The j indices that satisfy this query are 0, 3, and 6. nums\\[0\\] + nums\\[3\\] + nums\\[6\\] = 9\n2) The j indices that satisfy this query are 5, 6, and 7. nums\\[5\\] + nums\\[6\\] + nums\\[7\\] = 18\n3) The j indices that satisfy this query are 4 and 6. nums\\[4\\] + nums\\[6\\] = 10\n\n**Example 2:**\n\n**Input:** nums = \\[100,200,101,201,102,202,103,203\\], queries = \\[\\[0,7\\]\\]\n**Output:** \\[303\\]\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5 * 104`\n*   `0 <= nums[i] <= 109`\n*   `1 <= queries.length <= 1.5 * 105`\n*   `0 <= xi < n`\n*   `1 <= yi <= 5 * 104`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic String reorderSpaces(String text) {\n    int spaces = 0;\n    List<String> words = new ArrayList<>();\n    \n    String[] splitText = text.split(\"\\\\s+\");\n    for (String word : splitText) {\n        words.add(word);\n        spaces += word.length() - word.trim().length();\n    }\n    \n    if (words.size() == 1) {\n        return words.get(0) + \" \".repeat(spaces);\n    }\n\n    int spaceBetweenWords = spaces / (words.size() - 1);\n    int extraSpaces = spaces % (words.size() - 1);\n    StringBuilder result = new StringBuilder();\n    \n    for (int i = 0; i < words.size(); i++) {\n        result.append(words.get(i));\n        if (i < words.size() - 1) {\n            result.append(\" \".repeat(spaceBetweenWords));\n        }\n    }\n    \n    result.append(\" \".repeat(extraSpaces));\n\n    return result.toString();\n}\n```\n    \n    1. Count the number of spaces and split the text into a list/vector of words.\n2. If there's only one word, return the word followed by all spaces.\n3. Calculate the number of spaces to be distributed between words, as well as the extra spaces that remain.\n4. Iterate through the words, and for each word, append it to the result variable. If the current word is not the last one, append the appropriate number of spaces.\n5. After the loop, append any extra spaces to the result variable.\n6. Return the result variable.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <sstream>\n#include <vector>\n\nstd::string reorderSpaces(const std::string& text) {\n    int spaces = 0;\n    std::vector<std::string> words;\n    \n    std::stringstream ss(text);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n        spaces += std::count(word.begin(), word.end(), ' ');\n    }\n    \n    if (words.size() == 1) {\n        return words[0] + std::string(spaces, ' ');\n    }\n\n    int space_between_words = spaces / (words.size() - 1);\n    int extra_spaces = spaces % (words.size() - 1);\n    std::string result;\n    \n    for (size_t i = 0; i < words.size(); i++) {\n        result += words[i];\n        if (i < words.size() - 1) {\n            result += std::string(space_between_words, ' ');\n        }\n    }\n    \n    result += std::string(extra_spaces, ' ');\n\n    return result;\n}\n```\n    \n    1. Count the number of spaces and split the text into a list/vector of words.\n2. If there's only one word, return the word followed by all spaces.\n3. Calculate the number of spaces to be distributed between words, as well as the extra spaces that remain.\n4. Iterate through the words, and for each word, append it to the result variable. If the current word is not the last one, append the appropriate number of spaces.\n5. After the loop, append any extra spaces to the result variable.\n6. Return the result variable.\n    ", "python": "\n    ```python\ndef reorder_spaces(text: str) -> str:\n    spaces = text.count(' ')\n    words = text.split()\n    \n    if len(words) == 1:\n        return words[0] + ' ' * spaces\n\n    space_between_words = spaces // (len(words) - 1)\n    extra_spaces = spaces % (len(words) - 1)\n    result = ''\n    \n    for i, word in enumerate(words):\n        result += word\n        if i < len(words) - 1:\n            result += ' ' * space_between_words\n    \n    result += ' ' * extra_spaces\n\n    return result\n```\n    \n    1. Count the number of spaces and split the text into a list/vector of words.\n2. If there's only one word, return the word followed by all spaces.\n3. Calculate the number of spaces to be distributed between words, as well as the extra spaces that remain.\n4. Iterate through the words, and for each word, append it to the result variable. If the current word is not the last one, append the appropriate number of spaces.\n5. After the loop, append any extra spaces to the result variable.\n6. Return the result variable.\n    ", "javascript": "\n    ```javascript\nfunction reorderSpaces(text) {\n    const spaces = text.split('').filter(char => char === ' ').length;\n    const words = text.trim().split(/\\s+/);\n    \n    if (words.length === 1) {\n        return words[0] + ' '.repeat(spaces);\n    }\n\n    const spaceBetweenWords = Math.floor(spaces / (words.length - 1));\n    const extraSpaces = spaces % (words.length - 1);\n    let result = '';\n    \n    for (let i = 0; i < words.length; i++) {\n        result += words[i];\n        if (i < words.length - 1) {\n            result += ' '.repeat(spaceBetweenWords);\n        }\n    }\n    \n    result += ' '.repeat(extraSpaces);\n\n    return result;\n}\n```\n    \n    1. Count the number of spaces and split the text into a list/vector of words.\n2. If there's only one word, return the word followed by all spaces.\n3. Calculate the number of spaces to be distributed between words, as well as the extra spaces that remain.\n4. Iterate through the words, and for each word, append it to the result variable. If the current word is not the last one, append the appropriate number of spaces.\n5. After the loop, append any extra spaces to the result variable.\n6. Return the result variable.\n    "}
{"id": 1723, "slug": "find-minimum-time-to-finish-all-jobs", "title": "Find Minimum Time to Finish All Jobs", "difficulty": "Hard", "content": "You are given an integer array `jobs`, where `jobs[i]` is the amount of time it takes to complete the `ith` job.\n\nThere are `k` workers that you can assign jobs to. Each job should be assigned to **exactly** one worker. The **working time** of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the **maximum working time** of any worker is **minimized**.\n\n_Return the **minimum** possible **maximum working time** of any assignment._\n\n**Example 1:**\n\n**Input:** jobs = \\[3,2,3\\], k = 3\n**Output:** 3\n**Explanation:** By assigning each person one job, the maximum time is 3.\n\n**Example 2:**\n\n**Input:** jobs = \\[1,2,4,7,8\\], k = 2\n**Output:** 11\n**Explanation:** Assign the jobs the following way:\nWorker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)\nWorker 2: 4, 7 (working time = 4 + 7 = 11)\nThe maximum working time is 11.\n\n**Constraints:**\n\n*   `1 <= k <= jobs.length <= 12`\n*   `1 <= jobs[i] <= 107`", "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic int maxAchievableRequests(int n, ArrayList<ArrayList<Integer>> requests, int idx, ArrayList<Integer> counts) {\n    if (counts == null) {\n        counts = new ArrayList<Integer>(n);\n        for (int i = 0; i < n; i++) {\n            counts.add(0);\n        }\n    }\n    if (idx == requests.size()) {\n        for (int count : counts) {\n            if (count != 0) return 0;\n        }\n        return 0;\n    }\n    int ignored = maxAchievableRequests(n, requests, idx + 1, counts);\n    counts.set(requests.get(idx).get(0), counts.get(requests.get(idx).get(0)) + 1);\n    counts.set(requests.get(idx).get(1), counts.get(requests.get(idx).get(1)) - 1);\n\n    int accepted = 1 + maxAchievableRequests(n, requests, idx + 1, counts);\n\n    return Math.max(ignored, accepted);\n}\n```\n    \n    The algorithm uses a helper recursive function `max_achievable_requests` that keeps track of four variables:\n- `n`: the number of buildings\n- `requests`: the list of employee transfer requests\n- `idx`: the index of the current request being processed (default is 0 for the start)\n- `counts`: a list that holds the net change in employee transfers for each building (initially empty or None/null)\n\nIt uses a base case when `idx` is equal to the length of the `request` list; it checks if all the counts are balanced (all values in the `counts` array are 0). If the counts are balanced, it means all requests have been checked and return 0 as the value of the maximum achievable requests.\n\nIf the index is not at the end of the requests list, two options are tried: ignore the request and process the next request in the list, and accept the request and process the next request in the list. For each try, it updates the counts based on the current request and chooses the maximum of the combinations tried.\n\nThe time complexity of this algorithm is O(2^n) as it uses a depth-first search approach. It is inefficient for large inputs, but in the context of the question, it should work well to find the maximum number of achievable requests.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nint maxAchievableRequests(int n, std::vector<std::vector<int>>& requests, int idx = 0, std::vector<int> counts = {}) {\n    if (counts.empty()) {\n        counts.resize(n, 0);\n    }\n    if (idx == requests.size()) {\n        for (int count : counts) {\n            if (count != 0) return 0;\n        }\n        return 0;\n    }\n    int ignored = maxAchievableRequests(n, requests, idx + 1, counts);\n    counts[requests[idx][0]]++;\n    counts[requests[idx][1]]--;\n\n    int accepted = 1 + maxAchievableRequests(n, requests, idx + 1, counts);\n\n    return std::max(ignored, accepted);\n}\n```\n    \n    The algorithm uses a helper recursive function `max_achievable_requests` that keeps track of four variables:\n- `n`: the number of buildings\n- `requests`: the list of employee transfer requests\n- `idx`: the index of the current request being processed (default is 0 for the start)\n- `counts`: a list that holds the net change in employee transfers for each building (initially empty or None/null)\n\nIt uses a base case when `idx` is equal to the length of the `request` list; it checks if all the counts are balanced (all values in the `counts` array are 0). If the counts are balanced, it means all requests have been checked and return 0 as the value of the maximum achievable requests.\n\nIf the index is not at the end of the requests list, two options are tried: ignore the request and process the next request in the list, and accept the request and process the next request in the list. For each try, it updates the counts based on the current request and chooses the maximum of the combinations tried.\n\nThe time complexity of this algorithm is O(2^n) as it uses a depth-first search approach. It is inefficient for large inputs, but in the context of the question, it should work well to find the maximum number of achievable requests.\n    ", "python": "\n    ```python\ndef max_achievable_requests(n, requests, idx=0, counts=None):\n    if counts is None:\n        counts = [0] * n\n    if idx == len(requests):\n        if all(count == 0 for count in counts):\n            return 0\n        return 0\n\n    ignored = max_achievable_requests(n, requests, idx+1, counts[:])\n    counts[requests[idx][0]] += 1\n    counts[requests[idx][1]] -= 1\n\n    accepted = 1 + max_achievable_requests(n, requests, idx+1, counts)\n\n    return max(ignored, accepted)\n```\n    \n    The algorithm uses a helper recursive function `max_achievable_requests` that keeps track of four variables:\n- `n`: the number of buildings\n- `requests`: the list of employee transfer requests\n- `idx`: the index of the current request being processed (default is 0 for the start)\n- `counts`: a list that holds the net change in employee transfers for each building (initially empty or None/null)\n\nIt uses a base case when `idx` is equal to the length of the `request` list; it checks if all the counts are balanced (all values in the `counts` array are 0). If the counts are balanced, it means all requests have been checked and return 0 as the value of the maximum achievable requests.\n\nIf the index is not at the end of the requests list, two options are tried: ignore the request and process the next request in the list, and accept the request and process the next request in the list. For each try, it updates the counts based on the current request and chooses the maximum of the combinations tried.\n\nThe time complexity of this algorithm is O(2^n) as it uses a depth-first search approach. It is inefficient for large inputs, but in the context of the question, it should work well to find the maximum number of achievable requests.\n    ", "javascript": "\n    ```javascript\nfunction maxAchievableRequests(n, requests, idx = 0, counts = null) {\n    if (counts === null) {\n        counts = new Array(n).fill(0);\n    }\n    if (idx === requests.length) {\n        if (counts.every(count => count === 0)) return 0;\n        return 0;\n    }\n    let ignored = maxAchievableRequests(n, requests, idx + 1, [...counts]);\n    counts[requests[idx][0]]++;\n    counts[requests[idx][1]]--;\n\n    let accepted = 1 + maxAchievableRequests(n, requests, idx + 1, counts);\n\n    return Math.max(ignored, accepted);\n}\n```\n    \n    The algorithm uses a helper recursive function `max_achievable_requests` that keeps track of four variables:\n- `n`: the number of buildings\n- `requests`: the list of employee transfer requests\n- `idx`: the index of the current request being processed (default is 0 for the start)\n- `counts`: a list that holds the net change in employee transfers for each building (initially empty or None/null)\n\nIt uses a base case when `idx` is equal to the length of the `request` list; it checks if all the counts are balanced (all values in the `counts` array are 0). If the counts are balanced, it means all requests have been checked and return 0 as the value of the maximum achievable requests.\n\nIf the index is not at the end of the requests list, two options are tried: ignore the request and process the next request in the list, and accept the request and process the next request in the list. For each try, it updates the counts based on the current request and chooses the maximum of the combinations tried.\n\nThe time complexity of this algorithm is O(2^n) as it uses a depth-first search approach. It is inefficient for large inputs, but in the context of the question, it should work well to find the maximum number of achievable requests.\n    "}
{"id": 1728, "slug": "cat-and-mouse-ii", "title": "Cat and Mouse II", "difficulty": "Hard", "content": "A game is played by a cat and a mouse named Cat and Mouse.\n\nThe environment is represented by a `grid` of size `rows x cols`, where each element is a wall, floor, player (Cat, Mouse), or food.\n\n*   Players are represented by the characters `'C'`(Cat)`,'M'`(Mouse).\n*   Floors are represented by the character `'.'` and can be walked on.\n*   Walls are represented by the character `'#'` and cannot be walked on.\n*   Food is represented by the character `'F'` and can be walked on.\n*   There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n\nMouse and Cat play according to the following rules:\n\n*   Mouse **moves first**, then they take turns to move.\n*   During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the `grid`.\n*   `catJump, mouseJump` are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\n*   Staying in the same position is allowed.\n*   Mouse can jump over Cat.\n\nThe game can end in 4 ways:\n\n*   If Cat occupies the same position as Mouse, Cat wins.\n*   If Cat reaches the food first, Cat wins.\n*   If Mouse reaches the food first, Mouse wins.\n*   If Mouse cannot get to the food within 1000 turns, Cat wins.\n\nGiven a `rows x cols` matrix `grid` and two integers `catJump` and `mouseJump`, return `true` _if Mouse can win the game if both Cat and Mouse play optimally, otherwise return_ `false`.\n\n**Example 1:**\n\n**Input:** grid = \\[ \"####F \", \"#C... \", \"M.... \"\\], catJump = 1, mouseJump = 2\n**Output:** true\n**Explanation:** Cat cannot catch Mouse on its turn nor can it get the food before Mouse.\n\n**Example 2:**\n\n**Input:** grid = \\[ \"M.C...F \"\\], catJump = 1, mouseJump = 4\n**Output:** true\n\n**Example 3:**\n\n**Input:** grid = \\[ \"M.C...F \"\\], catJump = 1, mouseJump = 3\n**Output:** false\n\n**Constraints:**\n\n*   `rows == grid.length`\n*   `cols = grid[i].length`\n*   `1 <= rows, cols <= 8`\n*   `grid[i][j]` consist only of characters `'C'`, `'M'`, `'F'`, `'.'`, and `'#'`.\n*   There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n*   `1 <= catJump, mouseJump <= 8`", "java": "\n    ```java\nimport java.util.ArrayList;\n\nclass Fancy {\n    private ArrayList<Integer> sequence;\n\n    public Fancy() {\n        sequence = new ArrayList<>();\n    }\n\n    public void append(int val) {\n        sequence.add(val);\n    }\n\n    public void addAll(int inc) {\n        for (int i = 0; i < sequence.size(); i++) {\n            sequence.set(i, sequence.get(i) + inc);\n        }\n    }\n\n    public void multAll(int m) {\n        for (int i = 0; i < sequence.size(); i++) {\n            sequence.set(i, sequence.get(i) * m);\n        }\n    }\n\n    public int getIndex(int idx) {\n        if (idx >= sequence.size()) return -1;\n        return sequence.get(idx);\n    }\n}\n```\n\n    \n    The Fancy class has a sequence that stores integers. The following methods are implemented:\n1. append(val) - Appends the given value to the sequence.\n2. addAll(inc) - Adds the given increment to all elements in the sequence.\n3. multAll(m) - Multiplies all elements in the sequence with the given multiplier.\n4. getIndex(idx) - Returns the element at the given index in the sequence or -1 if the index is out of bounds. \n\nEach coded implementation in C++, Java, Python, and JavaScript maintains a sequence and manipulates it based on the methods called. The implementation details are the same across these languages, and the basic concepts rely on the usage of arrays, iterating over elements, and modifying elements in the array based on the operations requested.\n    ", "c++": "\n    ```cpp\nclass Fancy {\npublic:\n    Fancy() {}\n\n    void append(int val) {\n        sequence.push_back(val);\n    }\n\n    void addAll(int inc) {\n        for(auto& num : sequence) {\n            num += inc;\n        }\n    }\n\n    void multAll(int m) {\n        for(auto& num : sequence) {\n            num *= m;\n        }\n    }\n\n    int getIndex(int idx) {\n        if(idx >= sequence.size()) return -1;\n        return sequence[idx];\n    }\nprivate:\n    vector<int> sequence;\n};\n```\n\n    \n    The Fancy class has a sequence that stores integers. The following methods are implemented:\n1. append(val) - Appends the given value to the sequence.\n2. addAll(inc) - Adds the given increment to all elements in the sequence.\n3. multAll(m) - Multiplies all elements in the sequence with the given multiplier.\n4. getIndex(idx) - Returns the element at the given index in the sequence or -1 if the index is out of bounds. \n\nEach coded implementation in C++, Java, Python, and JavaScript maintains a sequence and manipulates it based on the methods called. The implementation details are the same across these languages, and the basic concepts rely on the usage of arrays, iterating over elements, and modifying elements in the array based on the operations requested.\n    ", "python": "\n    ```python\nclass Fancy:\n    def __init__(self):\n        self.sequence = []\n\n    def append(self, val):\n        self.sequence.append(val)\n\n    def addAll(self, inc):\n        self.sequence = [num + inc for num in self.sequence]\n\n    def multAll(self, m):\n        self.sequence = [num * m for num in self.sequence]\n\n    def getIndex(self, idx):\n        if idx >= len(self.sequence):\n            return -1\n        return self.sequence[idx]\n```\n\n    \n    The Fancy class has a sequence that stores integers. The following methods are implemented:\n1. append(val) - Appends the given value to the sequence.\n2. addAll(inc) - Adds the given increment to all elements in the sequence.\n3. multAll(m) - Multiplies all elements in the sequence with the given multiplier.\n4. getIndex(idx) - Returns the element at the given index in the sequence or -1 if the index is out of bounds. \n\nEach coded implementation in C++, Java, Python, and JavaScript maintains a sequence and manipulates it based on the methods called. The implementation details are the same across these languages, and the basic concepts rely on the usage of arrays, iterating over elements, and modifying elements in the array based on the operations requested.\n    ", "javascript": "\n    ```javascript\nclass Fancy {\n    constructor() {\n        this.sequence = [];\n    }\n\n    append(val) {\n        this.sequence.push(val);\n    }\n\n    addAll(inc) {\n        this.sequence = this.sequence.map(num => num + inc);\n    }\n\n    multAll(m) {\n        this.sequence = this.sequence.map(num => num * m);\n    }\n\n    getIndex(idx) {\n        if (idx >= this.sequence.length) return -1;\n        return this.sequence[idx];\n    }\n}\n```\n\n    \n    The Fancy class has a sequence that stores integers. The following methods are implemented:\n1. append(val) - Appends the given value to the sequence.\n2. addAll(inc) - Adds the given increment to all elements in the sequence.\n3. multAll(m) - Multiplies all elements in the sequence with the given multiplier.\n4. getIndex(idx) - Returns the element at the given index in the sequence or -1 if the index is out of bounds. \n\nEach coded implementation in C++, Java, Python, and JavaScript maintains a sequence and manipulates it based on the methods called. The implementation details are the same across these languages, and the basic concepts rely on the usage of arrays, iterating over elements, and modifying elements in the array based on the operations requested.\n    "}
{"id": 1746, "slug": "maximum-subarray-sum-after-one-operation", "title": "Maximum Subarray Sum After One Operation", "difficulty": "Medium", "content": "You are given an integer array `nums`. You must perform **exactly one** operation where you can **replace** one element `nums[i]` with `nums[i] * nums[i]`.\n\nReturn _the **maximum** possible subarray sum after **exactly one** operation_. The subarray must be non-empty.\n\n**Example 1:**\n\n**Input:** nums = \\[2,-1,-4,-3\\]\n**Output:** 17\n**Explanation:** You can perform the operation on index 2 (0-indexed) to make nums = \\[2,-1,**16**,-3\\]. Now, the maximum subarray sum is 2 + -1 + 16 = 17.\n\n**Example 2:**\n\n**Input:** nums = \\[1,-1,1,1,-1,-1,1\\]\n**Output:** 4\n**Explanation:** You can perform the operation on index 1 (0-indexed) to make nums = \\[1,**1**,1,1,-1,-1,1\\]. Now, the maximum subarray sum is 1 + 1 + 1 + 1 = 4.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`", "java": "\n    ```java\npublic int maxLengthBetweenEqualCharacters(String s) {\n    int maxLength = -1;\n    HashMap<Character, Integer> charIndexMap = new HashMap<>();\n\n    for (int i = 0; i < s.length(); i++) {\n        char currentChar = s.charAt(i);\n\n        if (charIndexMap.containsKey(currentChar)) {\n            maxLength = Math.max(maxLength, i - charIndexMap.get(currentChar) - 1);\n        } else {\n            charIndexMap.put(currentChar, i);\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    1. Initialize maxLength to -1 and create a hash map (or dictionary) called charIndexMap.\n2. Iterate through the string s and for each character:\n   a. If the character is already in charIndexMap, update maxLength with the maximum value between the current maxLength and the distance between the current index and the previous index of the character minus 1.\n   b. If the character is not in the charIndexMap, store the character and its index in the map.\n3. Return maxLength. If maxLength is never updated (no equal characters found), it will return -1 as required.\n    ", "c++": "\n    ```cpp\nint maxLengthBetweenEqualCharacters(std::string s) {\n    int maxLength = -1;\n    std::unordered_map<char, int> charIndexMap;\n\n    for (int i = 0; i < s.length(); i++) {\n        if (charIndexMap.count(s[i])) {\n            maxLength = std::max(maxLength, i - charIndexMap[s[i]] - 1);\n        } else {\n            charIndexMap[s[i]] = i;\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    1. Initialize maxLength to -1 and create a hash map (or dictionary) called charIndexMap.\n2. Iterate through the string s and for each character:\n   a. If the character is already in charIndexMap, update maxLength with the maximum value between the current maxLength and the distance between the current index and the previous index of the character minus 1.\n   b. If the character is not in the charIndexMap, store the character and its index in the map.\n3. Return maxLength. If maxLength is never updated (no equal characters found), it will return -1 as required.\n    ", "python": "\n    ```python\ndef maxLengthBetweenEqualCharacters(s: str) -> int:\n    max_length = -1\n    char_index_map = {}\n\n    for i, char in enumerate(s):\n        if char in char_index_map:\n            max_length = max(max_length, i - char_index_map[char] - 1)\n        else:\n            char_index_map[char] = i\n\n    return max_length\n```\n    \n    1. Initialize maxLength to -1 and create a hash map (or dictionary) called charIndexMap.\n2. Iterate through the string s and for each character:\n   a. If the character is already in charIndexMap, update maxLength with the maximum value between the current maxLength and the distance between the current index and the previous index of the character minus 1.\n   b. If the character is not in the charIndexMap, store the character and its index in the map.\n3. Return maxLength. If maxLength is never updated (no equal characters found), it will return -1 as required.\n    ", "javascript": "\n    ```javascript\nfunction maxLengthBetweenEqualCharacters(s) {\n    let maxLength = -1;\n    let charIndexMap = new Map();\n\n    for (let i = 0; i < s.length; i++) {\n        if (charIndexMap.has(s[i])) {\n            maxLength = Math.max(maxLength, i - charIndexMap.get(s[i]) - 1);\n        } else {\n            charIndexMap.set(s[i], i);\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    1. Initialize maxLength to -1 and create a hash map (or dictionary) called charIndexMap.\n2. Iterate through the string s and for each character:\n   a. If the character is already in charIndexMap, update maxLength with the maximum value between the current maxLength and the distance between the current index and the previous index of the character minus 1.\n   b. If the character is not in the charIndexMap, store the character and its index in the map.\n3. Return maxLength. If maxLength is never updated (no equal characters found), it will return -1 as required.\n    "}
{"id": 1751, "slug": "maximum-number-of-events-that-can-be-attended-ii", "title": "Maximum Number of Events That Can Be Attended II", "difficulty": "Hard", "content": "You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend.\n\nYou can only attend one event at a time. If you choose to attend an event, you must attend the **entire** event. Note that the end day is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends on the same day.\n\nReturn _the **maximum sum** of values that you can receive by attending events._\n\n**Example 1:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,1\\]\\], k = 2\n**Output:** 7\n**Explanation:** Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n\n**Example 2:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,10\\]\\], k = 2\n**Output:** 10\n**Explanation:** Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do **not** have to attend k events.\n\n**Example 3:**\n\n**Input:** events = \\[\\[1,1,1\\],\\[2,2,2\\],\\[3,3,3\\],\\[4,4,4\\]\\], k = 3\n**Output:** 9\n**Explanation:** Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.\n\n**Constraints:**\n\n*   `1 <= k <= events.length`\n*   `1 <= k * events.length <= 106`\n*   `1 <= startDayi <= endDayi <= 109`\n*   `1 <= valuei <= 106`", "java": "\n    ```java\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\n    char max_key = keysPressed.charAt(0);\n    int max_duration = releaseTimes[0];\n    for (int i = 1; i < releaseTimes.length; i++) {\n        int duration = releaseTimes[i] - releaseTimes[i - 1];\n        if (duration > max_duration || (duration == max_duration && keysPressed.charAt(i) > max_key)) {\n            max_key = keysPressed.charAt(i);\n            max_duration = duration;\n        }\n    }\n    return max_key;\n}\n```\n\n    \n    The algorithm starts by initializing the max_key to the first key in keysPressed and max_duration to the duration of the first key press. Then, from the second key press to the last, it calculates the duration of each key press by subtracting the previous release time from the current release time. It compares the current duration with the max_duration. If the current duration is larger than max_duration or if the durations are equal and the current key is lexicographically larger than the max_key, update max_key and max_duration. Finally, return max_key as the result.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nchar slowestKey(vector<int>& releaseTimes, string keysPressed) {\n    char max_key = keysPressed[0];\n    int max_duration = releaseTimes[0];\n    for (int i = 1; i < releaseTimes.size(); i++) {\n        int duration = releaseTimes[i] - releaseTimes[i - 1];\n        if (duration > max_duration || (duration == max_duration && keysPressed[i] > max_key)) {\n            max_key = keysPressed[i];\n            max_duration = duration;\n        }\n    }\n    return max_key;\n}\n```\n\n    \n    The algorithm starts by initializing the max_key to the first key in keysPressed and max_duration to the duration of the first key press. Then, from the second key press to the last, it calculates the duration of each key press by subtracting the previous release time from the current release time. It compares the current duration with the max_duration. If the current duration is larger than max_duration or if the durations are equal and the current key is lexicographically larger than the max_key, update max_key and max_duration. Finally, return max_key as the result.\n    ", "python": "\n    ```python\ndef slowestKey(releaseTimes, keysPressed):\n    max_key = keysPressed[0]\n    max_duration = releaseTimes[0]\n    for i in range(1, len(releaseTimes)):\n        duration = releaseTimes[i] - releaseTimes[i - 1]\n        if duration > max_duration or (duration == max_duration and keysPressed[i] > max_key):\n            max_key = keysPressed[i]\n            max_duration = duration\n    return max_key\n```\n\n    \n    The algorithm starts by initializing the max_key to the first key in keysPressed and max_duration to the duration of the first key press. Then, from the second key press to the last, it calculates the duration of each key press by subtracting the previous release time from the current release time. It compares the current duration with the max_duration. If the current duration is larger than max_duration or if the durations are equal and the current key is lexicographically larger than the max_key, update max_key and max_duration. Finally, return max_key as the result.\n    ", "javascript": "\n    ```javascript\nfunction slowestKey(releaseTimes, keysPressed) {\n    let max_key = keysPressed[0];\n    let max_duration = releaseTimes[0];\n\n    for (let i = 1; i < releaseTimes.length; i++) {\n        let duration = releaseTimes[i] - releaseTimes[i - 1];\n        if (duration > max_duration || (duration === max_duration && keysPressed[i] > max_key)) {\n            max_key = keysPressed[i];\n            max_duration = duration;\n        }\n    }\n    return max_key;\n}\n```\n\n    \n    The algorithm starts by initializing the max_key to the first key in keysPressed and max_duration to the duration of the first key press. Then, from the second key press to the last, it calculates the duration of each key press by subtracting the previous release time from the current release time. It compares the current duration with the max_duration. If the current duration is larger than max_duration or if the durations are equal and the current key is lexicographically larger than the max_key, update max_key and max_duration. Finally, return max_key as the result.\n    "}
{"id": 1755, "slug": "closest-subsequence-sum", "title": "Closest Subsequence Sum", "difficulty": "Hard", "content": "You are given an integer array `nums` and an integer `goal`.\n\nYou want to choose a subsequence of `nums` such that the sum of its elements is the closest possible to `goal`. That is, if the sum of the subsequence's elements is `sum`, then you want to **minimize the absolute difference** `abs(sum - goal)`.\n\nReturn _the **minimum** possible value of_ `abs(sum - goal)`.\n\nNote that a subsequence of an array is an array formed by removing some elements **(possibly all or none)** of the original array.\n\n**Example 1:**\n\n**Input:** nums = \\[5,-7,3,5\\], goal = 6\n**Output:** 0\n**Explanation:** Choose the whole array as a subsequence, with a sum of 6.\nThis is equal to the goal, so the absolute difference is 0.\n\n**Example 2:**\n\n**Input:** nums = \\[7,-9,15,-2\\], goal = -5\n**Output:** 1\n**Explanation:** Choose the subsequence \\[7,-9,-2\\], with a sum of -4.\nThe absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3\\], goal = -7\n**Output:** 7\n\n**Constraints:**\n\n*   `1 <= nums.length <= 40`\n*   `-107 <= nums[i] <= 107`\n*   `-109 <= goal <= 109`", "java": "\n    ```java\npublic int[] decrypt(int[] code, int k) {\n    int n = code.length;\n    int[] result = new int[n];\n    if (k == 0) return result;\n    \n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = 1; j <= Math.abs(k); j++) {\n            sum += k > 0 ? code[(i + j) % n] : code[(i - j + n) % n];\n        }\n        result[i] = sum;\n    }\n    return result;\n}\n```\n    \n    The given problem requires iterating through each element of the circular array code and, depending on the value of key k, summing up either the k next or k previous elements, and storing the sums into a new array called result. The new array represents the decrypted code.\n1. Create an array called 'result' of the same length as code and initialized with zeros in all fields. If k equals to 0, return the result immediately as all elements are already 0.\n2. Iterate through each element in code (use variable i as index). For each element, let sum be zero.\n3. Nested loop: iterate starting from j = 1 to abs(k), where abs() represents the absolute value. Add code elements to sum depending on k value:\n   - If k is greater than 0, add code[(i + j) % n].\n   - If k is less than 0, add code[(i - j + n) % n].\n4. Store sum in result array at index i.\n5. After iterating through all code elements, return the result array.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> decrypt(vector<int>& code, int k) {\n    int n = code.size();\n    vector<int> result(n);\n    if (k == 0) return vector<int>(n, 0);\n    \n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = 1; j <= abs(k); j++) {\n            sum += k > 0 ? code[(i + j) % n] : code[(i - j + n) % n];\n        }\n        result[i] = sum;\n    }\n    return result;\n}\n```\n    \n    The given problem requires iterating through each element of the circular array code and, depending on the value of key k, summing up either the k next or k previous elements, and storing the sums into a new array called result. The new array represents the decrypted code.\n1. Create an array called 'result' of the same length as code and initialized with zeros in all fields. If k equals to 0, return the result immediately as all elements are already 0.\n2. Iterate through each element in code (use variable i as index). For each element, let sum be zero.\n3. Nested loop: iterate starting from j = 1 to abs(k), where abs() represents the absolute value. Add code elements to sum depending on k value:\n   - If k is greater than 0, add code[(i + j) % n].\n   - If k is less than 0, add code[(i - j + n) % n].\n4. Store sum in result array at index i.\n5. After iterating through all code elements, return the result array.\n    ", "python": "\n    ```python\ndef decrypt(code, k):\n    n = len(code)\n    result = [0] * n\n    if k == 0: return result\n    \n    for i in range(n):\n        sum = 0\n        for j in range(1, abs(k) + 1):\n            sum += code[(i + j) % n] if k > 0 else code[(i - j + n) % n]\n        result[i] = sum\n    return result\n```\n    \n    The given problem requires iterating through each element of the circular array code and, depending on the value of key k, summing up either the k next or k previous elements, and storing the sums into a new array called result. The new array represents the decrypted code.\n1. Create an array called 'result' of the same length as code and initialized with zeros in all fields. If k equals to 0, return the result immediately as all elements are already 0.\n2. Iterate through each element in code (use variable i as index). For each element, let sum be zero.\n3. Nested loop: iterate starting from j = 1 to abs(k), where abs() represents the absolute value. Add code elements to sum depending on k value:\n   - If k is greater than 0, add code[(i + j) % n].\n   - If k is less than 0, add code[(i - j + n) % n].\n4. Store sum in result array at index i.\n5. After iterating through all code elements, return the result array.\n    ", "javascript": "\n    ```javascript\nfunction decrypt(code, k) {\n    const n = code.length;\n    const result = new Array(n).fill(0);\n    if (k === 0) return result;\n    \n    for (let i = 0; i < n; i++) {\n        let sum = 0;\n        for (let j = 1; j <= Math.abs(k); j++) {\n            sum += k > 0 ? code[(i + j) % n] : code[(i - j + n) % n];\n        }\n        result[i] = sum;\n    }\n    return result;\n}\n```\n    \n    The given problem requires iterating through each element of the circular array code and, depending on the value of key k, summing up either the k next or k previous elements, and storing the sums into a new array called result. The new array represents the decrypted code.\n1. Create an array called 'result' of the same length as code and initialized with zeros in all fields. If k equals to 0, return the result immediately as all elements are already 0.\n2. Iterate through each element in code (use variable i as index). For each element, let sum be zero.\n3. Nested loop: iterate starting from j = 1 to abs(k), where abs() represents the absolute value. Add code elements to sum depending on k value:\n   - If k is greater than 0, add code[(i + j) % n].\n   - If k is less than 0, add code[(i - j + n) % n].\n4. Store sum in result array at index i.\n5. After iterating through all code elements, return the result array.\n    "}
{"id": 1770, "slug": "maximum-score-from-performing-multiplication-operations", "title": "Maximum Score from Performing Multiplication Operations", "difficulty": "Hard", "content": "You are given two **0-indexed** integer arrays `nums` and `multipliers` of size `n` and `m` respectively, where `n >= m`.\n\nYou begin with a score of `0`. You want to perform **exactly** `m` operations. On the `ith` operation (**0-indexed**) you will:\n\n*   Choose one integer `x` from **either the start or the end** of the array `nums`.\n*   Add `multipliers[i] * x` to your score.\n    *   Note that `multipliers[0]` corresponds to the first operation, `multipliers[1]` to the second operation, and so on.\n*   Remove `x` from `nums`.\n\nReturn _the **maximum** score after performing_ `m` _operations._\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\], multipliers = \\[3,2,1\\]\n**Output:** 14\n**Explanation:** An optimal solution is as follows:\n- Choose from the end, \\[1,2,**3**\\], adding 3 \\* 3 = 9 to the score.\n- Choose from the end, \\[1,**2**\\], adding 2 \\* 2 = 4 to the score.\n- Choose from the end, \\[**1**\\], adding 1 \\* 1 = 1 to the score.\nThe total score is 9 + 4 + 1 = 14.\n\n**Example 2:**\n\n**Input:** nums = \\[-5,-3,-3,-2,7,1\\], multipliers = \\[-10,-5,3,4,6\\]\n**Output:** 102\n**Explanation:** An optimal solution is as follows:\n- Choose from the start, \\[**\\-5**,-3,-3,-2,7,1\\], adding -5 \\* -10 = 50 to the score.\n- Choose from the start, \\[**\\-3**,-3,-2,7,1\\], adding -3 \\* -5 = 15 to the score.\n- Choose from the start, \\[**\\-3**,-2,7,1\\], adding -3 \\* 3 = -9 to the score.\n- Choose from the end, \\[-2,7,**1**\\], adding 1 \\* 4 = 4 to the score.\n- Choose from the end, \\[-2,**7**\\], adding 7 \\* 6 = 42 to the score. \nThe total score is 50 + 15 - 9 + 4 + 42 = 102.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `m == multipliers.length`\n*   `1 <= m <= 300`\n*   `m <= n <= 105`\n*   `-1000 <= nums[i], multipliers[i] <= 1000`", "java": "\n    ```java\npublic int minDeletions(String s) {\n    int[] freq = new int[26];\n    HashSet<Integer> used = new HashSet<>();\n    int deletions = 0;\n\n    for (char c : s.toCharArray()) {\n        freq[c - 'a']++;\n    }\n\n    for (int count : freq) {\n        while (used.contains(count) && count > 0) {\n            deletions++;\n            count--;\n        }\n        used.add(count);\n    }\n\n    return deletions;\n}\n```\n    \n    1. Count the frequency of each character in the string.\n2. Create a set to store the unique frequencies that have been used.\n3. Initialize a deletion counter to 0.\n4. Iterate through the frequency counts of each character.\n5. For each count, check if it is already in the used set. If it is and the count is greater than 0, increment the deletion counter, and decrement the count.\n6. After adjusting the count, add the count to the used set.\n7. Return the deletion counter after iterating through all character frequencies.\n    ", "c++": "\n    ```cpp\nint minDeletions(string s) {\n    unordered_map<char, int> freq;\n    unordered_set<int> used;\n    int deletions = 0;\n\n    for (char c : s) {\n        freq[c]++;\n    }\n\n    for (auto const& [char, count] : freq) {\n        while (used.find(count) != used.end() && count > 0) {\n            deletions++;\n            count--;\n        }\n        used.insert(count);\n    }\n\n    return deletions;\n}\n```\n    \n    1. Count the frequency of each character in the string.\n2. Create a set to store the unique frequencies that have been used.\n3. Initialize a deletion counter to 0.\n4. Iterate through the frequency counts of each character.\n5. For each count, check if it is already in the used set. If it is and the count is greater than 0, increment the deletion counter, and decrement the count.\n6. After adjusting the count, add the count to the used set.\n7. Return the deletion counter after iterating through all character frequencies.\n    ", "python": "\n    ```python\ndef min_deletions(s):\n    freq = collections.Counter(s)\n    used = set()\n    deletions = 0\n\n    for count in freq.values():\n        while count in used and count > 0:\n            deletions += 1\n            count -= 1\n        used.add(count)\n\n    return deletions\n```\n    \n    1. Count the frequency of each character in the string.\n2. Create a set to store the unique frequencies that have been used.\n3. Initialize a deletion counter to 0.\n4. Iterate through the frequency counts of each character.\n5. For each count, check if it is already in the used set. If it is and the count is greater than 0, increment the deletion counter, and decrement the count.\n6. After adjusting the count, add the count to the used set.\n7. Return the deletion counter after iterating through all character frequencies.\n    ", "javascript": "\n    ```javascript\nfunction minDeletions(s) {\n    const freq = {};\n    const used = new Set();\n    let deletions = 0;\n\n    for (const c of s) {\n        freq[c] = (freq[c] || 0) + 1;\n    }\n\n    for (const count in freq) {\n        let num = freq[count];\n        while (used.has(num) && num > 0) {\n            deletions++;\n            num--;\n        }\n        used.add(num);\n    }\n\n    return deletions;\n}\n```\n    \n    1. Count the frequency of each character in the string.\n2. Create a set to store the unique frequencies that have been used.\n3. Initialize a deletion counter to 0.\n4. Iterate through the frequency counts of each character.\n5. For each count, check if it is already in the used set. If it is and the count is greater than 0, increment the deletion counter, and decrement the count.\n6. After adjusting the count, add the count to the used set.\n7. Return the deletion counter after iterating through all character frequencies.\n    "}
{"id": 1771, "slug": "maximize-palindrome-length-from-subsequences", "title": "Maximize Palindrome Length From Subsequences", "difficulty": "Hard", "content": "You are given two strings, `word1` and `word2`. You want to construct a string in the following manner:\n\n*   Choose some **non-empty** subsequence `subsequence1` from `word1`.\n*   Choose some **non-empty** subsequence `subsequence2` from `word2`.\n*   Concatenate the subsequences: `subsequence1 + subsequence2`, to make the string.\n\nReturn _the **length** of the longest **palindrome** that can be constructed in the described manner._ If no palindromes can be constructed, return `0`.\n\nA **subsequence** of a string `s` is a string that can be made by deleting some (possibly none) characters from `s` without changing the order of the remaining characters.\n\nA **palindrome** is a string that reads the same forward as well as backward.\n\n**Example 1:**\n\n**Input:** word1 =  \"cacb \", word2 =  \"cbba \"\n**Output:** 5\n**Explanation:** Choose  \"ab \" from word1 and  \"cba \" from word2 to make  \"abcba \", which is a palindrome.\n\n**Example 2:**\n\n**Input:** word1 =  \"ab \", word2 =  \"ab \"\n**Output:** 3\n**Explanation:** Choose  \"ab \" from word1 and  \"a \" from word2 to make  \"aba \", which is a palindrome.\n\n**Example 3:**\n\n**Input:** word1 =  \"aa \", word2 =  \"bb \"\n**Output:** 0\n**Explanation:** You cannot construct a palindrome from the described method, so return 0.\n\n**Constraints:**\n\n*   `1 <= word1.length, word2.length <= 1000`\n*   `word1` and `word2` consist of lowercase English letters.", "java": "\n    ```java\nimport java.util.*;\n\npublic int maxProfit(int[] inventory, int orders) {\n    long mod = 1000000007;\n    Integer[] inv = Arrays.stream(inventory).boxed().toArray(Integer[]::new);\n    Arrays.sort(inv, Collections.reverseOrder());\n    List<Integer> invList = new ArrayList<>(Arrays.asList(inv));\n    invList.add(0);\n    int n = invList.size();\n    long ans = 0, count = 1;\n    for (int i = 0; i < n - 1; ++i, ++count) {\n        long diff = invList.get(i) - invList.get(i + 1);\n        if (count * diff < orders) {\n            orders -= count * diff;\n            ans = (ans + (((invList.get(i) + invList.get(i + 1) + 1) * diff) / 2) % mod * count) % mod;\n        } else {\n            long q = orders / count;\n            long r = orders % count;\n            ans = (ans + (((invList.get(i) + invList.get(i) - q + 1) * q) / 2) % mod * count) % mod;\n            ans = (ans + r * (invList.get(i) - q)) % mod;\n            break;\n        }\n    }\n    return (int)ans;\n}\n```\n    \n    1. Sort the inventory array in decreasing order and append 0 to the end.\n2. Initialize a variable `count` to 1. This variable represents the number of balls that have the same value.\n3. Iterate through the inventory.\n    - Calculate the difference between the current element and the next element.\n    - If `count * diff` is smaller than the remaining `orders`, update `orders` and the `ans` appropriately. Increment the `count` variable.\n    - If `count * diff` is greater than or equal to `orders`, calculate the multiples and remainders of the orders in the current batch. Update the answer and break the loop.\n4. Return the calculated answer mod 1e9 + 7.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxProfit(std::vector<int>& inventory, int orders) {\n    long long mod = 1e9 + 7;\n    std::sort(inventory.begin(), inventory.end(), std::greater<>());\n    inventory.push_back(0);\n    long long n = inventory.size(), ans = 0, count = 1;\n    for (int i = 0; i < n - 1; ++i, ++count) {\n        long long diff = inventory[i] - inventory[i + 1];\n        if (count * diff < orders) {\n            orders -= count * diff;\n            ans = (ans + (((inventory[i] + inventory[i + 1] + 1) * diff) / 2) % mod * count) % mod;\n        } else {\n            long long q = orders / count;\n            long long r = orders % count;\n            ans = (ans + (((inventory[i] + inventory[i] - q + 1) * q) / 2) % mod * count) % mod;\n            ans = (ans + r * (inventory[i] - q)) % mod;\n            break;\n        }\n    }\n    return ans;\n}\n```\n    \n    1. Sort the inventory array in decreasing order and append 0 to the end.\n2. Initialize a variable `count` to 1. This variable represents the number of balls that have the same value.\n3. Iterate through the inventory.\n    - Calculate the difference between the current element and the next element.\n    - If `count * diff` is smaller than the remaining `orders`, update `orders` and the `ans` appropriately. Increment the `count` variable.\n    - If `count * diff` is greater than or equal to `orders`, calculate the multiples and remainders of the orders in the current batch. Update the answer and break the loop.\n4. Return the calculated answer mod 1e9 + 7.\n    ", "python": "\n    ```python\ndef maxProfit(inventory, orders):\n    mod = 10**9 + 7\n    inventory.sort(reverse=True)\n    inventory.append(0)\n    n, ans, count = len(inventory), 0, 1\n    for i in range(n - 1):\n        diff = inventory[i] - inventory[i + 1]\n        if count * diff < orders:\n            orders -= count * diff\n            ans = (ans + (((inventory[i] + inventory[i + 1] + 1) * diff) // 2) % mod * count) % mod\n        else:\n            q, r = divmod(orders, count)\n            ans = (ans + (((inventory[i] + inventory[i] - q + 1) * q) // 2) % mod * count) % mod\n            ans = (ans + r * (inventory[i] - q)) % mod\n            break\n        count += 1\n    return ans\n```\n    \n    1. Sort the inventory array in decreasing order and append 0 to the end.\n2. Initialize a variable `count` to 1. This variable represents the number of balls that have the same value.\n3. Iterate through the inventory.\n    - Calculate the difference between the current element and the next element.\n    - If `count * diff` is smaller than the remaining `orders`, update `orders` and the `ans` appropriately. Increment the `count` variable.\n    - If `count * diff` is greater than or equal to `orders`, calculate the multiples and remainders of the orders in the current batch. Update the answer and break the loop.\n4. Return the calculated answer mod 1e9 + 7.\n    ", "javascript": "\n    ```javascript\nfunction maxProfit(inventory, orders) {\n    const mod = 1e9 + 7;\n    inventory.sort((a, b) => b - a).push(0);\n    let n = inventory.length, ans = 0n, count = 1n;\n    for (let i = 0; i < n - 1; ++i, ++count) {\n        const diff = BigInt(inventory[i] - inventory[i + 1]);\n        if (count * diff < orders) {\n            orders -= count * diff;\n            ans = (ans + (((BigInt(inventory[i]) + BigInt(inventory[i + 1]) + 1n) * diff) / 2n) % mod * count) % mod;\n        } else {\n            const q = BigInt(orders / count);\n            const r = BigInt(orders % count);\n            ans = (ans + (((BigInt(inventory[i]) + BigInt(inventory[i]) - q + 1n) * q) / 2n) % mod * count) % mod;\n            ans = (ans + r * (BigInt(inventory[i]) - q)) % mod;\n            break;\n        }\n    }\n    return parseInt(ans);\n}\n```\n    \n    1. Sort the inventory array in decreasing order and append 0 to the end.\n2. Initialize a variable `count` to 1. This variable represents the number of balls that have the same value.\n3. Iterate through the inventory.\n    - Calculate the difference between the current element and the next element.\n    - If `count * diff` is smaller than the remaining `orders`, update `orders` and the `ans` appropriately. Increment the `count` variable.\n    - If `count * diff` is greater than or equal to `orders`, calculate the multiples and remainders of the orders in the current batch. Update the answer and break the loop.\n4. Return the calculated answer mod 1e9 + 7.\n    "}
{"id": 1786, "slug": "number-of-restricted-paths-from-first-to-last-node", "title": "Number of Restricted Paths From First to Last Node", "difficulty": "Medium", "content": "There is an undirected weighted connected graph. You are given a positive integer `n` which denotes that the graph has `n` nodes labeled from `1` to `n`, and an array `edges` where each `edges[i] = [ui, vi, weighti]` denotes that there is an edge between nodes `ui` and `vi` with weight equal to `weighti`.\n\nA path from node `start` to node `end` is a sequence of nodes `[z0, z1, z2, ..., zk]` such that `z0 = start` and `zk = end` and there is an edge between `zi` and `zi+1` where `0 <= i <= k-1`.\n\nThe distance of a path is the sum of the weights on the edges of the path. Let `distanceToLastNode(x)` denote the shortest distance of a path between node `n` and node `x`. A **restricted path** is a path that also satisfies that `distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k-1`.\n\nReturn _the number of restricted paths from node_ `1` _to node_ `n`. Since that number may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[1,2,3\\],\\[1,3,3\\],\\[2,3,1\\],\\[1,4,2\\],\\[5,2,2\\],\\[3,5,1\\],\\[5,4,10\\]\\]\n**Output:** 3\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The three restricted paths are:\n1) 1 --> 2 --> 5\n2) 1 --> 2 --> 3 --> 5\n3) 1 --> 3 --> 5\n\n**Example 2:**\n\n**Input:** n = 7, edges = \\[\\[1,3,1\\],\\[4,1,2\\],\\[7,3,4\\],\\[2,5,3\\],\\[5,6,1\\],\\[6,7,2\\],\\[7,5,3\\],\\[2,6,4\\]\\]\n**Output:** 1\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The only restricted path is 1 --> 3 --> 7.\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `n - 1 <= edges.length <= 4 * 104`\n*   `edges[i].length == 3`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   `1 <= weighti <= 105`\n*   There is at most one edge between any two nodes.\n*   There is at least one path between any two nodes.", "java": "\n    ```java\npublic int countConsistentStrings(String allowed, String[] words) {\n    Set<Character> allowedSet = new HashSet<>();\n    for (char c : allowed.toCharArray()) {\n        allowedSet.add(c);\n    }\n    int count = 0;\n    for (String word : words) {\n        boolean isValid = true;\n        for (char c : word.toCharArray()) {\n            if (!allowedSet.contains(c)) {\n                isValid = false;\n                break;\n            }\n        }\n        if (isValid) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    We create a set (allowedSet) with the characters of the allowed string. This makes it easy to check if a character is in the allowed string. We initialize a count variable with 0 as the number of consistent words.\n\nFor each word in the words array, we consider it valid initially. Then, we check each character in the word. If it's not in the allowedSet, the word is not valid, and we break the loop. If the word is valid, we increment the count by 1.\n\nAfter checking all the words, we return the count as the result. Our algorithm has a time complexity of O(n*m) where n is the number of words and m is the average length of those words.\n    ", "c++": "\n    ```cpp\nint countConsistentStrings(string allowed, vector<string>& words) {\n    unordered_set<char> allowedSet(allowed.begin(), allowed.end());\n    int count = 0;\n    for (const string& word : words) {\n        bool isValid = true;\n        for (char c : word) {\n            if (allowedSet.count(c) == 0) {\n                isValid = false;\n                break;\n            }\n        }\n        if (isValid) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    We create a set (allowedSet) with the characters of the allowed string. This makes it easy to check if a character is in the allowed string. We initialize a count variable with 0 as the number of consistent words.\n\nFor each word in the words array, we consider it valid initially. Then, we check each character in the word. If it's not in the allowedSet, the word is not valid, and we break the loop. If the word is valid, we increment the count by 1.\n\nAfter checking all the words, we return the count as the result. Our algorithm has a time complexity of O(n*m) where n is the number of words and m is the average length of those words.\n    ", "python": "\n    ```python\ndef count_consistent_strings(allowed, words):\n    allowed_set = set(allowed)\n    count = 0\n    for word in words:\n        is_valid = True\n        for c in word:\n            if c not in allowed_set:\n                is_valid = False\n                break\n        if is_valid:\n            count += 1\n    return count\n```\n    \n    We create a set (allowedSet) with the characters of the allowed string. This makes it easy to check if a character is in the allowed string. We initialize a count variable with 0 as the number of consistent words.\n\nFor each word in the words array, we consider it valid initially. Then, we check each character in the word. If it's not in the allowedSet, the word is not valid, and we break the loop. If the word is valid, we increment the count by 1.\n\nAfter checking all the words, we return the count as the result. Our algorithm has a time complexity of O(n*m) where n is the number of words and m is the average length of those words.\n    ", "javascript": "\n    ```javascript\nfunction countConsistentStrings(allowed, words) {\n    const allowedSet = new Set(allowed);\n    let count = 0;\n    for (const word of words) {\n        let isValid = true;\n        for (const c of word) {\n            if (!allowedSet.has(c)) {\n                isValid = false;\n                break;\n            }\n        }\n        if (isValid) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    We create a set (allowedSet) with the characters of the allowed string. This makes it easy to check if a character is in the allowed string. We initialize a count variable with 0 as the number of consistent words.\n\nFor each word in the words array, we consider it valid initially. Then, we check each character in the word. If it's not in the allowedSet, the word is not valid, and we break the loop. If the word is valid, we increment the count by 1.\n\nAfter checking all the words, we return the count as the result. Our algorithm has a time complexity of O(n*m) where n is the number of words and m is the average length of those words.\n    "}
{"id": 1787, "slug": "make-the-xor-of-all-segments-equal-to-zero", "title": "Make the XOR of All Segments Equal to Zero", "difficulty": "Hard", "content": "You are given an array `nums`\u200b\u200b\u200b and an integer `k`\u200b\u200b\u200b\u200b\u200b. The XOR of a segment `[left, right]` where `left <= right` is the `XOR` of all the elements with indices between `left` and `right`, inclusive: `nums[left] XOR nums[left+1] XOR ... XOR nums[right]`.\n\nReturn _the minimum number of elements to change in the array_ such that the `XOR` of all segments of size `k`\u200b\u200b\u200b\u200b\u200b\u200b is equal to zero.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,0,3,0\\], k = 1\n**Output:** 3\n**Explanation:** Modify the array from \\[**1**,**2**,0,**3**,0\\] to from \\[**0**,**0**,0,**0**,0\\].\n\n**Example 2:**\n\n**Input:** nums = \\[3,4,5,2,1,7,3,4,7\\], k = 3\n**Output:** 3\n**Explanation:** Modify the array from \\[3,4,**5**,**2**,**1**,7,3,4,7\\] to \\[3,4,**7**,**3**,**4**,7,3,4,7\\].\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,4,1,2,5,1,2,6\\], k = 3\n**Output:** 3\n**Explanation:** Modify the array from \\[1,2,**4,**1,2,**5**,1,2,**6**\\] to \\[1,2,**3**,1,2,**3**,1,2,**3**\\].\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 2000`\n*   `\u200b\u200b\u200b\u200b\u200b\u200b0 <= nums[i] < 210`", "java": "\n    ```java\npublic int[] calculateSummationOfAbsoluteDifferences(int[] nums) {\n    int n = nums.length;\n    int[] result = new int[n];\n\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i != j) {\n                result[i] += Math.abs(nums[i] - nums[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm iterates through each element `nums[i]` in the given integer array `nums`. For each element `nums[i]`, it also iterates through all other elements `nums[j]` in the array, skipping the case when `i == j`. Then, it calculates the absolute difference between `nums[i]` and `nums[j]`, and sums it to the corresponding result for element `nums[i]`. After iterating through all elements, an array `result` containing the summations of absolute differences for each element is returned.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> calculate_summation_of_absolute_differences(const std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> result(n, 0);\n\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i != j) {\n                result[i] += std::abs(nums[i] - nums[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm iterates through each element `nums[i]` in the given integer array `nums`. For each element `nums[i]`, it also iterates through all other elements `nums[j]` in the array, skipping the case when `i == j`. Then, it calculates the absolute difference between `nums[i]` and `nums[j]`, and sums it to the corresponding result for element `nums[i]`. After iterating through all elements, an array `result` containing the summations of absolute differences for each element is returned.\n    ", "python": "\n    ```python\ndef calculate_summation_of_absolute_differences(nums):\n    n = len(nums)\n    result = [0] * n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                result[i] += abs(nums[i] - nums[j])\n\n    return result\n```\n    \n    The algorithm iterates through each element `nums[i]` in the given integer array `nums`. For each element `nums[i]`, it also iterates through all other elements `nums[j]` in the array, skipping the case when `i == j`. Then, it calculates the absolute difference between `nums[i]` and `nums[j]`, and sums it to the corresponding result for element `nums[i]`. After iterating through all elements, an array `result` containing the summations of absolute differences for each element is returned.\n    ", "javascript": "\n    ```javascript\nfunction calculateSummationOfAbsoluteDifferences(nums) {\n    let n = nums.length;\n    let result = new Array(n).fill(0);\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < n; j++) {\n            if(i !== j) {\n                result[i] += Math.abs(nums[i] - nums[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm iterates through each element `nums[i]` in the given integer array `nums`. For each element `nums[i]`, it also iterates through all other elements `nums[j]` in the array, skipping the case when `i == j`. Then, it calculates the absolute difference between `nums[i]` and `nums[j]`, and sums it to the corresponding result for element `nums[i]`. After iterating through all elements, an array `result` containing the summations of absolute differences for each element is returned.\n    "}
{"id": 1799, "slug": "maximize-score-after-n-operations", "title": "Maximize Score After N Operations", "difficulty": "Hard", "content": "You are given `nums`, an array of positive integers of size `2 * n`. You must perform `n` operations on this array.\n\nIn the `ith` operation **(1-indexed)**, you will:\n\n*   Choose two elements, `x` and `y`.\n*   Receive a score of `i * gcd(x, y)`.\n*   Remove `x` and `y` from `nums`.\n\nReturn _the maximum score you can receive after performing_ `n` _operations._\n\nThe function `gcd(x, y)` is the greatest common divisor of `x` and `y`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2\\]\n**Output:** 1\n**Explanation:** The optimal choice of operations is:\n(1 \\* gcd(1, 2)) = 1\n\n**Example 2:**\n\n**Input:** nums = \\[3,4,6,8\\]\n**Output:** 11\n**Explanation:** The optimal choice of operations is:\n(1 \\* gcd(3, 6)) + (2 \\* gcd(4, 8)) = 3 + 8 = 11\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5,6\\]\n**Output:** 14\n**Explanation:** The optimal choice of operations is:\n(1 \\* gcd(1, 5)) + (2 \\* gcd(2, 4)) + (3 \\* gcd(3, 6)) = 1 + 4 + 9 = 14\n\n**Constraints:**\n\n*   `1 <= n <= 7`\n*   `nums.length == 2 * n`\n*   `1 <= nums[i] <= 106`", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.LinkedList;\n\nclass Solution {\n    public int minimumIncompatibility(int[] nums, int k) {\n        int n = nums.length;\n        if (n % k != 0) return -1;\n        \n        Arrays.sort(nums);\n        LinkedList<Integer> diffList = new LinkedList<>();\n        for (int i = 0; i < k; ++i) {\n            diffList.add(nums[(i + 1) * (n / k) - 1] - nums[i * (n / k)]);\n        }\n        \n        int sum = 0;\n        for (Integer diff : diffList) {\n            sum += diff;\n        }\n        \n        return sum;\n    }\n}\n```\n    \n    1. Get the length of the array and check if it can be divided into k subsets equally. If not, return -1.\n\n2. Sort the array in ascending order.\n\n3. Calculate the incompatibility for each subset by the difference between the maximum and minimum elements in that subset.\n\n4. Store the incompatibilities of subsets in a multiset for C++, LinkedList for Java, list for Python, and an array for JavaScript.\n\n5. Iterate through the created data structure and add up all the incompatibilities stored in it. Return the calculated sum.\n    ", "c++": "\n    ```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumIncompatibility(vector<int>& nums, int k) {\n    int n = nums.size();\n    if (n % k != 0) return -1;\n\n    sort(nums.begin(), nums.end());\n    multiset<int> st;\n    for (int i = 0; i < k; ++i) {\n        st.insert(nums[i * (n / k)] - nums[(i + 1) * (n / k) - 1]);\n    }\n\n    return accumulate(st.begin(), st.end(), 0);\n}\n```\n    \n    1. Get the length of the array and check if it can be divided into k subsets equally. If not, return -1.\n\n2. Sort the array in ascending order.\n\n3. Calculate the incompatibility for each subset by the difference between the maximum and minimum elements in that subset.\n\n4. Store the incompatibilities of subsets in a multiset for C++, LinkedList for Java, list for Python, and an array for JavaScript.\n\n5. Iterate through the created data structure and add up all the incompatibilities stored in it. Return the calculated sum.\n    ", "python": "\n    ```python\nfrom typing import List\n\ndef minimumIncompatibility(nums: List[int], k: int) -> int:\n    n = len(nums)\n    if n % k != 0:\n        return -1\n    \n    nums.sort()\n    diffs = [nums[(i + 1) * (n // k) - 1] - nums[i * (n // k)] for i in range(k)]\n    \n    return sum(diffs)\n```\n    \n    1. Get the length of the array and check if it can be divided into k subsets equally. If not, return -1.\n\n2. Sort the array in ascending order.\n\n3. Calculate the incompatibility for each subset by the difference between the maximum and minimum elements in that subset.\n\n4. Store the incompatibilities of subsets in a multiset for C++, LinkedList for Java, list for Python, and an array for JavaScript.\n\n5. Iterate through the created data structure and add up all the incompatibilities stored in it. Return the calculated sum.\n    ", "javascript": "\n    ```javascript\nfunction minimumIncompatibility(nums, k) {\n    let n = nums.length;\n    if (n % k !== 0) return -1;\n    \n    nums.sort((a, b) => a - b);\n    let diffs = [];\n    for (let i = 0; i < k; ++i) {\n        diffs.push(nums[(i + 1) * (n / k) - 1] - nums[i * (n / k)]);\n    }\n    \n    return diffs.reduce((acc, curr) => acc + curr, 0);\n}\n```\n    \n    1. Get the length of the array and check if it can be divided into k subsets equally. If not, return -1.\n\n2. Sort the array in ascending order.\n\n3. Calculate the incompatibility for each subset by the difference between the maximum and minimum elements in that subset.\n\n4. Store the incompatibilities of subsets in a multiset for C++, LinkedList for Java, list for Python, and an array for JavaScript.\n\n5. Iterate through the created data structure and add up all the incompatibilities stored in it. Return the calculated sum.\n    "}
{"id": 1815, "slug": "maximum-number-of-groups-getting-fresh-donuts", "title": "Maximum Number of Groups Getting Fresh Donuts", "difficulty": "Hard", "content": "There is a donuts shop that bakes donuts in batches of `batchSize`. They have a rule where they must serve **all** of the donuts of a batch before serving any donuts of the next batch. You are given an integer `batchSize` and an integer array `groups`, where `groups[i]` denotes that there is a group of `groups[i]` customers that will visit the shop. Each customer will get exactly one donut.\n\nWhen a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group.\n\nYou can freely rearrange the ordering of the groups. Return _the **maximum** possible number of happy groups after rearranging the groups._\n\n**Example 1:**\n\n**Input:** batchSize = 3, groups = \\[1,2,3,4,5,6\\]\n**Output:** 4\n**Explanation:** You can arrange the groups as \\[6,2,4,5,1,3\\]. Then the 1st, 2nd, 4th, and 6th groups will be happy.\n\n**Example 2:**\n\n**Input:** batchSize = 4, groups = \\[1,3,2,5,2,2,1,6\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= batchSize <= 9`\n*   `1 <= groups.length <= 30`\n*   `1 <= groups[i] <= 109`", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\n        int[] queryIDs = new int[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            queryIDs[i] = i;\n        }\n        Arrays.sort(queryIDs, (i, j) -> Integer.compare(queries[i][2], queries[j][2]));\n        Arrays.sort(edgeList, (a, b) -> Integer.compare(a[2], b[2]));\n\n        int[] parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n\n        boolean[] res = new boolean[queries.length];\n        int idx = 0;\n        for (int queryID : queryIDs) {\n            int[] query = queries[queryID];\n            int p = query[0], q = query[1], limit = query[2];\n\n            while (idx < edgeList.length && edgeList[idx][2] < limit) {\n                int u = edgeList[idx][0], v = edgeList[idx][1];\n                int ru = find(u, parent), rv = find(v, parent);\n                if (ru != rv) {\n                    parent[ru] = rv;\n                }\n                idx++;\n            }\n            res[queryID] = find(p, parent) == find(q, parent);\n        }\n        return res;\n    }\n\n    private int find(int x, int[] parent) {\n        if (x != parent[x]) {\n            parent[x] = find(parent[x], parent);\n        }\n        return parent[x];\n    }\n}\n```\n    \n    The algorithm starts by sorting `edgeList` by edge distance and `queries` by limit. We then use a disjoint set data structure (implemented using the `parent` list) to keep track of connected components, and we initialize each node to be its own parent.\n\nThe main idea of the algorithm is to iterate through the sorted queries and process those edges (in the edge list) with distance smaller than the query limit. We do this by iterating through the `queries`, and within each iteration, we iterate through the `edgeList` for all edges with distance less than the query limit, and union the connected nodes in the parent.\n\nAfter processing the edges, we then check if the two nodes in the current query, `p` and `q`, are in the same connected component. If they are, it means that there exists a path between them with edge distances less than the query limit. We store this result in the answer array.\n\nFinally, we return the answer array containing boolean values for each query.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\n    for (int i = 0; i < queries.size(); ++i) {\n        queries[i].push_back(i);\n    }\n    sort(queries.begin(), queries.end(), [](const vector<int> &a, const vector<int> &b) {\n        return a[2] < b[2];\n    });\n    sort(edgeList.begin(), edgeList.end(), [](const vector<int> &a, const vector<int> &b) {\n        return a[2] < b[2];\n    });\n\n    vector<int> parent(n);\n    for (int i = 0; i < n; ++i) {\n        parent[i] = i;\n    }\n\n    function<int(int)> find = [&](int x) {\n        return x == parent[x] ? x : parent[x] = find(parent[x]);\n    };\n\n    vector<bool> res(queries.size());\n    int idx = 0;\n    for (const auto &query : queries) {\n        int p = query[0], q = query[1], limit = query[2], id = query[3];\n        while (idx < edgeList.size() && edgeList[idx][2] < limit) {\n            int u = edgeList[idx][0], v = edgeList[idx][1];\n            int ru = find(u), rv = find(v);\n            if (ru != rv) {\n                parent[ru] = rv;\n            }\n            idx++;\n        }\n        res[id] = find(p) == find(q);\n    }\n    return res;\n}\n```\n    \n    The algorithm starts by sorting `edgeList` by edge distance and `queries` by limit. We then use a disjoint set data structure (implemented using the `parent` list) to keep track of connected components, and we initialize each node to be its own parent.\n\nThe main idea of the algorithm is to iterate through the sorted queries and process those edges (in the edge list) with distance smaller than the query limit. We do this by iterating through the `queries`, and within each iteration, we iterate through the `edgeList` for all edges with distance less than the query limit, and union the connected nodes in the parent.\n\nAfter processing the edges, we then check if the two nodes in the current query, `p` and `q`, are in the same connected component. If they are, it means that there exists a path between them with edge distances less than the query limit. We store this result in the answer array.\n\nFinally, we return the answer array containing boolean values for each query.\n    ", "python": "\n    ```python\nfrom typing import List\n\ndef distanceLimitedPathsExist(n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    edgeList.sort(key=lambda x: x[2])\n    queries = sorted(enumerate(queries), key=lambda x: x[1][2])\n\n    def find(x: int, parent: List[int]) -> int:\n        if x != parent[x]:\n            parent[x] = find(parent[x], parent)\n        return parent[x]\n\n    parent = list(range(n))\n    res = [False] * len(queries)\n    idx = 0\n\n    for query_id, query in queries:\n        p, q, limit = query\n        while idx < len(edgeList) and edgeList[idx][2] < limit:\n            u, v = edgeList[idx][:2]\n            ru, rv = find(u, parent), find(v, parent)\n            if ru != rv:\n                parent[ru] = rv\n            idx += 1\n        res[query_id] = find(p, parent) == find(q, parent)\n\n    return res\n```\n    \n    The algorithm starts by sorting `edgeList` by edge distance and `queries` by limit. We then use a disjoint set data structure (implemented using the `parent` list) to keep track of connected components, and we initialize each node to be its own parent.\n\nThe main idea of the algorithm is to iterate through the sorted queries and process those edges (in the edge list) with distance smaller than the query limit. We do this by iterating through the `queries`, and within each iteration, we iterate through the `edgeList` for all edges with distance less than the query limit, and union the connected nodes in the parent.\n\nAfter processing the edges, we then check if the two nodes in the current query, `p` and `q`, are in the same connected component. If they are, it means that there exists a path between them with edge distances less than the query limit. We store this result in the answer array.\n\nFinally, we return the answer array containing boolean values for each query.\n    ", "javascript": "\n    ```javascript\nfunction distanceLimitedPathsExist(n, edgeList, queries) {\n    edgeList.sort((a, b) => a[2] - b[2]);\n    queries = queries.map((query, idx) => [...query, idx]).sort((a, b) => a[2] - b[2]);\n\n    function find(x, parent) {\n        if (x !== parent[x]) {\n            parent[x] = find(parent[x], parent);\n        }\n        return parent[x];\n    }\n\n    const parent = Array.from({ length: n }, (_, idx) => idx);\n    const res = new Array(queries.length).fill(false);\n    let idx = 0;\n\n    for (const query of queries) {\n        const [p, q, limit, queryId] = query;\n        while (idx < edgeList.length && edgeList[idx][2] < limit) {\n            const [u, v] = edgeList[idx];\n            const [ru, rv] = [find(u, parent), find(v, parent)];\n            if (ru !== rv) {\n                parent[ru] = rv;\n            }\n            idx++;\n        }\n        res[queryId] = find(p, parent) === find(q, parent);\n    }\n\n    return res;\n}\n```\n    \n    The algorithm starts by sorting `edgeList` by edge distance and `queries` by limit. We then use a disjoint set data structure (implemented using the `parent` list) to keep track of connected components, and we initialize each node to be its own parent.\n\nThe main idea of the algorithm is to iterate through the sorted queries and process those edges (in the edge list) with distance smaller than the query limit. We do this by iterating through the `queries`, and within each iteration, we iterate through the `edgeList` for all edges with distance less than the query limit, and union the connected nodes in the parent.\n\nAfter processing the edges, we then check if the two nodes in the current query, `p` and `q`, are in the same connected component. If they are, it means that there exists a path between them with edge distances less than the query limit. We store this result in the answer array.\n\nFinally, we return the answer array containing boolean values for each query.\n    "}
{"id": 1824, "slug": "minimum-sideway-jumps", "title": "Minimum Sideway Jumps", "difficulty": "Medium", "content": "There is a **3 lane road** of length `n` that consists of `n + 1` **points** labeled from `0` to `n`. A frog **starts** at point `0` in the **second** lane and wants to jump to point `n`. However, there could be obstacles along the way.\n\nYou are given an array `obstacles` of length `n + 1` where each `obstacles[i]` (**ranging from 0 to 3**) describes an obstacle on the lane `obstacles[i]` at point `i`. If `obstacles[i] == 0`, there are no obstacles at point `i`. There will be **at most one** obstacle in the 3 lanes at each point.\n\n*   For example, if `obstacles[2] == 1`, then there is an obstacle on lane 1 at point 2.\n\nThe frog can only travel from point `i` to point `i + 1` on the same lane if there is not an obstacle on the lane at point `i + 1`. To avoid obstacles, the frog can also perform a **side jump** to jump to **another** lane (even if they are not adjacent) at the **same** point if there is no obstacle on the new lane.\n\n*   For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\nReturn _the **minimum number of side jumps** the frog needs to reach **any lane** at point n starting from lane `2` at point 0._\n\n**Note:** There will be no obstacles on points `0` and `n`.\n\n**Example 1:**\n\n**Input:** obstacles = \\[0,1,2,3,0\\]\n**Output:** 2 \n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n\n**Example 2:**\n\n**Input:** obstacles = \\[0,1,1,3,3,0\\]\n**Output:** 0\n**Explanation:** There are no obstacles on lane 2. No side jumps are required.\n\n**Example 3:**\n\n**Input:** obstacles = \\[0,2,1,0,3,0\\]\n**Output:** 2\n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps.\n\n**Constraints:**\n\n*   `obstacles.length == n + 1`\n*   `1 <= n <= 5 * 105`\n*   `0 <= obstacles[i] <= 3`\n*   `obstacles[0] == obstacles[n] == 0`", "java": "\n    ```java\nimport java.util.*;\n\npublic int eatenApples(int[] apples, int[] days) {\n    int n = apples.length;\n    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n    int ans = 0;\n\n    for (int i = 0; i < n || !pq.isEmpty(); ++i) {\n        if (i < n && apples[i] > 0) {\n            pq.offer(new int[]{i + days[i], apples[i]});\n        }\n\n        while (!pq.isEmpty() && pq.peek()[0] <= i) {\n            pq.poll();\n        }\n\n        if (!pq.isEmpty()) {\n            ans++;\n            int[] curr_apple = pq.poll();\n            if (curr_apple[1] > 1) {\n                curr_apple[1]--;\n                pq.offer(curr_apple);\n            }\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    To find the maximum number of apples that can be eaten, we can use the following greedy approach using min-heap (priority_queue):\n\n1. Iterate through the days 0 to n, and for each day, add the apples grown and its expiration date (`i + days[i]`) to the min-heap.\n2. Keep popping elements from the min-heap if their expiration date is less than or equal to the current day, as they are not edible anymore.\n3. If the min-heap is not empty, eat one apple from the least expiration date, and reduce its count by 1. Put it back in the min-heap if there are more apples with that expiration date.\n4. Keep this process up until we've checked all the apples.\n\nThe time complexity of this solution is O(n log n) due to the use of a min-heap.\n    ", "c++": "\n    ```cpp\n#include <queue>\n\nint eatenApples(vector<int>& apples, vector<int>& days) {\n    int n = apples.size();\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    int ans = 0;\n\n    for (int i = 0; i < n || !pq.empty(); ++i) {\n        if (i < n && apples[i] > 0) {\n            pq.push({i + days[i], apples[i]});\n        }\n\n        while (!pq.empty() && pq.top().first <= i) {\n            pq.pop();\n        }\n\n        if (!pq.empty()) {\n            ans++;\n            auto curr_apple = pq.top();\n            pq.pop();\n            if (curr_apple.second > 1) {\n                curr_apple.second--;\n                pq.push(curr_apple);\n            }\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    To find the maximum number of apples that can be eaten, we can use the following greedy approach using min-heap (priority_queue):\n\n1. Iterate through the days 0 to n, and for each day, add the apples grown and its expiration date (`i + days[i]`) to the min-heap.\n2. Keep popping elements from the min-heap if their expiration date is less than or equal to the current day, as they are not edible anymore.\n3. If the min-heap is not empty, eat one apple from the least expiration date, and reduce its count by 1. Put it back in the min-heap if there are more apples with that expiration date.\n4. Keep this process up until we've checked all the apples.\n\nThe time complexity of this solution is O(n log n) due to the use of a min-heap.\n    ", "python": "\n    ```python\nimport heapq\n\ndef eatenApples(apples, days):\n    n = len(apples)\n    pq = []\n    ans = 0\n\n    for i in range(n + 1):\n        if i < n and apples[i] > 0:\n            heapq.heappush(pq, (i + days[i], apples[i]))\n\n        while pq and pq[0][0] <= i:\n            heapq.heappop(pq)\n\n        if pq:\n            ans += 1\n            curr_apple = heapq.heappop(pq)\n            if curr_apple[1] > 1:\n                heapq.heappush(pq, (curr_apple[0], curr_apple[1] - 1))\n\n    return ans\n```\n\n    \n    To find the maximum number of apples that can be eaten, we can use the following greedy approach using min-heap (priority_queue):\n\n1. Iterate through the days 0 to n, and for each day, add the apples grown and its expiration date (`i + days[i]`) to the min-heap.\n2. Keep popping elements from the min-heap if their expiration date is less than or equal to the current day, as they are not edible anymore.\n3. If the min-heap is not empty, eat one apple from the least expiration date, and reduce its count by 1. Put it back in the min-heap if there are more apples with that expiration date.\n4. Keep this process up until we've checked all the apples.\n\nThe time complexity of this solution is O(n log n) due to the use of a min-heap.\n    ", "javascript": "\n    ```javascript\nfunction eatenApples(apples, days) {\n    const n = apples.length;\n    const pq = new PriorityQueue();\n    let ans = 0;\n\n    for (let i = 0; i < n || !pq.isEmpty(); ++i) {\n        if (i < n && apples[i] > 0) {\n            pq.enqueue([i + days[i], apples[i]]);\n        }\n\n        while (!pq.isEmpty() && pq.peek()[0] <= i) {\n            pq.dequeue();\n        }\n\n        if (!pq.isEmpty()) {\n            ans++;\n            let curr_apple = pq.dequeue();\n            if (curr_apple[1] > 1) {\n                curr_apple[1]--;\n                pq.enqueue(curr_apple);\n            }\n        }\n    }\n\n    return ans;\n}\n\nclass PriorityQueue {\n    constructor(comparator = (a, b) => a[0] - b[0]) {\n        this._comparator = comparator;\n        this._queue = [];\n    }\n\n    // Additional methods and details omitted ...\n}\n```\n\n    \n    To find the maximum number of apples that can be eaten, we can use the following greedy approach using min-heap (priority_queue):\n\n1. Iterate through the days 0 to n, and for each day, add the apples grown and its expiration date (`i + days[i]`) to the min-heap.\n2. Keep popping elements from the min-heap if their expiration date is less than or equal to the current day, as they are not edible anymore.\n3. If the min-heap is not empty, eat one apple from the least expiration date, and reduce its count by 1. Put it back in the min-heap if there are more apples with that expiration date.\n4. Keep this process up until we've checked all the apples.\n\nThe time complexity of this solution is O(n log n) due to the use of a min-heap.\n    "}
{"id": 1866, "slug": "number-of-ways-to-rearrange-sticks-with-k-sticks-visible", "title": "Number of Ways to Rearrange Sticks With K Sticks Visible", "difficulty": "Hard", "content": "There are `n` uniquely-sized sticks whose lengths are integers from `1` to `n`. You want to arrange the sticks such that **exactly** `k` sticks are **visible** from the left. A stick is **visible** from the left if there are no **longer** sticks to the **left** of it.\n\n*   For example, if the sticks are arranged `[1,3,2,5,4]`, then the sticks with lengths `1`, `3`, and `5` are visible from the left.\n\nGiven `n` and `k`, return _the **number** of such arrangements_. Since the answer may be large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 3, k = 2\n**Output:** 3\n**Explanation:** \\[1,3,2\\], \\[2,3,1\\], and \\[2,1,3\\] are the only arrangements such that exactly 2 sticks are visible.\nThe visible sticks are underlined.\n\n**Example 2:**\n\n**Input:** n = 5, k = 5\n**Output:** 1\n**Explanation:** \\[1,2,3,4,5\\] is the only arrangement such that all 5 sticks are visible.\nThe visible sticks are underlined.\n\n**Example 3:**\n\n**Input:** n = 20, k = 11\n**Output:** 647427950\n**Explanation:** There are 647427950 (mod 109 \\+ 7) ways to rearrange the sticks such that exactly 11 sticks are visible.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `1 <= k <= n`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic int[] restoreArray(int[][] adjacentPairs) {\n    Map<Integer, List<Integer>> graph = new HashMap<>();\n    for (int[] pair : adjacentPairs) {\n        graph.computeIfAbsent(pair[0], k -> new ArrayList<>()).add(pair[1]);\n        graph.computeIfAbsent(pair[1], k -> new ArrayList<>()).add(pair[0]);\n    }\n    int n = adjacentPairs.length + 1;\n    int[] nums = new int[n];\n    for (Map.Entry<Integer, List<Integer>> entry : graph.entrySet()) {\n        int key = entry.getKey();\n        List<Integer> nodes = entry.getValue();\n        if (nodes.size() == 1) {\n            nums[0] = key;\n            break;\n        }\n    }\n    nums[1] = graph.get(nums[0]).get(0);\n    for (int i = 2; i < n; i++) {\n        List<Integer> nodes = graph.get(nums[i - 1]);\n        nums[i] = nums[i - 2] == nodes.get(0) ? nodes.get(1) : nodes.get(0);\n    }\n    return nums;\n}\n```\n    \n    1. Create a graph represented by a hash map (or dictionary in Python) to store the adjacent nodes for each node.\n2. Iterate through the given adjacent pairs and update the graph by adding the corresponding adjacent nodes.\n3. Iterate through the graph and find a node with only one adjacent node (i.e., the first or last element of the original array), and set it as the first element of the resulting array.\n4. Starting from the second element of the resulting array, loop through and fill in the remaining elements based on the graph. For each element, choose the adjacent node that does not equal the previous element of the resulting array.\n5. Return the resulting array.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nstd::vector<int> restoreArray(std::vector<std::vector<int>>& adjacentPairs) {\n    std::unordered_map<int, std::vector<int>> graph;\n    for (const auto& pair : adjacentPairs) {\n        graph[pair[0]].push_back(pair[1]);\n        graph[pair[1]].push_back(pair[0]);\n    }\n    std::vector<int> nums;\n    for (const auto& entry : graph) {\n        if (entry.second.size() == 1) {\n            nums.push_back(entry.first);\n            break;\n        }\n    }\n    nums.push_back(graph[nums[0]][0]);\n    for (int i = 2; i < graph.size(); ++i) {\n        int n = graph[nums.back()].size();\n        nums.push_back(nums.back() == graph[nums[i-2]][0] ? graph[nums[i-2]][1] : graph[nums[i-2]][0]);\n    }\n    return nums;\n}\n```\n    \n    1. Create a graph represented by a hash map (or dictionary in Python) to store the adjacent nodes for each node.\n2. Iterate through the given adjacent pairs and update the graph by adding the corresponding adjacent nodes.\n3. Iterate through the graph and find a node with only one adjacent node (i.e., the first or last element of the original array), and set it as the first element of the resulting array.\n4. Starting from the second element of the resulting array, loop through and fill in the remaining elements based on the graph. For each element, choose the adjacent node that does not equal the previous element of the resulting array.\n5. Return the resulting array.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\n\ndef restoreArray(adjacentPairs):\n    graph = defaultdict(list)\n    for pair in adjacentPairs:\n        graph[pair[0]].append(pair[1])\n        graph[pair[1]].append(pair[0])\n\n    n = len(graph)\n    nums = [0] * n\n    for key, nodes in graph.items():\n        if len(nodes) == 1:\n            nums[0] = key\n            break\n\n    nums[1] = graph[nums[0]][0]\n    for i in range(2, n):\n        nums[i] = (graph[nums[i - 1]][1]\n                   if (nums[i - 2] == graph[nums[i - 1]][0])\n                   else graph[nums[i - 1]][0])\n\n    return nums\n```\n    \n    1. Create a graph represented by a hash map (or dictionary in Python) to store the adjacent nodes for each node.\n2. Iterate through the given adjacent pairs and update the graph by adding the corresponding adjacent nodes.\n3. Iterate through the graph and find a node with only one adjacent node (i.e., the first or last element of the original array), and set it as the first element of the resulting array.\n4. Starting from the second element of the resulting array, loop through and fill in the remaining elements based on the graph. For each element, choose the adjacent node that does not equal the previous element of the resulting array.\n5. Return the resulting array.\n    ", "javascript": "\n    ```javascript\nfunction restoreArray(adjacentPairs) {\n    const graph = new Map();\n    for (const pair of adjacentPairs) {\n        if (!graph.has(pair[0])) {\n            graph.set(pair[0], []);\n        }\n        if (!graph.has(pair[1])) {\n            graph.set(pair[1], []);\n        }\n        graph.get(pair[0]).push(pair[1]);\n        graph.get(pair[1]).push(pair[0]);\n    }\n    const n = graph.size;\n    const nums = Array(n);\n    for (const [key, nodes] of graph.entries()) {\n        if (nodes.length === 1) {\n            nums[0] = key;\n            break;\n        }\n    }\n\n    nums[1] = graph.get(nums[0])[0];\n    for (let i = 2; i < n; i++) {\n        const nodes = graph.get(nums[i - 1]);\n        nums[i] = nums[i-2] === nodes[0] ? nodes[1] : nodes[0];\n    }\n    return nums;\n}\n```\n    \n    1. Create a graph represented by a hash map (or dictionary in Python) to store the adjacent nodes for each node.\n2. Iterate through the given adjacent pairs and update the graph by adding the corresponding adjacent nodes.\n3. Iterate through the graph and find a node with only one adjacent node (i.e., the first or last element of the original array), and set it as the first element of the resulting array.\n4. Starting from the second element of the resulting array, loop through and fill in the remaining elements based on the graph. For each element, choose the adjacent node that does not equal the previous element of the resulting array.\n5. Return the resulting array.\n    "}
{"id": 1871, "slug": "jump-game-vii", "title": "Jump Game VII", "difficulty": "Medium", "content": "You are given a **0-indexed** binary string `s` and two integers `minJump` and `maxJump`. In the beginning, you are standing at index `0`, which is equal to `'0'`. You can move from index `i` to index `j` if the following conditions are fulfilled:\n\n*   `i + minJump <= j <= min(i + maxJump, s.length - 1)`, and\n*   `s[j] == '0'`.\n\nReturn `true` _if you can reach index_ `s.length - 1` _in_ `s`_, or_ `false` _otherwise._\n\n**Example 1:**\n\n**Input:** s =  \"011010 \", minJump = 2, maxJump = 3\n**Output:** true\n**Explanation:**\nIn the first step, move from index 0 to index 3. \nIn the second step, move from index 3 to index 5.\n\n**Example 2:**\n\n**Input:** s =  \"01101110 \", minJump = 2, maxJump = 3\n**Output:** false\n\n**Constraints:**\n\n*   `2 <= s.length <= 105`\n*   `s[i]` is either `'0'` or `'1'`.\n*   `s[0] == '0'`\n*   `1 <= minJump <= maxJump < s.length`", "java": "\n    ```java\npublic boolean isPalindrome(String s, int l, int r) {\n    while (l < r) {\n        if (s.charAt(l++) != s.charAt(r--)) return false;\n    }\n    return true;\n}\n\npublic boolean checkPartitioning(String s) {\n    int n = s.length();\n    for (int i = 0; i < n - 2; i++) {\n        if (isPalindrome(s, 0, i)) {\n            for (int j = i + 1; j < n - 1; j++) {\n                if (isPalindrome(s, i + 1, j) && isPalindrome(s, j + 1, n - 1)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm uses a nested loop to iterate through all pairs of partitions of the string `s`. For each partition, we check if the substrings created by the partition are palindromes using the `isPalindrome` function. If all three partitions form palindromic substrings, we return `true`. If the loops complete without finding a valid partition, we return `false`.\n\nThe `isPalindrome` function accepts a string, and two indices `l` and `r`. It checks whether the substring created by those indices is a palindrome or not by comparing characters from the start and the end of the substring. If all character pairs match, the function returns `true` otherwise it returns `false`.\n    ", "c++": "\n    ```cpp\nbool isPalindrome(const std::string &s, int l, int r) {\n    while (l < r) {\n        if (s[l++] != s[r--]) return false;\n    }\n    return true;\n}\n\nbool checkPartitioning(std::string s) {\n    int n = s.length();\n    for (int i = 0; i < n - 2; ++i) {\n        if (isPalindrome(s, 0, i)) {\n            for (int j = i + 1; j < n - 1; ++j) {\n                if (isPalindrome(s, i + 1, j) && isPalindrome(s, j + 1, n - 1)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm uses a nested loop to iterate through all pairs of partitions of the string `s`. For each partition, we check if the substrings created by the partition are palindromes using the `isPalindrome` function. If all three partitions form palindromic substrings, we return `true`. If the loops complete without finding a valid partition, we return `false`.\n\nThe `isPalindrome` function accepts a string, and two indices `l` and `r`. It checks whether the substring created by those indices is a palindrome or not by comparing characters from the start and the end of the substring. If all character pairs match, the function returns `true` otherwise it returns `false`.\n    ", "python": "\n    ```python\ndef is_palindrome(s, l, r):\n    while l < r:\n        if s[l] != s[r]:\n            return False\n        l += 1\n        r -= 1\n    return True\n\ndef check_partitioning(s):\n    n = len(s)\n    for i in range(n - 2):\n        if is_palindrome(s, 0, i):\n            for j in range(i + 1, n - 1):\n                if is_palindrome(s, i + 1, j) and is_palindrome(s, j + 1, n - 1):\n                    return True\n    return False\n```\n\n    \n    The algorithm uses a nested loop to iterate through all pairs of partitions of the string `s`. For each partition, we check if the substrings created by the partition are palindromes using the `isPalindrome` function. If all three partitions form palindromic substrings, we return `true`. If the loops complete without finding a valid partition, we return `false`.\n\nThe `isPalindrome` function accepts a string, and two indices `l` and `r`. It checks whether the substring created by those indices is a palindrome or not by comparing characters from the start and the end of the substring. If all character pairs match, the function returns `true` otherwise it returns `false`.\n    ", "javascript": "\n    ```javascript\nfunction isPalindrome(s, l, r) {\n    while (l < r) {\n        if (s[l++] !== s[r--]) return false;\n    }\n    return true;\n}\n\nfunction checkPartitioning(s) {\n    const n = s.length;\n    for (let i = 0; i < n - 2; i++) {\n        if (isPalindrome(s, 0, i)) {\n            for (let j = i + 1; j < n - 1; j++) {\n                if (isPalindrome(s, i + 1, j) && isPalindrome(s, j + 1, n - 1)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm uses a nested loop to iterate through all pairs of partitions of the string `s`. For each partition, we check if the substrings created by the partition are palindromes using the `isPalindrome` function. If all three partitions form palindromic substrings, we return `true`. If the loops complete without finding a valid partition, we return `false`.\n\nThe `isPalindrome` function accepts a string, and two indices `l` and `r`. It checks whether the substring created by those indices is a palindrome or not by comparing characters from the start and the end of the substring. If all character pairs match, the function returns `true` otherwise it returns `false`.\n    "}
{"id": 1872, "slug": "stone-game-viii", "title": "Stone Game VIII", "difficulty": "Hard", "content": "Alice and Bob take turns playing a game, with **Alice starting first**.\n\nThere are `n` stones arranged in a row. On each player's turn, while the number of stones is **more than one**, they will do the following:\n\n1.  Choose an integer `x > 1`, and **remove** the leftmost `x` stones from the row.\n2.  Add the **sum** of the **removed** stones' values to the player's score.\n3.  Place a **new stone**, whose value is equal to that sum, on the left side of the row.\n\nThe game stops when **only** **one** stone is left in the row.\n\nThe **score difference** between Alice and Bob is `(Alice's score - Bob's score)`. Alice's goal is to **maximize** the score difference, and Bob's goal is the **minimize** the score difference.\n\nGiven an integer array `stones` of length `n` where `stones[i]` represents the value of the `ith` stone **from the left**, return _the **score difference** between Alice and Bob if they both play **optimally**._\n\n**Example 1:**\n\n**Input:** stones = \\[-1,2,-3,4,-5\\]\n**Output:** 5\n**Explanation:**\n- Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of\n  value 2 on the left. stones = \\[2,-5\\].\n- Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on\n  the left. stones = \\[-3\\].\nThe difference between their scores is 2 - (-3) = 5.\n\n**Example 2:**\n\n**Input:** stones = \\[7,-6,5,10,5,-2,-6\\]\n**Output:** 13\n**Explanation:**\n- Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a\n  stone of value 13 on the left. stones = \\[13\\].\nThe difference between their scores is 13 - 0 = 13.\n\n**Example 3:**\n\n**Input:** stones = \\[-10,-12\\]\n**Output:** -22\n**Explanation:**\n- Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her\n  score and places a stone of value -22 on the left. stones = \\[-22\\].\nThe difference between their scores is (-22) - 0 = -22.\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `2 <= n <= 105`\n*   `-104 <= stones[i] <= 104`", "java": "\n    ```java\nimport java.util.*;\n\npublic boolean[] canEat(int[] candiesCount, int[][] queries) {\n    long[] prefixSum = new long[candiesCount.length + 1];\n    for (int i = 0; i < candiesCount.length; ++i) {\n        prefixSum[i + 1] = prefixSum[i] + candiesCount[i];\n    }\n\n    boolean[] result = new boolean[queries.length];\n    for (int i = 0; i < queries.length; ++i) {\n        int favoriteType = queries[i][0], favoriteDay = queries[i][1], dailyCap = queries[i][2];\n        long x1 = favoriteDay + 1;\n        long y1 = (favoriteDay + 1L) * dailyCap;\n\n        long x2 = prefixSum[favoriteType] + 1;\n        long y2 = prefixSum[favoriteType + 1];\n\n        result[i] = !(x1 > y2 || y1 < x2);\n    }\n\n    return result;\n}\n```\n    \n    We first calculate the prefix sum of the candiesCount array, which represents the total number of candies we have before a certain type. Then, for each query, we calculate two pair of ranges, x1 to y1 and x2 to y2:\n\n- x1 to y1 is the range of candies the user can eat until the favorite day (inclusive) according to the daily cap.\n- x2 to y2 is the range of candies of the favorite type.\n\nIf these two ranges overlap, it means that it is possible to eat a candy of the favorite type on the favorite day without violating the daily cap.\n\nFinally, we iterate over each query and check if the calculated ranges overlap. If they do, we set the answer for the corresponding index in the result array to true, otherwise we set it to false. Then, we return the result array.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<bool> canEat(std::vector<int>& candiesCount, std::vector<std::vector<int>>& queries) {\n    std::vector<long long> prefixSum(candiesCount.size() + 1);\n    for (int i = 0; i < candiesCount.size(); ++i) {\n        prefixSum[i + 1] = prefixSum[i] + candiesCount[i];\n    }\n\n    std::vector<bool> result(queries.size());\n    for (int i = 0; i < queries.size(); ++i) {\n        int favoriteType = queries[i][0], favoriteDay = queries[i][1], dailyCap = queries[i][2];\n        long long x1 = favoriteDay + 1;\n        long long y1 = (favoriteDay + 1LL) * dailyCap;\n\n        long long x2 = prefixSum[favoriteType] + 1;\n        long long y2 = prefixSum[favoriteType + 1];\n\n        result[i] = !(x1 > y2 || y1 < x2);\n    }\n\n    return result;\n}\n```\n    \n    We first calculate the prefix sum of the candiesCount array, which represents the total number of candies we have before a certain type. Then, for each query, we calculate two pair of ranges, x1 to y1 and x2 to y2:\n\n- x1 to y1 is the range of candies the user can eat until the favorite day (inclusive) according to the daily cap.\n- x2 to y2 is the range of candies of the favorite type.\n\nIf these two ranges overlap, it means that it is possible to eat a candy of the favorite type on the favorite day without violating the daily cap.\n\nFinally, we iterate over each query and check if the calculated ranges overlap. If they do, we set the answer for the corresponding index in the result array to true, otherwise we set it to false. Then, we return the result array.\n    ", "python": "\n    ```python\ndef can_eat(candiesCount, queries):\n    prefix_sum = [0] * (len(candiesCount) + 1)\n    for i in range(len(candiesCount)):\n        prefix_sum[i + 1] = prefix_sum[i] + candiesCount[i]\n\n    result = [False] * len(queries)\n    for i in range(len(queries)):\n        favoriteType, favoriteDay, dailyCap = queries[i]\n        x1 = favoriteDay + 1\n        y1 = (favoriteDay + 1) * dailyCap\n\n        x2 = prefix_sum[favoriteType] + 1\n        y2 = prefix_sum[favoriteType + 1]\n\n        result[i] = not (x1 > y2 or y1 < x2)\n\n    return result\n```\n    \n    We first calculate the prefix sum of the candiesCount array, which represents the total number of candies we have before a certain type. Then, for each query, we calculate two pair of ranges, x1 to y1 and x2 to y2:\n\n- x1 to y1 is the range of candies the user can eat until the favorite day (inclusive) according to the daily cap.\n- x2 to y2 is the range of candies of the favorite type.\n\nIf these two ranges overlap, it means that it is possible to eat a candy of the favorite type on the favorite day without violating the daily cap.\n\nFinally, we iterate over each query and check if the calculated ranges overlap. If they do, we set the answer for the corresponding index in the result array to true, otherwise we set it to false. Then, we return the result array.\n    ", "javascript": "\n    ```javascript\nfunction canEat(candiesCount, queries) {\n    const prefixSum = new Array(candiesCount.length + 1).fill(0);\n    for (let i = 0; i < candiesCount.length; ++i) {\n        prefixSum[i + 1] = prefixSum[i] + candiesCount[i];\n    }\n\n    const result = new Array(queries.length);\n    for (let i = 0; i < queries.length; ++i) {\n        const [favoriteType, favoriteDay, dailyCap] = queries[i];\n        const x1 = favoriteDay + 1;\n        const y1 = (favoriteDay + 1) * dailyCap;\n\n        const x2 = prefixSum[favoriteType] + 1;\n        const y2 = prefixSum[favoriteType + 1];\n\n        result[i] = !(x1 > y2 || y1 < x2);\n    }\n\n    return result;\n}\n```\n    \n    We first calculate the prefix sum of the candiesCount array, which represents the total number of candies we have before a certain type. Then, for each query, we calculate two pair of ranges, x1 to y1 and x2 to y2:\n\n- x1 to y1 is the range of candies the user can eat until the favorite day (inclusive) according to the daily cap.\n- x2 to y2 is the range of candies of the favorite type.\n\nIf these two ranges overlap, it means that it is possible to eat a candy of the favorite type on the favorite day without violating the daily cap.\n\nFinally, we iterate over each query and check if the calculated ranges overlap. If they do, we set the answer for the corresponding index in the result array to true, otherwise we set it to false. Then, we return the result array.\n    "}
{"id": 1879, "slug": "minimum-xor-sum-of-two-arrays", "title": "Minimum XOR Sum of Two Arrays", "difficulty": "Hard", "content": "You are given two integer arrays `nums1` and `nums2` of length `n`.\n\nThe **XOR sum** of the two integer arrays is `(nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])` (**0-indexed**).\n\n*   For example, the **XOR sum** of `[1,2,3]` and `[3,2,1]` is equal to `(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4`.\n\nRearrange the elements of `nums2` such that the resulting **XOR sum** is **minimized**.\n\nReturn _the **XOR sum** after the rearrangement_.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,2\\], nums2 = \\[2,3\\]\n**Output:** 2\n**Explanation:** Rearrange `nums2` so that it becomes `[3,2]`.\nThe XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2.\n\n**Example 2:**\n\n**Input:** nums1 = \\[1,0,3\\], nums2 = \\[5,3,4\\]\n**Output:** 8\n**Explanation:** Rearrange `nums2` so that it becomes `[5,4,3]`. \nThe XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8.\n\n**Constraints:**\n\n*   `n == nums1.length`\n*   `n == nums2.length`\n*   `1 <= n <= 14`\n*   `0 <= nums1[i], nums2[i] <= 107`", "java": "\n    ```java\npublic int maxScore(int a, int b, int c) {\n    return (a + b + c - Math.max(a, Math.max(b, c))) / 2;\n}\n```\n\n    \n    The algorithm works by calculating the sum of all three piles `a`, `b`, and `c` and subtracting the size of the largest pile. Since we can only take stones from two different piles at a time, we cannot take stones from the largest pile after we've equalized the stones in the other two piles. So, by subtracting the size of the largest pile, we're essentially finding out the sum of the stones in the other two piles that can be used for scoring points. Finally, we divide our result by 2 since we need two stones to score a point. In Python, we use integer division `//` to get the result as an integer.\n\nThe key insight is that the optimal strategy is to always take stones from the two largest piles in every turn. This way, the pile sizes remain as matched as possible, ensuring we maximize the number of moves available to us. Since each move reduces the sum of the two largest piles by one, we can simplify the calculation as described above without enumerating each move explicitly. \n    ", "c++": "\n    ```cpp\nint maxScore(int a, int b, int c) {\n    return (a + b + c - std::max({a, b, c})) / 2;\n}\n```\n\n    \n    The algorithm works by calculating the sum of all three piles `a`, `b`, and `c` and subtracting the size of the largest pile. Since we can only take stones from two different piles at a time, we cannot take stones from the largest pile after we've equalized the stones in the other two piles. So, by subtracting the size of the largest pile, we're essentially finding out the sum of the stones in the other two piles that can be used for scoring points. Finally, we divide our result by 2 since we need two stones to score a point. In Python, we use integer division `//` to get the result as an integer.\n\nThe key insight is that the optimal strategy is to always take stones from the two largest piles in every turn. This way, the pile sizes remain as matched as possible, ensuring we maximize the number of moves available to us. Since each move reduces the sum of the two largest piles by one, we can simplify the calculation as described above without enumerating each move explicitly. \n    ", "python": "\n    ```python\ndef max_score(a: int, b: int, c: int) -> int:\n    return (a + b + c - max(a, b, c)) // 2\n```\n\n    \n    The algorithm works by calculating the sum of all three piles `a`, `b`, and `c` and subtracting the size of the largest pile. Since we can only take stones from two different piles at a time, we cannot take stones from the largest pile after we've equalized the stones in the other two piles. So, by subtracting the size of the largest pile, we're essentially finding out the sum of the stones in the other two piles that can be used for scoring points. Finally, we divide our result by 2 since we need two stones to score a point. In Python, we use integer division `//` to get the result as an integer.\n\nThe key insight is that the optimal strategy is to always take stones from the two largest piles in every turn. This way, the pile sizes remain as matched as possible, ensuring we maximize the number of moves available to us. Since each move reduces the sum of the two largest piles by one, we can simplify the calculation as described above without enumerating each move explicitly. \n    ", "javascript": "\n    ```javascript\nfunction maxScore(a, b, c) {\n    return (a + b + c - Math.max(a, Math.max(b, c))) / 2;\n}\n```\n\n    \n    The algorithm works by calculating the sum of all three piles `a`, `b`, and `c` and subtracting the size of the largest pile. Since we can only take stones from two different piles at a time, we cannot take stones from the largest pile after we've equalized the stones in the other two piles. So, by subtracting the size of the largest pile, we're essentially finding out the sum of the stones in the other two piles that can be used for scoring points. Finally, we divide our result by 2 since we need two stones to score a point. In Python, we use integer division `//` to get the result as an integer.\n\nThe key insight is that the optimal strategy is to always take stones from the two largest piles in every turn. This way, the pile sizes remain as matched as possible, ensuring we maximize the number of moves available to us. Since each move reduces the sum of the two largest piles by one, we can simplify the calculation as described above without enumerating each move explicitly. \n    "}
{"id": 1884, "slug": "egg-drop-with-2-eggs-and-n-floors", "title": "Egg Drop With 2 Eggs and N Floors", "difficulty": "Medium", "content": "You are given **two identical** eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n\nYou know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor **higher** than `f` will **break**, and any egg dropped **at or below** floor `f` will **not break**.\n\nIn each move, you may take an **unbroken** egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may **reuse** it in future moves.\n\nReturn _the **minimum number of moves** that you need to determine **with certainty** what the value of_ `f` is.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** We can drop the first egg from floor 1 and the second egg from floor 2.\nIf the first egg breaks, we know that f = 0.\nIf the second egg breaks but the first egg didn't, we know that f = 1.\nOtherwise, if both eggs survive, we know that f = 2.\n\n**Example 2:**\n\n**Input:** n = 100\n**Output:** 14\n**Explanation:** One optimal strategy is:\n- Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9.\n- If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14.\n- If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100.\nRegardless of the outcome, it takes at most 14 drops to determine f.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`", "java": "\n    ```java\npublic int minOperationsToAlternate(String s) {\n    int countA = 0, countB = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (i % 2 == 0) {\n            if (s.charAt(i) == '0') countA++;\n            else countB++;\n        } else {\n            if (s.charAt(i) == '0') countB++;\n            else countA++;\n        }\n    }\n    return Math.min(countA, countB);\n}\n```\n    \n    To solve this problem, we loop through each character in the input string and count how many characters that are '0' and '1'. We should count them separately for odd and even indices. Then we compare the counts for both possible alternating patterns (starting with '0' and starting with '1') and return the minimum count.\n\n1. Initialize two variables `count_a` and `count_b` to 0.\n2. Loop through the characters in the string `s`.\n    - If the character index is even:\n        - Increment `count_a` if the character is '0'.\n        - Increment `count_b` if the character is '1'.\n    - If the character index is odd:\n        - Increment `count_a` if the character is '1'.\n        - Increment `count_b` if the character is '0'.\n3. Return the minimum of `count_a` and `count_b` as the result.\n    ", "c++": "\n    ```cpp\nint min_operations_to_alternate(const std::string& s) {\n    int count_a = 0, count_b = 0;\n    for (std::size_t i = 0; i < s.size(); ++i) {\n        if (i % 2 == 0) {\n            if (s[i] == '0') count_a++;\n            else count_b++;\n        } else {\n            if (s[i] == '0') count_b++;\n            else count_a++;\n        }\n    }\n    return std::min(count_a, count_b);\n}\n```\n    \n    To solve this problem, we loop through each character in the input string and count how many characters that are '0' and '1'. We should count them separately for odd and even indices. Then we compare the counts for both possible alternating patterns (starting with '0' and starting with '1') and return the minimum count.\n\n1. Initialize two variables `count_a` and `count_b` to 0.\n2. Loop through the characters in the string `s`.\n    - If the character index is even:\n        - Increment `count_a` if the character is '0'.\n        - Increment `count_b` if the character is '1'.\n    - If the character index is odd:\n        - Increment `count_a` if the character is '1'.\n        - Increment `count_b` if the character is '0'.\n3. Return the minimum of `count_a` and `count_b` as the result.\n    ", "python": "\n    ```python\ndef min_operations_to_alternate(s: str) -> int:\n    count_a, count_b = 0, 0\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c == '0':\n                count_a += 1\n            else:\n                count_b += 1\n        else:\n            if c == '0':\n                count_b += 1\n            else:\n                count_a += 1\n    return min(count_a, count_b)\n```\n    \n    To solve this problem, we loop through each character in the input string and count how many characters that are '0' and '1'. We should count them separately for odd and even indices. Then we compare the counts for both possible alternating patterns (starting with '0' and starting with '1') and return the minimum count.\n\n1. Initialize two variables `count_a` and `count_b` to 0.\n2. Loop through the characters in the string `s`.\n    - If the character index is even:\n        - Increment `count_a` if the character is '0'.\n        - Increment `count_b` if the character is '1'.\n    - If the character index is odd:\n        - Increment `count_a` if the character is '1'.\n        - Increment `count_b` if the character is '0'.\n3. Return the minimum of `count_a` and `count_b` as the result.\n    ", "javascript": "\n    ```javascript\nfunction minOperationsToAlternate(s) {\n    let countA = 0, countB = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (i % 2 === 0) {\n            if (s[i] === '0') countA++;\n            else countB++;\n        } else {\n            if (s[i] === '0') countB++;\n            else countA++;\n        }\n    }\n    return Math.min(countA, countB);\n}\n```\n    \n    To solve this problem, we loop through each character in the input string and count how many characters that are '0' and '1'. We should count them separately for odd and even indices. Then we compare the counts for both possible alternating patterns (starting with '0' and starting with '1') and return the minimum count.\n\n1. Initialize two variables `count_a` and `count_b` to 0.\n2. Loop through the characters in the string `s`.\n    - If the character index is even:\n        - Increment `count_a` if the character is '0'.\n        - Increment `count_b` if the character is '1'.\n    - If the character index is odd:\n        - Increment `count_a` if the character is '1'.\n        - Increment `count_b` if the character is '0'.\n3. Return the minimum of `count_a` and `count_b` as the result.\n    "}
{"id": 1888, "slug": "minimum-number-of-flips-to-make-the-binary-string-alternating", "title": "Minimum Number of Flips to Make the Binary String Alternating", "difficulty": "Medium", "content": "You are given a binary string `s`. You are allowed to perform two types of operations on the string in any sequence:\n\n*   **Type-1: Remove** the character at the start of the string `s` and **append** it to the end of the string.\n*   **Type-2: Pick** any character in `s` and **flip** its value, i.e., if its value is `'0'` it becomes `'1'` and vice-versa.\n\nReturn _the **minimum** number of **type-2** operations you need to perform_ _such that_ `s` _becomes **alternating**._\n\nThe string is called **alternating** if no two adjacent characters are equal.\n\n*   For example, the strings `\"010 \"` and `\"1010 \"` are alternating, while the string `\"0100 \"` is not.\n\n**Example 1:**\n\n**Input:** s =  \"111000 \"\n**Output:** 2\n**Explanation**: Use the first operation two times to make s =  \"100011 \".\nThen, use the second operation on the third and sixth elements to make s =  \"101010 \".\n\n**Example 2:**\n\n**Input:** s =  \"010 \"\n**Output:** 0\n**Explanation**: The string is already alternating.\n\n**Example 3:**\n\n**Input:** s =  \"1110 \"\n**Output:** 1\n**Explanation**: Use the second operation on the second element to make s =  \"1010 \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'0'` or `'1'`.", "java": "\n    ```java\npublic int nearestValidPoint(int x, int y, int[][] points) {\n    int minDistance = Integer.MAX_VALUE;\n    int minIndex = -1;\n\n    for (int i = 0; i < points.length; i++) {\n        if (x == points[i][0] || y == points[i][1]) {\n            int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                minIndex = i;\n            }\n        }\n    }\n\n    return minIndex;\n}\n```\n    \n    The algorithm iterates through the array of points and checks, in each iteration, whether the point shares the same x-coordinate or the same y-coordinate with the given location. If it does, it calculates the Manhattan distance between the current point and the location. If this distance is smaller than the minimum distance found so far, the algorithm updates the minimum distance and the index of the point in the array.\n\nIn the end, if at least one valid point was found, the algorithm returns the index of the point with the smallest Manhattan distance. If no valid points were found, the algorithm returns -1.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <limits>\n\nint nearestValidPoint(int x, int y, std::vector<std::vector<int>>& points) {\n    int minDistance = std::numeric_limits<int>::max();\n    int minIndex = -1;\n\n    for (int i = 0; i < points.size(); ++i) {\n        if (x == points[i][0] || y == points[i][1]) {\n            int distance = std::abs(x - points[i][0]) + std::abs(y - points[i][1]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                minIndex = i;\n            }\n        }\n    }\n\n    return minIndex;\n}\n```\n    \n    The algorithm iterates through the array of points and checks, in each iteration, whether the point shares the same x-coordinate or the same y-coordinate with the given location. If it does, it calculates the Manhattan distance between the current point and the location. If this distance is smaller than the minimum distance found so far, the algorithm updates the minimum distance and the index of the point in the array.\n\nIn the end, if at least one valid point was found, the algorithm returns the index of the point with the smallest Manhattan distance. If no valid points were found, the algorithm returns -1.\n    ", "python": "\n    ```python\ndef nearestValidPoint(x, y, points):\n    min_distance = float('inf')\n    min_index = -1\n\n    for i, point in enumerate(points):\n        if x == point[0] or y == point[1]:\n            distance = abs(x - point[0]) + abs(y - point[1])\n            if distance < min_distance:\n                min_distance = distance\n                min_index = i\n\n    return min_index\n```\n    \n    The algorithm iterates through the array of points and checks, in each iteration, whether the point shares the same x-coordinate or the same y-coordinate with the given location. If it does, it calculates the Manhattan distance between the current point and the location. If this distance is smaller than the minimum distance found so far, the algorithm updates the minimum distance and the index of the point in the array.\n\nIn the end, if at least one valid point was found, the algorithm returns the index of the point with the smallest Manhattan distance. If no valid points were found, the algorithm returns -1.\n    ", "javascript": "\n    ```javascript\nfunction nearestValidPoint(x, y, points) {\n    let minDistance = Infinity;\n    let minIndex = -1;\n\n    for (let i = 0; i < points.length; i++) {\n        if (x === points[i][0] || y === points[i][1]) {\n            let distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                minIndex = i;\n            }\n        }\n    }\n\n    return minIndex;\n}\n```\n    \n    The algorithm iterates through the array of points and checks, in each iteration, whether the point shares the same x-coordinate or the same y-coordinate with the given location. If it does, it calculates the Manhattan distance between the current point and the location. If this distance is smaller than the minimum distance found so far, the algorithm updates the minimum distance and the index of the point in the array.\n\nIn the end, if at least one valid point was found, the algorithm returns the index of the point with the smallest Manhattan distance. If no valid points were found, the algorithm returns -1.\n    "}
{"id": 1896, "slug": "minimum-cost-to-change-the-final-value-of-expression", "title": "Minimum Cost to Change the Final Value of Expression", "difficulty": "Hard", "content": "You are given a **valid** boolean expression as a string `expression` consisting of the characters `'1'`,`'0'`,`'&'` (bitwise **AND** operator),`'|'` (bitwise **OR** operator),`'('`, and `')'`.\n\n*   For example, `\"()1|1 \"` and `\"(1)&() \"` are **not valid** while `\"1 \"`, `\"(((1))|(0)) \"`, and `\"1|(0&(1)) \"` are **valid** expressions.\n\nReturn _the **minimum cost** to change the final value of the expression_.\n\n*   For example, if `expression = \"1|1|(0&0)&1 \"`, its **value** is `1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1`. We want to apply operations so that the **new** expression evaluates to `0`.\n\nThe **cost** of changing the final value of an expression is the **number of operations** performed on the expression. The types of **operations** are described as follows:\n\n*   Turn a `'1'` into a `'0'`.\n*   Turn a `'0'` into a `'1'`.\n*   Turn a `'&'` into a `'|'`.\n*   Turn a `'|'` into a `'&'`.\n\n**Note:** `'&'` does **not** take precedence over `'|'` in the **order of calculation**. Evaluate parentheses **first**, then in **left-to-right** order.\n\n**Example 1:**\n\n**Input:** expression =  \"1&(0|1) \"\n**Output:** 1\n**Explanation:** We can turn  \"1&(0**|**1) \" into  \"1&(0**&**1) \" by changing the '|' to a '&' using 1 operation.\nThe new expression evaluates to 0. \n\n**Example 2:**\n\n**Input:** expression =  \"(0&0)&(0&0&0) \"\n**Output:** 3\n**Explanation:** We can turn  \"(0**&0**)**&**(0&0&0) \" into  \"(0**|1**)**|**(0&0&0) \" using 3 operations.\nThe new expression evaluates to 1.\n\n**Example 3:**\n\n**Input:** expression =  \"(0|(1|0&1)) \"\n**Output:** 1\n**Explanation:** We can turn  \"(0|(**1**|0&1)) \" into  \"(0|(**0**|0&1)) \" using 1 operation.\nThe new expression evaluates to 0.\n\n**Constraints:**\n\n*   `1 <= expression.length <= 105`\n*   `expression` only contains `'1'`,`'0'`,`'&'`,`'|'`,`'('`, and `')'`\n*   All parentheses are properly matched.\n*   There will be no empty parentheses (i.e: `\"() \"` is not a substring of `expression`).", "java": "\n    ```java\npublic int maximumScore(int[] nums, int[] multipliers) {\n    int n = nums.length, m = multipliers.length;\n    int[][] dp = new int[m + 1][m + 1];\n    int maxScore = Integer.MIN_VALUE;\n\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; i + j <= m; j++) {\n            if (i == 0 && j == 0) continue;\n            int score = 0;\n            if (i == 0) {\n                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1];\n            } else if (j == 0) {\n                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1];\n            } else {\n                score = Math.max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],\n                                dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]);\n            }\n            dp[i][j] = score;\n            if (i + j == m) {\n                maxScore = Math.max(maxScore, score);\n            }\n        }\n    }\n\n    return maxScore;\n}\n```\n    \n    The algorithm uses dynamic programming to solve the problem. We create a 2D dp matrix of size (m+1)x(m+1), iterate the matrix from i=0 to m and j such that i+j<=m. Then, for each cell, we calculate the score at that cell based on the previous indices and the elements of the nums and multipliers arrays. We update the maxScore whenever the sum of i and j is equal to m.\n\nFinally, we return the maxScore after iterating through the entire dp matrix. The time complexity of this algorithm is O(m^2) as it iterates through a 2D matrix.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maximumScore(vector<int>& nums, vector<int>& multipliers) {\n    int n = nums.size(), m = multipliers.size();\n    vector<vector<int>> dp(m + 1, vector<int>(m + 1, 0));\n    int maxScore = INT_MIN;\n\n    for (int i = 0; i <= m; ++i) {\n        for (int j = 0; i + j <= m; ++j) {\n            if (i == 0 && j == 0) continue;\n            int score = 0;\n            if (i == 0) {\n                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1];\n            } else if (j == 0) {\n                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1];\n            } else {\n              score = max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],\n                          dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]);\n            }\n            dp[i][j] = score;\n            if (i + j == m) {\n                maxScore = max(maxScore, score);\n            }\n        }\n    }\n\n    return maxScore;\n}\n```\n    \n    The algorithm uses dynamic programming to solve the problem. We create a 2D dp matrix of size (m+1)x(m+1), iterate the matrix from i=0 to m and j such that i+j<=m. Then, for each cell, we calculate the score at that cell based on the previous indices and the elements of the nums and multipliers arrays. We update the maxScore whenever the sum of i and j is equal to m.\n\nFinally, we return the maxScore after iterating through the entire dp matrix. The time complexity of this algorithm is O(m^2) as it iterates through a 2D matrix.\n    ", "python": "\n    ```python\ndef maximumScore(nums, multipliers):\n    n, m = len(nums), len(multipliers)\n    dp = [[0] * (m + 1) for _ in range(m + 1)]\n    maxScore = float('-inf')\n\n    for i in range(m + 1):\n        for j in range(m - i + 1):\n            if i == 0 and j == 0:\n                continue\n            score = 0\n            if i == 0:\n                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]\n            elif j == 0:\n                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1]\n            else:\n                score = max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],\n                            dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1])\n            dp[i][j] = score\n            if i + j == m:\n                maxScore = max(maxScore, score)\n\n    return maxScore\n```\n    \n    The algorithm uses dynamic programming to solve the problem. We create a 2D dp matrix of size (m+1)x(m+1), iterate the matrix from i=0 to m and j such that i+j<=m. Then, for each cell, we calculate the score at that cell based on the previous indices and the elements of the nums and multipliers arrays. We update the maxScore whenever the sum of i and j is equal to m.\n\nFinally, we return the maxScore after iterating through the entire dp matrix. The time complexity of this algorithm is O(m^2) as it iterates through a 2D matrix.\n    ", "javascript": "\n    ```javascript\nfunction maximumScore(nums, multipliers) {\n    const n = nums.length, m = multipliers.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(m + 1).fill(0));\n    let maxScore = Number.MIN_SAFE_INTEGER;\n\n    for (let i = 0; i <= m; i++) {\n        for (let j = 0; i + j <= m; j++) {\n            if (i === 0 && j === 0) continue;\n            let score = 0;\n            if (i === 0) {\n                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1];\n            } else if (j === 0) {\n                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1];\n            } else {\n                score = Math.max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],\n                                dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]);\n            }\n            dp[i][j] = score;\n            if (i + j === m) {\n                maxScore = Math.max(maxScore, score);\n            }\n        }\n    }\n\n    return maxScore;\n}\n```\n    \n    The algorithm uses dynamic programming to solve the problem. We create a 2D dp matrix of size (m+1)x(m+1), iterate the matrix from i=0 to m and j such that i+j<=m. Then, for each cell, we calculate the score at that cell based on the previous indices and the elements of the nums and multipliers arrays. We update the maxScore whenever the sum of i and j is equal to m.\n\nFinally, we return the maxScore after iterating through the entire dp matrix. The time complexity of this algorithm is O(m^2) as it iterates through a 2D matrix.\n    "}
{"id": 1900, "slug": "the-earliest-and-latest-rounds-where-players-compete", "title": "The Earliest and Latest Rounds Where Players Compete", "difficulty": "Hard", "content": "There is a tournament where `n` players are participating. The players are standing in a single row and are numbered from `1` to `n` based on their **initial** standing position (player `1` is the first player in the row, player `2` is the second player in the row, etc.).\n\nThe tournament consists of multiple rounds (starting from round number `1`). In each round, the `ith` player from the front of the row competes against the `ith` player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.\n\n*   For example, if the row consists of players `1, 2, 4, 6, 7`\n    *   Player `1` competes against player `7`.\n    *   Player `2` competes against player `6`.\n    *   Player `4` automatically advances to the next round.\n\nAfter each round is over, the winners are lined back up in the row based on the **original ordering** assigned to them initially (ascending order).\n\nThe players numbered `firstPlayer` and `secondPlayer` are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may **choose** the outcome of this round.\n\nGiven the integers `n`, `firstPlayer`, and `secondPlayer`, return _an integer array containing two values, the **earliest** possible round number and the **latest** possible round number in which these two players will compete against each other, respectively_.\n\n**Example 1:**\n\n**Input:** n = 11, firstPlayer = 2, secondPlayer = 4\n**Output:** \\[3,4\\]\n**Explanation:**\nOne possible scenario which leads to the earliest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 2, 3, 4, 5, 6, 11\nThird round: 2, 3, 4\nOne possible scenario which leads to the latest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 1, 2, 3, 4, 5, 6\nThird round: 1, 2, 4\nFourth round: 2, 4\n\n**Example 2:**\n\n**Input:** n = 5, firstPlayer = 1, secondPlayer = 5\n**Output:** \\[1,1\\]\n**Explanation:** The players numbered 1 and 5 compete in the first round.\nThere is no way to make them compete in any other round.\n\n**Constraints:**\n\n*   `2 <= n <= 28`\n*   `1 <= firstPlayer < secondPlayer <= n`", "java": "\n    ```java\nimport java.util.List;\n\npublic class Solution {\n    public int closestCost(List<Integer> baseCosts, List<Integer> toppingCosts, int target) {\n        int closest = baseCosts.get(0);\n        for (int base : baseCosts) {\n            int cost = base;\n            for (int i = 0; i < (1 << (toppingCosts.size() * 2)); ++i) {\n                int bitMask = i;\n                for (int j = 0; j < toppingCosts.size(); ++j, bitMask >>= 2) {\n                    cost += (bitMask & 3) * toppingCosts.get(j);\n                }\n\n                if (Math.abs(target - cost) < Math.abs(target - closest)) {\n                    closest = cost;\n                } else if (Math.abs(target - cost) == Math.abs(target - closest) && cost < closest) {\n                    closest = cost;\n                }\n\n                cost = base;\n            }\n        }\n        return closest;\n    }\n}\n```\n\n    \n    In all the four languages, the given algorithms have a similar approach:\n\n1. Initialize the result (closest) to the first base cost.\n2. Loop through each base cost.\n   a. Set the current cost to current base cost. \n   b. Use another loop to create all combinations of topping costs. We use bitwise manipulation to achieve that by looping through all integers from 0 to 2^(2 * m) - 1, and get 2-bit numbers for each topping multiple. Both loops help simulate all possible combinations.\n   c. For each combination of toppings (mantained as bitMask), calculate the total cost by adding the appropriate toppings to the current base cost.\n   d. Check if the current cost is better (closer or lower but equally close) than the best found (closest) so far.\n   e. Reset the cost to the base cost and repeat the process for the next combination.\n3. Return the best found cost closest to the target.\n\nThis algorithm explores all possible combinations of base costs and topping costs, therefore finding the optimal combination. Since the search space is 2^(2 * m) for the toppings, the time complexity is O(n * 2^(2 * m)), where n is the number of base costs and m is the number of topping costs.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nint closestCost(std::vector<int>& baseCosts, std::vector<int>& toppingCosts, int target) {\n    int closest = baseCosts[0];\n    for (int base : baseCosts) {\n        int cost = base;\n        for (int i = 0; i < 1 << (toppingCosts.size() * 2); ++i) {\n            int bitMask = i;\n            for (int j = 0; j < toppingCosts.size(); ++j, bitMask >>= 2) {\n                cost += (bitMask & 3) * toppingCosts[j];\n            }\n\n            if (abs(target - cost) < abs(target - closest)) {\n                closest = cost;\n            } else if (abs(target - cost) == abs(target - closest) && cost < closest) {\n                closest = cost;\n            }\n\n            cost = base;\n        }\n    }\n    return closest;\n}\n```\n\n    \n    In all the four languages, the given algorithms have a similar approach:\n\n1. Initialize the result (closest) to the first base cost.\n2. Loop through each base cost.\n   a. Set the current cost to current base cost. \n   b. Use another loop to create all combinations of topping costs. We use bitwise manipulation to achieve that by looping through all integers from 0 to 2^(2 * m) - 1, and get 2-bit numbers for each topping multiple. Both loops help simulate all possible combinations.\n   c. For each combination of toppings (mantained as bitMask), calculate the total cost by adding the appropriate toppings to the current base cost.\n   d. Check if the current cost is better (closer or lower but equally close) than the best found (closest) so far.\n   e. Reset the cost to the base cost and repeat the process for the next combination.\n3. Return the best found cost closest to the target.\n\nThis algorithm explores all possible combinations of base costs and topping costs, therefore finding the optimal combination. Since the search space is 2^(2 * m) for the toppings, the time complexity is O(n * 2^(2 * m)), where n is the number of base costs and m is the number of topping costs.\n    ", "python": "\n    ```python\ndef closest_cost(base_costs, topping_costs, target):\n    closest = base_costs[0]\n    \n    for base in base_costs:\n        cost = base\n        \n        for i in range(1 << (len(topping_costs) * 2)):\n            bit_mask = i\n            \n            for j, topping_cost in enumerate(topping_costs):\n                cost += (bit_mask & 3) * topping_cost\n                bit_mask >>= 2\n                \n            if abs(target - cost) < abs(target - closest):\n                closest = cost\n            elif abs(target - cost) == abs(target - closest) and cost < closest:\n                closest = cost\n                \n            cost = base\n            \n    return closest\n```\n\n    \n    In all the four languages, the given algorithms have a similar approach:\n\n1. Initialize the result (closest) to the first base cost.\n2. Loop through each base cost.\n   a. Set the current cost to current base cost. \n   b. Use another loop to create all combinations of topping costs. We use bitwise manipulation to achieve that by looping through all integers from 0 to 2^(2 * m) - 1, and get 2-bit numbers for each topping multiple. Both loops help simulate all possible combinations.\n   c. For each combination of toppings (mantained as bitMask), calculate the total cost by adding the appropriate toppings to the current base cost.\n   d. Check if the current cost is better (closer or lower but equally close) than the best found (closest) so far.\n   e. Reset the cost to the base cost and repeat the process for the next combination.\n3. Return the best found cost closest to the target.\n\nThis algorithm explores all possible combinations of base costs and topping costs, therefore finding the optimal combination. Since the search space is 2^(2 * m) for the toppings, the time complexity is O(n * 2^(2 * m)), where n is the number of base costs and m is the number of topping costs.\n    ", "javascript": "\n    ```javascript\nfunction closestCost(baseCosts, toppingCosts, target) {\n    let closest = baseCosts[0];\n\n    for (const base of baseCosts) {\n        let cost = base;\n        for (let i = 0; i < (1 << (toppingCosts.length * 2)); ++i) {\n            let bitMask = i;\n            for (let j = 0; j < toppingCosts.length; ++j, bitMask >>= 2) {\n                cost += (bitMask & 3) * toppingCosts[j];\n            }\n\n            if (Math.abs(target - cost) < Math.abs(target - closest)) {\n                closest = cost;\n            } else if (Math.abs(target - cost) === Math.abs(target - closest) && cost < closest) {\n                closest = cost;\n            }\n\n            cost = base;\n        }\n    }\n\n    return closest;\n}\n```\n\n    \n    In all the four languages, the given algorithms have a similar approach:\n\n1. Initialize the result (closest) to the first base cost.\n2. Loop through each base cost.\n   a. Set the current cost to current base cost. \n   b. Use another loop to create all combinations of topping costs. We use bitwise manipulation to achieve that by looping through all integers from 0 to 2^(2 * m) - 1, and get 2-bit numbers for each topping multiple. Both loops help simulate all possible combinations.\n   c. For each combination of toppings (mantained as bitMask), calculate the total cost by adding the appropriate toppings to the current base cost.\n   d. Check if the current cost is better (closer or lower but equally close) than the best found (closest) so far.\n   e. Reset the cost to the base cost and repeat the process for the next combination.\n3. Return the best found cost closest to the target.\n\nThis algorithm explores all possible combinations of base costs and topping costs, therefore finding the optimal combination. Since the search space is 2^(2 * m) for the toppings, the time complexity is O(n * 2^(2 * m)), where n is the number of base costs and m is the number of topping costs.\n    "}
{"id": 1908, "slug": "game-of-nim", "title": "Game of Nim", "difficulty": "Medium", "content": "Alice and Bob take turns playing a game with **Alice starting first**.\n\nIn this game, there are `n` piles of stones. On each player's turn, the player should remove any **positive** number of stones from a non-empty pile **of his or her choice**. The first player who cannot make a move loses, and the other player wins.\n\nGiven an integer array `piles`, where `piles[i]` is the number of stones in the `ith` pile, return `true` _if Alice wins, or_ `false` _if Bob wins_.\n\nBoth Alice and Bob play **optimally**.\n\n**Example 1:**\n\n**Input:** piles = \\[1\\]\n**Output:** true\n**Explanation:** There is only one possible scenario:\n- On the first turn, Alice removes one stone from the first pile. piles = \\[0\\].\n- On the second turn, there are no stones left for Bob to remove. Alice wins.\n\n**Example 2:**\n\n**Input:** piles = \\[1,1\\]\n**Output:** false\n**Explanation:** It can be proven that Bob will always win. One possible scenario is:\n- On the first turn, Alice removes one stone from the first pile. piles = \\[0,1\\].\n- On the second turn, Bob removes one stone from the second pile. piles = \\[0,0\\].\n- On the third turn, there are no stones left for Alice to remove. Bob wins.\n\n**Example 3:**\n\n**Input:** piles = \\[1,2,3\\]\n**Output:** false\n**Explanation:** It can be proven that Bob will always win. One possible scenario is:\n- On the first turn, Alice removes three stones from the third pile. piles = \\[1,2,0\\].\n- On the second turn, Bob removes one stone from the second pile. piles = \\[1,1,0\\].\n- On the third turn, Alice removes one stone from the first pile. piles = \\[0,1,0\\].\n- On the fourth turn, Bob removes one stone from the second pile. piles = \\[0,0,0\\].\n- On the fifth turn, there are no stones left for Alice to remove. Bob wins.\n\n**Constraints:**\n\n*   `n == piles.length`\n*   `1 <= n <= 7`\n*   `1 <= piles[i] <= 7`\n\n**Follow-up:** Could you find a linear time solution? Although the linear time solution may be beyond the scope of an interview, it could be interesting to know.", "java": "\n    ```java\npublic boolean aliceWins(int[] piles) {\n    int xorSum = 0;\n    for (int pile : piles) {\n        xorSum ^= pile;\n    }\n    return xorSum != 0;\n}\n```\n\n    \n    The game is actually a variant of Nim game. The optimal strategy is that both players keep reducing piles to ensure that the bitwise XOR of all piles remains 0. After each player's turn, if the bitwise XOR of all piles is 0, the player wins if there are no piles with stones left; otherwise, the player loses.\n\nTo determine if Alice wins, we first calculate the bitwise XOR of all the piles' sizes. If the bitwise XOR is not 0, Alice can win by making a move that changes the XOR to 0. Otherwise, Alice will lose since any move she makes will give Bob a chance to make XOR 0 afterward.\n\nSo the algorithm is simply to calculate the XOR of all piles and compare the final result to 0.\n    ", "c++": "\n    ```cpp\nbool aliceWins(vector<int>& piles) {\n    int xor_sum = 0;\n    for (int pile : piles) {\n        xor_sum ^= pile;\n    }\n    return xor_sum != 0;\n}\n```\n\n    \n    The game is actually a variant of Nim game. The optimal strategy is that both players keep reducing piles to ensure that the bitwise XOR of all piles remains 0. After each player's turn, if the bitwise XOR of all piles is 0, the player wins if there are no piles with stones left; otherwise, the player loses.\n\nTo determine if Alice wins, we first calculate the bitwise XOR of all the piles' sizes. If the bitwise XOR is not 0, Alice can win by making a move that changes the XOR to 0. Otherwise, Alice will lose since any move she makes will give Bob a chance to make XOR 0 afterward.\n\nSo the algorithm is simply to calculate the XOR of all piles and compare the final result to 0.\n    ", "python": "\n    ```python\ndef alice_wins(piles):\n    xor_sum = 0\n    for pile in piles:\n        xor_sum ^= pile\n    return xor_sum != 0\n```\n\n    \n    The game is actually a variant of Nim game. The optimal strategy is that both players keep reducing piles to ensure that the bitwise XOR of all piles remains 0. After each player's turn, if the bitwise XOR of all piles is 0, the player wins if there are no piles with stones left; otherwise, the player loses.\n\nTo determine if Alice wins, we first calculate the bitwise XOR of all the piles' sizes. If the bitwise XOR is not 0, Alice can win by making a move that changes the XOR to 0. Otherwise, Alice will lose since any move she makes will give Bob a chance to make XOR 0 afterward.\n\nSo the algorithm is simply to calculate the XOR of all piles and compare the final result to 0.\n    ", "javascript": "\n    ```javascript\nfunction aliceWins(piles) {\n    let xorSum = 0;\n    for (let pile of piles) {\n        xorSum ^= pile;\n    }\n    return xorSum !== 0;\n}\n```\n\n    \n    The game is actually a variant of Nim game. The optimal strategy is that both players keep reducing piles to ensure that the bitwise XOR of all piles remains 0. After each player's turn, if the bitwise XOR of all piles is 0, the player wins if there are no piles with stones left; otherwise, the player loses.\n\nTo determine if Alice wins, we first calculate the bitwise XOR of all the piles' sizes. If the bitwise XOR is not 0, Alice can win by making a move that changes the XOR to 0. Otherwise, Alice will lose since any move she makes will give Bob a chance to make XOR 0 afterward.\n\nSo the algorithm is simply to calculate the XOR of all piles and compare the final result to 0.\n    "}
{"id": 1911, "slug": "maximum-alternating-subsequence-sum", "title": "Maximum Alternating Subsequence Sum", "difficulty": "Medium", "content": "The **alternating sum** of a **0-indexed** array is defined as the **sum** of the elements at **even** indices **minus** the **sum** of the elements at **odd** indices.\n\n*   For example, the alternating sum of `[4,2,5,3]` is `(4 + 5) - (2 + 3) = 4`.\n\nGiven an array `nums`, return _the **maximum alternating sum** of any subsequence of_ `nums` _(after **reindexing** the elements of the subsequence)_.\n\nA **subsequence** of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, `[2,7,4]` is a subsequence of `[4,2,3,7,2,1,4]` (the underlined elements), while `[2,4,2]` is not.\n\n**Example 1:**\n\n**Input:** nums = \\[4,2,5,3\\]\n**Output:** 7\n**Explanation:** It is optimal to choose the subsequence \\[4,2,5\\] with alternating sum (4 + 5) - 2 = 7.\n\n**Example 2:**\n\n**Input:** nums = \\[5,6,7,8\\]\n**Output:** 8\n**Explanation:** It is optimal to choose the subsequence \\[8\\] with alternating sum 8.\n\n**Example 3:**\n\n**Input:** nums = \\[6,2,1,2,4,5\\]\n**Output:** 10\n**Explanation:** It is optimal to choose the subsequence \\[6,1,5\\] with alternating sum (6 + 5) - 1 = 10.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`", "java": "\n    ```java\nint minElements(int[] nums, int limit, int goal) {\n    long sum = 0;\n    for (int num : nums) sum += num;\n    long diff = Math.abs(goal - sum);\n    return (int)((diff + limit - 1) / limit);\n}\n```\n\n    \n    The solution calculates the sum of the given array and finds the difference between the goal and the sum (abs(goal - sum)). Then, it calculates the required number of elements to add based on the limit. To find the minimum number of elements, we divide the difference by the limit and round up to the closest integer value. This ensures that the minimum number of elements is added while maintaining the property of abs(nums[i]) <= limit.\n    ", "c++": "\n    ```cpp\nint minElements(std::vector<int>& nums, int limit, int goal) {\n    long long sum = 0;\n    for (int num : nums) sum += num;\n    long long diff = abs(goal - sum);\n    return (diff + limit - 1) / limit;\n}\n```\n\n    \n    The solution calculates the sum of the given array and finds the difference between the goal and the sum (abs(goal - sum)). Then, it calculates the required number of elements to add based on the limit. To find the minimum number of elements, we divide the difference by the limit and round up to the closest integer value. This ensures that the minimum number of elements is added while maintaining the property of abs(nums[i]) <= limit.\n    ", "python": "\n    ```python\ndef min_elements(nums, limit, goal):\n    total_sum = sum(nums)\n    diff = abs(goal - total_sum)\n    return (diff + limit - 1) // limit\n```\n\n    \n    The solution calculates the sum of the given array and finds the difference between the goal and the sum (abs(goal - sum)). Then, it calculates the required number of elements to add based on the limit. To find the minimum number of elements, we divide the difference by the limit and round up to the closest integer value. This ensures that the minimum number of elements is added while maintaining the property of abs(nums[i]) <= limit.\n    ", "javascript": "\n    ```javascript\nfunction minElements(nums, limit, goal) {\n    let sum = nums.reduce((a, b) => a + b, 0);\n    let diff = Math.abs(goal - sum);\n    return Math.ceil(diff / limit);\n}\n```\n\n    \n    The solution calculates the sum of the given array and finds the difference between the goal and the sum (abs(goal - sum)). Then, it calculates the required number of elements to add based on the limit. To find the minimum number of elements, we divide the difference by the limit and round up to the closest integer value. This ensures that the minimum number of elements is added while maintaining the property of abs(nums[i]) <= limit.\n    "}
{"id": 1916, "slug": "count-ways-to-build-rooms-in-an-ant-colony", "title": "Count Ways to Build Rooms in an Ant Colony", "difficulty": "Hard", "content": "You are an ant tasked with adding `n` new rooms numbered `0` to `n-1` to your colony. You are given the expansion plan as a **0-indexed** integer array of length `n`, `prevRoom`, where `prevRoom[i]` indicates that you must build room `prevRoom[i]` before building room `i`, and these two rooms must be connected **directly**. Room `0` is already built, so `prevRoom[0] = -1`. The expansion plan is given such that once all the rooms are built, every room will be reachable from room `0`.\n\nYou can only build **one room** at a time, and you can travel freely between rooms you have **already built** only if they are **connected**. You can choose to build **any room** as long as its **previous room** is already built.\n\nReturn _the **number of different orders** you can build all the rooms in_. Since the answer may be large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** prevRoom = \\[-1,0,1\\]\n**Output:** 1\n**Explanation:** There is only one way to build the additional rooms: 0 -> 1 -> 2\n\n**Example 2:**\n\n**Input:** prevRoom = \\[-1,0,0,1,2\\]\n**Output:** 6\n**Explanation:**\nThe 6 ways are:\n0 -> 1 -> 3 -> 2 -> 4\n0 -> 2 -> 4 -> 1 -> 3\n0 -> 1 -> 2 -> 3 -> 4\n0 -> 1 -> 2 -> 4 -> 3\n0 -> 2 -> 1 -> 3 -> 4\n0 -> 2 -> 1 -> 4 -> 3\n\n**Constraints:**\n\n*   `n == prevRoom.length`\n*   `2 <= n <= 105`\n*   `prevRoom[0] == -1`\n*   `0 <= prevRoom[i] < n` for all `1 <= i < n`\n*   Every room is reachable from room `0` once all the rooms are built.", "java": "\n    ```java\npublic int findCenter(int[][] edges) {\n    if (edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1]) {\n        return edges[0][0];\n    }\n    return edges[0][1];\n}\n```\n    \n    The algorithm only needs to examine the first two elements in the edges array because it knows that the graph is a star graph. In such a graph, every node is connected to the center node. So, the center node must appear twice in the first two elements of the edges array (once in each edge). The algorithm checks if the first node in the first edge is the center by seeing if it exists in the second edge. If it does not, the function returns the second node in the first edge, as that must be the center. This approach has a constant time complexity (O(1)) because it examines a fixed number of array elements, regardless of the size of the input matrix.\n    ", "c++": "\n    ```cpp\nint findCenter(vector<vector<int>>& edges) {\n    if (edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1]) {\n        return edges[0][0];\n    }\n    return edges[0][1];\n}\n```\n    \n    The algorithm only needs to examine the first two elements in the edges array because it knows that the graph is a star graph. In such a graph, every node is connected to the center node. So, the center node must appear twice in the first two elements of the edges array (once in each edge). The algorithm checks if the first node in the first edge is the center by seeing if it exists in the second edge. If it does not, the function returns the second node in the first edge, as that must be the center. This approach has a constant time complexity (O(1)) because it examines a fixed number of array elements, regardless of the size of the input matrix.\n    ", "python": "\n    ```python\ndef findCenter(edges):\n    if edges[0][0] == edges[1][0] or edges[0][0] == edges[1][1]:\n        return edges[0][0]\n    return edges[0][1]\n```\n    \n    The algorithm only needs to examine the first two elements in the edges array because it knows that the graph is a star graph. In such a graph, every node is connected to the center node. So, the center node must appear twice in the first two elements of the edges array (once in each edge). The algorithm checks if the first node in the first edge is the center by seeing if it exists in the second edge. If it does not, the function returns the second node in the first edge, as that must be the center. This approach has a constant time complexity (O(1)) because it examines a fixed number of array elements, regardless of the size of the input matrix.\n    ", "javascript": "\n    ```javascript\nfunction findCenter(edges) {\n    if (edges[0][0] === edges[1][0] || edges[0][0] === edges[1][1]) {\n        return edges[0][0];\n    }\n    return edges[0][1];\n}\n```\n    \n    The algorithm only needs to examine the first two elements in the edges array because it knows that the graph is a star graph. In such a graph, every node is connected to the center node. So, the center node must appear twice in the first two elements of the edges array (once in each edge). The algorithm checks if the first node in the first edge is the center by seeing if it exists in the second edge. If it does not, the function returns the second node in the first edge, as that must be the center. This approach has a constant time complexity (O(1)) because it examines a fixed number of array elements, regardless of the size of the input matrix.\n    "}
{"id": 1928, "slug": "minimum-cost-to-reach-destination-in-time", "title": "Minimum Cost to Reach Destination in Time", "difficulty": "Hard", "content": "There is a country of `n` cities numbered from `0` to `n - 1` where **all the cities are connected** by bi-directional roads. The roads are represented as a 2D integer array `edges` where `edges[i] = [xi, yi, timei]` denotes a road between cities `xi` and `yi` that takes `timei` minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.\n\nEach time you pass through a city, you must pay a passing fee. This is represented as a **0-indexed** integer array `passingFees` of length `n` where `passingFees[j]` is the amount of dollars you must pay when you pass through city `j`.\n\nIn the beginning, you are at city `0` and want to reach city `n - 1` in `maxTime` **minutes or less**. The **cost** of your journey is the **summation of passing fees** for each city that you passed through at some moment of your journey (**including** the source and destination cities).\n\nGiven `maxTime`, `edges`, and `passingFees`, return _the **minimum cost** to complete your journey, or_ `-1` _if you cannot complete it within_ `maxTime` _minutes_.\n\n**Example 1:**\n\n**Input:** maxTime = 30, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 11\n**Explanation:** The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees.\n\n**Example 2:**\n\n**Input:** maxTime = 29, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 48\n**Explanation:** The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees.\nYou cannot take path 0 -> 1 -> 2 -> 5 since it would take too long.\n\n**Example 3:**\n\n**Input:** maxTime = 25, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** -1\n**Explanation:** There is no way to reach city 5 from city 0 within 25 minutes.\n\n**Constraints:**\n\n*   `1 <= maxTime <= 1000`\n*   `n == passingFees.length`\n*   `2 <= n <= 1000`\n*   `n - 1 <= edges.length <= 1000`\n*   `0 <= xi, yi <= n - 1`\n*   `1 <= timei <= 1000`\n*   `1 <= passingFees[j] <= 1000`\n*   The graph may contain multiple edges between two nodes.\n*   The graph does not contain self loops.", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int getNumberOfBacklogOrders(int[][] orders) {\n        PriorityQueue<int[]> sell = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        PriorityQueue<int[]> buy = new PriorityQueue<>((a, b) -> b[0] - a[0]);\n\n        for (int[] order : orders) {\n            if (order[2] == 0) {\n                while (!sell.isEmpty() && order[1] > 0 && sell.peek()[0] <= order[0]) {\n                    int executedAmount = Math.min(order[1], sell.peek()[1]);\n                    order[1] -= executedAmount;\n                    sell.peek()[1] -= executedAmount;\n                    if (sell.peek()[1] == 0) sell.poll();\n                }\n                if (order[1] > 0) buy.offer(order);\n            } else {\n                while (!buy.isEmpty() && order[1] > 0 && buy.peek()[0] >= order[0]) {\n                    int executedAmount = Math.min(order[1], buy.peek()[1]);\n                    order[1] -= executedAmount;\n                    buy.peek()[1] -= executedAmount;\n                    if (buy.peek()[1] == 0) buy.poll();\n                }\n                if (order[1] > 0) sell.offer(order);\n            }\n        }\n\n        long res = 0;\n        while (!buy.isEmpty()) res += buy.poll()[1];\n        while (!sell.isEmpty()) res += sell.poll()[1];\n        res %= 1_000_000_007;\n\n        return (int) res;\n    }\n}\n```\n\n    \n    The algorithm uses two priority queues, one for buy orders and one for sell orders. When iterating over the input orders, for each buy order if there are sell orders that can be executed, execute them and update the current buy order amount accordingly. If the buy order still has residual amount, add it to the buy order queue. Same goes for sell orders.\n\nAfter processing all input orders, the residual orders in the buy and sell queues are the ones that couldn't be executed, sum their amounts and return the result modulo 1,000,000,007.\n    ", "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\n\nint getNumberOfBacklogOrders(std::vector<std::vector<int>>& orders) {\n    auto cmpSell = [](std::vector<int>& a, std::vector<int>& b) {\n        return a[0] > b[0];\n    };\n    auto cmpBuy = [](std::vector<int>& a, std.stringvector<int>&b) {\n        return a[0] < b[0];\n    };\n\n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(cmpSell)> sell(cmpSell);\n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(cmpBuy)> buy(cmpBuy);\n\n    for (auto& order : orders) {\n        if (order[2] == 0) {\n            while (!sell.empty() && order[1] > 0 && sell.top()[0] <= order[0]) {\n                std::vector<int>& currOrder = sell.top();\n                int executedAmount = std::min(order[1], currOrder[1]);\n                order[1] -= executedAmount;\n                currOrder[1] -= executedAmount;\n                if (currOrder[1] == 0) {\n                    sell.pop();\n                }\n            }\n            if (order[1] > 0) {\n                buy.push(order);\n            }\n        } else {\n            while (!buy.empty() && order[1] > 0 && buy.top()[0] >= order[0]) {\n                std::vector<int>& currOrder = buy.top();\n                int executedAmount = std::min(order[1], currOrder[1]);\n                order[1] -= executedAmount;\n                currOrder[1] -= executedAmount;\n                if (currOrder[1] == 0) {\n                    buy.pop();\n                }\n            }\n            if (order[1] > 0) {\n                sell.push(order);\n            }\n        }\n    }\n\n    int64_t res = 0;\n    while (!buy.empty()) {\n        res += buy.top()[1];\n        buy.pop();\n    }\n    while (!sell.empty()) {\n        res += sell.top()[1];\n        sell.pop();\n    }\n\n    res %= 1000000007;\n    return static_cast<int>(res);\n}\n```\n\n    \n    The algorithm uses two priority queues, one for buy orders and one for sell orders. When iterating over the input orders, for each buy order if there are sell orders that can be executed, execute them and update the current buy order amount accordingly. If the buy order still has residual amount, add it to the buy order queue. Same goes for sell orders.\n\nAfter processing all input orders, the residual orders in the buy and sell queues are the ones that couldn't be executed, sum their amounts and return the result modulo 1,000,000,007.\n    ", "python": "\n    ```python\nfrom heapq import heappush, heappop\n\ndef getNumberOfBacklogOrders(orders):\n    buy, sell = [], []\n\n    for price, amount, orderType in orders:\n        if orderType == 0:\n            while amount > 0 and sell and -sell[0][0] <= price:\n                executedAmount = min(amount, sell[0][1])\n                amount -= executedAmount\n                sell[0] = [-sell[0][0], sell[0][1] - executedAmount]\n                if sell[0][1] == 0:\n                    heappop(sell)\n            if amount:\n                heappush(buy, [-price, amount])\n        else:\n            while amount > 0 and buy and buy[0][0] >= price:\n                executedAmount = min(amount, buy[0][1])\n                amount -= executedAmount\n                buy[0] = [buy[0][0], buy[0][1] - executedAmount]\n                if buy[0][1] == 0:\n                    heappop(buy)\n            if amount:\n                heappush(sell, [-price, amount])\n\n    res = sum(item[1] for item in buy) + sum(item[1] for item in sell)\n    return res % 1000000007\n```\n\n    \n    The algorithm uses two priority queues, one for buy orders and one for sell orders. When iterating over the input orders, for each buy order if there are sell orders that can be executed, execute them and update the current buy order amount accordingly. If the buy order still has residual amount, add it to the buy order queue. Same goes for sell orders.\n\nAfter processing all input orders, the residual orders in the buy and sell queues are the ones that couldn't be executed, sum their amounts and return the result modulo 1,000,000,007.\n    ", "javascript": "\n    ```javascript\nfunction getNumberOfBacklogOrders(orders) {\n    const sell = new PriorityQueue((a, b) => a[0] - b[0]);\n    const buy = new PriorityQueue((a, b) => b[0] - a[0]);\n\n    for (const order of orders) {\n        const [price, amount, orderType] = order;\n        let currAmount = amount;\n        if (orderType === 0) {\n            while (currAmount > 0 && sell.size() > 0 && sell.peek()[0] <= price) {\n                const executedAmount = Math.min(currAmount, sell.peek()[1]);\n                currAmount -= executedAmount;\n                sell.peek()[1] -= executedAmount;\n                if (sell.peek()[1] === 0) sell.pop();\n            }\n            if (currAmount > 0) buy.push([price, currAmount]);\n        } else {\n            while (currAmount > 0 && buy.size() > 0 && buy.peek()[0] >= price) {\n                const executedAmount = Math.min(currAmount, buy.peek()[1]);\n                currAmount -= executedAmount;\n                buy.peek()[1] -= executedAmount;\n                if (buy.peek()[1] === 0) buy.pop();\n            }\n            if (currAmount > 0) sell.push([price, currAmount]);\n        }\n    }\n\n    let res = 0;\n    while (buy.size() > 0) res += buy.pop()[1];\n    while (sell.size() > 0) res += sell.pop()[1];\n\n    return res % 1000000007;\n}\n```\n\n    \n    The algorithm uses two priority queues, one for buy orders and one for sell orders. When iterating over the input orders, for each buy order if there are sell orders that can be executed, execute them and update the current buy order amount accordingly. If the buy order still has residual amount, add it to the buy order queue. Same goes for sell orders.\n\nAfter processing all input orders, the residual orders in the buy and sell queues are the ones that couldn't be executed, sum their amounts and return the result modulo 1,000,000,007.\n    "}
{"id": 1947, "slug": "maximum-compatibility-score-sum", "title": "Maximum Compatibility Score Sum", "difficulty": "Medium", "content": "There is a survey that consists of `n` questions where each question's answer is either `0` (no) or `1` (yes).\n\nThe survey was given to `m` students numbered from `0` to `m - 1` and `m` mentors numbered from `0` to `m - 1`. The answers of the students are represented by a 2D integer array `students` where `students[i]` is an integer array that contains the answers of the `ith` student (**0-indexed**). The answers of the mentors are represented by a 2D integer array `mentors` where `mentors[j]` is an integer array that contains the answers of the `jth` mentor (**0-indexed**).\n\nEach student will be assigned to **one** mentor, and each mentor will have **one** student assigned to them. The **compatibility score** of a student-mentor pair is the number of answers that are the same for both the student and the mentor.\n\n*   For example, if the student's answers were `[1, 0, 1]` and the mentor's answers were `[0, 0, 1]`, then their compatibility score is 2 because only the second and the third answers are the same.\n\nYou are tasked with finding the optimal student-mentor pairings to **maximize** the **sum of the compatibility scores**.\n\nGiven `students` and `mentors`, return _the **maximum compatibility score sum** that can be achieved._\n\n**Example 1:**\n\n**Input:** students = \\[\\[1,1,0\\],\\[1,0,1\\],\\[0,0,1\\]\\], mentors = \\[\\[1,0,0\\],\\[0,0,1\\],\\[1,1,0\\]\\]\n**Output:** 8\n**Explanation:** We assign students to mentors in the following way:\n- student 0 to mentor 2 with a compatibility score of 3.\n- student 1 to mentor 0 with a compatibility score of 2.\n- student 2 to mentor 1 with a compatibility score of 3.\nThe compatibility score sum is 3 + 2 + 3 = 8.\n\n**Example 2:**\n\n**Input:** students = \\[\\[0,0\\],\\[0,0\\],\\[0,0\\]\\], mentors = \\[\\[1,1\\],\\[1,1\\],\\[1,1\\]\\]\n**Output:** 0\n**Explanation:** The compatibility score of any student-mentor pair is 0.\n\n**Constraints:**\n\n*   `m == students.length == mentors.length`\n*   `n == students[i].length == mentors[j].length`\n*   `1 <= m, n <= 8`\n*   `students[i][k]` is either `0` or `1`.\n*   `mentors[j][k]` is either `0` or `1`.", "java": "\n    ```java\nimport java.util.*;\n\npublic int countDifferentSubsequenceGCDs(int[] nums) {\n    int maximum = Arrays.stream(nums).max().getAsInt();\n    int[] gcdCount = new int[maximum + 1];\n    \n    for (int num : nums) {\n        for (int i = 1; i * i <= num; i++) {\n            if (num % i == 0) {\n                gcdCount[i]++;\n                if (i * i != num) {\n                    gcdCount[num / i]++;\n                }\n            }\n        }\n    }\n    \n    int differentGCDs = 0;\n    for (int i = 1; i <= maximum; i++) {\n        if (gcdCount[i] > 0) {\n            differentGCDs++;\n        }\n    }\n    \n    return differentGCDs;\n}\n```\n    \n    1. First, find the maximum number of the given array.\n2. Create an array `gcdCount` with the length of (maximum + 1), initializing all the values to 0.\n3. Iterate through `nums`. For each number, find its divisors and increment the count of the divisors in the `gcdCount` array.\n4. Iterate through the `gcdCount` array starting from index 1 to `maximum`, and count the number of non-zero values.\n5. Return the count of non-zero values as the number of different GCDs.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint countDifferentSubsequenceGCDs(vector<int>& nums) {\n    int maximum = *max_element(nums.begin(), nums.end());\n    vector<int> gcdCount(maximum + 1, 0);\n    \n    for (int num: nums) {\n        for (int i = 1; i * i <= num; i++) {\n            if (num % i == 0) {\n                gcdCount[i]++;\n                if (i * i != num) {\n                    gcdCount[num / i]++;\n                }\n            }\n        }\n    }\n    \n    int differentGCDs = 0;\n    for (int i = 1; i <= maximum; i++) {\n        if (gcdCount[i]) {\n            differentGCDs++;\n        }\n    }\n    \n    return differentGCDs;\n}\n```\n    \n    1. First, find the maximum number of the given array.\n2. Create an array `gcdCount` with the length of (maximum + 1), initializing all the values to 0.\n3. Iterate through `nums`. For each number, find its divisors and increment the count of the divisors in the `gcdCount` array.\n4. Iterate through the `gcdCount` array starting from index 1 to `maximum`, and count the number of non-zero values.\n5. Return the count of non-zero values as the number of different GCDs.\n    ", "python": "\n    ```python\ndef count_different_subsequence_GCDs(nums):\n    maximum = max(nums)\n    gcd_count = [0] * (maximum + 1)\n    \n    for num in nums:\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                gcd_count[i] += 1\n                if i * i != num:\n                    gcd_count[num // i] += 1\n                    \n    different_GCDs = sum(1 for count in gcd_count if count > 0)\n    \n    return different_GCDs\n```\n    \n    1. First, find the maximum number of the given array.\n2. Create an array `gcdCount` with the length of (maximum + 1), initializing all the values to 0.\n3. Iterate through `nums`. For each number, find its divisors and increment the count of the divisors in the `gcdCount` array.\n4. Iterate through the `gcdCount` array starting from index 1 to `maximum`, and count the number of non-zero values.\n5. Return the count of non-zero values as the number of different GCDs.\n    ", "javascript": "\n    ```javascript\nfunction countDifferentSubsequenceGCDs(nums) {\n    let maximum = Math.max(...nums);\n    let gcdCount = new Array(maximum + 1).fill(0);\n    \n    for (const num of nums) {\n        for (let i = 1; i * i <= num; i++) {\n            if (num % i === 0) {\n                gcdCount[i]++;\n                if (i * i !== num) {\n                    gcdCount[num / i]++;\n                }\n            }\n        }\n    }\n    \n    let differentGCDs = 0;\n    for (let i = 1; i <= maximum; i++) {\n        if (gcdCount[i] > 0) {\n            differentGCDs++;\n        }\n    }\n    \n    return differentGCDs;\n}\n```\n    \n    1. First, find the maximum number of the given array.\n2. Create an array `gcdCount` with the length of (maximum + 1), initializing all the values to 0.\n3. Iterate through `nums`. For each number, find its divisors and increment the count of the divisors in the `gcdCount` array.\n4. Iterate through the `gcdCount` array starting from index 1 to `maximum`, and count the number of non-zero values.\n5. Return the count of non-zero values as the number of different GCDs.\n    "}
{"id": 1955, "slug": "count-number-of-special-subsequences", "title": "Count Number of Special Subsequences", "difficulty": "Hard", "content": "A sequence is **special** if it consists of a **positive** number of `0`s, followed by a **positive** number of `1`s, then a **positive** number of `2`s.\n\n*   For example, `[0,1,2]` and `[0,0,1,1,1,2]` are special.\n*   In contrast, `[2,1,0]`, `[1]`, and `[0,1,2,0]` are not special.\n\nGiven an array `nums` (consisting of **only** integers `0`, `1`, and `2`), return _the **number of different subsequences** that are special_. Since the answer may be very large, **return it modulo** `109 + 7`.\n\nA **subsequence** of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Two subsequences are **different** if the **set of indices** chosen are different.\n\n**Example 1:**\n\n**Input:** nums = \\[0,1,2,2\\]\n**Output:** 3\n**Explanation:** The special subsequences are bolded \\[**0**,**1**,**2**,2\\], \\[**0**,**1**,2,**2**\\], and \\[**0**,**1**,**2**,**2**\\].\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,0,0\\]\n**Output:** 0\n**Explanation:** There are no special subsequences in \\[2,2,0,0\\].\n\n**Example 3:**\n\n**Input:** nums = \\[0,1,2,0,1,2\\]\n**Output:** 7\n**Explanation:** The special subsequences are bolded:\n- \\[**0**,**1**,**2**,0,1,2\\]\n- \\[**0**,**1**,2,0,1,**2**\\]\n- \\[**0**,**1**,**2**,0,1,**2**\\]\n- \\[**0**,**1**,2,0,**1**,**2**\\]\n- \\[**0**,1,2,**0**,**1**,**2**\\]\n- \\[**0**,1,2,0,**1**,**2**\\]\n- \\[0,1,2,**0**,**1**,**2**\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 2`", "java": "\n    ```java\nimport java.util.PriorityQueue;\n\nclass SeatManager {\n    private PriorityQueue<Integer> availableSeats;\n\n    public SeatManager(int n) {\n        availableSeats = new PriorityQueue<>();\n        for (int i = 1; i <= n; i++) {\n            availableSeats.add(i);\n        }\n    }\n\n    public int reserve() {\n        return availableSeats.poll();\n    }\n\n    public void unreserve(int seatNumber) {\n        availableSeats.add(seatNumber);\n    }\n}\n```\n    \n    The SeatManager class manages the reservation state of n seats numbered from 1 to n. To implement this, we use a priority queue data structure to represent available seats. The priority queue allows us to efficiently fetch the lowest available seat number and maintain an ordered list when a seat is unreserved.\n\nThe constructor initializes the available_seats priority queue with seat numbers ranging from 1 to n.\n\nThe reserve() function reserves the seat by returning the lowest available seat number and removing it from the priority queue.\n\nThe unreserve(int seatNumber) function accepts a seat number as an argument and returns the seat to the priority queue of available seats.\n\nIn all languages, we use the built-in priority queue implementation (min-heap in case of Python, PriorityQueue in Java, and custom implementation using array and sort functions in JavaScript).\n    ", "c++": "\n    ```cpp\n#include <queue>\n\nclass SeatManager {\n    std::priority_queue<int, std::vector<int>, std::greater<int>> available_seats;\npublic:\n    SeatManager(int n) {\n        for (int i = 1; i <= n; ++i) {\n            available_seats.push(i);\n        }\n    }\n\n    int reserve() {\n        int seat = available_seats.top();\n        available_seats.pop();\n        return seat;\n    }\n\n    void unreserve(int seatNumber) {\n        available_seats.push(seatNumber);\n    }\n};\n```\n    \n    The SeatManager class manages the reservation state of n seats numbered from 1 to n. To implement this, we use a priority queue data structure to represent available seats. The priority queue allows us to efficiently fetch the lowest available seat number and maintain an ordered list when a seat is unreserved.\n\nThe constructor initializes the available_seats priority queue with seat numbers ranging from 1 to n.\n\nThe reserve() function reserves the seat by returning the lowest available seat number and removing it from the priority queue.\n\nThe unreserve(int seatNumber) function accepts a seat number as an argument and returns the seat to the priority queue of available seats.\n\nIn all languages, we use the built-in priority queue implementation (min-heap in case of Python, PriorityQueue in Java, and custom implementation using array and sort functions in JavaScript).\n    ", "python": "\n    ```python\nimport heapq\n\nclass SeatManager:\n    def __init__(self, n: int):\n        self.available_seats = [i for i in range(1, n + 1)]\n        heapq.heapify(self.available_seats)\n\n    def reserve(self) -> int:\n        return heapq.heappop(self.available_seats)\n\n    def unreserve(self, seatNumber: int) -> None:\n        heapq.heappush(self.available_seats, seatNumber)\n```\n    \n    The SeatManager class manages the reservation state of n seats numbered from 1 to n. To implement this, we use a priority queue data structure to represent available seats. The priority queue allows us to efficiently fetch the lowest available seat number and maintain an ordered list when a seat is unreserved.\n\nThe constructor initializes the available_seats priority queue with seat numbers ranging from 1 to n.\n\nThe reserve() function reserves the seat by returning the lowest available seat number and removing it from the priority queue.\n\nThe unreserve(int seatNumber) function accepts a seat number as an argument and returns the seat to the priority queue of available seats.\n\nIn all languages, we use the built-in priority queue implementation (min-heap in case of Python, PriorityQueue in Java, and custom implementation using array and sort functions in JavaScript).\n    ", "javascript": "\n    ```javascript\nclass SeatManager {\n    constructor(n) {\n        this.availableSeats = [];\n        for (let i = 1; i <= n; i++) {\n            this.availableSeats.push(i);\n        }\n        this.availableSeats.sort((a, b) => a - b);\n    }\n\n    reserve() {\n        return this.availableSeats.shift();\n    }\n\n    unreserve(seatNumber) {\n        this.availableSeats.push(seatNumber);\n        this.availableSeats.sort((a, b) => a - b);\n    }\n}\n```\n    \n    The SeatManager class manages the reservation state of n seats numbered from 1 to n. To implement this, we use a priority queue data structure to represent available seats. The priority queue allows us to efficiently fetch the lowest available seat number and maintain an ordered list when a seat is unreserved.\n\nThe constructor initializes the available_seats priority queue with seat numbers ranging from 1 to n.\n\nThe reserve() function reserves the seat by returning the lowest available seat number and removing it from the priority queue.\n\nThe unreserve(int seatNumber) function accepts a seat number as an argument and returns the seat to the priority queue of available seats.\n\nIn all languages, we use the built-in priority queue implementation (min-heap in case of Python, PriorityQueue in Java, and custom implementation using array and sort functions in JavaScript).\n    "}
{"id": 1976, "slug": "number-of-ways-to-arrive-at-destination", "title": "Number of Ways to Arrive at Destination", "difficulty": "Medium", "content": "You are in a city that consists of `n` intersections numbered from `0` to `n - 1` with **bi-directional** roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.\n\nYou are given an integer `n` and a 2D integer array `roads` where `roads[i] = [ui, vi, timei]` means that there is a road between intersections `ui` and `vi` that takes `timei` minutes to travel. You want to know in how many ways you can travel from intersection `0` to intersection `n - 1` in the **shortest amount of time**.\n\nReturn _the **number of ways** you can arrive at your destination in the **shortest amount of time**_. Since the answer may be large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 7, roads = \\[\\[0,6,7\\],\\[0,1,2\\],\\[1,2,3\\],\\[1,3,3\\],\\[6,3,3\\],\\[3,5,1\\],\\[6,5,1\\],\\[2,5,1\\],\\[0,4,5\\],\\[4,6,2\\]\\]\n**Output:** 4\n**Explanation:** The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 \u279d 6\n- 0 \u279d 4 \u279d 6\n- 0 \u279d 1 \u279d 2 \u279d 5 \u279d 6\n- 0 \u279d 1 \u279d 3 \u279d 5 \u279d 6\n\n**Example 2:**\n\n**Input:** n = 2, roads = \\[\\[1,0,10\\]\\]\n**Output:** 1\n**Explanation:** There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n\n**Constraints:**\n\n*   `1 <= n <= 200`\n*   `n - 1 <= roads.length <= n * (n - 1) / 2`\n*   `roads[i].length == 3`\n*   `0 <= ui, vi <= n - 1`\n*   `1 <= timei <= 109`\n*   `ui != vi`\n*   There is at most one road connecting any two intersections.\n*   You can reach any intersection from any other intersection.", "java": "\n    ```java\npublic boolean canSplitString(String s) {\n    int[] count = new int[10];\n    for (char c : s.toCharArray()) {\n        count[c - '0']++;\n    }\n\n    for (int i = 1; i <= 9; i++) {\n        if (count[i] > 0 && count[i] == count[i - 1]) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    Initialize a `count` array to store frequency of digits in the input string `s`. Iterate through the characters of the string and increment the frequency of each digit using its numerical value. After completion, the `count` array holds the frequency of each digit in the input string.\n\nIterate through the frequency count array from index 1 to 9. If the counts of the current digit `i` and the previous digit `i-1` are equal and greater than 0, it's possible to split the string as described. In this case, return `true`. If the loop completes, return `false`, as the string cannot be split as described above.\n    ", "c++": "\n    ```cpp\nbool canSplitString(const std::string& s) {\n    int count[10] = {0};\n    for (char c : s) {\n        count[c - '0'] += 1;\n    }\n\n    for (int i = 1; i <= 9; ++i) {\n        if (count[i] > 0 && count[i] == count[i - 1]) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    Initialize a `count` array to store frequency of digits in the input string `s`. Iterate through the characters of the string and increment the frequency of each digit using its numerical value. After completion, the `count` array holds the frequency of each digit in the input string.\n\nIterate through the frequency count array from index 1 to 9. If the counts of the current digit `i` and the previous digit `i-1` are equal and greater than 0, it's possible to split the string as described. In this case, return `true`. If the loop completes, return `false`, as the string cannot be split as described above.\n    ", "python": "\n    ```python\ndef can_split_string(s: str) -> bool:\n    count = [0] * 10\n\n    for c in s:\n        count[int(c)] += 1\n\n    for i in range(1, 10):\n        if count[i] > 0 and count[i] == count[i - 1]:\n            return True\n\n    return False\n```\n    \n    Initialize a `count` array to store frequency of digits in the input string `s`. Iterate through the characters of the string and increment the frequency of each digit using its numerical value. After completion, the `count` array holds the frequency of each digit in the input string.\n\nIterate through the frequency count array from index 1 to 9. If the counts of the current digit `i` and the previous digit `i-1` are equal and greater than 0, it's possible to split the string as described. In this case, return `true`. If the loop completes, return `false`, as the string cannot be split as described above.\n    ", "javascript": "\n    ```javascript\nfunction canSplitString(s) {\n    const count = new Array(10).fill(0);\n\n    for (const c of s) {\n        count[Number(c)] += 1;\n    }\n\n    for (let i = 1; i <= 9; i++) {\n        if (count[i] > 0 && count[i] === count[i - 1]) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    Initialize a `count` array to store frequency of digits in the input string `s`. Iterate through the characters of the string and increment the frequency of each digit using its numerical value. After completion, the `count` array holds the frequency of each digit in the input string.\n\nIterate through the frequency count array from index 1 to 9. If the counts of the current digit `i` and the previous digit `i-1` are equal and greater than 0, it's possible to split the string as described. In this case, return `true`. If the loop completes, return `false`, as the string cannot be split as described above.\n    "}
{"id": 1977, "slug": "number-of-ways-to-separate-numbers", "title": "Number of Ways to Separate Numbers", "difficulty": "Hard", "content": "You wrote down many **positive** integers in a string called `num`. However, you realized that you forgot to add commas to seperate the different numbers. You remember that the list of integers was **non-decreasing** and that **no** integer had leading zeros.\n\nReturn _the **number of possible lists of integers** that you could have written down to get the string_ `num`. Since the answer may be large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** num =  \"327 \"\n**Output:** 2\n**Explanation:** You could have written down the numbers:\n3, 27\n327\n\n**Example 2:**\n\n**Input:** num =  \"094 \"\n**Output:** 0\n**Explanation:** No numbers can have leading zeros and all numbers must be positive.\n\n**Example 3:**\n\n**Input:** num =  \"0 \"\n**Output:** 0\n**Explanation:** No numbers can have leading zeros and all numbers must be positive.\n\n**Constraints:**\n\n*   `1 <= num.length <= 3500`\n*   `num` consists of digits `'0'` through `'9'`.", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic int[] intervalFinding(int[][] intervals, int[] queries) {\n    Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\n    int[] ans = new int[queries.length];\n    for (int i = 0; i < queries.length; i++) {\n        int q = queries[i];\n        int min_size = Integer.MAX_VALUE;\n        for (int[] interval : intervals) {\n            if (interval[0] <= q && q <= interval[1]) {\n                min_size = Math.min(min_size, interval[1] - interval[0] + 1);\n            }\n        }\n        ans[i] = min_size == Integer.MAX_VALUE ? -1 : min_size;\n    }\n    return ans;\n}\n```\n\n    \n    1. Sort the intervals based on their starting point (lefti) in ascending order, so we can have a quicker check while iterating through the intervals. This can be done with standard sorting function and custom compare function in each programming language.\n2. Initialize an empty answer array `ans` that will store the answer of each query.\n3. Iterate through the `queries` array.\n4. For each query `q`, initialize a `min_size` variable with maximum possible value for that language. Here we use `INT_MAX`, `Integer.MAX_VALUE`, `float('inf')`, and `Infinity` for C++, Java, Python, and JavaScript, respectively.\n5. For each `interval` in the sorted `intervals`, if the query `q` lies within the given interval (lefti <= q <= righti), calculate the size of the interval (righti - lefti + 1) and update the `min_size` with the minimum value of the current interval size.\n6. After iterating through all the intervals, check if the `min_size` is still equal to the initial maximum value. If it is, the query didn't match any interval, so append `-1` to the answer array. Otherwise, append the `min_size`.\n7. Repeat these steps for all queries in the `queries` array.\n8. Finally, return the `ans` array.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> intervalFinding(vector<vector<int>>& intervals, vector<int>& queries) {\n    sort(intervals.begin(), intervals.end());\n    vector<int> ans;\n    for (int q : queries) {\n        int min_size = INT_MAX;\n        for (vector<int> &interval : intervals) {\n            if (interval[0] <= q && q <= interval[1]) {\n                min_size = min(min_size, interval[1] - interval[0] + 1);\n            }\n        }\n        ans.push_back(min_size == INT_MAX ? -1 : min_size);\n    }\n    return ans;\n}\n```\n    \n    1. Sort the intervals based on their starting point (lefti) in ascending order, so we can have a quicker check while iterating through the intervals. This can be done with standard sorting function and custom compare function in each programming language.\n2. Initialize an empty answer array `ans` that will store the answer of each query.\n3. Iterate through the `queries` array.\n4. For each query `q`, initialize a `min_size` variable with maximum possible value for that language. Here we use `INT_MAX`, `Integer.MAX_VALUE`, `float('inf')`, and `Infinity` for C++, Java, Python, and JavaScript, respectively.\n5. For each `interval` in the sorted `intervals`, if the query `q` lies within the given interval (lefti <= q <= righti), calculate the size of the interval (righti - lefti + 1) and update the `min_size` with the minimum value of the current interval size.\n6. After iterating through all the intervals, check if the `min_size` is still equal to the initial maximum value. If it is, the query didn't match any interval, so append `-1` to the answer array. Otherwise, append the `min_size`.\n7. Repeat these steps for all queries in the `queries` array.\n8. Finally, return the `ans` array.\n    ", "python": "\n    ```python\ndef intervalFinding(intervals, queries):\n    intervals.sort(key=lambda x: x[0])\n    ans = []\n    for q in queries:\n        min_size = float('inf')\n        for interval in intervals:\n            if interval[0] <= q <= interval[1]:\n                min_size = min(min_size, interval[1] - interval[0] + 1)\n        ans.append(-1 if min_size == float('inf') else min_size)\n    return ans\n```\n\n    \n    1. Sort the intervals based on their starting point (lefti) in ascending order, so we can have a quicker check while iterating through the intervals. This can be done with standard sorting function and custom compare function in each programming language.\n2. Initialize an empty answer array `ans` that will store the answer of each query.\n3. Iterate through the `queries` array.\n4. For each query `q`, initialize a `min_size` variable with maximum possible value for that language. Here we use `INT_MAX`, `Integer.MAX_VALUE`, `float('inf')`, and `Infinity` for C++, Java, Python, and JavaScript, respectively.\n5. For each `interval` in the sorted `intervals`, if the query `q` lies within the given interval (lefti <= q <= righti), calculate the size of the interval (righti - lefti + 1) and update the `min_size` with the minimum value of the current interval size.\n6. After iterating through all the intervals, check if the `min_size` is still equal to the initial maximum value. If it is, the query didn't match any interval, so append `-1` to the answer array. Otherwise, append the `min_size`.\n7. Repeat these steps for all queries in the `queries` array.\n8. Finally, return the `ans` array.\n    ", "javascript": "\n    ```javascript\nfunction intervalFinding(intervals, queries) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    const ans = [];\n    for (const q of queries) {\n        let min_size = Infinity;\n        for (const interval of intervals) {\n            if (interval[0] <= q && q <= interval[1]) {\n                min_size = Math.min(min_size, interval[1] - interval[0] + 1);\n            }\n        }\n        ans.push(min_size === Infinity ? -1 : min_size);\n    }\n    return ans;\n}\n```\n\n    \n    1. Sort the intervals based on their starting point (lefti) in ascending order, so we can have a quicker check while iterating through the intervals. This can be done with standard sorting function and custom compare function in each programming language.\n2. Initialize an empty answer array `ans` that will store the answer of each query.\n3. Iterate through the `queries` array.\n4. For each query `q`, initialize a `min_size` variable with maximum possible value for that language. Here we use `INT_MAX`, `Integer.MAX_VALUE`, `float('inf')`, and `Infinity` for C++, Java, Python, and JavaScript, respectively.\n5. For each `interval` in the sorted `intervals`, if the query `q` lies within the given interval (lefti <= q <= righti), calculate the size of the interval (righti - lefti + 1) and update the `min_size` with the minimum value of the current interval size.\n6. After iterating through all the intervals, check if the `min_size` is still equal to the initial maximum value. If it is, the query didn't match any interval, so append `-1` to the answer array. Otherwise, append the `min_size`.\n7. Repeat these steps for all queries in the `queries` array.\n8. Finally, return the `ans` array.\n    "}
{"id": 1986, "slug": "minimum-number-of-work-sessions-to-finish-the-tasks", "title": "Minimum Number of Work Sessions to Finish the Tasks", "difficulty": "Medium", "content": "There are `n` tasks assigned to you. The task times are represented as an integer array `tasks` of length `n`, where the `ith` task takes `tasks[i]` hours to finish. A **work session** is when you work for **at most** `sessionTime` consecutive hours and then take a break.\n\nYou should finish the given tasks in a way that satisfies the following conditions:\n\n*   If you start a task in a work session, you must complete it in the **same** work session.\n*   You can start a new task **immediately** after finishing the previous one.\n*   You may complete the tasks in **any order**.\n\nGiven `tasks` and `sessionTime`, return _the **minimum** number of **work sessions** needed to finish all the tasks following the conditions above._\n\nThe tests are generated such that `sessionTime` is **greater** than or **equal** to the **maximum** element in `tasks[i]`.\n\n**Example 1:**\n\n**Input:** tasks = \\[1,2,3\\], sessionTime = 3\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.\n- Second work session: finish the third task in 3 hours.\n\n**Example 2:**\n\n**Input:** tasks = \\[3,1,3,1,1\\], sessionTime = 8\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.\n- Second work session: finish the last task in 1 hour.\n\n**Example 3:**\n\n**Input:** tasks = \\[1,2,3,4,5\\], sessionTime = 15\n**Output:** 1\n**Explanation:** You can finish all the tasks in one work session.\n\n**Constraints:**\n\n*   `n == tasks.length`\n*   `1 <= n <= 14`\n*   `1 <= tasks[i] <= 10`\n*   `max(tasks[i]) <= sessionTime <= 15`", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int largestPathValue(String colors, int[][] edges) {\n        int n = colors.length();\n        List<Set<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new HashSet<>());\n        }\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n        }\n        int[][] cache = new int[n][26];\n        int[] inDegree = new int[n];\n        for (int[] edge : edges) {\n            inDegree[edge[1]]++;\n        }\n        int res = -1;\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                res = Math.max(res, dfs(i, graph, colors, cache));\n            }\n        }\n        return res;\n    }\n\n    private int dfs(int node, List<Set<Integer>> graph, String colors, int[][] cache) {\n        if (cache[node][colors.charAt(node) - 'a'] == 0) {\n            cache[node][colors.charAt(node) - 'a'] = 1;\n            for (int neighbor : graph.get(node)) {\n                cache[node][colors.charAt(node) - 'a'] = Math.max(cache[node][colors.charAt(node) - 'a'], 1 + dfs(neighbor, graph, colors, cache));\n            }\n        }\n        return cache[node][colors.charAt(node) - 'a'];\n    }\n}\n```\n    \n    For each language implementation, the algorithm follows the process below:\n\n1. Convert the given `edges` into an adjacency list representation (a list with a set of neighbors for each node).\n2. Initialize the `cache` (a 2D array) to store the largest color value of valid paths from a node considering the color of that node.\n3. Calculate the `inDegree` (number of incoming edges) for every node.\n4. Initialize the variable `res` to -1 (it will store the largest color value).\n5. Iterate through all the nodes, and for each node with an `inDegree` of 0 (no incoming edges) call the `dfs` function.\n6. In the `dfs` function, use depth-first search to traverse the directed graph and compute the largest color value of valid paths from a node considering the color of that node using memoization (storing it in `cache` to avoid recomputation).\n7. Update `res` with the maximum of its current value and the color value returned by the `dfs` function for a given node.\n8. Return `res` (the largest color value of any valid path in the graph).\n\nThe DFS function is used to compute the largest color value of any valid path in the graph for a given node. The memoization (caching) technique is used to avoid redundant calculations and optimize the time complexity of the algorithm.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nint dfs(int node, vector<unordered_set<int>> &graph, string &colors, vector<vector<int>> &cache) {\n    if (!cache[node][colors[node] - 'a']) {\n        cache[node][colors[node] - 'a'] = 1;\n        for (int neighbor : graph[node]) {\n            cache[node][colors[node] - 'a'] = max(cache[node][colors[node] - 'a'], 1 + dfs(neighbor, graph, colors, cache));\n        }\n    }\n    return cache[node][colors[node] - 'a'];\n}\n\nint largestPathValue(string colors, vector<vector<int>> &edges) {\n    int n = colors.size();\n    vector<unordered_set<int>> graph(n);\n    for (const auto &edge : edges) {\n        graph[edge[0]].insert(edge[1]);\n    }\n    vector<vector<int>> cache(n, vector<int>(26));\n    vector<int> in_degree(n);\n    for (const auto &edge : edges) {\n        in_degree[edge[1]]++;\n    }\n    int res = -1;\n    for (int i = 0; i < n; ++i) {\n        if (!in_degree[i]) {\n            res = max(res, dfs(i, graph, colors, cache));\n        }\n    }\n    return res;\n}\n```\n    \n    For each language implementation, the algorithm follows the process below:\n\n1. Convert the given `edges` into an adjacency list representation (a list with a set of neighbors for each node).\n2. Initialize the `cache` (a 2D array) to store the largest color value of valid paths from a node considering the color of that node.\n3. Calculate the `inDegree` (number of incoming edges) for every node.\n4. Initialize the variable `res` to -1 (it will store the largest color value).\n5. Iterate through all the nodes, and for each node with an `inDegree` of 0 (no incoming edges) call the `dfs` function.\n6. In the `dfs` function, use depth-first search to traverse the directed graph and compute the largest color value of valid paths from a node considering the color of that node using memoization (storing it in `cache` to avoid recomputation).\n7. Update `res` with the maximum of its current value and the color value returned by the `dfs` function for a given node.\n8. Return `res` (the largest color value of any valid path in the graph).\n\nThe DFS function is used to compute the largest color value of any valid path in the graph for a given node. The memoization (caching) technique is used to avoid redundant calculations and optimize the time complexity of the algorithm.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\n\n\ndef largestPathValue(colors, edges):\n    def dfs(node):\n        if not cache[node][ord(colors[node]) - ord('a')]:\n            cache[node][ord(colors[node]) - ord('a')] = 1\n            for neighbor in graph[node]:\n                cache[node][ord(colors[node]) - ord('a')] = max(cache[node][ord(colors[node]) - ord('a')],\n                                                               1 + dfs(neighbor))\n        return cache[node][ord(colors[node]) - ord('a')]\n\n    n = len(colors)\n    graph = [set() for _ in range(n)]\n    for a, b in edges:\n        graph[a].add(b)\n\n    cache = [[0] * 26 for _ in range(n)]\n    in_degree = [0] * n\n    for a, b in edges:\n        in_degree[b] += 1\n    res = -1\n    for i in range(n):\n        if in_degree[i] == 0:\n            res = max(res, dfs(i))\n    return res\n```\n    \n    For each language implementation, the algorithm follows the process below:\n\n1. Convert the given `edges` into an adjacency list representation (a list with a set of neighbors for each node).\n2. Initialize the `cache` (a 2D array) to store the largest color value of valid paths from a node considering the color of that node.\n3. Calculate the `inDegree` (number of incoming edges) for every node.\n4. Initialize the variable `res` to -1 (it will store the largest color value).\n5. Iterate through all the nodes, and for each node with an `inDegree` of 0 (no incoming edges) call the `dfs` function.\n6. In the `dfs` function, use depth-first search to traverse the directed graph and compute the largest color value of valid paths from a node considering the color of that node using memoization (storing it in `cache` to avoid recomputation).\n7. Update `res` with the maximum of its current value and the color value returned by the `dfs` function for a given node.\n8. Return `res` (the largest color value of any valid path in the graph).\n\nThe DFS function is used to compute the largest color value of any valid path in the graph for a given node. The memoization (caching) technique is used to avoid redundant calculations and optimize the time complexity of the algorithm.\n    ", "javascript": "\n    ```javascript\nfunction largestPathValue(colors, edges) {\n    function dfs(node) {\n        if (!cache[node][colors.charCodeAt(node) - 'a'.charCodeAt(0)]) {\n            cache[node][colors.charCodeAt(node) - 'a'.charCodeAt(0)] = 1;\n            for (const neighbor of graph[node]) {\n                cache[node][colors.charCodeAt(node) - 'a'.charCodeAt(0)] = Math.max(cache[node][colors.charCodeAt(node) - 'a'.charCodeAt(0)], 1 + dfs(neighbor));\n            }\n        }\n        return cache[node][colors.charCodeAt(node) - 'a'.charCodeAt(0)];\n    }\n\n    const n = colors.length;\n    const graph = new Array(n).fill().map(() => new Set());\n    for (const edge of edges) {\n        graph[edge[0]].add(edge[1]);\n    }\n\n    const cache = new Array(n).fill().map(() => new Array(26).fill(0));\n    const inDegree = new Array(n).fill(0);\n    for (const edge of edges) {\n        inDegree[edge[1]]++;\n    }\n    let res = -1;\n    for (let i = 0; i < n; i++) {\n        if (inDegree[i] === 0) {\n            res = Math.max(res, dfs(i));\n        }\n    }\n    return res;\n}\n```\n    \n    For each language implementation, the algorithm follows the process below:\n\n1. Convert the given `edges` into an adjacency list representation (a list with a set of neighbors for each node).\n2. Initialize the `cache` (a 2D array) to store the largest color value of valid paths from a node considering the color of that node.\n3. Calculate the `inDegree` (number of incoming edges) for every node.\n4. Initialize the variable `res` to -1 (it will store the largest color value).\n5. Iterate through all the nodes, and for each node with an `inDegree` of 0 (no incoming edges) call the `dfs` function.\n6. In the `dfs` function, use depth-first search to traverse the directed graph and compute the largest color value of valid paths from a node considering the color of that node using memoization (storing it in `cache` to avoid recomputation).\n7. Update `res` with the maximum of its current value and the color value returned by the `dfs` function for a given node.\n8. Return `res` (the largest color value of any valid path in the graph).\n\nThe DFS function is used to compute the largest color value of any valid path in the graph for a given node. The memoization (caching) technique is used to avoid redundant calculations and optimize the time complexity of the algorithm.\n    "}
{"id": 1987, "slug": "number-of-unique-good-subsequences", "title": "Number of Unique Good Subsequences", "difficulty": "Hard", "content": "You are given a binary string `binary`. A **subsequence** of `binary` is considered **good** if it is **not empty** and has **no leading zeros** (with the exception of `\"0 \"`).\n\nFind the number of **unique good subsequences** of `binary`.\n\n*   For example, if `binary = \"001 \"`, then all the **good** subsequences are `[ \"0 \", \"0 \", \"1 \"]`, so the **unique** good subsequences are `\"0 \"` and `\"1 \"`. Note that subsequences `\"00 \"`, `\"01 \"`, and `\"001 \"` are not good because they have leading zeros.\n\nReturn _the number of **unique good subsequences** of_ `binary`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n**Example 1:**\n\n**Input:** binary =  \"001 \"\n**Output:** 2\n**Explanation:** The good subsequences of binary are \\[ \"0 \",  \"0 \",  \"1 \"\\].\nThe unique good subsequences are  \"0 \" and  \"1 \".\n\n**Example 2:**\n\n**Input:** binary =  \"11 \"\n**Output:** 2\n**Explanation:** The good subsequences of binary are \\[ \"1 \",  \"1 \",  \"11 \"\\].\nThe unique good subsequences are  \"1 \" and  \"11 \".\n\n**Example 3:**\n\n**Input:** binary =  \"101 \"\n**Output:** 5\n**Explanation:** The good subsequences of binary are \\[ \"1 \",  \"0 \",  \"1 \",  \"10 \",  \"11 \",  \"101 \"\\]. \nThe unique good subsequences are  \"0 \",  \"1 \",  \"10 \",  \"11 \", and  \"101 \".\n\n**Constraints:**\n\n*   `1 <= binary.length <= 105`\n*   `binary` consists of only `'0'`s and `'1'`s.", "java": "\n    ```java\npublic int countGoodSubstrings(String s) {\n    int count = 0;\n    for (int i = 0; i < s.length() - 2; i++) {\n        if (s.charAt(i) != s.charAt(i + 1) && s.charAt(i) != s.charAt(i + 2) && s.charAt(i + 1) != s.charAt(i + 2))\n            count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given string `s` till the third last character. For each character, it checks if the current character and the next two characters are distinct. If they are distinct, it means we have found a good substring of length three and increase the `count`. After the iteration, the function returns the total count of good substrings found.\n    ", "c++": "\n    ```cpp\nint countGoodSubstrings(const std::string &s) {\n    int count = 0;\n    for (int i = 0; i < s.length() - 2; i++) {\n        if (s[i] != s[i + 1] && s[i] != s[i + 2] && s[i + 1] != s[i + 2])\n            count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given string `s` till the third last character. For each character, it checks if the current character and the next two characters are distinct. If they are distinct, it means we have found a good substring of length three and increase the `count`. After the iteration, the function returns the total count of good substrings found.\n    ", "python": "\n    ```python\ndef count_good_substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:\n            count += 1\n    return count\n```\n    \n    The algorithm iterates through the given string `s` till the third last character. For each character, it checks if the current character and the next two characters are distinct. If they are distinct, it means we have found a good substring of length three and increase the `count`. After the iteration, the function returns the total count of good substrings found.\n    ", "javascript": "\n    ```javascript\nfunction countGoodSubstrings(s) {\n    let count = 0;\n    for (let i = 0; i < s.length - 2; i++) {\n        if (s[i] !== s[i + 1] && s[i] !== s[i + 2] && s[i + 1] !== s[i + 2])\n            count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given string `s` till the third last character. For each character, it checks if the current character and the next two characters are distinct. If they are distinct, it means we have found a good substring of length three and increase the `count`. After the iteration, the function returns the total count of good substrings found.\n    "}
{"id": 1994, "slug": "the-number-of-good-subsets", "title": "The Number of Good Subsets", "difficulty": "Hard", "content": "You are given an integer array `nums`. We call a subset of `nums` **good** if its product can be represented as a product of one or more **distinct prime** numbers.\n\n*   For example, if `nums = [1, 2, 3, 4]`:\n    *   `[2, 3]`, `[1, 2, 3]`, and `[1, 3]` are **good** subsets with products `6 = 2*3`, `6 = 2*3`, and `3 = 3` respectively.\n    *   `[1, 4]` and `[4]` are not **good** subsets with products `4 = 2*2` and `4 = 2*2` respectively.\n\nReturn _the number of different **good** subsets in_ `nums` _**modulo**_ `109 + 7`.\n\nA **subset** of `nums` is any array that can be obtained by deleting some (possibly none or all) elements from `nums`. Two subsets are different if and only if the chosen indices to delete are different.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 6\n**Explanation:** The good subsets are:\n- \\[1,2\\]: product is 2, which is the product of distinct prime 2.\n- \\[1,2,3\\]: product is 6, which is the product of distinct primes 2 and 3.\n- \\[1,3\\]: product is 3, which is the product of distinct prime 3.\n- \\[2\\]: product is 2, which is the product of distinct prime 2.\n- \\[2,3\\]: product is 6, which is the product of distinct primes 2 and 3.\n- \\[3\\]: product is 3, which is the product of distinct prime 3.\n\n**Example 2:**\n\n**Input:** nums = \\[4,2,3,15\\]\n**Output:** 5\n**Explanation:** The good subsets are:\n- \\[2\\]: product is 2, which is the product of distinct prime 2.\n- \\[2,3\\]: product is 6, which is the product of distinct primes 2 and 3.\n- \\[2,15\\]: product is 30, which is the product of distinct primes 2, 3, and 5.\n- \\[3\\]: product is 3, which is the product of distinct prime 3.\n- \\[15\\]: product is 15, which is the product of distinct primes 3 and 5.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 30`", "java": "\n    ```java\nint minSwaps(String s) {\n    int zeros = 0, ones = 0;\n    for (char c : s.toCharArray()) {\n        if (c == '0') {\n            zeros++;\n        } else {\n            ones++;\n        }\n    }\n\n    if (Math.abs(zeros - ones) > 1) {\n        return -1;\n    }\n\n    int mismatchCount1 = 0, mismatchCount2 = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (i % 2 == 0) {\n            if (s.charAt(i) != '0') mismatchCount1++;\n            if (s.charAt(i) != '1') mismatchCount2++;\n        } else {\n            if (s.charAt(i) != '1') mismatchCount1++;\n            if (s.charAt(i) != '0') mismatchCount2++;\n        }\n    }\n\n    return Math.min(mismatchCount1, mismatchCount2) / 2;\n}\n```\n\n    \n    1. Count the number of zeros and ones.\n2. If the absolute difference between zeros and ones is greater than 1, it's impossible to create an alternating string, return -1.\n3. Initialize two mismatch counts to count the number of mismatches assuming either that the first character is '0' or '1'.\n4. Loop through the string and increment the mismatch counts accordingly.\n5. The minimum number of swaps is the minimum of the mismatch counts divided by 2 because each swap corrects two mismatched characters.\n    ", "c++": "\n    ```cpp\nint min_swaps(std::string s) {\n    int zeros = 0, ones = 0;\n    for (char c : s) {\n        if (c == '0') {\n            zeros++;\n        } else {\n            ones++;\n        }\n    }\n\n    if (abs(zeros - ones) > 1) {\n        return -1;\n    }\n\n    int mismatch_count1 = 0, mismatch_count2 = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (i % 2 == 0) {\n            if (s[i] != '0') mismatch_count1++;\n            if (s[i] != '1') mismatch_count2++;\n        } else {\n            if (s[i] != '1') mismatch_count1++;\n            if (s[i] != '0') mismatch_count2++;\n        }\n    }\n\n    return min(mismatch_count1, mismatch_count2) / 2;\n}\n```\n\n    \n    1. Count the number of zeros and ones.\n2. If the absolute difference between zeros and ones is greater than 1, it's impossible to create an alternating string, return -1.\n3. Initialize two mismatch counts to count the number of mismatches assuming either that the first character is '0' or '1'.\n4. Loop through the string and increment the mismatch counts accordingly.\n5. The minimum number of swaps is the minimum of the mismatch counts divided by 2 because each swap corrects two mismatched characters.\n    ", "python": "\n    ```python\ndef min_swaps(s: str) -> int:\n    zeros, ones = 0, 0\n    for c in s:\n        if c == '0':\n            zeros += 1\n        else:\n            ones += 1\n\n    if abs(zeros - ones) > 1:\n        return -1\n\n    mismatch_count1, mismatch_count2 = 0, 0\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c != '0': mismatch_count1 += 1\n            if c != '1': mismatch_count2 += 1\n        else:\n            if c != '1': mismatch_count1 += 1\n            if c != '0': mismatch_count2 += 1\n\n    return min(mismatch_count1, mismatch_count2) // 2\n```\n\n    \n    1. Count the number of zeros and ones.\n2. If the absolute difference between zeros and ones is greater than 1, it's impossible to create an alternating string, return -1.\n3. Initialize two mismatch counts to count the number of mismatches assuming either that the first character is '0' or '1'.\n4. Loop through the string and increment the mismatch counts accordingly.\n5. The minimum number of swaps is the minimum of the mismatch counts divided by 2 because each swap corrects two mismatched characters.\n    ", "javascript": "\n    ```javascript\nfunction minSwaps(s) {\n    let zeros = 0, ones = 0;\n    for (const c of s) {\n        if (c === '0') {\n            zeros++;\n        } else {\n            ones++;\n        }\n    }\n    \n    if (Math.abs(zeros - ones) > 1) {\n        return -1;\n    }\n\n    let mismatchCount1 = 0, mismatchCount2 = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (i % 2 === 0) {\n            if (s[i] !== '0') mismatchCount1++;\n            if (s[i] !== '1') mismatchCount2++;\n        } else {\n            if (s[i] !== '1') mismatchCount1++;\n            if (s[i] !== '0') mismatchCount2++;\n}\n    }\n\n    return Math.min(mismatchCount1, mismatchCount2) / 2;\n}\n```\n\n    \n    1. Count the number of zeros and ones.\n2. If the absolute difference between zeros and ones is greater than 1, it's impossible to create an alternating string, return -1.\n3. Initialize two mismatch counts to count the number of mismatches assuming either that the first character is '0' or '1'.\n4. Loop through the string and increment the mismatch counts accordingly.\n5. The minimum number of swaps is the minimum of the mismatch counts divided by 2 because each swap corrects two mismatched characters.\n    "}
