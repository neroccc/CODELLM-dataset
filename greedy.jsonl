{"id": 11, "slug": "container-with-most-water", "title": "Container With Most Water", "difficulty": null, "content": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn _the maximum amount of water a container can store_.\n\n**Notice** that you may not slant the container.\n\n**Example 1:**\n\n**Input:** height = \\[1,8,6,2,5,4,8,3,7\\]\n**Output:** 49\n**Explanation:** The above vertical lines are represented by array \\[1,8,6,2,5,4,8,3,7\\]. In this case, the max area of water (blue section) the container can contain is 49.\n\n**Example 2:**\n\n**Input:** height = \\[1,1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `n == height.length`\n*   `2 <= n <= 105`\n*   `0 <= height[i] <= 104`", "java": "\n    ```java\npublic int maxArea(int[] height) {\n    int max_area = 0, left = 0, right = height.length - 1;\n    while (left < right) {\n        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    ", "c++": "\n    ```cpp\nint maxArea(vector<int>& height) {\n    int max_area = 0, left = 0, right = height.size() - 1;\n    while (left < right) {\n        max_area = max(max_area, min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    ", "python": "\n    ```python\ndef max_area(height):\n    max_area, left, right = 0, 0, len(height) - 1\n    while left < right:\n        max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    ", "javascript": "\n    ```javascript\nfunction maxArea(height) {\n    let max_area = 0, left = 0, right = height.length - 1;\n    while (left < right) {\n        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    "}
{"id": 44, "slug": "wildcard-matching", "title": "Wildcard Matching", "difficulty": "Hard", "content": "Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n*   `'?'` Matches any single character.\n*   `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the **entire** input string (not partial).\n\n**Example 1:**\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n\n**Example 2:**\n\n**Input:** s =  \"aa \", p =  \"\\* \"\n**Output:** true\n**Explanation:** '\\*' matches any sequence.\n\n**Example 3:**\n\n**Input:** s =  \"cb \", p =  \"?a \"\n**Output:** false\n**Explanation:** '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n\n**Constraints:**\n\n*   `0 <= s.length, p.length <= 2000`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'?'` or `'*'`.", "java": "\n    ```java\npublic boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    int i = 0, j = 0, asterisk = -1, match = 0;\n    while (i < m) {\n        if (j < n && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {\n            i++; j++;\n        } else if (j < n && p.charAt(j) == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk != -1) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p.charAt(j) == '*') j++;\n    return j == n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ", "c++": "\n    ```cpp\nbool isMatch(const std::string& s, const std::string& p) {\n    int m = s.size(), n = p.size();\n    int i = 0, j = 0, asterisk = -1, match;\n    while (i < m) {\n        if (j < n && (s[i] == p[j] || p[j] == '?')) {\n            i++; j++;\n        } else if (j < n && p[j] == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] == '*') j++;\n    return j == n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ", "python": "\n    ```python\ndef is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    i = j = 0\n    match = asterisk = -1\n    while i < m:\n        if j < n and (s[i] == p[j] or p[j] == '?'):\n            i, j = i + 1, j + 1\n        elif j < n and p[j] == '*':\n            match, asterisk = i, j\n            j += 1\n        elif asterisk >= 0:\n            i, j = match + 1, asterisk + 1\n            match += 1\n        else:\n            return False\n    while j < n and p[j] == '*':\n        j += 1\n    return j == n\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ", "javascript": "\n    ```javascript\nfunction isMatch(s, p) {\n    let m = s.length,\n        n = p.length;\n    let i = 0,\n        j = 0,\n        asterisk = -1,\n        match = 0;\n    while (i < m) {\n        if (j < n && (s[i] === p[j] || p[j] === '?')) {\n            i++;\n            j++;\n        } else if (j < n && p[j] === '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] === '*') j++;\n    return j === n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    "}
{"id": 45, "slug": "jump-game-ii", "title": "Jump Game II", "difficulty": "Medium", "content": "You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.\n\nEach element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:\n\n*   `0 <= j <= nums[i]` and\n*   `i + j < n`\n\nReturn _the minimum number of jumps to reach_ `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,1,1,4\\]\n**Output:** 2\n**Explanation:** The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n**Example 2:**\n\n**Input:** nums = \\[2,3,0,1,4\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 1000`\n*   It's guaranteed that you can reach `nums[n - 1]`.", "java": "\n    ```java\npublic int jump(int[] nums) {\n    int jumps = 0, currentEnd = 0, currentFarthest = 0;\n    \n    for (int i = 0; i < nums.length - 1; i++) {\n        currentFarthest = Math.max(currentFarthest, i + nums[i]);\n        if (i == currentEnd) {\n            jumps++;\n            currentEnd = currentFarthest;\n        }\n    }\n    return jumps;\n}\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ", "c++": "\n    ```cpp\nint jump(vector<int>& nums) {\n    int jumps = 0, current_end = 0, current_farthest = 0;\n    \n    for (int i = 0; i < nums.size() - 1; i++) {\n        current_farthest = max(current_farthest, i + nums[i]);\n        if (i == current_end) {\n            jumps++;\n            current_end = current_farthest;\n        }\n    }\n    return jumps;\n}\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ", "python": "\n    ```python\ndef jump(nums):\n    jumps = 0\n    current_end = 0\n    current_farthest = 0\n\n    for i in range(len(nums) - 1):\n        current_farthest = max(current_farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = current_farthest\n\n    return jumps\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ", "javascript": "\n    ```javascript\nfunction jump(nums) {\n    let jumps = 0, currentEnd = 0, currentFarthest = 0;\n\n    for (let i = 0; i < nums.length - 1; i++) {\n        currentFarthest = Math.max(currentFarthest, i + nums[i]);\n        if (i === currentEnd) {\n            jumps++;\n            currentEnd = currentFarthest;\n        }\n    }\n    return jumps;\n}\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    "}
{"id": 55, "slug": "jump-game", "title": "Jump Game", "difficulty": "Medium", "content": "You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` _if you can reach the last index, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,1,1,4\\]\n**Output:** true\n**Explanation:** Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n**Example 2:**\n\n**Input:** nums = \\[3,2,1,0,4\\]\n**Output:** false\n**Explanation:** You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 105`", "java": "\n    ```java\npublic boolean canJump(int[] nums) {\n    int maxReach = 0;\n    for (int i = 0; i < nums.length; ++i) {\n        if (i > maxReach) return false;\n        maxReach = Math.max(maxReach, i + nums[i]);\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the `nums` array, keeping track of the maximum reachable index in `maxReach`. In each iteration, it compares the current index `i` with `maxReach`. If `i` is greater than `maxReach`, it means that the last index cannot be reached. Otherwise, it updates the `maxReach` by taking the maximum value between the current `maxReach` and the sum of the current index `i` and the value of `nums[i]`. If the end of iteration is reached, it means that the last index can be reached, so the function returns true.\n    ", "c++": "\n    ```cpp\nbool canJump(vector<int>& nums) {\n    int maxReach = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (i > maxReach) return false;\n        maxReach = max(maxReach, i + nums[i]);\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the `nums` array, keeping track of the maximum reachable index in `maxReach`. In each iteration, it compares the current index `i` with `maxReach`. If `i` is greater than `maxReach`, it means that the last index cannot be reached. Otherwise, it updates the `maxReach` by taking the maximum value between the current `maxReach` and the sum of the current index `i` and the value of `nums[i]`. If the end of iteration is reached, it means that the last index can be reached, so the function returns true.\n    ", "python": "\n    ```python\ndef canJump(nums):\n    max_reach = 0\n    for i, num in enumerate(nums):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + num)\n    return True\n```\n    \n    The algorithm iterates through the `nums` array, keeping track of the maximum reachable index in `maxReach`. In each iteration, it compares the current index `i` with `maxReach`. If `i` is greater than `maxReach`, it means that the last index cannot be reached. Otherwise, it updates the `maxReach` by taking the maximum value between the current `maxReach` and the sum of the current index `i` and the value of `nums[i]`. If the end of iteration is reached, it means that the last index can be reached, so the function returns true.\n    ", "javascript": "\n    ```javascript\nfunction canJump(nums) {\n    let maxReach = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        if (i > maxReach) return false;\n        maxReach = Math.max(maxReach, i + nums[i]);\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the `nums` array, keeping track of the maximum reachable index in `maxReach`. In each iteration, it compares the current index `i` with `maxReach`. If `i` is greater than `maxReach`, it means that the last index cannot be reached. Otherwise, it updates the `maxReach` by taking the maximum value between the current `maxReach` and the sum of the current index `i` and the value of `nums[i]`. If the end of iteration is reached, it means that the last index can be reached, so the function returns true.\n    "}
{"id": 122, "slug": "best-time-to-buy-and-sell-stock-ii", "title": "Best Time to Buy and Sell Stock II", "difficulty": "Medium", "content": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\n\nFind and return _the **maximum** profit you can achieve_.\n\n**Example 1:**\n\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n**Example 3:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n**Constraints:**\n\n*   `1 <= prices.length <= 3 * 104`\n*   `0 <= prices[i] <= 104`", "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int max_profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ", "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int max_profit = 0;\n    for (int i = 1; i < prices.size(); i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ", "python": "\n    ```python\ndef max_profit(prices):\n    max_profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            max_profit += prices[i] - prices[i - 1]\n    return max_profit\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ", "javascript": "\n    ```javascript\nfunction maxProfit(prices) {\n    let max_profit = 0;\n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    "}
{"id": 134, "slug": "gas-station", "title": "Gas Station", "difficulty": "Medium", "content": "There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays `gas` and `cost`, return _the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return_ `-1`. If there exists a solution, it is **guaranteed** to be **unique**\n\n**Example 1:**\n\n**Input:** gas = \\[1,2,3,4,5\\], cost = \\[3,4,5,1,2\\]\n**Output:** 3\n**Explanation:**\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n\n**Example 2:**\n\n**Input:** gas = \\[2,3,4\\], cost = \\[3,4,3\\]\n**Output:** -1\n**Explanation:**\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\n\n**Constraints:**\n\n*   `n == gas.length == cost.length`\n*   `1 <= n <= 105`\n*   `0 <= gas[i], cost[i] <= 104`", "java": "\n    ```java\npublic int canCompleteCircuit(int[] gas, int[] cost) {\n    int totalGas = 0, totalCost = 0, start = 0, gasTank = 0;\n    for (int i = 0; i < gas.length; i++) {\n        totalGas += gas[i];\n        totalCost += cost[i];\n        gasTank += gas[i] - cost[i];\n        if (gasTank < 0) {\n            start = i + 1;\n            gasTank = 0;\n        }\n    }\n    return (totalGas < totalCost) ? -1 : start;\n}\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    ", "c++": "\n    ```cpp\nint can_complete_circuit(vector<int>& gas, vector<int>& cost) {\n    int total_gas = 0, total_cost = 0, start = 0, gas_tank = 0;\n    for (int i = 0; i < gas.size(); ++i) {\n        total_gas += gas[i];\n        total_cost += cost[i];\n        gas_tank += gas[i] - cost[i];\n        if (gas_tank < 0) {\n            start = i + 1;\n            gas_tank = 0;\n        }\n    }\n    return (total_gas < total_cost) ? -1 : start;\n}\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    ", "python": "\n    ```python\ndef can_complete_circuit(gas, cost):\n    total_gas, total_cost, start, gas_tank = 0, 0, 0, 0\n    for i in range(len(gas)):\n        total_gas += gas[i]\n        total_cost += cost[i]\n        gas_tank += gas[i] - cost[i]\n        if gas_tank < 0:\n            start = i + 1\n            gas_tank = 0\n    return -1 if total_gas < total_cost else start\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    ", "javascript": "\n    ```javascript\nfunction canCompleteCircuit(gas, cost) {\n    let totalGas = 0, totalCost = 0, start = 0, gasTank = 0;\n    for (let i = 0; i < gas.length; i++) {\n        totalGas += gas[i];\n        totalCost += cost[i];\n        gasTank += gas[i] - cost[i];\n        if (gasTank < 0) {\n            start = i + 1;\n            gasTank = 0;\n        }\n    }\n    return (totalGas < totalCost) ? -1 : start;\n}\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    "}
{"id": 135, "slug": "candy", "title": "Candy", "difficulty": "Hard", "content": "There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.\n\nYou are giving candies to these children subjected to the following requirements:\n\n*   Each child must have at least one candy.\n*   Children with a higher rating get more candies than their neighbors.\n\nReturn _the minimum number of candies you need to have to distribute the candies to the children_.\n\n**Example 1:**\n\n**Input:** ratings = \\[1,0,2\\]\n**Output:** 5\n**Explanation:** You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\n**Example 2:**\n\n**Input:** ratings = \\[1,2,2\\]\n**Output:** 4\n**Explanation:** You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n\n**Constraints:**\n\n*   `n == ratings.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= ratings[i] <= 2 * 104`", "java": "\n    ```java\npublic int minCandies(int[] ratings) {\n    int n = ratings.length;\n    int[] candies = new int[n];\n    for (int i = 0; i < n; i++) candies[i] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (int i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    int sum = 0;\n    for (int candy : candies) sum += candy;\n\n    return sum;\n}\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint minCandies(vector<int>& ratings) {\n    int n = ratings.size();\n    vector<int> candies(n, 1);\n\n    for(int i = 1; i < n; i++) {\n        if(ratings[i] > ratings[i-1]) candies[i] = candies[i-1] + 1;\n    }\n    for(int i = n - 2; i >= 0; i--) {\n        if(ratings[i] > ratings[i+1]) candies[i] = max(candies[i], candies[i+1] + 1);\n    }\n\n    int sum = 0;\n    for(int candy : candies) sum += candy;\n\n    return sum;\n}\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ", "python": "\n    ```python\ndef min_candies(ratings):\n    n = len(ratings)\n    candies = [1] * n\n\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n\n    return sum(candies)\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ", "javascript": "\n    ```javascript\nfunction minCandies(ratings) {\n    const n = ratings.length;\n    const candies = Array(n).fill(1);\n\n    for (let i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (let i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    return candies.reduce((a, b) => a + b, 0);\n}\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    "}
{"id": 179, "slug": "largest-number", "title": "Largest Number", "difficulty": "Medium", "content": "Given a list of non-negative integers `nums`, arrange them such that they form the largest number and return it.\n\nSince the result may be very large, so you need to return a string instead of an integer.\n\n**Example 1:**\n\n**Input:** nums = \\[10,2\\]\n**Output:**  \"210 \"\n\n**Example 2:**\n\n**Input:** nums = \\[3,30,34,5,9\\]\n**Output:**  \"9534330 \"\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 109`", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Solution {\n    public String largestNumber(int[] nums) {\n        String[] strNums = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            strNums[i] = String.valueOf(nums[i]);\n        }\n        Arrays.sort(strNums, (a, b) -> (b + a).compareTo(a + b));\n        if (strNums[0].equals(\"0\")) {\n            return \"0\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (String str : strNums) sb.append(str);\n        return sb.toString();\n    }\n}\n```\n    \n    1. Convert all integers to strings.\n2. Sort the strings using a custom comparator. The comparator shall compare concatenation of two strings in reverse order, i.e., a+b and b+a. Compare a+b and b+a, if a+b is larger, it means a should be before b, else b should before a.\n3. Join sorted strings to form the answer. If the first string is '0', return '0' as that means all elements are '0' (as strings are sorted).\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <string>\n#include <vector>\n\nbool compare(std::string a, std::string b) {\n    return a+b > b+a;\n}\n\nstd::string largestNumber(std::vector<int>& nums) {\n    std::vector<std::string> asStrs;\n    for (int num : nums) asStrs.push_back(std::to_string(num));\n    std::sort(asStrs.begin(), asStrs.end(), compare);\n    std::string res;\n    for (std::string s: asStrs) res += s;\n    return res[0] == '0' ? \"0\" : res;\n}\n```\n    \n    1. Convert all integers to strings.\n2. Sort the strings using a custom comparator. The comparator shall compare concatenation of two strings in reverse order, i.e., a+b and b+a. Compare a+b and b+a, if a+b is larger, it means a should be before b, else b should before a.\n3. Join sorted strings to form the answer. If the first string is '0', return '0' as that means all elements are '0' (as strings are sorted).\n    ", "python": "\n    ```python\nfrom functools import cmp_to_key\n\ndef largestNumber(nums):\n    def comparator(a, b):\n        return -1 if a + b > b + a else int(a + b < b + a)\n\n    nums_as_str = list(map(str, nums))\n    nums_as_str.sort(key=cmp_to_key(comparator))\n    return '0' if nums_as_str[0] == \"0\" else \"\".join(nums_as_str)\n```\n    \n    1. Convert all integers to strings.\n2. Sort the strings using a custom comparator. The comparator shall compare concatenation of two strings in reverse order, i.e., a+b and b+a. Compare a+b and b+a, if a+b is larger, it means a should be before b, else b should before a.\n3. Join sorted strings to form the answer. If the first string is '0', return '0' as that means all elements are '0' (as strings are sorted).\n    ", "javascript": "\n    ```javascript\nfunction largestNumber(nums) {\n    const numsAsStrings = nums.map(String);\n    numsAsStrings.sort((a, b) => (b + a).localeCompare(a + b));\n    return numsAsStrings[0] === '0' ? '0' : numsAsStrings.join('');\n}\n```\n    \n    1. Convert all integers to strings.\n2. Sort the strings using a custom comparator. The comparator shall compare concatenation of two strings in reverse order, i.e., a+b and b+a. Compare a+b and b+a, if a+b is larger, it means a should be before b, else b should before a.\n3. Join sorted strings to form the answer. If the first string is '0', return '0' as that means all elements are '0' (as strings are sorted).\n    "}
{"id": 253, "slug": "meeting-rooms-ii", "title": "Meeting Rooms II", "difficulty": "Medium", "content": "Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of conference rooms required_.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[0,30\\],\\[5,10\\],\\[15,20\\]\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[7,10\\],\\[2,4\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 104`\n*   `0 <= starti < endi <= 106`", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic int minMeetingRooms(int[][] intervals) {\n    if (intervals == null || intervals.length == 0) return 0;\n    \n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    \n    minHeap.add(intervals[0][1]);\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= minHeap.peek()) {\n            minHeap.poll();\n        }\n        minHeap.add(intervals[i][1]);\n    }\n    \n    return minHeap.size();\n}\n```\n    \n    1. Sort the intervals by their start times.\n2. Initialize a min-heap to store the end times of the intervals.\n3. Iterate through the sorted intervals.\n   - If the start time of the current interval is greater than or equal to the minimum end time in the heap, it means the meeting room is available, so remove the minimum end time.\n   - Add the end time of the current interval to the heap.\n4. The size of the heap represents the minimum number of meeting rooms required.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nint minMeetingRooms(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return 0;\n\n    std::sort(intervals.begin(), intervals.end(),\n              [](const std::vector<int>& a, const std::vector<int>& b) { return a[0] < b[0]; });\n\n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;\n    min_heap.push(intervals[0][1]);\n\n    for (int i = 1; i < intervals.size(); i++) {\n        if (intervals[i][0] >= min_heap.top()) {\n            min_heap.pop();\n        }\n        min_heap.push(intervals[i][1]);\n    }\n\n    return min_heap.size();\n}\n```\n    \n    1. Sort the intervals by their start times.\n2. Initialize a min-heap to store the end times of the intervals.\n3. Iterate through the sorted intervals.\n   - If the start time of the current interval is greater than or equal to the minimum end time in the heap, it means the meeting room is available, so remove the minimum end time.\n   - Add the end time of the current interval to the heap.\n4. The size of the heap represents the minimum number of meeting rooms required.\n    ", "python": "\n    ```python\nimport heapq\n\ndef minMeetingRooms(intervals):\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n\n    min_heap = [intervals[0][1]]\n    for start, end in intervals[1:]:\n        if start >= min_heap[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, end)\n\n    return len(min_heap)\n```\n    \n    1. Sort the intervals by their start times.\n2. Initialize a min-heap to store the end times of the intervals.\n3. Iterate through the sorted intervals.\n   - If the start time of the current interval is greater than or equal to the minimum end time in the heap, it means the meeting room is available, so remove the minimum end time.\n   - Add the end time of the current interval to the heap.\n4. The size of the heap represents the minimum number of meeting rooms required.\n    ", "javascript": "\n    ```javascript\nfunction minMeetingRooms(intervals) {\n    if (intervals.length === 0) return 0;\n\n    intervals.sort((a, b) => a[0] - b[0]);\n    const minHeap = [intervals[0][1]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= minHeap[0]) {\n            minHeap.shift();\n        }\n        minHeap.push(intervals[i][1]);\n        minHeap.sort((a, b) => a - b);\n    }\n\n    return minHeap.length;\n}\n```\n    \n    1. Sort the intervals by their start times.\n2. Initialize a min-heap to store the end times of the intervals.\n3. Iterate through the sorted intervals.\n   - If the start time of the current interval is greater than or equal to the minimum end time in the heap, it means the meeting room is available, so remove the minimum end time.\n   - Add the end time of the current interval to the heap.\n4. The size of the heap represents the minimum number of meeting rooms required.\n    "}
{"id": 280, "slug": "wiggle-sort", "title": "Wiggle Sort", "difficulty": "Medium", "content": "Given an integer array `nums`, reorder it such that `nums[0] <= nums[1] >= nums[2] <= nums[3]...`.\n\nYou may assume the input array always has a valid answer.\n\n**Example 1:**\n\n**Input:** nums = \\[3,5,2,1,6,4\\]\n**Output:** \\[3,5,1,6,2,4\\]\n**Explanation:** \\[1,6,2,5,3,4\\] is also accepted.\n\n**Example 2:**\n\n**Input:** nums = \\[6,6,5,6,3,8\\]\n**Output:** \\[6,6,5,6,3,8\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `0 <= nums[i] <= 104`\n*   It is guaranteed that there will be an answer for the given input `nums`.\n\n**Follow up:** Could you solve the problem in `O(n)` time complexity?", "java": "\n    ```java\npublic void wiggleSort(int[] nums) {\n    for (int i = 1; i < nums.length; i++) {\n        if (i % 2 == 0 && nums[i] > nums[i-1] || i % 2 == 1 && nums[i] < nums[i-1]) {\n            int temp = nums[i];\n            nums[i] = nums[i-1];\n            nums[i-1] = temp;\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the array from index 1 to the end. It checks whether the current element violates the wiggle condition. If the current index is even and the current element is greater than the previous element, or if the current index is odd and the current element is smaller than the previous element, it swaps the current and the previous element.\n    ", "c++": "\n    ```cpp\nvoid wiggleSort(vector<int>& nums) {\n    for (int i = 1; i < nums.size(); i++) {\n        if (i%2 == 0 && nums[i] > nums[i-1] || i%2 == 1 && nums[i] < nums[i-1]) {\n            swap(nums[i], nums[i-1]);\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the array from index 1 to the end. It checks whether the current element violates the wiggle condition. If the current index is even and the current element is greater than the previous element, or if the current index is odd and the current element is smaller than the previous element, it swaps the current and the previous element.\n    ", "python": "\n    ```python\ndef wiggleSort(nums):\n    for i in range(1, len(nums)):\n        if (i % 2 == 0 and nums[i] > nums[i-1]) or (i % 2 == 1 and nums[i] < nums[i-1]):\n            nums[i], nums[i-1] = nums[i-1], nums[i]\n```\n    \n    The algorithm iterates through the array from index 1 to the end. It checks whether the current element violates the wiggle condition. If the current index is even and the current element is greater than the previous element, or if the current index is odd and the current element is smaller than the previous element, it swaps the current and the previous element.\n    ", "javascript": "\n    ```javascript\nfunction wiggleSort(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        if (i % 2 === 0 && nums[i] > nums[i-1] || i % 2 === 1 && nums[i] < nums[i-1]) {\n            [nums[i], nums[i-1]] = [nums[i-1], nums[i]];\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the array from index 1 to the end. It checks whether the current element violates the wiggle condition. If the current index is even and the current element is greater than the previous element, or if the current index is odd and the current element is smaller than the previous element, it swaps the current and the previous element.\n    "}
{"id": 316, "slug": "remove-duplicate-letters", "title": "Remove Duplicate Letters", "difficulty": "Medium", "content": "Given a string `s`, remove duplicate letters so that every letter appears once and only once. You must make sure your result is **the smallest in lexicographical order** among all possible results.\n\n**Example 1:**\n\n**Input:** s =  \"bcabc \"\n**Output:**  \"abc \"\n\n**Example 2:**\n\n**Input:** s =  \"cbacdcbc \"\n**Output:**  \"acdb \"\n\n**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of lowercase English letters.\n\n**Note:** This question is the same as 1081: [https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/)", "java": "\n    ```java\nimport java.util.*;\n\npublic class Solution {\n    public String removeDuplicateLetters(String s) {\n        int[] count = new int[256];\n        boolean[] visited = new boolean[256];\n        Stack<Character> st = new Stack<>();\n        \n        for (char ch : s.toCharArray()) {\n            count[ch]++;\n        }\n        \n        for (char ch : s.toCharArray()) {\n            count[ch]--;\n            if (visited[ch]) continue;\n            while (!st.isEmpty() && ch < st.peek() && count[st.peek()] > 0) {\n                visited[st.pop()] = false;\n            }\n            st.push(ch);\n            visited[ch] = true;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        while (!st.empty()) {\n            result.append(st.pop());\n        }\n        return result.reverse().toString();\n    }\n}\n```\n    \n    1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nstring removeDuplicateLetters(string s) {\n    vector<int> count(256, 0);\n    vector<bool> visited(256, false);\n    stack<char> st;\n    \n    for (char ch : s) {\n        count[ch]++;\n    }\n    \n    for (char ch : s) {\n        count[ch]--;\n        if (visited[ch]) continue;\n        while (!st.empty() && ch < st.top() && count[st.top()] > 0) {\n            visited[st.top()] = false;\n            st.pop();\n        }\n        st.push(ch);\n        visited[ch] = true;\n    }\n    \n    string result = \"\";\n    while (!st.empty()) {\n        result = st.top() + result;\n        st.pop();\n    }\n    return result;\n}\n```\n    \n    1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string.\n    ", "python": "\n    ```python\ndef removeDuplicateLetters(s):\n    count = [0] * 256\n    visited = [False] * 256\n    st = []\n\n    for ch in s:\n        count[ord(ch)] += 1\n\n    for ch in s:\n        count[ord(ch)] -= 1\n        if visited[ord(ch)]:\n            continue\n        while st and ch < st[-1] and count[ord(st[-1])] > 0:\n            visited[ord(st.pop())] = False\n        st.append(ch)\n        visited[ord(ch)] = True\n\n    return \"\".join(st)   \n```\n    \n    1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string.\n    ", "javascript": "\n    ```javascript\nfunction removeDuplicateLetters(s) {\n    let count = new Array(256).fill(0);\n    let visited = new Array(256).fill(false);\n    let st = [];\n    \n    for (let ch of s) {\n        count[ch.charCodeAt(0)]++;\n    }\n    \n    for (let ch of s) {\n        count[ch.charCodeAt(0)]--;\n        if (visited[ch.charCodeAt(0)]) continue;\n        while (st.length > 0 && ch < st[st.length - 1] && count[st[st.length - 1].charCodeAt(0)] > 0) {\n            visited[st.pop().charCodeAt(0)] = false;\n        }\n        st.push(ch);\n        visited[ch.charCodeAt(0)] = true;\n    }\n\n    return st.join(\"\");\n}\n```\n    \n    1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string.\n    "}
{"id": 321, "slug": "create-maximum-number", "title": "Create Maximum Number", "difficulty": "Hard", "content": "You are given two integer arrays `nums1` and `nums2` of lengths `m` and `n` respectively. `nums1` and `nums2` represent the digits of two numbers. You are also given an integer `k`.\n\nCreate the maximum number of length `k <= m + n` from digits of the two numbers. The relative order of the digits from the same array must be preserved.\n\nReturn an array of the `k` digits representing the answer.\n\n**Example 1:**\n\n**Input:** nums1 = \\[3,4,6,5\\], nums2 = \\[9,1,2,5,8,3\\], k = 5\n**Output:** \\[9,8,6,5,3\\]\n\n**Example 2:**\n\n**Input:** nums1 = \\[6,7\\], nums2 = \\[6,0,4\\], k = 5\n**Output:** \\[6,7,6,0,4\\]\n\n**Example 3:**\n\n**Input:** nums1 = \\[3,9\\], nums2 = \\[8,9\\], k = 3\n**Output:** \\[9,8,9\\]\n\n**Constraints:**\n\n*   `m == nums1.length`\n*   `n == nums2.length`\n*   `1 <= m, n <= 500`\n*   `0 <= nums1[i], nums2[i] <= 9`\n*   `1 <= k <= m + n`", "java": "\n    \r\n```java\r\npublic int[] maxNumber(int[] nums1, int[] nums2, int k) {\r\n    int[] ans = new int[k];\r\n    int m = nums1.length, n = nums2.length;\r\n    \r\n    for (int i = Math.max(0, k - n); i <= k && i <= m; i++) {\r\n        int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\r\n        if (greater(candidate, 0, ans, 0)) ans = candidate;\r\n    }\r\n    return ans;\r\n}\r\n\r\nprivate int[] maxArray(int[] nums, int k) {\r\n    int n = nums.length;\r\n    int[] ans = new int[k];\r\n    for (int i = 0, j = 0; i < n; i++) {\r\n        while (n - i > k - j && j > 0 && ans[j - 1] < nums[i]) j--;\r\n        if (j < k) ans[j++] = nums[i];\r\n    }\r\n    return ans;\r\n}\r\n\r\nprivate int[] merge(int[] nums1, int[] nums2, int k) {\r\n    int[] ans = new int[k];\r\n    for (int i = 0, j = 0, r = 0; r < k; r++)\r\n        ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\r\n    return ans;\r\n}\r\n\r\nprivate boolean greater(int[] nums1, int i, int[] nums2, int j) {\r\n    while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\r\n        i++;\r\n        j++;\r\n    }\r\n    return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\r\n}\r\n```\r\n\r\n    \n    \r\nThe algorithm works by first finding the maximum subsequence of the required length from each input array while retaining their relative order. It then iterates through all possible combinations of subsequences of the two arrays (nums1 and nums2) with lengths summing to k, and merges them while preserving their element's relative order. During the merge, the algorithm always selects the maximum elements from the two arrays, giving preference to the first array if both elements are equal. Finally, the maximum array of length k is returned. \r\n    ", "c++": "\n    \r\n```cpp\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nstd::vector<int> maxNumber(std::vector<int>& nums1, std::vector<int>& nums2, int k) {\r\n    int m = nums1.size(), n = nums2.size();\r\n    std::vector<int> ans(k, 0);\r\n    for (int i = std::max(0, k - n); i <= k && i <= m; ++i) {\r\n        std::vector<int> candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\r\n        if (greater(candidate, 0, ans, 0)) ans = candidate;\r\n    }\r\n    return ans;\r\n}\r\n\r\nstd::vector<int> maxArray(std::vector<int>& nums, int k) {\r\n    int n = nums.size();\r\n    std::vector<int> ans(k, 0);\r\n    for (int i = 0, j = 0; i < n; ++i) {\r\n        while (n - i > k - j && j > 0 && ans[j - 1] < nums[i]) j--;\r\n        if (j < k) ans[j++] = nums[i];\r\n    }\r\n    return ans;\r\n}\r\n\r\nstd::vector<int> merge(std::vector<int>& nums1, std::vector<int>& nums2, int k) {\r\n    std::vector<int> ans(k, 0);\r\n    for (int i = 0, j = 0, r = 0; r < k; ++r)\r\n        ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\r\n    return ans;\r\n}\r\n\r\nbool greater(std::vector<int>& nums1, int i, std::vector<int>& nums2, int j) {\r\n    while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j]) {\r\n        i++;\r\n        j++;\r\n    }\r\n    return j == nums2.size() || (i < nums1.size() && nums1[i] > nums2[j]);\r\n}\r\n```\r\n\r\n    \n    \r\nThe algorithm works by first finding the maximum subsequence of the required length from each input array while retaining their relative order. It then iterates through all possible combinations of subsequences of the two arrays (nums1 and nums2) with lengths summing to k, and merges them while preserving their element's relative order. During the merge, the algorithm always selects the maximum elements from the two arrays, giving preference to the first array if both elements are equal. Finally, the maximum array of length k is returned. \r\n    ", "python": "\n    \r\n```javascript\r\nfunction maxNumber(nums1, nums2, k) {\r\n    function maxArray(nums, k) {\r\n        let ans = [];\r\n        for (let i = 0; i < nums.length; i++) {\r\n            while (nums.length - i > k - ans.length && ans.length && ans[ans.length - 1] < nums[i])\r\n                ans.pop();\r\n            if (ans.length < k) ans.push(nums[i]);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    function merge(nums1, nums2) {\r\n        let ans = [], i = 0, j = 0;\r\n        while (i < nums1.length || j < nums2.length)\r\n            ans.push((nums1.slice(i).join('') >= nums2.slice(j).join('') ? nums1[i++] : nums2[j++]));\r\n        return ans;\r\n    }\r\n\r\n    let result = [];\r\n    for (let i = Math.max(0, k - nums2.length); i <= k && i <= nums1.length; i++) {\r\n        const candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i));\r\n        if (candidate.join('') > result.join('')) result = candidate;\r\n    }\r\n    return result;\r\n}\r\n```\r\n\r\n    \n    \r\nThe algorithm works by first finding the maximum subsequence of the required length from each input array while retaining their relative order. It then iterates through all possible combinations of subsequences of the two arrays (nums1 and nums2) with lengths summing to k, and merges them while preserving their element's relative order. During the merge, the algorithm always selects the maximum elements from the two arrays, giving preference to the first array if both elements are equal. Finally, the maximum array of length k is returned. \r\n    ", "javascript": "\n    \r\n```python\r\ndef maxNumber(nums1, nums2, k):\r\n    def maxArray(nums, k):\r\n        ans = []\r\n        for i, num in enumerate(nums):\r\n            while len(ans) + len(nums) - i > k and ans and ans[-1] < num:\r\n                ans.pop()\r\n            if len(ans) < k:\r\n                ans.append(num)\r\n        return ans\r\n\r\n    def merge(nums1, nums2):\r\n        return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]\r\n\r\n    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))\r\n               for i in range(k + 1)\r\n               if i <= len(nums1) and k - i <= len(nums2))\r\n```\r\n\r\n    \n    \r\nThe algorithm works by first finding the maximum subsequence of the required length from each input array while retaining their relative order. It then iterates through all possible combinations of subsequences of the two arrays (nums1 and nums2) with lengths summing to k, and merges them while preserving their element's relative order. During the merge, the algorithm always selects the maximum elements from the two arrays, giving preference to the first array if both elements are equal. Finally, the maximum array of length k is returned. \r\n    "}
{"id": 324, "slug": "wiggle-sort-ii", "title": "Wiggle Sort II", "difficulty": "Medium", "content": "Given an integer array `nums`, reorder it such that `nums[0] < nums[1] > nums[2] < nums[3]...`.\n\nYou may assume the input array always has a valid answer.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,1,1,6,4\\]\n**Output:** \\[1,6,1,5,1,4\\]\n**Explanation:** \\[1,4,1,5,1,6\\] is also accepted.\n\n**Example 2:**\n\n**Input:** nums = \\[1,3,2,2,3,1\\]\n**Output:** \\[2,3,1,3,1,2\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `0 <= nums[i] <= 5000`\n*   It is guaranteed that there will be an answer for the given input `nums`.\n\n**Follow Up:** Can you do it in `O(n)` time and/or **in-place** with `O(1)` extra space?", "java": "\n    ```java\nimport java.util.Arrays;\npublic void wiggleSort(int[] nums) {\n    Arrays.sort(nums);\n    for (int i = 1; i < nums.length - 1; i += 2) {\n        int temp = nums[i];\n        nums[i] = nums[i + 1];\n        nums[i + 1] = temp;\n    }\n}\n```\n\n    \n    1. First, sort the array in ascending order. This step ensures that the smaller element is always before the larger element in the sorted array.\n2. Iterate through the sorted array, starting from the second element (index 1) and incrementing by 2 so that the iteration only impacts every other element.\n3. Swap the current element with the next element in the array during the iteration. This will make the current element greater than its neighbors, fulfilling the requirements of the wiggle sort.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\nvoid wiggleSort(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    for (int i = 1; i < nums.size() - 1; i += 2) {\n        swap(nums[i], nums[i + 1]);\n    }\n}\n```\n\n    \n    1. First, sort the array in ascending order. This step ensures that the smaller element is always before the larger element in the sorted array.\n2. Iterate through the sorted array, starting from the second element (index 1) and incrementing by 2 so that the iteration only impacts every other element.\n3. Swap the current element with the next element in the array during the iteration. This will make the current element greater than its neighbors, fulfilling the requirements of the wiggle sort.\n    ", "python": "\n    ```python\ndef wiggleSort(nums):\n    nums.sort()\n    for i in range(1, len(nums) - 1, 2):\n        nums[i], nums[i + 1] = nums[i + 1], nums[i]\n```\n\n    \n    1. First, sort the array in ascending order. This step ensures that the smaller element is always before the larger element in the sorted array.\n2. Iterate through the sorted array, starting from the second element (index 1) and incrementing by 2 so that the iteration only impacts every other element.\n3. Swap the current element with the next element in the array during the iteration. This will make the current element greater than its neighbors, fulfilling the requirements of the wiggle sort.\n    ", "javascript": "\n    ```javascript\nfunction wiggleSort(nums) {\n    nums.sort((a, b) => a - b);\n    for (let i = 1; i < nums.length - 1; i += 2) {\n        [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    }\n}\n```\n\n    \n    1. First, sort the array in ascending order. This step ensures that the smaller element is always before the larger element in the sorted array.\n2. Iterate through the sorted array, starting from the second element (index 1) and incrementing by 2 so that the iteration only impacts every other element.\n3. Swap the current element with the next element in the array during the iteration. This will make the current element greater than its neighbors, fulfilling the requirements of the wiggle sort.\n    "}
{"id": 330, "slug": "patching-array", "title": "Patching Array", "difficulty": "Hard", "content": "Given a sorted integer array `nums` and an integer `n`, add/patch elements to the array such that any number in the range `[1, n]` inclusive can be formed by the sum of some elements in the array.\n\nReturn _the minimum number of patches required_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,3\\], n = 6\n**Output:** 1\nExplanation:\nCombinations of nums are \\[1\\], \\[3\\], \\[1,3\\], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: \\[1\\], \\[2\\], \\[3\\], \\[1,3\\], \\[2,3\\], \\[1,2,3\\].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range \\[1, 6\\].\nSo we only need 1 patch.\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,10\\], n = 20\n**Output:** 2\nExplanation: The two patches can be \\[2, 4\\].\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,2\\], n = 5\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 104`\n*   `nums` is sorted in **ascending order**.\n*   `1 <= n <= 231 - 1`", "java": "\n    ```java\npublic int minPatches(int[] nums, int n) {\n    long maxSum = 0;\n    int patches = 0, i = 0;\n    \n    while (maxSum < n) {\n        if (i < nums.length && nums[i] <= maxSum + 1) {\n            maxSum += nums[i];\n            i++;\n        } else {\n            maxSum += maxSum + 1;\n            patches++;\n        }\n    }\n    return patches;\n}\n```\n    \n    The algorithm maintains a variable `maxSum` which stores the maximum sum that can be obtained using the current elements in the nums array. Initially, `maxSum` is set to 0, and we iterate through the array until `maxSum` is greater than or equal to the given `n`.\n\nDuring the iteration, if the current element (nums[i]) is less than or equal to `maxSum + 1`, we can extend our sum range by updating `maxSum += nums[i]`. This means that the current element can be used to form a sum in the target range.\n\nHowever, if the current nums[i] is greater than `maxSum + 1`, a patch would be needed. To minimize the number of patches, the best element to add would be `maxSum + 1`, as it extends the current maxSum twice as much without gaps. So, we update `maxSum += maxSum + 1`, and increment the patches count.\n\nWe repeat this process until `maxSum` reaches or exceeds the given `n`. Finally, we return the number of patches used.\n    ", "c++": "\n    ```cpp\nint minPatches(vector<int>& nums, int n) {\n    long long maxSum = 0;\n    int patches = 0, i = 0;\n    \n    while (maxSum < n) {\n        if (i < nums.size() && nums[i] <= maxSum + 1) {\n            maxSum += nums[i];\n            i++;\n        } else {\n            maxSum += maxSum + 1;\n            patches++;\n        }\n    }\n    return patches;\n}\n```\n    \n    The algorithm maintains a variable `maxSum` which stores the maximum sum that can be obtained using the current elements in the nums array. Initially, `maxSum` is set to 0, and we iterate through the array until `maxSum` is greater than or equal to the given `n`.\n\nDuring the iteration, if the current element (nums[i]) is less than or equal to `maxSum + 1`, we can extend our sum range by updating `maxSum += nums[i]`. This means that the current element can be used to form a sum in the target range.\n\nHowever, if the current nums[i] is greater than `maxSum + 1`, a patch would be needed. To minimize the number of patches, the best element to add would be `maxSum + 1`, as it extends the current maxSum twice as much without gaps. So, we update `maxSum += maxSum + 1`, and increment the patches count.\n\nWe repeat this process until `maxSum` reaches or exceeds the given `n`. Finally, we return the number of patches used.\n    ", "python": "\n    ```python\ndef minPatches(nums, n):\n    max_sum = 0\n    patches = 0\n    i = 0\n\n    while max_sum < n:\n        if i < len(nums) and nums[i] <= max_sum + 1:\n            max_sum += nums[i]\n            i += 1\n        else:\n            max_sum += max_sum + 1\n            patches += 1\n\n    return patches\n```\n\n    \n    The algorithm maintains a variable `maxSum` which stores the maximum sum that can be obtained using the current elements in the nums array. Initially, `maxSum` is set to 0, and we iterate through the array until `maxSum` is greater than or equal to the given `n`.\n\nDuring the iteration, if the current element (nums[i]) is less than or equal to `maxSum + 1`, we can extend our sum range by updating `maxSum += nums[i]`. This means that the current element can be used to form a sum in the target range.\n\nHowever, if the current nums[i] is greater than `maxSum + 1`, a patch would be needed. To minimize the number of patches, the best element to add would be `maxSum + 1`, as it extends the current maxSum twice as much without gaps. So, we update `maxSum += maxSum + 1`, and increment the patches count.\n\nWe repeat this process until `maxSum` reaches or exceeds the given `n`. Finally, we return the number of patches used.\n    ", "javascript": "\n    ```javascript\nfunction minPatches(nums, n) {\n    let maxSum = 0;\n    let patches = 0;\n    let i = 0;\n\n    while (maxSum < n) {\n        if (i < nums.length && nums[i] <= maxSum + 1) {\n            maxSum += nums[i];\n            i++;\n        } else {\n            maxSum += maxSum + 1;\n            patches++;\n        }\n    }\n    return patches;\n}\n```\n\n    \n    The algorithm maintains a variable `maxSum` which stores the maximum sum that can be obtained using the current elements in the nums array. Initially, `maxSum` is set to 0, and we iterate through the array until `maxSum` is greater than or equal to the given `n`.\n\nDuring the iteration, if the current element (nums[i]) is less than or equal to `maxSum + 1`, we can extend our sum range by updating `maxSum += nums[i]`. This means that the current element can be used to form a sum in the target range.\n\nHowever, if the current nums[i] is greater than `maxSum + 1`, a patch would be needed. To minimize the number of patches, the best element to add would be `maxSum + 1`, as it extends the current maxSum twice as much without gaps. So, we update `maxSum += maxSum + 1`, and increment the patches count.\n\nWe repeat this process until `maxSum` reaches or exceeds the given `n`. Finally, we return the number of patches used.\n    "}
{"id": 334, "slug": "increasing-triplet-subsequence", "title": "Increasing Triplet Subsequence", "difficulty": "Medium", "content": "Given an integer array `nums`, return `true` _if there exists a triple of indices_ `(i, j, k)` _such that_ `i < j < k` _and_ `nums[i] < nums[j] < nums[k]`. If no such indices exists, return `false`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5\\]\n**Output:** true\n**Explanation:** Any triplet where i < j < k is valid.\n\n**Example 2:**\n\n**Input:** nums = \\[5,4,3,2,1\\]\n**Output:** false\n**Explanation:** No triplet exists.\n\n**Example 3:**\n\n**Input:** nums = \\[2,1,5,0,4,6\\]\n**Output:** true\n**Explanation:** The triplet (3, 4, 5) is valid because nums\\[3\\] == 0 < nums\\[4\\] == 4 < nums\\[5\\] == 6.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5 * 105`\n*   `-231 <= nums[i] <= 231 - 1`\n\n**Follow up:** Could you implement a solution that runs in `O(n)` time complexity and `O(1)` space complexity?", "java": "\n    ```java\npublic boolean findTriplets(int[] nums) {\n    int first = Integer.MAX_VALUE;\n    int second = Integer.MAX_VALUE;\n\n    for (int num : nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    We use a greedy algorithm here. We keep track of two variables: `first` and `second`. `first` is initialized to the maximum integer value supported by the language. Similarly, `second` is initialized to the max integer value.\n\nWe iterate through the given array `nums`. If the current value is less than or equal to `first`, then we update `first` to be the current value. This helps us find the smallest value in the array. If the current value is not less than `first` but is less than or equal to `second`, we update `second` to be the current value. This helps us find the second smallest value, whose position is strictly greater than the position of `first`.\n\nNow, during iteration, if we find any value that is greater than `second`, then we return `true`, as we have found three indices such that they satisfy the given condition.\n\nIf we iterate through the entire array and don't find a value that is greater than `second`, we return `false`. This means that we couldn't find a triplet satisfying the given condition.\n\nThis greedy algorithm runs in O(n) time complexity, as we iterate through the array once.\n    ", "c++": "\n    ```cpp\nbool findTriplets(vector<int>& nums) {\n    int first = INT_MAX, second = INT_MAX;\n\n    for (int num : nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    We use a greedy algorithm here. We keep track of two variables: `first` and `second`. `first` is initialized to the maximum integer value supported by the language. Similarly, `second` is initialized to the max integer value.\n\nWe iterate through the given array `nums`. If the current value is less than or equal to `first`, then we update `first` to be the current value. This helps us find the smallest value in the array. If the current value is not less than `first` but is less than or equal to `second`, we update `second` to be the current value. This helps us find the second smallest value, whose position is strictly greater than the position of `first`.\n\nNow, during iteration, if we find any value that is greater than `second`, then we return `true`, as we have found three indices such that they satisfy the given condition.\n\nIf we iterate through the entire array and don't find a value that is greater than `second`, we return `false`. This means that we couldn't find a triplet satisfying the given condition.\n\nThis greedy algorithm runs in O(n) time complexity, as we iterate through the array once.\n    ", "python": "\n    ```python\ndef findTriplets(nums: List[int]) -> bool:\n    first = float('inf')\n    second = float('inf')\n\n    for num in nums:\n        if num <= first:\n            first = num\n        elif num <= second:\n            second = num\n        else:\n            return True\n    return False\n```\n    \n    We use a greedy algorithm here. We keep track of two variables: `first` and `second`. `first` is initialized to the maximum integer value supported by the language. Similarly, `second` is initialized to the max integer value.\n\nWe iterate through the given array `nums`. If the current value is less than or equal to `first`, then we update `first` to be the current value. This helps us find the smallest value in the array. If the current value is not less than `first` but is less than or equal to `second`, we update `second` to be the current value. This helps us find the second smallest value, whose position is strictly greater than the position of `first`.\n\nNow, during iteration, if we find any value that is greater than `second`, then we return `true`, as we have found three indices such that they satisfy the given condition.\n\nIf we iterate through the entire array and don't find a value that is greater than `second`, we return `false`. This means that we couldn't find a triplet satisfying the given condition.\n\nThis greedy algorithm runs in O(n) time complexity, as we iterate through the array once.\n    ", "javascript": "\n    ```javascript\nfunction findTriplets(nums) {\n    let first = Number.MAX_VALUE;\n    let second = Number.MAX_VALUE;\n\n    for (let num of nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    We use a greedy algorithm here. We keep track of two variables: `first` and `second`. `first` is initialized to the maximum integer value supported by the language. Similarly, `second` is initialized to the max integer value.\n\nWe iterate through the given array `nums`. If the current value is less than or equal to `first`, then we update `first` to be the current value. This helps us find the smallest value in the array. If the current value is not less than `first` but is less than or equal to `second`, we update `second` to be the current value. This helps us find the second smallest value, whose position is strictly greater than the position of `first`.\n\nNow, during iteration, if we find any value that is greater than `second`, then we return `true`, as we have found three indices such that they satisfy the given condition.\n\nIf we iterate through the entire array and don't find a value that is greater than `second`, we return `false`. This means that we couldn't find a triplet satisfying the given condition.\n\nThis greedy algorithm runs in O(n) time complexity, as we iterate through the array once.\n    "}
{"id": 358, "slug": "rearrange-string-k-distance-apart", "title": "Rearrange String k Distance Apart", "difficulty": "Hard", "content": "Given a string `s` and an integer `k`, rearrange `s` such that the same characters are **at least** distance `k` from each other. If it is not possible to rearrange the string, return an empty string `\" \"`.\n\n**Example 1:**\n\n**Input:** s =  \"aabbcc \", k = 3\n**Output:**  \"abcabc \"\n**Explanation:** The same letters are at least a distance of 3 from each other.\n\n**Example 2:**\n\n**Input:** s =  \"aaabc \", k = 3\n**Output:**  \" \"\n**Explanation:** It is not possible to rearrange the string.\n\n**Example 3:**\n\n**Input:** s =  \"aaadbbcc \", k = 2\n**Output:**  \"abacabcd \"\n**Explanation:** The same letters are at least a distance of 2 from each other.\n\n**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consists of only lowercase English letters.\n*   `0 <= k <= s.length`", "java": "\n    ```java\nimport java.util.*;\n\npublic class Solution {\n    public String rearrangeString(String s, int k) {\n        if (k == 0) return s;\n\n        Map<Character, Integer> freqMap = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\n        }\n\n        PriorityQueue<Map.Entry<Character, Integer>> maxHeap =\n                new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\n        maxHeap.addAll(freqMap.entrySet());\n\n        StringBuilder result = new StringBuilder();\n        while (!maxHeap.isEmpty()) {\n            List<Map.Entry<Character, Integer>> temp = new ArrayList<>();\n\n            for (int i = 0; i < k && !maxHeap.isEmpty(); i++) {\n                Map.Entry<Character, Integer> curr = maxHeap.poll();\n\n                result.append(curr.getKey());\n                if (curr.getValue() - 1 > 0) {\n                    curr.setValue(curr.getValue() - 1);\n                    temp.add(curr);\n                }\n            }\n\n            maxHeap.addAll(temp);\n\n            if (maxHeap.isEmpty()) break;\n            if (result.length() < s.length()) {\n                int spaces = k - temp.size();\n                while (spaces-- > 0) result.append(\" \");\n            }\n        }\n\n        if (result.length() < s.length()) return \"\";\n        return result.toString();\n    }\n}\n```\n\n    \n    The algorithm involves the following steps:\n1. Calculate the frequency of each character in the input string `s`. Store it in a hash table (dictionary/map) `freq`.\n2. Build a max heap (priority queue) from the frequency table. The heap will be sorted based on the frequency values.\n3. While the max heap is not empty, pop the first `k` elements from the heap, where `k` is the minimum distance required between the same characters, and append the characters to the result string.\n4. If the frequency of the popped elements is greater than one, decrement their frequency and store them in a temporary list `temp`.\n5. After popping `k` elements, add them back to the max heap.\n6. If the max heap is empty, break the loop.\n7. If the length of the result string is less than the input string, append `k - temp.length` spaces.\n8. If the final result string length is less than the input string, return an empty string. Otherwise, return the result string.\n\nThis algorithm ensures that characters with the highest frequency are placed first in the result string followed by other characters, maintaining a distance of at least `k` between the same characters. If it's not possible to place characters at that distance, an empty string will be returned.\n    ", "c++": "\n    ```cpp\n#include <queue>\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nstring rearrangeString(string s, int k) {\n    if (k == 0) return s;\n    \n    unordered_map<char, int> freq;\n    for (char c : s) {\n        freq[c]++;\n    }\n    \n    priority_queue<pair<int, char>> max_heap;\n    for (const auto& kv : freq) {\n        max_heap.emplace(kv.second, kv.first);\n    }\n    \n    string result;\n    while (!max_heap.empty()) {\n        vector<pair<int, char>> temp;\n        \n        for (int i = 0; i < k && !max_heap.empty(); ++i) {\n            auto curr = max_heap.top();\n            max_heap.pop();\n            \n            result += curr.second;\n            if (--curr.first > 0) {\n                temp.push_back(curr);\n            }\n        }\n        \n        for (const auto& entry : temp) {\n            max_heap.push(entry);\n        }\n        \n        if (max_heap.empty()) break;\n        if (result.length() < s.length()) result.append(k - temp.size(), ' ');\n    }\n    \n    if (result.length() < s.length()) return \"\";\n    return result;\n}\n```\n\n    \n    The algorithm involves the following steps:\n1. Calculate the frequency of each character in the input string `s`. Store it in a hash table (dictionary/map) `freq`.\n2. Build a max heap (priority queue) from the frequency table. The heap will be sorted based on the frequency values.\n3. While the max heap is not empty, pop the first `k` elements from the heap, where `k` is the minimum distance required between the same characters, and append the characters to the result string.\n4. If the frequency of the popped elements is greater than one, decrement their frequency and store them in a temporary list `temp`.\n5. After popping `k` elements, add them back to the max heap.\n6. If the max heap is empty, break the loop.\n7. If the length of the result string is less than the input string, append `k - temp.length` spaces.\n8. If the final result string length is less than the input string, return an empty string. Otherwise, return the result string.\n\nThis algorithm ensures that characters with the highest frequency are placed first in the result string followed by other characters, maintaining a distance of at least `k` between the same characters. If it's not possible to place characters at that distance, an empty string will be returned.\n    ", "python": "\n    ```python\nimport heapq\nfrom collections import Counter\n\ndef rearrange_string(s, k):\n    if k == 0:\n        return s\n\n    counter = Counter(s)\n    max_heap = [(-count, char) for char, count in counter.items()]\n    heapq.heapify(max_heap)\n\n    result = []\n    while max_heap:\n        temp = []\n\n        for _ in range(k):\n            if not max_heap:\n                break\n\n            count, char = heapq.heappop(max_heap)\n            result.append(char)\n\n            if count + 1 < 0:\n                temp.append((count + 1, char))\n\n        for item in temp:\n            heapq.heappush(max_heap, item)\n\n        if not max_heap:\n            break\n\n        if len(result) < len(s):\n            result.extend([' '] * (k - len(temp)))\n\n    if len(result) < len(s):\n        return \"\"\n    return \"\".join(result)\n```\n\n    \n    The algorithm involves the following steps:\n1. Calculate the frequency of each character in the input string `s`. Store it in a hash table (dictionary/map) `freq`.\n2. Build a max heap (priority queue) from the frequency table. The heap will be sorted based on the frequency values.\n3. While the max heap is not empty, pop the first `k` elements from the heap, where `k` is the minimum distance required between the same characters, and append the characters to the result string.\n4. If the frequency of the popped elements is greater than one, decrement their frequency and store them in a temporary list `temp`.\n5. After popping `k` elements, add them back to the max heap.\n6. If the max heap is empty, break the loop.\n7. If the length of the result string is less than the input string, append `k - temp.length` spaces.\n8. If the final result string length is less than the input string, return an empty string. Otherwise, return the result string.\n\nThis algorithm ensures that characters with the highest frequency are placed first in the result string followed by other characters, maintaining a distance of at least `k` between the same characters. If it's not possible to place characters at that distance, an empty string will be returned.\n    ", "javascript": "\n    ```javascript\nfunction rearrangeString(s, k) {\n  if (k === 0) return s;\n\n  const freqMap = new Map();\n  for (const c of s) {\n    freqMap.set(c, (freqMap.get(c) || 0) + 1);\n  }\n\n  const maxHeap = Array.from(freqMap.entries()).sort((a, b) => b[1] - a[1]);\n\n  let result = '';\n  while (maxHeap.length) {\n    const temp = [];\n\n    for (let i = 0; i < k && maxHeap.length > 0; i++) {\n      const curr = maxHeap.shift();\n\n      result += curr[0];\n      if (curr[1] - 1 > 0) {\n        temp.push([curr[0], curr[1] - 1]);\n      }\n    }\n\n    maxHeap.unshift(...temp.sort((a, b) => b[1] - a[1]));\n\n    if (!maxHeap.length) break;\n    if (result.length < s.length) {\n      result += \" \".repeat(k - temp.length);\n    }\n  }\n\n  if (result.length < s.length) return \"\";\n  return result;\n}\n```\n\n    \n    The algorithm involves the following steps:\n1. Calculate the frequency of each character in the input string `s`. Store it in a hash table (dictionary/map) `freq`.\n2. Build a max heap (priority queue) from the frequency table. The heap will be sorted based on the frequency values.\n3. While the max heap is not empty, pop the first `k` elements from the heap, where `k` is the minimum distance required between the same characters, and append the characters to the result string.\n4. If the frequency of the popped elements is greater than one, decrement their frequency and store them in a temporary list `temp`.\n5. After popping `k` elements, add them back to the max heap.\n6. If the max heap is empty, break the loop.\n7. If the length of the result string is less than the input string, append `k - temp.length` spaces.\n8. If the final result string length is less than the input string, return an empty string. Otherwise, return the result string.\n\nThis algorithm ensures that characters with the highest frequency are placed first in the result string followed by other characters, maintaining a distance of at least `k` between the same characters. If it's not possible to place characters at that distance, an empty string will be returned.\n    "}
{"id": 376, "slug": "wiggle-subsequence", "title": "Wiggle Subsequence", "difficulty": "Medium", "content": "A **wiggle sequence** is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n\n*   For example, `[1, 7, 4, 9, 2, 5]` is a **wiggle sequence** because the differences `(6, -3, 5, -7, 3)` alternate between positive and negative.\n*   In contrast, `[1, 4, 7, 2, 5]` and `[1, 7, 4, 5, 5]` are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\n\nA **subsequence** is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\n\nGiven an integer array `nums`, return _the length of the longest **wiggle subsequence** of_ `nums`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,7,4,9,2,5\\]\n**Output:** 6\n**Explanation:** The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\n\n**Example 2:**\n\n**Input:** nums = \\[1,17,5,10,13,15,10,5,16,8\\]\n**Output:** 7\n**Explanation:** There are several subsequences that achieve this length.\nOne is \\[1, 17, 10, 13, 10, 16, 8\\] with differences (16, -7, 3, -3, 6, -8).\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7,8,9\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 1000`\n\n**Follow up:** Could you solve this in `O(n)` time?", "java": "\n    ```java\npublic int wiggleMaxLength(int[] nums) {\n    int len = nums.length;\n    if (len < 2) return len;\n\n    int up = 1, down = 1;\n    for (int i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return Math.max(up, down);\n}\n```\n    \n    The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory.\n    ", "c++": "\n    ```cpp\nint wiggleMaxLength(vector<int>& nums) {\n    int len = nums.size();\n    if (len < 2) return len;\n\n    int up = 1, down = 1;\n    for (int i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return max(up, down);\n}\n```\n    \n    The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory.\n    ", "python": "\n    ```python\ndef wiggleMaxLength(nums):\n    if len(nums) < 2:\n        return len(nums)\n\n    up, down = 1, 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)\n```\n    \n    The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory.\n    ", "javascript": "\n    ```javascript\nfunction wiggleMaxLength(nums) {\n    let len = nums.length;\n    if (len < 2) return len;\n\n    let up = 1, down = 1;\n    for (let i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return Math.max(up, down);\n}\n```\n    \n    The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory.\n    "}
{"id": 397, "slug": "integer-replacement", "title": "Integer Replacement", "difficulty": "Medium", "content": "Given a positive integer `n`, you can apply one of the following operations:\n\n1.  If `n` is even, replace `n` with `n / 2`.\n2.  If `n` is odd, replace `n` with either `n + 1` or `n - 1`.\n\nReturn _the minimum number of operations needed for_ `n` _to become_ `1`.\n\n**Example 1:**\n\n**Input:** n = 8\n**Output:** 3\n**Explanation:** 8 -> 4 -> 2 -> 1\n\n**Example 2:**\n\n**Input:** n = 7\n**Output:** 4\n**Explanation:** 7 -> 8 -> 4 -> 2 -> 1\nor 7 -> 6 -> 3 -> 2 -> 1\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`", "java": "\n    ```java\nint minOperations(int n) {\n    int steps = 0;\n    while(n > 1) {\n        n = (n % 2 == 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ", "c++": "\n    ```cpp\nint minOperations(int n) {\n    int steps = 0;\n    while(n > 1) {\n        n = (n % 2 == 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ", "python": "\n    ```python\ndef min_operations(n):\n    steps = 0\n    while n > 1:\n        n = n // 2 if n % 2 == 0 else n - 1\n        steps += 1\n    return steps\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ", "javascript": "\n    ```javascript\nfunction minOperations(n) {\n    let steps = 0;\n    while(n > 1) {\n        n = (n % 2 === 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    "}
{"id": 402, "slug": "remove-k-digits", "title": "Remove K Digits", "difficulty": "Medium", "content": "Given string num representing a non-negative integer `num`, and an integer `k`, return _the smallest possible integer after removing_ `k` _digits from_ `num`.\n\n**Example 1:**\n\n**Input:** num =  \"1432219 \", k = 3\n**Output:**  \"1219 \"\n**Explanation:** Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n\n**Example 2:**\n\n**Input:** num =  \"10200 \", k = 1\n**Output:**  \"200 \"\n**Explanation:** Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n\n**Example 3:**\n\n**Input:** num =  \"10 \", k = 2\n**Output:**  \"0 \"\n**Explanation:** Remove all the digits from the number and it is left with nothing which is 0.\n\n**Constraints:**\n\n*   `1 <= k <= num.length <= 105`\n*   `num` consists of only digits.\n*   `num` does not have any leading zeros except for the zero itself.", "java": "\n    ```java\npublic String removeKDigits(String num, int k) {\n    StringBuilder result = new StringBuilder();\n    for (char c : num.toCharArray()) {\n        while (k > 0 && result.length() > 0 && result.charAt(result.length() - 1) > c) {\n            result.setLength(result.length() - 1);\n            k--;\n        }\n        result.append(c);\n    }\n    result.setLength(result.length() - k);\n    while (result.length() > 0 && result.charAt(0) == '0') {\n        result.deleteCharAt(0);\n    }\n    return result.length() == 0 ? \"0\" : result.toString();\n}\n```\n    \n    The algorithm maintains a stack, initially empty. It iterates through the input string char by char, and for each char, it tries to remove the largest possible digit from the stack, as long as k is greater than 0. If the stack is empty or its topmost element is smaller than the current char, the current char is pushed into the stack. \n\nAfter the iteration, if k is still greater than 0, then we remove the remaining top k elements from the stack. Finally, the resultant smallest integer is formed from the stack, removing any leading zeros if present, and returned as a string.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string, as it iterates through the input string once and processes each character.\n    ", "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring removeKDigits(string num, int k) {\n    string result = \"\";\n    for (char c : num) {\n        while (k > 0 && !result.empty() && result.back() > c) {\n            result.pop_back();\n            k--;\n        }\n        result.push_back(c);\n    }\n    result.resize(result.length() - k);\n    while (!result.empty() && result[0] == '0') {\n        result.erase(result.begin());\n    }\n    return result.empty() ? \"0\" : result;\n}\n```\n    \n    The algorithm maintains a stack, initially empty. It iterates through the input string char by char, and for each char, it tries to remove the largest possible digit from the stack, as long as k is greater than 0. If the stack is empty or its topmost element is smaller than the current char, the current char is pushed into the stack. \n\nAfter the iteration, if k is still greater than 0, then we remove the remaining top k elements from the stack. Finally, the resultant smallest integer is formed from the stack, removing any leading zeros if present, and returned as a string.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string, as it iterates through the input string once and processes each character.\n    ", "python": "\n    ```python\ndef remove_k_digits(num, k):\n    stack = []\n    for c in num:\n        while k > 0 and stack and stack[-1] > c:\n            stack.pop()\n            k -= 1\n        stack.append(c)\n    while k > 0:\n        stack.pop()\n        k -= 1\n    return ''.join(stack).lstrip('0') or '0'\n```\n    \n    The algorithm maintains a stack, initially empty. It iterates through the input string char by char, and for each char, it tries to remove the largest possible digit from the stack, as long as k is greater than 0. If the stack is empty or its topmost element is smaller than the current char, the current char is pushed into the stack. \n\nAfter the iteration, if k is still greater than 0, then we remove the remaining top k elements from the stack. Finally, the resultant smallest integer is formed from the stack, removing any leading zeros if present, and returned as a string.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string, as it iterates through the input string once and processes each character.\n    ", "javascript": "\n    ```javascript\nfunction removeKDigits(num, k) {\n    let stack = [];\n    for (let i = 0; i < num.length; i++) {\n        let c = num[i];\n        while (k > 0 && stack.length > 0 && stack[stack.length - 1] > c) {\n            stack.pop();\n            k--;\n        }\n        stack.push(c);\n    }\n    while (k > 0) {\n        stack.pop();\n        k--;\n    }\n    let result = stack.join('').replace(/^0+/, '');\n    return result || '0';\n}\n```\n    \n    The algorithm maintains a stack, initially empty. It iterates through the input string char by char, and for each char, it tries to remove the largest possible digit from the stack, as long as k is greater than 0. If the stack is empty or its topmost element is smaller than the current char, the current char is pushed into the stack. \n\nAfter the iteration, if k is still greater than 0, then we remove the remaining top k elements from the stack. Finally, the resultant smallest integer is formed from the stack, removing any leading zeros if present, and returned as a string.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string, as it iterates through the input string once and processes each character.\n    "}
{"id": 409, "slug": "longest-palindrome", "title": "Longest Palindrome", "difficulty": "Easy", "content": "Given a string `s` which consists of lowercase or uppercase letters, return _the length of the **longest palindrome**_ that can be built with those letters.\n\nLetters are **case sensitive**, for example, `\"Aa \"` is not considered a palindrome here.\n\n**Example 1:**\n\n**Input:** s =  \"abccccdd \"\n**Output:** 7\n**Explanation:** One longest palindrome that can be built is  \"dccaccd \", whose length is 7.\n\n**Example 2:**\n\n**Input:** s =  \"a \"\n**Output:** 1\n**Explanation:** The longest palindrome that can be built is  \"a \", whose length is 1.\n\n**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase **and/or** uppercase English letters only.", "java": "\n    ```java\npublic int longestPalindrome(String s) {\n    int[] charCount = new int[128];\n    int result = 0;\n    for (char c : s.toCharArray())\n        charCount[c]++;\n    for (int count : charCount) {\n        result += count / 2 * 2;\n        if (result % 2 == 0 && count % 2 == 1)\n            result++;\n    }\n    return result;\n}\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    ", "c++": "\n    ```cpp\nint longestPalindrome(string s) {\n    int charCount[128] = {0};\n    int result = 0;\n    for (char c : s)\n        charCount[c]++;\n    for (int count : charCount) {\n        result += count / 2 * 2;\n        if (result % 2 == 0 && count % 2 == 1)\n            result++;\n    }\n    return result;\n}\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    ", "python": "\n    ```python\ndef longestPalindrome(s: str) -> int:\n    charCount = [0] * 128\n    result = 0\n    for c in s:\n        charCount[ord(c)] += 1\n    for count in charCount:\n        result += count // 2 * 2\n        if result % 2 == 0 and count % 2 == 1:\n            result += 1\n    return result\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    ", "javascript": "\n    ```javascript\nfunction longestPalindrome(s) {\n    let charCount = new Array(128).fill(0);\n    let result = 0;\n    for (let c of s)\n        charCount[c.charCodeAt(0)]++;\n    for (let count of charCount) {\n        result += Math.floor(count / 2) * 2;\n        if (result % 2 === 0 && count % 2 === 1)\n            result++;\n    }\n    return result;\n}\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    "}
{"id": 410, "slug": "split-array-largest-sum", "title": "Split Array Largest Sum", "difficulty": "Hard", "content": "Given an integer array `nums` and an integer `k`, split `nums` into `k` non-empty subarrays such that the largest sum of any subarray is **minimized**.\n\nReturn _the minimized largest sum of the split_.\n\nA **subarray** is a contiguous part of the array.\n\n**Example 1:**\n\n**Input:** nums = \\[7,2,5,10,8\\], k = 2\n**Output:** 18\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[7,2,5\\] and \\[10,8\\], where the largest sum among the two subarrays is only 18.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5\\], k = 2\n**Output:** 9\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[1,2,3\\] and \\[4,5\\], where the largest sum among the two subarrays is only 9.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 106`\n*   `1 <= k <= min(50, nums.length)`", "java": "\n    ```java\npublic int splitArray(int[] nums, int m) {\n    long left = 0, right = 0;\n    for (int num : nums) {\n        left = Math.max(left, num);\n        right += num;\n    }\n\n    while (left < right) {\n        long mid = (left + right) / 2;\n        int count = 1;\n        long curSum = 0;\n        for (int num : nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return (int)left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ", "c++": "\n    ```cpp\nint splitArray(vector<int>& nums, int m) {\n    long long left = 0, right = 0;\n    for (int num : nums) {\n        left = max(left, (long long)num);\n        right += num;\n    }\n\n    while (left < right) {\n        long long mid = (left + right) / 2;\n        int count = 1;\n        long long curSum = 0;\n        for (int num : nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return (int)left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ", "python": "\n    ```python\ndef splitArray(nums, m):\n    left, right = max(nums), sum(nums)\n\n    while left < right:\n        mid = (left + right) // 2\n        count, cur_sum = 1, 0\n        for num in nums:\n            cur_sum += num\n            if cur_sum > mid:\n                cur_sum = num\n                count += 1\n\n        if count > m:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ", "javascript": "\n    ```javascript\nfunction splitArray(nums, m) {\n    let left = 0, right = 0;\n    for (let num of nums) {\n        left = Math.max(left, num);\n        right += num;\n    }\n\n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        let count = 1;\n        let curSum = 0;\n        for (let num of nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    "}
{"id": 420, "slug": "strong-password-checker", "title": "Strong Password Checker", "difficulty": "Hard", "content": "A password is considered strong if the below conditions are all met:\n\n*   It has at least `6` characters and at most `20` characters.\n*   It contains at least **one lowercase** letter, at least **one uppercase** letter, and at least **one digit**.\n*   It does not contain three repeating characters in a row (i.e., `\"B**aaa**bb0 \"` is weak, but `\"B**aa**b**a**0 \"` is strong).\n\nGiven a string `password`, return _the minimum number of steps required to make `password` strong. if `password` is already strong, return `0`._\n\nIn one step, you can:\n\n*   Insert one character to `password`,\n*   Delete one character from `password`, or\n*   Replace one character of `password` with another character.\n\n**Example 1:**\n\n**Input:** password = \"a\"\n**Output:** 5\n\n**Example 2:**\n\n**Input:** password = \"aA1\"\n**Output:** 3\n\n**Example 3:**\n\n**Input:** password = \"1337C0d3\"\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= password.length <= 50`\n*   `password` consists of letters, digits, dot `'.'` or exclamation mark `'!'`.", "java": "\n    ```java\nint strongPassword(String password) {\n    int missingLower = 1, missingUpper = 1, missingDigit = 1;\n    int total = password.length();\n    for (char c : password.toCharArray()) {\n        if (Character.isLowerCase(c)) missingLower = 0;\n        if (Character.isUpperCase(c)) missingUpper = 0;\n        if (Character.isDigit(c)) missingDigit = 0;\n    }\n    int missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return Math.max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    ", "c++": "\n    ```cpp\n#include <cctype>\n#include <algorithm>\nint strongPassword(string password) {\n    int missingLower = 1, missingUpper = 1, missingDigit = 1;\n    int total = (int)password.size();\n    for (char c : password) {\n        if (islower(c)) missingLower = 0;\n        if (isupper(c)) missingUpper = 0;\n        if (isdigit(c)) missingDigit = 0;\n    }\n    int missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    ", "python": "\n    ```python\ndef strong_password(password):\n    missing_lower = 1\n    missing_upper = 1\n    missing_digit = 1\n    total = len(password)\n    \n    for c in password:\n        if c.islower(): missing_lower = 0\n        if c.isupper(): missing_upper = 0\n        if c.isdigit(): missing_digit = 0\n    \n    missing = missing_lower + missing_upper + missing_digit\n    if total < 6: return max(missing, 6 - total)\n    if total > 20: return missing + total - 20\n\n    return missing\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    ", "javascript": "\n    ```javascript\nfunction strongPassword(password) {\n    let missingLower = 1, missingUpper = 1, missingDigit = 1;\n    let total = password.length;\n    for (const c of password) {\n        if (c.match(/[a-z]/)) missingLower = 0;\n        if (c.match(/[A-Z]/)) missingUpper = 0;\n        if (c.match(/[0-9]/)) missingDigit = 0;\n    }\n    let missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return Math.max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    "}
{"id": 435, "slug": "non-overlapping-intervals", "title": "Non-overlapping Intervals", "difficulty": "Medium", "content": "Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[1,3\\]\\]\n**Output:** 1\n**Explanation:** \\[1,3\\] can be removed and the rest of the intervals are non-overlapping.\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[1,2\\],\\[1,2\\]\\]\n**Output:** 2\n**Explanation:** You need to remove two \\[1,2\\] to make the rest of the intervals non-overlapping.\n\n**Example 3:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** 0\n**Explanation:** You don't need to remove any of the intervals since they're already non-overlapping.\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 105`\n*   `intervals[i].length == 2`\n*   `-5 * 104 <= starti < endi <= 5 * 104`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals.length == 0) return 0;\n\n    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n\n    int count = 0;\n    int prev_end = intervals[0][1];\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nbool compare(const std::vector<int>& a, const std::vector<int>& b) {\n    return a[1] < b[1];\n}\n\nint eraseOverlapIntervals(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return 0;\n    \n    std::sort(intervals.begin(), intervals.end(), compare);\n    \n    int count = 0;\n    int prev_end = intervals[0][1];\n    \n    for (size_t i = 1; i < intervals.size(); i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n    \n    return count;\n}\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ", "python": "\n    ```python\ndef eraseOverlapIntervals(intervals):\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    prev_end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        if intervals[i][0] < prev_end:\n            count += 1\n        else:\n            prev_end = intervals[i][1]\n    \n    return count\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ", "javascript": "\n    ```javascript\nfunction eraseOverlapIntervals(intervals) {\n    if (intervals.length === 0) return 0;\n\n    intervals.sort((a, b) => a[1] - b[1]);\n\n    let count = 0;\n    let prev_end = intervals[0][1];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    "}
{"id": 452, "slug": "minimum-number-of-arrows-to-burst-balloons", "title": "Minimum Number of Arrows to Burst Balloons", "difficulty": "Medium", "content": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array `points` where `points[i] = [xstart, xend]` denotes a balloon whose **horizontal diameter** stretches between `xstart` and `xend`. You do not know the exact y-coordinates of the balloons.\n\nArrows can be shot up **directly vertically** (in the positive y-direction) from different points along the x-axis. A balloon with `xstart` and `xend` is **burst** by an arrow shot at `x` if `xstart <= x <= xend`. There is **no limit** to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\n\nGiven the array `points`, return _the **minimum** number of arrows that must be shot to burst all balloons_.\n\n**Example 1:**\n\n**Input:** points = \\[\\[10,16\\],\\[2,8\\],\\[1,6\\],\\[7,12\\]\\]\n**Output:** 2\n**Explanation:** The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons \\[2,8\\] and \\[1,6\\].\n- Shoot an arrow at x = 11, bursting the balloons \\[10,16\\] and \\[7,12\\].\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,2\\],\\[3,4\\],\\[5,6\\],\\[7,8\\]\\]\n**Output:** 4\n**Explanation:** One arrow needs to be shot for each balloon for a total of 4 arrows.\n\n**Example 3:**\n\n**Input:** points = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]\n**Output:** 2\n**Explanation:** The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 2, bursting the balloons \\[1,2\\] and \\[2,3\\].\n- Shoot an arrow at x = 4, bursting the balloons \\[3,4\\] and \\[4,5\\].\n\n**Constraints:**\n\n*   `1 <= points.length <= 105`\n*   `points[i].length == 2`\n*   `-231 <= xstart < xend <= 231 - 1`", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int findMinArrowShots(int[][] points) {\n    if (points.length == 0) return 0;\n    Arrays.sort(points, Comparator.comparingInt(a -> a[1]));\n\n    int arrows = 1;\n    int end = points[0][1];\n\n    for (int i = 1; i < points.length; i++) {\n        if (points[i][0] > end) {\n            arrows++;\n            end = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n```\n    \n    The algorithm sorts the given points by the end value of their ranges. Then, it initializes a variable `arrows` to 1 (to count the first arrow) and `end` to the end value of the first point (to keep track of the last point reached by arrows).\n\nThen, it iterates through the array, starting from the second point to the end. For each point, it checks whether the start value is greater than the current `end` value. If it is, that means this point is not covered by the previous arrows, so it increments the `arrows` counter and updates `end` to the end value of the current point.\n\nFinally, it returns the value of `arrows` as the minimum number of arrows needed to burst all balloons. \n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint findMinArrowShots(std::vector<std::vector<int>>& points) {\n    if (points.empty()) return 0;\n    std::sort(points.begin(), points.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    int arrows = 1;\n    int end = points[0][1];\n\n    for (int i = 1; i < points.size(); ++i) {\n        if (points[i][0] > end) {\n            arrows++;\n            end = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n```\n    \n    The algorithm sorts the given points by the end value of their ranges. Then, it initializes a variable `arrows` to 1 (to count the first arrow) and `end` to the end value of the first point (to keep track of the last point reached by arrows).\n\nThen, it iterates through the array, starting from the second point to the end. For each point, it checks whether the start value is greater than the current `end` value. If it is, that means this point is not covered by the previous arrows, so it increments the `arrows` counter and updates `end` to the end value of the current point.\n\nFinally, it returns the value of `arrows` as the minimum number of arrows needed to burst all balloons. \n    ", "python": "\n    ```python\ndef findMinArrowShots(points):\n    if not points:\n        return 0\n    points.sort(key=lambda x: x[1])\n\n    arrows = 1\n    end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] > end:\n            arrows += 1\n            end = points[i][1]\n\n    return arrows\n```\n    \n    The algorithm sorts the given points by the end value of their ranges. Then, it initializes a variable `arrows` to 1 (to count the first arrow) and `end` to the end value of the first point (to keep track of the last point reached by arrows).\n\nThen, it iterates through the array, starting from the second point to the end. For each point, it checks whether the start value is greater than the current `end` value. If it is, that means this point is not covered by the previous arrows, so it increments the `arrows` counter and updates `end` to the end value of the current point.\n\nFinally, it returns the value of `arrows` as the minimum number of arrows needed to burst all balloons. \n    ", "javascript": "\n    ```javascript\nfunction findMinArrowShots(points) {\n    if (points.length === 0) return 0;\n    points.sort((a, b) => a[1] - b[1]);\n\n    let arrows = 1;\n    let end = points[0][1];\n\n    for (let i = 1; i < points.length; i++) {\n        if (points[i][0] > end) {\n            arrows++;\n            end = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n```\n    \n    The algorithm sorts the given points by the end value of their ranges. Then, it initializes a variable `arrows` to 1 (to count the first arrow) and `end` to the end value of the first point (to keep track of the last point reached by arrows).\n\nThen, it iterates through the array, starting from the second point to the end. For each point, it checks whether the start value is greater than the current `end` value. If it is, that means this point is not covered by the previous arrows, so it increments the `arrows` counter and updates `end` to the end value of the current point.\n\nFinally, it returns the value of `arrows` as the minimum number of arrows needed to burst all balloons. \n    "}
{"id": 455, "slug": "assign-cookies", "title": "Assign Cookies", "difficulty": "Easy", "content": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n\nEach child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number.\n\n**Example 1:**\n\n**Input:** g = \\[1,2,3\\], s = \\[1,1\\]\n**Output:** 1\n**Explanation:** You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\n**Example 2:**\n\n**Input:** g = \\[1,2\\], s = \\[1,2,3\\]\n**Output:** 2\n**Explanation:** You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\n\n**Constraints:**\n\n*   `1 <= g.length <= 3 * 104`\n*   `0 <= s.length <= 3 * 104`\n*   `1 <= g[i], s[j] <= 231 - 1`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int findContentChildren(int[] g, int[] s) {\n    Arrays.sort(g);\n    Arrays.sort(s);\n    int i = 0, j = 0;\n\n    while (i < g.length && j < s.length) {\n        if (s[j] >= g[i]) {\n            i++;\n        }\n\n        j++;\n    }\n\n    return i;\n}\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint findContentChildren(std::vector<int>& g, std::vector<int>& s) {\n    std::sort(g.begin(), g.end());\n    std::sort(s.begin(), s.end());\n    int i = 0, j = 0;\n\n    while (i < g.size() && j < s.size()) {\n      if (s[j] >= g[i]) {\n        i++;\n      }\n\n      j++;\n    }\n\n    return i;\n}\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    ", "python": "\n    ```python\ndef find_content_children(g, s):\n    g.sort()\n    s.sort()\n    i = j = 0\n\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1\n\n        j += 1\n\n    return i\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    ", "javascript": "\n    ```javascript\nfunction findContentChildren(g, s) {\n    g.sort((a, b) => a - b);\n    s.sort((a, b) => a - b);\n    let i = 0, j = 0;\n\n    while (i < g.length && j < s.length) {\n        if (s[j] >= g[i]) {\n            i++;\n        }\n\n        j++;\n    }\n\n    return i;\n}\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    "}
{"id": 484, "slug": "find-permutation", "title": "Find Permutation", "difficulty": "Medium", "content": "A permutation `perm` of `n` integers of all the integers in the range `[1, n]` can be represented as a string `s` of length `n - 1` where:\n\n*   `s[i] == 'I'` if `perm[i] < perm[i + 1]`, and\n*   `s[i] == 'D'` if `perm[i] > perm[i + 1]`.\n\nGiven a string `s`, reconstruct the lexicographically smallest permutation `perm` and return it.\n\n**Example 1:**\n\n**Input:** s =  \"I \"\n**Output:** \\[1,2\\]\n**Explanation:** \\[1,2\\] is the only legal permutation that can represented by s, where the number 1 and 2 construct an increasing relationship.\n\n**Example 2:**\n\n**Input:** s =  \"DI \"\n**Output:** \\[2,1,3\\]\n**Explanation:** Both \\[2,1,3\\] and \\[3,1,2\\] can be represented as  \"DI \", but since we want to find the smallest lexicographical permutation, you should return \\[2,1,3\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'I'` or `'D'`.", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int[] findPermutation(String s) {\n        int[] perm = new int[s.length() + 1];\n        int left = 1;\n        for(int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == 'I') {\n                perm[i] = left++;\n                while(i + 1 < s.length() && s.charAt(i + 1) == 'D')\n                    i++;\n            }\n        }\n        perm[s.length()] = left++;\n        for(int i = s.length() - 1; i >= 0; i--)\n            if(s.charAt(i) == 'D')\n                perm[i] = left++;\n        return perm;\n    }\n}\n```\n    \n    The algorithm works as follows:\n\n1. Initialize an empty permutation array `perm` of length `n+1` (where `n` is the length of string `s`).\n2. Initialize a variable `left` with the value 1. This variable will keep track of the next unused smallest number.\n3. Iterate through the given string `s`. If the character at index `i` is 'I', place the value of `left` at the same index in the `perm` array and increment `left`. If there is a sequence of 'D's following current 'I', jump directly to the end of this sequence.\n4. After iterating through the whole string, assign the value of `left` to the last position of the `perm` array and increment `left`.\n5. Iterate through the string `s` in reverse order. If the character at index `i` is 'D', place the value of `left` at the same index in the `perm` array and increment `left`.\n6. At the end of the process, the filled `perm` array represents the lexicographically smallest permutation.\n\nThe time complexity of this algorithm is O(n) as it iterates through the string `s` and fills the `perm` array in linear time.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> findPermutation(std::string s) {\n    std::vector<int> perm(s.length() + 1);\n    int left = 1;\n    for(int i = 0; i < s.length(); i++) {\n        if(s[i] == 'I') {\n            perm[i] = left++;\n            while(i + 1 < s.length() && s[i + 1] == 'D')\n                i++;\n        }\n    }\n    perm[s.length()] = left++;\n    for(int i = s.length() - 1; i >= 0; i--)\n        if(s[i] == 'D')\n            perm[i] = left++;\n    return perm;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Initialize an empty permutation array `perm` of length `n+1` (where `n` is the length of string `s`).\n2. Initialize a variable `left` with the value 1. This variable will keep track of the next unused smallest number.\n3. Iterate through the given string `s`. If the character at index `i` is 'I', place the value of `left` at the same index in the `perm` array and increment `left`. If there is a sequence of 'D's following current 'I', jump directly to the end of this sequence.\n4. After iterating through the whole string, assign the value of `left` to the last position of the `perm` array and increment `left`.\n5. Iterate through the string `s` in reverse order. If the character at index `i` is 'D', place the value of `left` at the same index in the `perm` array and increment `left`.\n6. At the end of the process, the filled `perm` array represents the lexicographically smallest permutation.\n\nThe time complexity of this algorithm is O(n) as it iterates through the string `s` and fills the `perm` array in linear time.\n    ", "python": "\n    ```python\ndef findPermutation(s: str) -> list[int]:\n    perm = [0] * (len(s) + 1)\n    left = 1\n    i = 0\n    while i < len(s):\n        if s[i] == 'I':\n            perm[i] = left\n            left += 1\n            while i + 1 < len(s) and s[i + 1] == 'D':\n                i += 1\n        i += 1\n    perm[len(s)] = left\n    left += 1\n    for i in reversed(range(len(s))):\n        if s[i] == 'D':\n            perm[i] = left\n            left += 1\n    return perm\n```\n    \n    The algorithm works as follows:\n\n1. Initialize an empty permutation array `perm` of length `n+1` (where `n` is the length of string `s`).\n2. Initialize a variable `left` with the value 1. This variable will keep track of the next unused smallest number.\n3. Iterate through the given string `s`. If the character at index `i` is 'I', place the value of `left` at the same index in the `perm` array and increment `left`. If there is a sequence of 'D's following current 'I', jump directly to the end of this sequence.\n4. After iterating through the whole string, assign the value of `left` to the last position of the `perm` array and increment `left`.\n5. Iterate through the string `s` in reverse order. If the character at index `i` is 'D', place the value of `left` at the same index in the `perm` array and increment `left`.\n6. At the end of the process, the filled `perm` array represents the lexicographically smallest permutation.\n\nThe time complexity of this algorithm is O(n) as it iterates through the string `s` and fills the `perm` array in linear time.\n    ", "javascript": "\n    ```javascript\nfunction findPermutation(s) {\n    let perm = new Array(s.length + 1).fill(0);\n    let left = 1;\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === 'I') {\n            perm[i] = left++;\n            while(i + 1 < s.length && s[i + 1] === 'D')\n                i++;\n        }\n    }\n    perm[s.length] = left++;\n    for(let i = s.length - 1; i >= 0; i--)\n        if(s[i] === 'D')\n            perm[i] = left++;\n    return perm;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Initialize an empty permutation array `perm` of length `n+1` (where `n` is the length of string `s`).\n2. Initialize a variable `left` with the value 1. This variable will keep track of the next unused smallest number.\n3. Iterate through the given string `s`. If the character at index `i` is 'I', place the value of `left` at the same index in the `perm` array and increment `left`. If there is a sequence of 'D's following current 'I', jump directly to the end of this sequence.\n4. After iterating through the whole string, assign the value of `left` to the last position of the `perm` array and increment `left`.\n5. Iterate through the string `s` in reverse order. If the character at index `i` is 'D', place the value of `left` at the same index in the `perm` array and increment `left`.\n6. At the end of the process, the filled `perm` array represents the lexicographically smallest permutation.\n\nThe time complexity of this algorithm is O(n) as it iterates through the string `s` and fills the `perm` array in linear time.\n    "}
{"id": 502, "slug": "ipo", "title": "IPO", "difficulty": "Hard", "content": "Suppose LeetCode will start its **IPO** soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the **IPO**. Since it has limited resources, it can only finish at most `k` distinct projects before the **IPO**. Help LeetCode design the best way to maximize its total capital after finishing at most `k` distinct projects.\n\nYou are given `n` projects where the `ith` project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.\n\nInitially, you have `w` capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n\nPick a list of **at most** `k` distinct projects from given projects to **maximize your final capital**, and return _the final maximized capital_.\n\nThe answer is guaranteed to fit in a 32-bit signed integer.\n\n**Example 1:**\n\n**Input:** k = 2, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,1\\]\n**Output:** 4\n**Explanation:** Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\n**Example 2:**\n\n**Input:** k = 3, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,2\\]\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= k <= 105`\n*   `0 <= w <= 109`\n*   `n == profits.length`\n*   `n == capital.length`\n*   `1 <= n <= 105`\n*   `0 <= profits[i] <= 104`\n*   `0 <= capital[i] <= 109`", "java": "\n    ```java\nimport java.util.PriorityQueue;\nimport java.util.Arrays;\n\npublic class Solution {\n    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n        int[][] project_pool = new int[profits.length][2];\n        \n        for (int i = 0; i < profits.length; i++) {\n            project_pool[i] = new int[] {capital[i], profits[i]};\n        }\n        \n        Arrays.sort(project_pool, (a, b) -> a[0] - b[0]);\n        \n        PriorityQueue<Integer> profit_pool = new PriorityQueue<>((a, b) -> b - a);\n        int index = 0;\n        \n        for (int i = 0; i < k; i++) {\n            while (index < project_pool.length &&\n                   project_pool[index][0] <= w) {\n                profit_pool.add(project_pool[index++][1]);\n            }\n            \n            if (!profit_pool.isEmpty()) {\n                w += profit_pool.poll();\n            } else {\n                break;\n            }\n        }\n        \n        return w;\n    }\n}\n```\n    \n    1. Create an array of project pool, where each element is a pair of (capital, profit).\n2. Sort the project pool array by capital in ascending order.\n3. Initialize a priority queue called profit pool to store the profits of projects based on which one has the highest profit.\n4. Iterate through projects up to k times.\n5. In each iteration, check projects with capitals less than or equal to w in the project pool, push their profits into the profit pool and remove them from the project pool.\n6. If there is any profit in the profit pool, pop the one with the highest profit and add the profit to w.\n7. Return the final maximized capital w after finishing at most k distinct projects.\n    ", "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {\n    vector<pair<int, int>> project_pool;\n    \n    for (size_t i = 0; i < profits.size(); i++) {\n        project_pool.emplace_back(capital[i], profits[i]);\n    }\n    \n    sort(project_pool.begin(), project_pool.end());\n    \n    priority_queue<int> profit_pool;\n    int index = 0;\n    \n    for (int i = 0; i < k; i++) {\n        while (index < project_pool.size() &&\n               project_pool[index].first <= w) {\n            profit_pool.push(project_pool[index++].second);\n        }\n        \n        if (!profit_pool.empty()) {\n            w += profit_pool.top();\n            profit_pool.pop();\n        } else {\n            break;\n        }\n    }\n    \n    return w;\n}\n```\n    \n    1. Create an array of project pool, where each element is a pair of (capital, profit).\n2. Sort the project pool array by capital in ascending order.\n3. Initialize a priority queue called profit pool to store the profits of projects based on which one has the highest profit.\n4. Iterate through projects up to k times.\n5. In each iteration, check projects with capitals less than or equal to w in the project pool, push their profits into the profit pool and remove them from the project pool.\n6. If there is any profit in the profit pool, pop the one with the highest profit and add the profit to w.\n7. Return the final maximized capital w after finishing at most k distinct projects.\n    ", "python": "\n    ```python\nimport heapq\n\ndef findMaximizedCapital(k: int, w: int, profits, capital) -> int:\n    project_pool = list(zip(capital, profits))\n    project_pool.sort(reverse=True)\n    \n    profit_pool = []\n    \n    while k:\n        while project_pool and project_pool[-1][0] <= w:\n            heapq.heappush(profit_pool, -project_pool.pop()[1])\n        \n        if not profit_pool:\n            break\n        \n        w -= heapq.heappop(profit_pool)\n        k -= 1\n        \n    return w\n```\n    \n    1. Create an array of project pool, where each element is a pair of (capital, profit).\n2. Sort the project pool array by capital in ascending order.\n3. Initialize a priority queue called profit pool to store the profits of projects based on which one has the highest profit.\n4. Iterate through projects up to k times.\n5. In each iteration, check projects with capitals less than or equal to w in the project pool, push their profits into the profit pool and remove them from the project pool.\n6. If there is any profit in the profit pool, pop the one with the highest profit and add the profit to w.\n7. Return the final maximized capital w after finishing at most k distinct projects.\n    ", "javascript": "\n    ```javascript\nfunction findMaximizedCapital(k, w, profits, capital) {\n    const project_pool = profits.map((p, i) => [capital[i], p]).sort((a, b) => a[0] - b[0]);\n    const profit_pool = new MaxPriorityQueue();\n    let index = 0;\n\n    for (let i = 0; i < k; i++) {\n        while (index < project_pool.length && project_pool[index][0] <= w) {\n            profit_pool.insert(project_pool[index++][1]);\n        }\n\n        if (!profit_pool.isEmpty()) {\n            w += profit_pool.removeMax();\n        } else {\n            break;\n        }\n    }\n\n    return w;\n}\n\nclass MaxPriorityQueue {\n    constructor() {\n        this.queue = [];\n    }\n    \n    insert(value) {\n        this.queue.push(value);\n        this.siftUp(this.queue.length - 1);\n    }\n    \n    removeMax() {\n        const maxValue = this.queue[0];\n        const lastValue = this.queue.pop();\n        \n        if (this.queue.length) {\n            this.queue[0] = lastValue;\n            this.siftDown(0);\n        }\n        \n        return maxValue;\n    }\n    \n    siftUp(index) {\n        while (index) {\n            const parentIndex = (index - 1) >> 1;\n            if (this.queue[parentIndex] >= this.queue[index]) break;\n            [this.queue[parentIndex], this.queue[index]] = [this.queue[index], this.queue[parentIndex]];\n            index = parentIndex;\n        }\n    }\n    \n    siftDown(index) {\n        while (true) {\n            const leftIndex = (index << 1) + 1;\n            const rightIndex = leftIndex + 1;\n            let maxIndex = index;\n            if (leftIndex < this.queue.length && this.queue[leftIndex] > this.queue[maxIndex]) maxIndex = leftIndex;\n            if (rightIndex < this.queue.length && this.queue[rightIndex] > this.queue[maxIndex]) maxIndex = rightIndex;\n            if (maxIndex === index) break;\n            [this.queue[index], this.queue[maxIndex]] = [this.queue[maxIndex], this.queue[index]];\n            index = maxIndex;\n        }\n    }\n    \n    isEmpty() {\n        return this.queue.length === 0;\n    }\n}\n```\n    \n    1. Create an array of project pool, where each element is a pair of (capital, profit).\n2. Sort the project pool array by capital in ascending order.\n3. Initialize a priority queue called profit pool to store the profits of projects based on which one has the highest profit.\n4. Iterate through projects up to k times.\n5. In each iteration, check projects with capitals less than or equal to w in the project pool, push their profits into the profit pool and remove them from the project pool.\n6. If there is any profit in the profit pool, pop the one with the highest profit and add the profit to w.\n7. Return the final maximized capital w after finishing at most k distinct projects.\n    "}
{"id": 517, "slug": "super-washing-machines", "title": "Super Washing Machines", "difficulty": "Hard", "content": "You have `n` super washing machines on a line. Initially, each washing machine has some dresses or is empty.\n\nFor each move, you could choose any `m` (`1 <= m <= n`) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\n\nGiven an integer array `machines` representing the number of dresses in each washing machine from left to right on the line, return _the minimum number of moves to make all the washing machines have the same number of dresses_. If it is not possible to do it, return `-1`.\n\n**Example 1:**\n\n**Input:** machines = \\[1,0,5\\]\n**Output:** 3\n**Explanation:**\n1st move:    1     0 <-- 5    =>    1     1     4\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n3rd move:    2     1 <-- 3    =>    2     2     2\n\n**Example 2:**\n\n**Input:** machines = \\[0,3,0\\]\n**Output:** 2\n**Explanation:**\n1st move:    0 <-- 3     0    =>    1     2     0\n2nd move:    1     2 --> 0    =>    1     1     1\n\n**Example 3:**\n\n**Input:** machines = \\[0,2,0\\]\n**Output:** -1\n**Explanation:**\nIt's impossible to make all three washing machines have the same number of dresses.\n\n**Constraints:**\n\n*   `n == machines.length`\n*   `1 <= n <= 104`\n*   `0 <= machines[i] <= 105`", "java": "\n    ```java\npublic int findMinMoves(int[] machines) {\n    int n = machines.length;\n    int totalDresses = 0;\n    for (int m : machines) totalDresses += m;\n    if (totalDresses % n != 0) return -1;\n    int average = totalDresses / n;\n    int moves = 0, imbalance = 0;\n    \n    for (int i = 0; i < n; i++) {\n        imbalance += machines[i] - average;\n        moves = Math.max(moves, Math.max(Math.abs(imbalance), machines[i] - average));\n    }\n    \n    return moves;\n}\n```\n    \n    1. Calculate the total number of dresses and check if it can be evenly distributed among the machines. If it cannot, return -1.\n2. Calculate the average number of dresses each machine should have.\n3. Initialize the moves and imbalance count to 0.\n4. Iterate through the machines and calculate the current imbalance for each machine.\n5. Update the moves count by taking the maximum of the current moves, the absolute value of the current imbalance, and the difference between the current machine's dresses and the average value.\n6. Return the moves count.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\nint findMinMoves(std::vector<int>& machines) {\n    int n = machines.size();\n    int totalDresses = std::accumulate(machines.begin(), machines.end(), 0);\n    if (totalDresses % n != 0) return -1;\n    int average = totalDresses / n;\n    int moves = 0, imbalance = 0;\n    \n    for (int i = 0; i < n; i++) {\n        imbalance += machines[i] - average;\n        moves = std::max(moves, std::max(abs(imbalance), machines[i] - average));\n    }\n    \n    return moves;\n}\n```\n    \n    1. Calculate the total number of dresses and check if it can be evenly distributed among the machines. If it cannot, return -1.\n2. Calculate the average number of dresses each machine should have.\n3. Initialize the moves and imbalance count to 0.\n4. Iterate through the machines and calculate the current imbalance for each machine.\n5. Update the moves count by taking the maximum of the current moves, the absolute value of the current imbalance, and the difference between the current machine's dresses and the average value.\n6. Return the moves count.\n    ", "python": "\n    ```python\ndef find_min_moves(machines):\n    n = len(machines)\n    total_dresses = sum(machines)\n    if total_dresses % n != 0:\n        return -1\n    average = total_dresses // n\n    moves = 0\n    imbalance = 0\n    \n    for i in range(n):\n        imbalance += machines[i] - average\n        moves = max(moves, abs(imbalance), machines[i] - average)\n        \n    return moves\n```\n    \n    1. Calculate the total number of dresses and check if it can be evenly distributed among the machines. If it cannot, return -1.\n2. Calculate the average number of dresses each machine should have.\n3. Initialize the moves and imbalance count to 0.\n4. Iterate through the machines and calculate the current imbalance for each machine.\n5. Update the moves count by taking the maximum of the current moves, the absolute value of the current imbalance, and the difference between the current machine's dresses and the average value.\n6. Return the moves count.\n    ", "javascript": "\n    ```javascript\nfunction findMinMoves(machines) {\n    let n = machines.length;\n    let totalDresses = machines.reduce((a, b) => a + b, 0);\n    if (totalDresses % n !== 0) return -1;\n    let average = totalDresses / n;\n    let moves = 0, imbalance = 0;\n    \n    for (let i = 0; i < n; i++) {\n        imbalance += machines[i] - average;\n        moves = Math.max(moves, Math.max(Math.abs(imbalance), machines[i] - average));\n    }\n    \n    return moves;\n}\n```\n    \n    1. Calculate the total number of dresses and check if it can be evenly distributed among the machines. If it cannot, return -1.\n2. Calculate the average number of dresses each machine should have.\n3. Initialize the moves and imbalance count to 0.\n4. Iterate through the machines and calculate the current imbalance for each machine.\n5. Update the moves count by taking the maximum of the current moves, the absolute value of the current imbalance, and the difference between the current machine's dresses and the average value.\n6. Return the moves count.\n    "}
{"id": 527, "slug": "word-abbreviation", "title": "Word Abbreviation", "difficulty": "Hard", "content": "Given an array of **distinct** strings `words`, return _the minimal possible **abbreviations** for every word_.\n\nThe following are the rules for a string abbreviation:\n\n1.  The **initial** abbreviation for each word is: the first character, then the number of characters in between, followed by the last character.\n2.  If more than one word shares the **same** abbreviation, then perform the following operation:\n    *   **Increase** the prefix (characters in the first part) of each of their abbreviations by `1`.\n        *   For example, say you start with the words `[ \"abcdef \", \"abndef \"]` both initially abbreviated as `\"a4f \"`. Then, a sequence of operations would be `[ \"a4f \", \"a4f \"]` -> `[ \"ab3f \", \"ab3f \"]` -> `[ \"abc2f \", \"abn2f \"]`.\n    *   This operation is repeated until every abbreviation is **unique**.\n3.  At the end, if an abbreviation did not make a word shorter, then keep it as the original word.\n\n**Example 1:**\n\n**Input:** words = \\[\"like\",\"god\",\"internal\",\"me\",\"internet\",\"interval\",\"intension\",\"face\",\"intrusion\"\\]\n**Output:** \\[\"l2e\",\"god\",\"internal\",\"me\",\"i6t\",\"interval\",\"inte4n\",\"f2e\",\"intr4n\"\\]\n\n**Example 2:**\n\n**Input:** words = \\[\"aa\",\"aaa\"\\]\n**Output:** \\[\"aa\",\"aaa\"\\]\n\n**Constraints:**\n\n*   `1 <= words.length <= 400`\n*   `2 <= words[i].length <= 400`\n*   `words[i]` consists of lowercase English letters.\n*   All the strings of `words` are **unique**.", "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Arrays;\n\npublic String[] wordsAbbreviation(String[] words) {\n    int n = words.length;\n    String[] abbr = new String[n];\n    int[] prefixLen = new int[n];\n\n    for (int i = 0; i < n; i++) {\n        abbr[i] = abbrev(words[i], 1);\n        prefixLen[i] = 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        while (true) {\n            Map<String, int[]> groups = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (abbr[i].equals(abbr[j])) {\n                    if (!groups.containsKey(abbr[j])) {\n                        groups.put(abbr[j], new int[]{0, 0});\n                    }\n                    groups.get(abbr[j])[0]++;\n                    groups.get(abbr[j])[1] = j;\n                }\n            }\n            if (groups.get(abbr[i])[0] == 1) {\n                break;\n            }\n            abbr[groups.get(abbr[i])[1]] = abbrev(words[groups.get(abbr[i])[1]], ++prefixLen[groups.get(abbr[i])[1]]);\n            abbr[i] = abbrev(words[i], ++prefixLen[i]);\n        }\n    }\n\n    return abbr;\n}\n\nprivate String abbrev(String s, int k) {\n    int n = s.length();\n    if (k >= n - 2) {\n        return s;\n    }\n    return s.substring(0, k + 1) + Integer.toString(n - k - 2) + s.charAt(n - 1);\n}\n```\n    \n    1. Initialize abbreviation lists and prefix lengths for each word.\n2. For each word, calculate its initial abbreviation based on the rule 1.\n3. Check if there are any words that share the same abbreviation.\n4. If there are, increase the prefix of those words as stated in rule 2 and update the abbreviation.\n5. Repeat steps 3 and 4 until every abbreviation is unique.\n6. Once all abbreviations are unique, return the list of abbreviations.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::string abbrev(const std::string& s, int k) {\n    int n = s.length();\n    if (k >= n - 2) {\n        return s;\n    }\n    return s.substr(0, k + 1) + std::to_string(n - k - 2) + s.back();\n}\n\nstd::vector<std::string> wordsAbbreviation(std::vector<std::string>& words) {\n    int n = words.size();\n    std::vector<std::string> abbr;\n    std::vector<int> prefixLen(n, 1);\n\n    for (int i = 0; i < n; ++i) {\n        abbr.push_back(abbrev(words[i], 1));\n    }\n\n    for (int i = 0; i < n; ++i) {\n        while (true) {\n            std::unordered_map<std::string, std::vector<int>> groups;\n            for (int j = i + 1; j < n; ++j) {\n                if (abbr[i] == abbr[j]) {\n                    groups[abbr[j]].push_back(j);\n                }\n            }\n            if (groups.empty()) {\n                break;\n            }\n            for (const auto &group : groups) {\n                for (int id : group.second) {\n                    abbr[id] = abbrev(words[id], ++prefixLen[id]);\n                }\n            }\n            abbr[i] = abbrev(words[i], ++prefixLen[i]);\n        }\n    }\n\n    return abbr;\n}\n```\n    \n    1. Initialize abbreviation lists and prefix lengths for each word.\n2. For each word, calculate its initial abbreviation based on the rule 1.\n3. Check if there are any words that share the same abbreviation.\n4. If there are, increase the prefix of those words as stated in rule 2 and update the abbreviation.\n5. Repeat steps 3 and 4 until every abbreviation is unique.\n6. Once all abbreviations are unique, return the list of abbreviations.\n    ", "python": "\n    ```python\ndef wordsAbbreviation(words):\n    def abbrev(word, k):\n        return word[:k+1] + str(len(word) - k - 2) + word[-1] if k < len(word) - 2 else word\n\n    n = len(words)\n    abbr = [abbrev(word, 1) for word in words]\n    prefix_len = [1] * n\n\n    for i in range(n):\n        while abbr.count(abbr[i]) > 1:\n            groups = {}\n            for j in range(i + 1, n):\n                if abbr[i] == abbr[j]:\n                    if abbr[j] not in groups:\n                        groups[abbr[j]] = []\n                    groups[abbr[j]].append(j)\n            for group_members in groups.values():\n                for j in group_members:\n                    abbr[j] = abbrev(words[j], prefix_len[j] + 1)\n                    prefix_len[j] += 1\n            abbr[i] = abbrev(words[i], prefix_len[i] + 1)\n            prefix_len[i] += 1\n\n    return abbr\n```\n    \n    1. Initialize abbreviation lists and prefix lengths for each word.\n2. For each word, calculate its initial abbreviation based on the rule 1.\n3. Check if there are any words that share the same abbreviation.\n4. If there are, increase the prefix of those words as stated in rule 2 and update the abbreviation.\n5. Repeat steps 3 and 4 until every abbreviation is unique.\n6. Once all abbreviations are unique, return the list of abbreviations.\n    ", "javascript": "\n    ```javascript\nfunction wordsAbbreviation(words) {\n    function abbrev(word, k) {\n        return k < word.length - 2 ? word.slice(0, k + 1) + (word.length - k - 2) + word.slice(-1) : word;\n    }\n\n    const n = words.length;\n    const abbr = words.map(word => abbrev(word, 1));\n    const prefixLen = new Array(n).fill(1);\n\n    for (let i = 0; i < n; i++) {\n        while (abbr.filter(a => a === abbr[i]).length > 1) {\n            const groups = {};\n            for (let j = i + 1; j < n; j++) {\n                if (abbr[i] === abbr[j]) {\n                    if (!groups[abbr[j]]) {\n                        groups[abbr[j]] = [];\n                    }\n                    groups[abbr[j]].push(j);\n                }\n            }\n            for (const groupMembers of Object.values(groups)) {\n                for (const j of groupMembers) {\n                    abbr[j] = abbrev(words[j], prefixLen[j] + 1);\n                    prefixLen[j]++;\n                }\n            }\n            abbr[i] = abbrev(words[i], prefixLen[i] + 1);\n            prefixLen[i]++;\n        }\n    }\n\n    return abbr;\n}\n```\n    \n    1. Initialize abbreviation lists and prefix lengths for each word.\n2. For each word, calculate its initial abbreviation based on the rule 1.\n3. Check if there are any words that share the same abbreviation.\n4. If there are, increase the prefix of those words as stated in rule 2 and update the abbreviation.\n5. Repeat steps 3 and 4 until every abbreviation is unique.\n6. Once all abbreviations are unique, return the list of abbreviations.\n    "}
{"id": 555, "slug": "split-concatenated-strings", "title": "Split Concatenated Strings", "difficulty": "Medium", "content": "You are given an array of strings `strs`. You could concatenate these strings together into a loop, where for each string, you could choose to reverse it or not. Among all the possible loops\n\nReturn _the lexicographically largest string after cutting the loop, which will make the looped string into a regular one_.\n\nSpecifically, to find the lexicographically largest string, you need to experience two phases:\n\n1.  Concatenate all the strings into a loop, where you can reverse some strings or not and connect them in the same order as given.\n2.  Cut and make one breakpoint in any place of the loop, which will make the looped string into a regular one starting from the character at the cutpoint.\n\nAnd your job is to find the lexicographically largest one among all the possible regular strings.\n\n**Example 1:**\n\n**Input:** strs = \\[ \"abc \", \"xyz \"\\]\n**Output:**  \"zyxcba \"\n**Explanation:** You can get the looped string  \"-abcxyz- \",  \"-abczyx- \",  \"-cbaxyz- \",  \"-cbazyx- \", where '-' represents the looped status. \nThe answer string came from the fourth looped one, where you could cut from the middle character 'a' and get  \"zyxcba \".\n\n**Example 2:**\n\n**Input:** strs = \\[ \"abc \"\\]\n**Output:**  \"cba \"\n\n**Constraints:**\n\n*   `1 <= strs.length <= 1000`\n*   `1 <= strs[i].length <= 1000`\n*   `1 <= sum(strs[i].length) <= 1000`\n*   `strs[i]` consists of lowercase English letters.", "java": "\n    ```java\nimport java.util.*;\n\npublic String splitLoopedString(String[] strs) {\n    String ans = \"\", cur = \"\";\n    for (String s : strs) {\n        String rev = new StringBuilder(s).reverse().toString();\n        cur += (s.compareTo(rev) > 0) ? s : rev;\n    }\n\n    for (int i = 0, k = 0; i < strs.length; i++) {\n        String rev = new StringBuilder(strs[i]).reverse().toString();\n        for (String xstr : Arrays.asList(strs[i], rev)) {\n            for (int j = 0; j < xstr.length(); j++) {\n                String t = xstr.substring(j) + cur.substring(k + xstr.length()) + cur.substring(0, k) + xstr.substring(0, j);\n                ans = ans.compareTo(t) > 0 ? ans : t;\n            }\n        }\n        k += strs[i].length();\n    }\n    return ans;\n}\n```\n    \n    The algorithm finds the lexicographically largest string in two steps. First, it concatenates all input strings into one looped string, choosing to use either the original string or its reverse for each string, based on which one is lexicographically larger. This way the looped string contains the maximum possible characters.\n\nAfter creating the looped string, it iterates through all possible breakpoints in the loop. For each breakpoint, it constructs a regular string by moving the characters from the breakpoint to the end of the loop to the beginning of the new regular string, and checks whether the newly constructed string is lexicographically larger than the current maximum string. If it is, it updates the maximum string.\n\nThe time complexity of this algorithm is O(N*L^2) where N is the number of strings, and L is the length of the strings. This is because, in the worst case, the algorithm iterates through all strings (N), all possible breakpoints (L), and all characters of the string (L).\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string splitLoopedString(std::vector<std::string>& strs) {\n    std::string ans;\n    std::string cur;\n    for (auto &s : strs) {\n        std::string rev(s.rbegin(), s.rend());\n        cur += std::max(s, rev);\n    }\n\n    for (size_t i = 0, k = 0; i < strs.size(); ++i) {\n        std::string rev(strs[i].rbegin(), strs[i].rend());\n        for (auto &xstr : {strs[i], rev}) {\n            for (size_t j = 0; j < xstr.size(); ++j) {\n                std::string t = xstr.substr(j) + cur.substr(k + xstr.size()) + cur.substr(0, k) + xstr.substr(0, j);\n                ans = std::max(ans, t);\n            }\n        }\n        k += strs[i].size();\n    }\n    return ans;\n}\n```\n    \n    The algorithm finds the lexicographically largest string in two steps. First, it concatenates all input strings into one looped string, choosing to use either the original string or its reverse for each string, based on which one is lexicographically larger. This way the looped string contains the maximum possible characters.\n\nAfter creating the looped string, it iterates through all possible breakpoints in the loop. For each breakpoint, it constructs a regular string by moving the characters from the breakpoint to the end of the loop to the beginning of the new regular string, and checks whether the newly constructed string is lexicographically larger than the current maximum string. If it is, it updates the maximum string.\n\nThe time complexity of this algorithm is O(N*L^2) where N is the number of strings, and L is the length of the strings. This is because, in the worst case, the algorithm iterates through all strings (N), all possible breakpoints (L), and all characters of the string (L).\n    ", "python": "\n    ```python\ndef splitLoopedString(strs):\n    ans = ''\n    cur = ''.join(max(s, s[::-1]) for s in strs)\n    \n    for i, s in enumerate(strs):\n        for xstr in (s, s[::-1]):\n            for j in range(len(xstr)):\n                t = xstr[j:] + cur[len(xstr):] + cur[:len(xstr)] + xstr[:j]\n                ans = max(ans, t)\n        cur = cur[len(s):] + cur[:len(s)]\n    \n    return ans\n```\n\n    \n    The algorithm finds the lexicographically largest string in two steps. First, it concatenates all input strings into one looped string, choosing to use either the original string or its reverse for each string, based on which one is lexicographically larger. This way the looped string contains the maximum possible characters.\n\nAfter creating the looped string, it iterates through all possible breakpoints in the loop. For each breakpoint, it constructs a regular string by moving the characters from the breakpoint to the end of the loop to the beginning of the new regular string, and checks whether the newly constructed string is lexicographically larger than the current maximum string. If it is, it updates the maximum string.\n\nThe time complexity of this algorithm is O(N*L^2) where N is the number of strings, and L is the length of the strings. This is because, in the worst case, the algorithm iterates through all strings (N), all possible breakpoints (L), and all characters of the string (L).\n    ", "javascript": "\n    ```javascript\nfunction splitLoopedString(strs) {\n    let ans = \"\", cur = \"\";\n    strs.forEach(s => {\n        const rev = s.split('').reverse().join('');\n        cur += s > rev ? s : rev;\n    });\n\n    for (let i = 0, k = 0; i < strs.length; i++) {\n        let rev = strs[i].split('').reverse().join('');\n        [strs[i], rev].forEach(xstr => {\n            for (let j = 0; j < xstr.length; j++) {\n                let t = xstr.slice(j) + cur.slice(k + xstr.length) + cur.slice(0, k) + xstr.slice(0, j);\n                ans = ans > t ? ans : t;\n            }\n        });\n        k += strs[i].length;\n    }\n    return ans;\n}\n```\n    \n    The algorithm finds the lexicographically largest string in two steps. First, it concatenates all input strings into one looped string, choosing to use either the original string or its reverse for each string, based on which one is lexicographically larger. This way the looped string contains the maximum possible characters.\n\nAfter creating the looped string, it iterates through all possible breakpoints in the loop. For each breakpoint, it constructs a regular string by moving the characters from the breakpoint to the end of the loop to the beginning of the new regular string, and checks whether the newly constructed string is lexicographically larger than the current maximum string. If it is, it updates the maximum string.\n\nThe time complexity of this algorithm is O(N*L^2) where N is the number of strings, and L is the length of the strings. This is because, in the worst case, the algorithm iterates through all strings (N), all possible breakpoints (L), and all characters of the string (L).\n    "}
{"id": 561, "slug": "array-partition", "title": "Array Partition", "difficulty": "Easy", "content": "Given an integer array `nums` of `2n` integers, group these integers into `n` pairs `(a1, b1), (a2, b2), ..., (an, bn)` such that the sum of `min(ai, bi)` for all `i` is **maximized**. Return _the maximized sum_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,4,3,2\\]\n**Output:** 4\n**Explanation:** All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4.\n\n**Example 2:**\n\n**Input:** nums = \\[6,2,6,5,1,2\\]\n**Output:** 9\n**Explanation:** The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\n*   `nums.length == 2 * n`\n*   `-104 <= nums[i] <= 104`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int arrayPairSum(int[] nums) {\n    Arrays.sort(nums);\n    int sum = 0;\n    for (int i = 0; i < nums.length; i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}\n```\n    \n    1. First, sort the given 'nums' array/vector in ascending order.\n2. Iterate over the sorted array, with a step of 2, starting from index 0.\n3. During the iteration, accumulate the sum of every ith element (from sorted array) to maximize the sum of minimum elements in pairs.\n4. Return the accumulated sum.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint arrayPairSum(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int sum = 0;\n    for (int i = 0; i < nums.size(); i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}\n```\n    \n    1. First, sort the given 'nums' array/vector in ascending order.\n2. Iterate over the sorted array, with a step of 2, starting from index 0.\n3. During the iteration, accumulate the sum of every ith element (from sorted array) to maximize the sum of minimum elements in pairs.\n4. Return the accumulated sum.\n    ", "python": "\n    ```python\ndef array_pair_sum(nums):\n    nums.sort()\n    return sum(nums[::2])\n```\n    \n    1. First, sort the given 'nums' array/vector in ascending order.\n2. Iterate over the sorted array, with a step of 2, starting from index 0.\n3. During the iteration, accumulate the sum of every ith element (from sorted array) to maximize the sum of minimum elements in pairs.\n4. Return the accumulated sum.\n    ", "javascript": "\n    ```javascript\nfunction arrayPairSum(nums) {\n    nums.sort((a, b) => a - b);\n    let sum = 0;\n    for (let i = 0; i < nums.length; i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}\n```\n    \n    1. First, sort the given 'nums' array/vector in ascending order.\n2. Iterate over the sorted array, with a step of 2, starting from index 0.\n3. During the iteration, accumulate the sum of every ith element (from sorted array) to maximize the sum of minimum elements in pairs.\n4. Return the accumulated sum.\n    "}
{"id": 581, "slug": "shortest-unsorted-continuous-subarray", "title": "Shortest Unsorted Continuous Subarray", "difficulty": "Medium", "content": "Given an integer array `nums`, you need to find one **continuous subarray** that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.\n\nReturn _the shortest such subarray and output its length_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,6,4,8,10,9,15\\]\n**Output:** 5\n**Explanation:** You need to sort \\[6, 4, 8, 10, 9\\] in ascending order to make the whole array sorted in ascending order.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 0\n\n**Example 3:**\n\n**Input:** nums = \\[1\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-105 <= nums[i] <= 105`\n\n**Follow up:** Can you solve it in `O(n)` time complexity?", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int findUnsortedSubarray(int[] nums) {\n    int[] sortedNums = nums.clone();\n    Arrays.sort(sortedNums);\n    int start = 0, end = nums.length - 1;\n    while (start < nums.length && nums[start] == sortedNums[start]) start++;\n    while (end > start && nums[end] == sortedNums[end]) end--;\n    return end - start + 1;\n}\n```\n    \n    1. Create a copy of the input array and sort it in ascending order.\n2. Initialize two variables, `start` and `end`, to check the boundaries of the unsorted subarray.\n3. Loop through the array, comparing the sorted copy and the original array. When we encounter a mismatch at some index, we break the loop and store the index in `start`. This `start` index is the beginning of the unsorted subarray.\n4. Similarly, we start from the end of the array and find the first mismatch. We store this index in `end`. This `end` index is the boundary of the unsorted subarray.\n5. Calculate the length of the unsorted subarray as `end - start + 1`.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint findUnsortedSubarray(vector<int>& nums) {\n    vector<int> sorted_nums(nums);\n    sort(sorted_nums.begin(), sorted_nums.end());\n    int start = 0, end = nums.size() - 1;\n    while (start < nums.size() && nums[start] == sorted_nums[start]) start++;\n    while (end > start && nums[end] == sorted_nums[end]) end--;\n    return end - start + 1;\n}\n```\n    \n    1. Create a copy of the input array and sort it in ascending order.\n2. Initialize two variables, `start` and `end`, to check the boundaries of the unsorted subarray.\n3. Loop through the array, comparing the sorted copy and the original array. When we encounter a mismatch at some index, we break the loop and store the index in `start`. This `start` index is the beginning of the unsorted subarray.\n4. Similarly, we start from the end of the array and find the first mismatch. We store this index in `end`. This `end` index is the boundary of the unsorted subarray.\n5. Calculate the length of the unsorted subarray as `end - start + 1`.\n    ", "python": "\n    ```python\ndef findUnsortedSubarray(nums):\n    sorted_nums = sorted(nums)\n    start, end = 0, len(nums) - 1\n    while start < len(nums) and nums[start] == sorted_nums[start]:\n        start += 1\n    while end > start and nums[end] == sorted_nums[end]:\n        end -= 1\n    return end - start + 1\n```\n    \n    1. Create a copy of the input array and sort it in ascending order.\n2. Initialize two variables, `start` and `end`, to check the boundaries of the unsorted subarray.\n3. Loop through the array, comparing the sorted copy and the original array. When we encounter a mismatch at some index, we break the loop and store the index in `start`. This `start` index is the beginning of the unsorted subarray.\n4. Similarly, we start from the end of the array and find the first mismatch. We store this index in `end`. This `end` index is the boundary of the unsorted subarray.\n5. Calculate the length of the unsorted subarray as `end - start + 1`.\n    ", "javascript": "\n    ```javascript\nfunction findUnsortedSubarray(nums) {\n    const sortedNums = [...nums].sort((a, b) => a - b);\n    let start = 0, end = nums.length - 1;\n    while (start < nums.length && nums[start] === sortedNums[start]) start++;\n    while (end > start && nums[end] === sortedNums[end]) end--;\n    return end - start + 1;\n}\n```\n    \n    1. Create a copy of the input array and sort it in ascending order.\n2. Initialize two variables, `start` and `end`, to check the boundaries of the unsorted subarray.\n3. Loop through the array, comparing the sorted copy and the original array. When we encounter a mismatch at some index, we break the loop and store the index in `start`. This `start` index is the beginning of the unsorted subarray.\n4. Similarly, we start from the end of the array and find the first mismatch. We store this index in `end`. This `end` index is the boundary of the unsorted subarray.\n5. Calculate the length of the unsorted subarray as `end - start + 1`.\n    "}
{"id": 605, "slug": "can-place-flowers", "title": "Can Place Flowers", "difficulty": "Easy", "content": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in **adjacent** plots.\n\nGiven an integer array `flowerbed` containing `0`'s and `1`'s, where `0` means empty and `1` means not empty, and an integer `n`, return `true` _if_ `n` _new flowers can be planted in the_ `flowerbed` _without violating the no-adjacent-flowers rule and_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** flowerbed = \\[1,0,0,0,1\\], n = 1\n**Output:** true\n\n**Example 2:**\n\n**Input:** flowerbed = \\[1,0,0,0,1\\], n = 2\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= flowerbed.length <= 2 * 104`\n*   `flowerbed[i]` is `0` or `1`.\n*   There are no two adjacent flowers in `flowerbed`.\n*   `0 <= n <= flowerbed.length`", "java": "\n    ```java\npublic boolean canPlaceFlowers(int[] flowerbed, int n) {\n    int count = 0;\n    for(int i = 0; i < flowerbed.length; i++) {\n        if(flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) {\n            flowerbed[i] = 1;\n            count++;\n        }\n        if(count >= n) return true;\n    }\n    return count >= n;\n}\n```\n\n    \n    1. Initialize a variable `count` to keep track of the number of flowers planted.\n2. Iterate through the flowerbed with a variable `i`.\n3. Check the possibility of planting flowers at the current index:\n   - If `flowerbed[i]` is already 0,\n   - `i` is 0 (first plot) or the plot before the current plot is empty,\n   - `i` is the last plot or the plot after the current plot is empty.\n4. If all these conditions are met, plant a flower at the current plot by setting `flowerbed[i]` to 1 and increment the count.\n5. If the count is equal to or greater than `n`, return true.\n6. After iterating through the entire array, if the count is still equal to or greater than `n`, return true; otherwise, return false.\n    ", "c++": "\n    ```cpp\nbool canPlaceFlowers(vector<int>& flowerbed, int n) {\n    int count = 0;\n    for(int i = 0; i < flowerbed.size(); i++) {\n        if(flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) {\n            flowerbed[i] = 1;\n            count++;\n        }\n        if(count >= n) return true;\n    }\n    return count >= n;\n}\n```\n\n    \n    1. Initialize a variable `count` to keep track of the number of flowers planted.\n2. Iterate through the flowerbed with a variable `i`.\n3. Check the possibility of planting flowers at the current index:\n   - If `flowerbed[i]` is already 0,\n   - `i` is 0 (first plot) or the plot before the current plot is empty,\n   - `i` is the last plot or the plot after the current plot is empty.\n4. If all these conditions are met, plant a flower at the current plot by setting `flowerbed[i]` to 1 and increment the count.\n5. If the count is equal to or greater than `n`, return true.\n6. After iterating through the entire array, if the count is still equal to or greater than `n`, return true; otherwise, return false.\n    ", "python": "\n    ```python\ndef canPlaceFlowers(flowerbed, n):\n    count = 0\n    for i in range(len(flowerbed)):\n        if flowerbed[i] == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):\n            flowerbed[i] = 1\n            count += 1\n        if count >= n:\n            return True\n    return count >= n\n```\n\n    \n    1. Initialize a variable `count` to keep track of the number of flowers planted.\n2. Iterate through the flowerbed with a variable `i`.\n3. Check the possibility of planting flowers at the current index:\n   - If `flowerbed[i]` is already 0,\n   - `i` is 0 (first plot) or the plot before the current plot is empty,\n   - `i` is the last plot or the plot after the current plot is empty.\n4. If all these conditions are met, plant a flower at the current plot by setting `flowerbed[i]` to 1 and increment the count.\n5. If the count is equal to or greater than `n`, return true.\n6. After iterating through the entire array, if the count is still equal to or greater than `n`, return true; otherwise, return false.\n    ", "javascript": "\n    ```javascript\nfunction canPlaceFlowers(flowerbed, n) {\n    let count = 0;\n    for(let i = 0; i < flowerbed.length; i++) {\n        if(flowerbed[i] === 0 && (i === 0 || flowerbed[i - 1] === 0) && (i === flowerbed.length - 1 || flowerbed[i + 1] === 0)) {\n            flowerbed[i] = 1;\n            count++;\n        }\n        if(count >= n) return true;\n    }\n    return count >= n;\n}\n```\n\n    \n    1. Initialize a variable `count` to keep track of the number of flowers planted.\n2. Iterate through the flowerbed with a variable `i`.\n3. Check the possibility of planting flowers at the current index:\n   - If `flowerbed[i]` is already 0,\n   - `i` is 0 (first plot) or the plot before the current plot is empty,\n   - `i` is the last plot or the plot after the current plot is empty.\n4. If all these conditions are met, plant a flower at the current plot by setting `flowerbed[i]` to 1 and increment the count.\n5. If the count is equal to or greater than `n`, return true.\n6. After iterating through the entire array, if the count is still equal to or greater than `n`, return true; otherwise, return false.\n    "}
{"id": 611, "slug": "valid-triangle-number", "title": "Valid Triangle Number", "difficulty": "Medium", "content": "Given an integer array `nums`, return _the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,2,3,4\\]\n**Output:** 3\n**Explanation:** Valid combinations are: \n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3\n\n**Example 2:**\n\n**Input:** nums = \\[4,2,3,4\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 1000`", "java": "\n    ```java\npublic int triangleNumber(int[] nums) {\n    Arrays.sort(nums);\n    int count = 0;\n    for (int i = 0; i < nums.length; ++i) {\n        for (int j = i + 1; j < nums.length; ++j) {\n            for (int k = j + 1; k < nums.length; ++k) {\n                if (nums[i] + nums[j] > nums[k]) {\n                    count++;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    1. Sort the given array in ascending order.\n2. Iterate through the sorted array using three nested loops i, j, and k, where i < j < k. The loops go through possible triplet candidates (nums[i], nums[j], nums[k]).\n3. For each triplet, check if nums[i] + nums[j] > nums[k]. If true, it satisfies the triangle inequality property, and we increase the count.\n4. If nums[i] + nums[j] is not greater than nums[k], it means no other k value will satisfy the triangle inequality with the current i and j values. So, we break the innermost loop.\n5. Return the count, which is the number of valid triplets.\n    ", "c++": "\n    ```cpp\nint triangleNumber(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int count = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        for (int j = i + 1; j < nums.size(); ++j) {\n            for (int k = j + 1; k < nums.size(); ++k) {\n                if (nums[i] + nums[j] > nums[k]) {\n                    ++count;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    1. Sort the given array in ascending order.\n2. Iterate through the sorted array using three nested loops i, j, and k, where i < j < k. The loops go through possible triplet candidates (nums[i], nums[j], nums[k]).\n3. For each triplet, check if nums[i] + nums[j] > nums[k]. If true, it satisfies the triangle inequality property, and we increase the count.\n4. If nums[i] + nums[j] is not greater than nums[k], it means no other k value will satisfy the triangle inequality with the current i and j values. So, we break the innermost loop.\n5. Return the count, which is the number of valid triplets.\n    ", "python": "\n    ```python\ndef triangleNumber(nums: list) -> int:\n    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] + nums[j] > nums[k]:\n                    count += 1\n                else:\n                    break\n    return count\n```\n    \n    1. Sort the given array in ascending order.\n2. Iterate through the sorted array using three nested loops i, j, and k, where i < j < k. The loops go through possible triplet candidates (nums[i], nums[j], nums[k]).\n3. For each triplet, check if nums[i] + nums[j] > nums[k]. If true, it satisfies the triangle inequality property, and we increase the count.\n4. If nums[i] + nums[j] is not greater than nums[k], it means no other k value will satisfy the triangle inequality with the current i and j values. So, we break the innermost loop.\n5. Return the count, which is the number of valid triplets.\n    ", "javascript": "\n    ```javascript\nfunction triangleNumber(nums) {\n    nums.sort((a, b) => a - b);\n    let count = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        for (let j = i + 1; j < nums.length; ++j) {\n            for (let k = j + 1; k < nums.length; ++k) {\n                if (nums[i] + nums[j] > nums[k]) {\n                    count++;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    1. Sort the given array in ascending order.\n2. Iterate through the sorted array using three nested loops i, j, and k, where i < j < k. The loops go through possible triplet candidates (nums[i], nums[j], nums[k]).\n3. For each triplet, check if nums[i] + nums[j] > nums[k]. If true, it satisfies the triangle inequality property, and we increase the count.\n4. If nums[i] + nums[j] is not greater than nums[k], it means no other k value will satisfy the triangle inequality with the current i and j values. So, we break the innermost loop.\n5. Return the count, which is the number of valid triplets.\n    "}
{"id": 621, "slug": "task-scheduler", "title": "Task Scheduler", "difficulty": "Medium", "content": "Given a characters array `tasks`, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\n\nHowever, there is a non-negative integer `n` that represents the cooldown period between two **same tasks** (the same letter in the array), that is that there must be at least `n` units of time between any two same tasks.\n\nReturn _the least number of units of times that the CPU will take to finish all the given tasks_.\n\n**Example 1:**\n\n**Input:** tasks = \\[ \"A \", \"A \", \"A \", \"B \", \"B \", \"B \"\\], n = 2\n**Output:** 8\n**Explanation:** \nA -> B -> idle -> A -> B -> idle -> A -> B\nThere is at least 2 units of time between any two same tasks.\n\n**Example 2:**\n\n**Input:** tasks = \\[ \"A \", \"A \", \"A \", \"B \", \"B \", \"B \"\\], n = 0\n**Output:** 6\n**Explanation:** On this case any permutation of size 6 would work since n = 0.\n\\[ \"A \", \"A \", \"A \", \"B \", \"B \", \"B \"\\]\n\\[ \"A \", \"B \", \"A \", \"B \", \"A \", \"B \"\\]\n\\[ \"B \", \"B \", \"B \", \"A \", \"A \", \"A \"\\]\n...\nAnd so on.\n\n**Example 3:**\n\n**Input:** tasks = \\[ \"A \", \"A \", \"A \", \"A \", \"A \", \"A \", \"B \", \"C \", \"D \", \"E \", \"F \", \"G \"\\], n = 2\n**Output:** 16\n**Explanation:** \nOne possible solution is\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\n\n**Constraints:**\n\n*   `1 <= task.length <= 104`\n*   `tasks[i]` is upper-case English letter.\n*   The integer `n` is in the range `[0, 100]`.", "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\n\npublic int leastInterval(char[] tasks, int n) {\n    HashMap<Character, Integer> taskFreq = new HashMap<>();\n    for (char task : tasks) {\n        taskFreq.put(task, taskFreq.getOrDefault(task, 0) + 1);\n    }\n\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\n    maxHeap.addAll(taskFreq.values());\n\n    int cycles = 0;\n\n    while (!maxHeap.isEmpty()) {\n        List<Integer> temp = new ArrayList<>();\n        for (int i = 0; i < n + 1; i++) {\n            if (!maxHeap.isEmpty()) {\n                temp.add(maxHeap.remove());\n            }\n        }\n\n        for (int freq : temp) {\n            if (--freq > 0) {\n                maxHeap.add(freq);\n            }\n        }\n\n        cycles += maxHeap.isEmpty() ? temp.size() : n + 1;\n    }\n\n    return cycles;\n}\n```\n\n    \n    1. Count the frequency of each task using a HashMap, and store these frequencies in a sorted array or list (sorted in descending order).\n2. Calculate the maximum frequency (max_f) of a task, and the total number of idle slots required between tasks with this frequency. This is done by multiplying (max_f - 1) by the cooldown time (n).\n3. Iterate through the remaining task frequencies, decrementing the idle slots by the minimum of the current task frequency and max_f.\n4. If there are remaining idle slots, add this value to the total number of tasks to get the least number of units of time needed to complete all tasks. Otherwise, just return the total number of tasks, as there is no need for any idle time.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nint leastInterval(std::vector<char>& tasks, int n) {\n    std::unordered_map<char, int> task_freq;\n    for (char task : tasks) {\n        task_freq[task]++;\n    }\n\n    std::vector<int> frequencies;\n    for (auto entry : task_freq) {\n        frequencies.push_back(entry.second);\n    }\n\n    std::sort(frequencies.rbegin(), frequencies.rend());\n\n    int max_f = frequencies[0] - 1;\n    int idle_slots = max_f * n;\n\n    for (int i = 1; i < frequencies.size(); i++) {\n        idle_slots -= std::min(frequencies[i], max_f);\n    }\n\n    return idle_slots > 0 ? idle_slots + tasks.size() : tasks.size();\n}\n```\n\n    \n    1. Count the frequency of each task using a HashMap, and store these frequencies in a sorted array or list (sorted in descending order).\n2. Calculate the maximum frequency (max_f) of a task, and the total number of idle slots required between tasks with this frequency. This is done by multiplying (max_f - 1) by the cooldown time (n).\n3. Iterate through the remaining task frequencies, decrementing the idle slots by the minimum of the current task frequency and max_f.\n4. If there are remaining idle slots, add this value to the total number of tasks to get the least number of units of time needed to complete all tasks. Otherwise, just return the total number of tasks, as there is no need for any idle time.\n    ", "python": "\n    ```python\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    task_freq = Counter(tasks)\n\n    max_f = max(task_freq.values())\n    max_count = sum(1 for count in task_freq.values() if count == max_f)\n\n    return max(len(tasks), (max_f - 1) * (n + 1) + max_count)\n```\n\n    \n    1. Count the frequency of each task using a HashMap, and store these frequencies in a sorted array or list (sorted in descending order).\n2. Calculate the maximum frequency (max_f) of a task, and the total number of idle slots required between tasks with this frequency. This is done by multiplying (max_f - 1) by the cooldown time (n).\n3. Iterate through the remaining task frequencies, decrementing the idle slots by the minimum of the current task frequency and max_f.\n4. If there are remaining idle slots, add this value to the total number of tasks to get the least number of units of time needed to complete all tasks. Otherwise, just return the total number of tasks, as there is no need for any idle time.\n    ", "javascript": "\n    ```javascript\nfunction leastInterval(tasks, n) {\n    const taskFreq = {};\n    tasks.forEach(task => {\n        taskFreq[task] = (taskFreq[task] || 0) + 1;\n    });\n\n    const frequencies = Object.values(taskFreq).sort((a, b) => b - a);\n\n    const maxF = frequencies[0] - 1;\n    let idleSlots = maxF * n;\n\n    for (let i = 1; i < frequencies.length; i++) {\n        idleSlots -= Math.min(frequencies[i], maxF);\n    }\n\n    return idleSlots > 0 ? idleSlots + tasks.length : tasks.length;\n}\n```\n\n    \n    1. Count the frequency of each task using a HashMap, and store these frequencies in a sorted array or list (sorted in descending order).\n2. Calculate the maximum frequency (max_f) of a task, and the total number of idle slots required between tasks with this frequency. This is done by multiplying (max_f - 1) by the cooldown time (n).\n3. Iterate through the remaining task frequencies, decrementing the idle slots by the minimum of the current task frequency and max_f.\n4. If there are remaining idle slots, add this value to the total number of tasks to get the least number of units of time needed to complete all tasks. Otherwise, just return the total number of tasks, as there is no need for any idle time.\n    "}
{"id": 624, "slug": "maximum-distance-in-arrays", "title": "Maximum Distance in Arrays", "difficulty": "Medium", "content": "You are given `m` `arrays`, where each array is sorted in **ascending order**.\n\nYou can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers `a` and `b` to be their absolute difference `|a - b|`.\n\nReturn _the maximum distance_.\n\n**Example 1:**\n\n**Input:** arrays = \\[\\[1,2,3\\],\\[4,5\\],\\[1,2,3\\]\\]\n**Output:** 4\n**Explanation:** One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.\n\n**Example 2:**\n\n**Input:** arrays = \\[\\[1\\],\\[1\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `m == arrays.length`\n*   `2 <= m <= 105`\n*   `1 <= arrays[i].length <= 500`\n*   `-104 <= arrays[i][j] <= 104`\n*   `arrays[i]` is sorted in **ascending order**.\n*   There will be at most `105` integers in all the arrays.", "java": "\n    ```java\npublic int maxDistance(List<List<Integer>> arrays) {\n    int max_dist = 0, min_val = arrays.get(0).get(0), max_val = arrays.get(0).get(arrays.get(0).size() - 1);\n    for (int i = 1; i < arrays.size(); i++) {\n        max_dist = Math.max(max_dist, Math.max(\n                Math.abs(arrays.get(i).get(arrays.get(i).size() - 1) - min_val),\n                Math.abs(max_val - arrays.get(i).get(0))\n        ));\n        min_val = Math.min(min_val, arrays.get(i).get(0));\n        max_val = Math.max(max_val, arrays.get(i).get(arrays.get(i).size() - 1));\n    }\n    return max_dist;\n}\n```\n    \n    We start by initializing the `max_dist` as 0, and get the minimum and maximum values from the first array in the list. Then, we iterate through the other arrays starting from index 1. For each array, we calculate the maximum distance between the current minimum value and the last element of that array, or the current maximum value and the first element of the current array. Using the calculated maximum distance, we update the maximum distance `max_dist` if it exceeds the current value. Finally, we update the minimum and maximum values with the minimum and maximum of the current array. This approach ensures that we are considering the possible array combinations without calculating every possible pair.\n    ", "c++": "\n    ```cpp\nint maxDistance(vector<vector<int>>& arrays) {\n    int max_dist = 0, min_val = arrays[0][0], max_val = arrays[0].back();\n    for(int i = 1; i < arrays.size(); i++) {\n        max_dist = max(max_dist, max(abs(arrays[i].back() - min_val), abs(max_val - arrays[i][0])));\n        min_val = min(min_val, arrays[i][0]);\n        max_val = max(max_val, arrays[i].back());\n    }\n    return max_dist;\n}\n```\n    \n    We start by initializing the `max_dist` as 0, and get the minimum and maximum values from the first array in the list. Then, we iterate through the other arrays starting from index 1. For each array, we calculate the maximum distance between the current minimum value and the last element of that array, or the current maximum value and the first element of the current array. Using the calculated maximum distance, we update the maximum distance `max_dist` if it exceeds the current value. Finally, we update the minimum and maximum values with the minimum and maximum of the current array. This approach ensures that we are considering the possible array combinations without calculating every possible pair.\n    ", "python": "\n    ```python\ndef maxDistance(arrays: List[List[int]]) -> int:\n    max_dist = 0\n    min_val = arrays[0][0]\n    max_val = arrays[0][-1]\n    \n    for arr in arrays[1:]:\n        max_dist = max(max_dist, max(abs(arr[-1] - min_val), abs(max_val - arr[0])))\n        min_val = min(min_val, arr[0])\n        max_val = max(max_val, arr[-1])\n        \n    return max_dist\n```\n    \n    We start by initializing the `max_dist` as 0, and get the minimum and maximum values from the first array in the list. Then, we iterate through the other arrays starting from index 1. For each array, we calculate the maximum distance between the current minimum value and the last element of that array, or the current maximum value and the first element of the current array. Using the calculated maximum distance, we update the maximum distance `max_dist` if it exceeds the current value. Finally, we update the minimum and maximum values with the minimum and maximum of the current array. This approach ensures that we are considering the possible array combinations without calculating every possible pair.\n    ", "javascript": "\n    ```javascript\nvar maxDistance = function(arrays) {\n    let max_dist = 0;\n    let min_val = arrays[0][0];\n    let max_val = arrays[0][arrays[0].length - 1];\n\n    for (let i = 1; i < arrays.length; i++) {\n        max_dist = Math.max(max_dist, Math.max(\n            Math.abs(arrays[i][arrays[i].length - 1] - min_val),\n            Math.abs(max_val - arrays[i][0])\n        ));\n        min_val = Math.min(min_val, arrays[i][0]);\n        max_val = Math.max(max_val, arrays[i][arrays[i].length - 1]);\n    }\n    return max_dist;\n};\n```\n    \n    We start by initializing the `max_dist` as 0, and get the minimum and maximum values from the first array in the list. Then, we iterate through the other arrays starting from index 1. For each array, we calculate the maximum distance between the current minimum value and the last element of that array, or the current maximum value and the first element of the current array. Using the calculated maximum distance, we update the maximum distance `max_dist` if it exceeds the current value. Finally, we update the minimum and maximum values with the minimum and maximum of the current array. This approach ensures that we are considering the possible array combinations without calculating every possible pair.\n    "}
{"id": 625, "slug": "minimum-factorization", "title": "Minimum Factorization", "difficulty": "Medium", "content": "Given a positive integer num, return _the smallest positive integer_ `x` _whose multiplication of each digit equals_ `num`. If there is no answer or the answer is not fit in **32-bit** signed integer, return `0`.\n\n**Example 1:**\n\n**Input:** num = 48\n**Output:** 68\n\n**Example 2:**\n\n**Input:** num = 15\n**Output:** 35\n\n**Constraints:**\n\n*   `1 <= num <= 231 - 1`", "java": "\n    ```java\npublic int smallestFactorization(int num) {\n    if (num == 1) return 1;\n    long result = 0, factor = 1;\n    for (int i = 9; i > 1; --i) {\n        while (num % i == 0) {\n            num /= i;\n            result += i * factor;\n            factor *= 10;\n            if (result > Integer.MAX_VALUE) return 0;\n        }\n    }\n    return num == 1 ? (int) result : 0;\n}\n```\n    \n    The algorithm iterates from 9 to 2 (in reverse order) and divides the input number `num` by the current iterating value `i`. If `num` is completely divisible by `i`, the loop updates `result` by adding the current `i * factor` and updating the `factor` by multiplying it by 10. If `result` ever goes beyond the 32-bit signed integer limit, the function returns 0. The loop continues to iterate and divide `num` until `num` becomes 1 (i.e., all factors have been found) or there are no more appropriate dividers. If `num` is 1, i.e., all factors are found, the result is returned; otherwise, the function returns 0.\n    ", "c++": "\n    ```cpp\nint smallestFactorization(int num) {\n    if (num == 1) return 1;\n    long result = 0, factor = 1;\n    for (int i = 9; i > 1; --i) {\n        while (num % i == 0) {\n            num /= i;\n            result += i * factor;\n            factor *= 10;\n            if (result > INT_MAX) return 0;\n        }\n    }\n    return num == 1 ? result : 0;\n}\n```\n    \n    The algorithm iterates from 9 to 2 (in reverse order) and divides the input number `num` by the current iterating value `i`. If `num` is completely divisible by `i`, the loop updates `result` by adding the current `i * factor` and updating the `factor` by multiplying it by 10. If `result` ever goes beyond the 32-bit signed integer limit, the function returns 0. The loop continues to iterate and divide `num` until `num` becomes 1 (i.e., all factors have been found) or there are no more appropriate dividers. If `num` is 1, i.e., all factors are found, the result is returned; otherwise, the function returns 0.\n    ", "python": "\n    ```python\ndef smallestFactorization(num: int) -> int:\n    if num == 1:\n        return 1\n    result = 0\n    factor = 1\n    for i in range(9, 1, -1):\n        while num % i == 0:\n            num //= i\n            result += i * factor\n            factor *= 10\n            if result > 2**31 - 1:\n                return 0\n    return result if num == 1 else 0\n```\n    \n    The algorithm iterates from 9 to 2 (in reverse order) and divides the input number `num` by the current iterating value `i`. If `num` is completely divisible by `i`, the loop updates `result` by adding the current `i * factor` and updating the `factor` by multiplying it by 10. If `result` ever goes beyond the 32-bit signed integer limit, the function returns 0. The loop continues to iterate and divide `num` until `num` becomes 1 (i.e., all factors have been found) or there are no more appropriate dividers. If `num` is 1, i.e., all factors are found, the result is returned; otherwise, the function returns 0.\n    ", "javascript": "\n    ```javascript\nfunction smallestFactorization(num) {\n    if (num === 1) return 1;\n    let result = 0, factor = 1;\n    for (let i = 9; i > 1; --i) {\n        while (num % i === 0) {\n            num /= i;\n            result += i * factor;\n            factor *= 10;\n            if (result > (2**31 - 1)) return 0;\n        }\n    }\n    return num === 1 ? result : 0;\n}\n```\n    \n    The algorithm iterates from 9 to 2 (in reverse order) and divides the input number `num` by the current iterating value `i`. If `num` is completely divisible by `i`, the loop updates `result` by adding the current `i * factor` and updating the `factor` by multiplying it by 10. If `result` ever goes beyond the 32-bit signed integer limit, the function returns 0. The loop continues to iterate and divide `num` until `num` becomes 1 (i.e., all factors have been found) or there are no more appropriate dividers. If `num` is 1, i.e., all factors are found, the result is returned; otherwise, the function returns 0.\n    "}
{"id": 630, "slug": "course-schedule-iii", "title": "Course Schedule III", "difficulty": "Hard", "content": "There are `n` different online courses numbered from `1` to `n`. You are given an array `courses` where `courses[i] = [durationi, lastDayi]` indicate that the `ith` course should be taken **continuously** for `durationi` days and must be finished before or on `lastDayi`.\n\nYou will start on the `1st` day and you cannot take two or more courses simultaneously.\n\nReturn _the maximum number of courses that you can take_.\n\n**Example 1:**\n\n**Input:** courses = \\[\\[100,200\\],\\[200,1300\\],\\[1000,1250\\],\\[2000,3200\\]\\]\n**Output:** 3\nExplanation: \nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n\n**Example 2:**\n\n**Input:** courses = \\[\\[1,2\\]\\]\n**Output:** 1\n\n**Example 3:**\n\n**Input:** courses = \\[\\[3,2\\],\\[4,3\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= courses.length <= 104`\n*   `1 <= durationi, lastDayi <= 104`", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic int scheduleCourse(int[][] courses) {\n    Arrays.sort(courses, (a, b) -> a[1] - b[1]);\n\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n    int time = 0;\n\n    for (int[] course : courses) {\n        time += course[0];\n        pq.offer(course[0]);\n\n        if (time > course[1]) {\n            time -= pq.poll();\n        }\n    }\n\n    return pq.size();\n}\n```\n    \n    1. Sort the courses based on their deadline (lastDay).\n2. Create a max-heap (priority queue) to store the course durations.\n3. Initialize a variable `time` to track the current time (start at 0).\n4. Iterate through the sorted courses:\n   a. Add the duration to the `time`.\n   b. Push the duration to the max-heap.\n   c. If the `time` is greater than the course's deadline, then remove the longest duration from max-heap and subtract it from `time`.\n5. Return the size of the max-heap, which represents the number of courses that can be taken.\n\nBy sorting the courses by deadline and using a max-heap to store durations, we can efficiently determine which courses to take and which to drop when the deadline is not met. This greedy approach ensures that at each iteration, the optimal solution is reached up to the current course.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nint scheduleCourse(std::vector<std::vector<int>>& courses) {\n    std::sort(courses.begin(), courses.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    std::priority_queue<int> pq;\n    int time = 0;\n\n    for (const auto& course : courses) {\n        time += course[0];\n        pq.push(course[0]);\n\n        if (time > course[1]) {\n            time -= pq.top();\n            pq.pop();\n        }\n    }\n\n    return pq.size();\n}\n```\n    \n    1. Sort the courses based on their deadline (lastDay).\n2. Create a max-heap (priority queue) to store the course durations.\n3. Initialize a variable `time` to track the current time (start at 0).\n4. Iterate through the sorted courses:\n   a. Add the duration to the `time`.\n   b. Push the duration to the max-heap.\n   c. If the `time` is greater than the course's deadline, then remove the longest duration from max-heap and subtract it from `time`.\n5. Return the size of the max-heap, which represents the number of courses that can be taken.\n\nBy sorting the courses by deadline and using a max-heap to store durations, we can efficiently determine which courses to take and which to drop when the deadline is not met. This greedy approach ensures that at each iteration, the optimal solution is reached up to the current course.\n    ", "python": "\n    ```python\nimport heapq\n\ndef scheduleCourse(courses):\n    courses.sort(key=lambda x: x[1])\n    curr_time, duration_sum = 0, []\n\n    for duration, deadline in courses:\n        curr_time += duration\n        heapq.heappush(duration_sum, -duration)\n\n        if curr_time > deadline:\n            curr_time += heapq.heappop(duration_sum)\n\n    return len(duration_sum)\n```\n    \n    1. Sort the courses based on their deadline (lastDay).\n2. Create a max-heap (priority queue) to store the course durations.\n3. Initialize a variable `time` to track the current time (start at 0).\n4. Iterate through the sorted courses:\n   a. Add the duration to the `time`.\n   b. Push the duration to the max-heap.\n   c. If the `time` is greater than the course's deadline, then remove the longest duration from max-heap and subtract it from `time`.\n5. Return the size of the max-heap, which represents the number of courses that can be taken.\n\nBy sorting the courses by deadline and using a max-heap to store durations, we can efficiently determine which courses to take and which to drop when the deadline is not met. This greedy approach ensures that at each iteration, the optimal solution is reached up to the current course.\n    ", "javascript": "\n    ```javascript\nfunction scheduleCourse(courses) {\n    courses.sort((a, b) => a[1] - b[1]);\n\n    const pq = new PriorityQueue((a, b) => b - a);\n    let time = 0;\n\n    for (const course of courses) {\n        time += course[0];\n        pq.push(course[0]);\n\n        if (time > course[1]) {\n            time -= pq.pop();\n        }\n    }\n\n    return pq.size();\n}\n\nclass PriorityQueue {\n    constructor(comparator) {\n        this.data = [];\n        this.comparator = comparator;\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.data.sort(this.comparator);\n    }\n\n    pop() {\n        return this.data.shift();\n    }\n\n    size() {\n        return this.data.length;\n    }\n}\n```\n    \n    1. Sort the courses based on their deadline (lastDay).\n2. Create a max-heap (priority queue) to store the course durations.\n3. Initialize a variable `time` to track the current time (start at 0).\n4. Iterate through the sorted courses:\n   a. Add the duration to the `time`.\n   b. Push the duration to the max-heap.\n   c. If the `time` is greater than the course's deadline, then remove the longest duration from max-heap and subtract it from `time`.\n5. Return the size of the max-heap, which represents the number of courses that can be taken.\n\nBy sorting the courses by deadline and using a max-heap to store durations, we can efficiently determine which courses to take and which to drop when the deadline is not met. This greedy approach ensures that at each iteration, the optimal solution is reached up to the current course.\n    "}
{"id": 632, "slug": "smallest-range-covering-elements-from-k-lists", "title": "Smallest Range Covering Elements from K Lists", "difficulty": "Hard", "content": "You have `k` lists of sorted integers in **non-decreasing order**. Find the **smallest** range that includes at least one number from each of the `k` lists.\n\nWe define the range `[a, b]` is smaller than range `[c, d]` if `b - a < d - c` **or** `a < c` if `b - a == d - c`.\n\n**Example 1:**\n\n**Input:** nums = \\[\\[4,10,15,24,26\\],\\[0,9,12,20\\],\\[5,18,22,30\\]\\]\n**Output:** \\[20,24\\]\n**Explanation:** \nList 1: \\[4, 10, 15, 24,26\\], 24 is in range \\[20,24\\].\nList 2: \\[0, 9, 12, 20\\], 20 is in range \\[20,24\\].\nList 3: \\[5, 18, 22, 30\\], 22 is in range \\[20,24\\].\n\n**Example 2:**\n\n**Input:** nums = \\[\\[1,2,3\\],\\[1,2,3\\],\\[1,2,3\\]\\]\n**Output:** \\[1,1\\]\n\n**Constraints:**\n\n*   `nums.length == k`\n*   `1 <= k <= 3500`\n*   `1 <= nums[i].length <= 50`\n*   `-105 <= nums[i][j] <= 105`\n*   `nums[i]` is sorted in **non-decreasing** order.", "java": "\n    ```java\nimport java.util.PriorityQueue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Comparator;\n\npublic int[] smallestRange(List<List<Integer>> nums) {\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n\n    int maxVal = Integer.MIN_VALUE;\n    for (int i = 0; i < nums.size(); i++) {\n        minHeap.offer(new int[] {nums.get(i).get(0), i});\n        maxVal = Math.max(maxVal, nums.get(i).get(0));\n    }\n\n    List<Integer> listIndices = new ArrayList<>();\n    for (int i = 0; i < nums.size(); i++) {\n        listIndices.add(0);\n    }\n    int minRange = Integer.MAX_VALUE;\n    int start = -1, end = -1;\n\n    while (minHeap.size() == nums.size()) {\n        int[] entry = minHeap.poll();\n        int val = entry[0];\n        int listIdx = entry[1];\n        int range = maxVal - val;\n\n        if (range < minRange) {\n            minRange = range;\n            start = val;\n            end = maxVal;\n        }\n\n        listIndices.set(listIdx, listIndices.get(listIdx) + 1);\n        if (listIndices.get(listIdx) < nums.get(listIdx).size()) {\n            int newVal = nums.get(listIdx).get(listIndices.get(listIdx));\n            minHeap.offer(new int[] {newVal, listIdx});\n            maxVal = Math.max(maxVal, newVal);\n        }\n    }\n\n    return new int[] {start, end};\n}\n```\n    \n    1. The algorithm starts by initializing a min heap, listIndices, maxVal, and the range [start, end]. \n2. Then, for each list in nums, we add the first element and its index into the min heap and update maxVal when necessary. Meanwhile, we fill listIndices with zeros.\n3. We loop as long as min heap size is equal to the number of lists. Within the loop:\n   a. We get the smallest value and its list index from the min heap.\n   b. If it produces a smaller range, we update the range [start, end].\n   c. We increment the relevant list index and update the current value when necessary.\n   d. We push the newVal along with its listIdx into the min heap and update maxVal if needed.\n4. Finally, the updated range is returned.\n\n \n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <limits>\n#include <utility>\n\nstd::pair<int, int> smallestRange(std::vector<std::vector<int>>& nums) {\n    auto listComparator = [](const auto& a, const auto& b) {\n        return a.first > b.first;\n    };\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(listComparator)> minHeap(listComparator);\n\n    int maxVal = std::numeric_limits<int>::min();\n    for (int i = 0; i < nums.size(); i++) {\n        minHeap.push({nums[i][0], i});\n        maxVal = std::max(maxVal, nums[i][0]);\n    }\n\n    std::vector<int> listIndices(nums.size(), 0);\n    int minRange = std::numeric_limits<int>::max();\n    int start = -1, end = -1;\n\n    while (minHeap.size() == nums.size()) {\n        auto entry = minHeap.top();\n        minHeap.pop();\n        int val = entry.first;\n        int listIdx = entry.second;\n        int range = maxVal - val;\n\n        if (range < minRange) {\n            minRange = range;\n            start = val;\n            end = maxVal;\n        }\n\n        listIndices[listIdx]++;\n        if (listIndices[listIdx] < nums[listIdx].size()) {\n            int newVal = nums[listIdx][listIndices[listIdx]];\n            minHeap.push({newVal, listIdx});\n            maxVal = std::max(maxVal, newVal);\n        }\n    }\n\n    return {start, end};\n}\n```\n    \n    1. The algorithm starts by initializing a min heap, listIndices, maxVal, and the range [start, end]. \n2. Then, for each list in nums, we add the first element and its index into the min heap and update maxVal when necessary. Meanwhile, we fill listIndices with zeros.\n3. We loop as long as min heap size is equal to the number of lists. Within the loop:\n   a. We get the smallest value and its list index from the min heap.\n   b. If it produces a smaller range, we update the range [start, end].\n   c. We increment the relevant list index and update the current value when necessary.\n   d. We push the newVal along with its listIdx into the min heap and update maxVal if needed.\n4. Finally, the updated range is returned.\n\n \n    ", "python": "\n    ```python\nimport heapq\n\ndef smallestRange(nums):\n    minHeap = []\n    maxVal = -1e9\n    \n    for i, lst in enumerate(nums):\n        heapq.heappush(minHeap, (lst[0], i))\n        maxVal = max(maxVal, lst[0])\n        \n    listIndices = [0] * len(nums)\n    minRange = 1e9\n    start, end = -1, -1\n    \n    while len(minHeap) == len(nums):\n        val, listIdx = heapq.heappop(minHeap)\n        range_ = maxVal - val\n        \n        if range_ < minRange:\n            minRange = range_\n            start, end = val, maxVal\n            \n        listIndices[listIdx] += 1\n        if listIndices[listIdx] < len(nums[listIdx]):\n            newVal = nums[listIdx][listIndices[listIdx]]\n            heapq.heappush(minHeap, (newVal, listIdx))\n            maxVal = max(maxVal, newVal)\n            \n    return [start, end]\n```\n    \n    1. The algorithm starts by initializing a min heap, listIndices, maxVal, and the range [start, end]. \n2. Then, for each list in nums, we add the first element and its index into the min heap and update maxVal when necessary. Meanwhile, we fill listIndices with zeros.\n3. We loop as long as min heap size is equal to the number of lists. Within the loop:\n   a. We get the smallest value and its list index from the min heap.\n   b. If it produces a smaller range, we update the range [start, end].\n   c. We increment the relevant list index and update the current value when necessary.\n   d. We push the newVal along with its listIdx into the min heap and update maxVal if needed.\n4. Finally, the updated range is returned.\n\n \n    ", "javascript": "\n    ```javascript\nfunction smallestRange(nums) {\n    const minHeap = [],\n          listIndices = Array(nums.length).fill(0);\n          \n    let maxVal = -Infinity;\n    \n    for (let i = 0; i < nums.length; i++) {\n        minHeap.push([nums[i][0], i]);\n        maxVal = Math.max(maxVal, nums[i][0]);\n    }\n    minHeap.sort(([a], [b]) => a - b);\n\n    let minRange = Infinity,\n        start = -1,\n        end = -1;\n    \n    while (minHeap.length === nums.length) {\n        const [val, listIdx] = minHeap.shift();\n        const range = maxVal - val;\n        \n        if (range < minRange) {\n            minRange = range;\n            start = val;\n            end = maxVal;\n        }\n\n        listIndices[listIdx]++;\n        if (listIndices[listIdx] < nums[listIdx].length) {\n            const newVal = nums[listIdx][listIndices[listIdx]];\n            minHeap.push([newVal, listIdx]);\n            minHeap.sort(([a], [b]) => a - b);\n            maxVal = Math.max(maxVal, newVal);\n        }\n    }\n\n    return [start, end];\n}\n```\n    \n    1. The algorithm starts by initializing a min heap, listIndices, maxVal, and the range [start, end]. \n2. Then, for each list in nums, we add the first element and its index into the min heap and update maxVal when necessary. Meanwhile, we fill listIndices with zeros.\n3. We loop as long as min heap size is equal to the number of lists. Within the loop:\n   a. We get the smallest value and its list index from the min heap.\n   b. If it produces a smaller range, we update the range [start, end].\n   c. We increment the relevant list index and update the current value when necessary.\n   d. We push the newVal along with its listIdx into the min heap and update maxVal if needed.\n4. Finally, the updated range is returned.\n\n \n    "}
{"id": 646, "slug": "maximum-length-of-pair-chain", "title": "Maximum Length of Pair Chain", "difficulty": "Medium", "content": "You are given an array of `n` pairs `pairs` where `pairs[i] = [lefti, righti]` and `lefti < righti`.\n\nA pair `p2 = [c, d]` **follows** a pair `p1 = [a, b]` if `b < c`. A **chain** of pairs can be formed in this fashion.\n\nReturn _the length longest chain which can be formed_.\n\nYou do not need to use up all the given intervals. You can select pairs in any order.\n\n**Example 1:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 2\n**Explanation:** The longest chain is \\[1,2\\] -> \\[3,4\\].\n\n**Example 2:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[7,8\\],\\[4,5\\]\\]\n**Output:** 3\n**Explanation:** The longest chain is \\[1,2\\] -> \\[4,5\\] -> \\[7,8\\].\n\n**Constraints:**\n\n*   `n == pairs.length`\n*   `1 <= n <= 1000`\n*   `-1000 <= lefti < righti <= 1000`", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int findLongestChain(int[][] pairs) {\n    Arrays.sort(pairs, Comparator.comparingInt(a -> a[1]));\n\n    int max_chain_length = 0, last_right = Integer.MIN_VALUE;\n    for (int[] pair : pairs) {\n        if (pair[0] > last_right) {\n            last_right = pair[1];\n            max_chain_length++;\n        }\n    }\n    \n    return max_chain_length;\n}\n```\n\n    \n    The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint findLongestChain(std::vector<std::vector<int>>& pairs) {\n    std::sort(pairs.begin(), pairs.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    int max_chain_length = 0, last_right = INT_MIN;\n    for (const auto& pair : pairs) {\n        if (pair[0] > last_right) {\n            last_right = pair[1];\n            max_chain_length++;\n        }\n    }\n    \n    return max_chain_length;\n}\n```\n\n    \n    The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n.\n    ", "python": "\n    ```python\ndef findLongestChain(pairs):\n    pairs.sort(key=lambda x: x[1])\n\n    max_chain_length = 0\n    last_right = float('-inf')\n    for pair in pairs:\n        if pair[0] > last_right:\n            last_right = pair[1]\n            max_chain_length += 1\n\n    return max_chain_length\n```\n\n    \n    The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n.\n    ", "javascript": "\n    ```javascript\nfunction findLongestChain(pairs) {\n    pairs.sort((a, b) => a[1] - b[1]);\n\n    let max_chain_length = 0, last_right = Number.MIN_SAFE_INTEGER;\n    for (const pair of pairs) {\n        if (pair[0] > last_right) {\n            last_right = pair[1];\n            max_chain_length++;\n        }\n    }\n\n    return max_chain_length;\n}\n```\n\n    \n    The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n.\n    "}
{"id": 649, "slug": "dota2-senate", "title": "Dota2 Senate", "difficulty": "Medium", "content": "In the world of Dota2, there are two parties: the Radiant and the Dire.\n\nThe Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise **one** of the two rights:\n\n*   **Ban one senator's right:** A senator can make another senator lose all his rights in this and all the following rounds.\n*   **Announce the victory:** If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.\n\nGiven a string `senate` representing each senator's party belonging. The character `'R'` and `'D'` represent the Radiant party and the Dire party. Then if there are `n` senators, the size of the given string will be `n`.\n\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\n\nSuppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be `\"Radiant \"` or `\"Dire \"`.\n\n**Example 1:**\n\n**Input:** senate =  \"RD \"\n**Output:**  \"Radiant \"\n**Explanation:** \nThe first senator comes from Radiant and he can just ban the next senator's right in round 1. \nAnd the second senator can't exercise any rights anymore since his right has been banned. \nAnd in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\n\n**Example 2:**\n\n**Input:** senate =  \"RDD \"\n**Output:**  \"Dire \"\n**Explanation:** \nThe first senator comes from Radiant and he can just ban the next senator's right in round 1. \nAnd the second senator can't exercise any rights anymore since his right has been banned. \nAnd the third senator comes from Dire and he can ban the first senator's right in round 1. \nAnd in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\n\n**Constraints:**\n\n*   `n == senate.length`\n*   `1 <= n <= 104`\n*   `senate[i]` is either `'R'` or `'D'`.", "java": "\n    ```java\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic String predictPartyVictory(String senate) {\n    Queue<Integer> radiant = new LinkedList<>();\n    Queue<Integer> dire = new LinkedList<>();\n    int n = senate.length();\n    \n    for (int i = 0; i < n; i++) {\n        if (senate.charAt(i) == 'R')\n            radiant.add(i);\n        else\n            dire.add(i);\n    }\n\n    while (!radiant.isEmpty() && !dire.isEmpty()) {\n        int r = radiant.poll();\n        int d = dire.poll();\n\n        if (r < d)\n            radiant.add(r + n);\n        else\n            dire.add(d + n);\n    }\n\n    return radiant.isEmpty() ? \"Dire\" : \"Radiant\";\n}\n```\n\n    \n    The algorithm uses a power of choices using round-based voting which works as follows:\n\n1. Create two queues: Radiant and Dire, and a variable `n` to store the length of the senate string.\n2. Iterate through the `senate` string, and for each character, enqueue the position to the respective queue.\n3. While both queues are not empty, dequeue an element from each queue (Radiant and Dire). Compare if the radiant element is smaller; then enqueue radiant element + `n` to the Radiant queue, otherwise, enqueue dire element + `n` to Dire queue.\n4. When one of the queues is empty, return the victory of the party that still has elements in the queue. If the Radiant queue is not empty, return \"Radiant\", otherwise, return \"Dire\".\n\nThis way, the algorithm simulates the round-based voting, considering the best strategy for each party. When one party is no longer able to vote, the other party wins.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <queue>\n\nstd::string predictPartyVictory(std::string senate) {\n    std::queue<int> radiant, dire;\n    int n = senate.size();\n    \n    for (int i = 0; i < n; i++) {\n        if (senate[i] == 'R')\n            radiant.push(i);\n        else\n            dire.push(i);\n    }\n\n    while (!radiant.empty() && !dire.empty()) {\n        int r = radiant.front();\n        int d = dire.front();\n        radiant.pop();\n        dire.pop();\n\n        if (r < d)\n            radiant.push(r + n);\n        else\n            dire.push(d + n);\n    }\n\n    return radiant.empty() ? \"Dire\" : \"Radiant\";\n}\n```\n\n    \n    The algorithm uses a power of choices using round-based voting which works as follows:\n\n1. Create two queues: Radiant and Dire, and a variable `n` to store the length of the senate string.\n2. Iterate through the `senate` string, and for each character, enqueue the position to the respective queue.\n3. While both queues are not empty, dequeue an element from each queue (Radiant and Dire). Compare if the radiant element is smaller; then enqueue radiant element + `n` to the Radiant queue, otherwise, enqueue dire element + `n` to Dire queue.\n4. When one of the queues is empty, return the victory of the party that still has elements in the queue. If the Radiant queue is not empty, return \"Radiant\", otherwise, return \"Dire\".\n\nThis way, the algorithm simulates the round-based voting, considering the best strategy for each party. When one party is no longer able to vote, the other party wins.\n    ", "python": "\n    ```python\nfrom collections import deque\n\ndef predict_party_victory(senate: str) -> str:\n    radiant = deque()\n    dire = deque()\n    n = len(senate)\n    \n    for i, s in enumerate(senate):\n        if s == 'R':\n            radiant.append(i)\n        else:\n            dire.append(i)\n\n    while radiant and dire:\n        r = radiant.popleft()\n        d = dire.popleft()\n\n        if r < d:\n            radiant.append(r + n)\n        else:\n            dire.append(d + n)\n\n    return \"Dire\" if not radiant else \"Radiant\"\n```\n\n    \n    The algorithm uses a power of choices using round-based voting which works as follows:\n\n1. Create two queues: Radiant and Dire, and a variable `n` to store the length of the senate string.\n2. Iterate through the `senate` string, and for each character, enqueue the position to the respective queue.\n3. While both queues are not empty, dequeue an element from each queue (Radiant and Dire). Compare if the radiant element is smaller; then enqueue radiant element + `n` to the Radiant queue, otherwise, enqueue dire element + `n` to Dire queue.\n4. When one of the queues is empty, return the victory of the party that still has elements in the queue. If the Radiant queue is not empty, return \"Radiant\", otherwise, return \"Dire\".\n\nThis way, the algorithm simulates the round-based voting, considering the best strategy for each party. When one party is no longer able to vote, the other party wins.\n    ", "javascript": "\n    ```javascript\nfunction predictPartyVictory(senate) {\n    let radiant = [];\n    let dire = [];\n    let n = senate.length;\n    \n    for (let i = 0; i < n; i++) {\n        if (senate[i] === 'R')\n            radiant.push(i);\n        else\n            dire.push(i);\n    }\n\n    while (radiant.length > 0 && dire.length > 0) {\n        let r = radiant.shift();\n        let d = dire.shift();\n\n        if (r < d)\n            radiant.push(r + n);\n        else\n            dire.push(d + n);\n    }\n\n    return radiant.length === 0 ? \"Dire\" : \"Radiant\";\n}\n```\n\n    \n    The algorithm uses a power of choices using round-based voting which works as follows:\n\n1. Create two queues: Radiant and Dire, and a variable `n` to store the length of the senate string.\n2. Iterate through the `senate` string, and for each character, enqueue the position to the respective queue.\n3. While both queues are not empty, dequeue an element from each queue (Radiant and Dire). Compare if the radiant element is smaller; then enqueue radiant element + `n` to the Radiant queue, otherwise, enqueue dire element + `n` to Dire queue.\n4. When one of the queues is empty, return the victory of the party that still has elements in the queue. If the Radiant queue is not empty, return \"Radiant\", otherwise, return \"Dire\".\n\nThis way, the algorithm simulates the round-based voting, considering the best strategy for each party. When one party is no longer able to vote, the other party wins.\n    "}
{"id": 659, "slug": "split-array-into-consecutive-subsequences", "title": "Split Array into Consecutive Subsequences", "difficulty": "Medium", "content": "You are given an integer array `nums` that is **sorted in non-decreasing order**.\n\nDetermine if it is possible to split `nums` into **one or more subsequences** such that **both** of the following conditions are true:\n\n*   Each subsequence is a **consecutive increasing sequence** (i.e. each integer is **exactly one** more than the previous integer).\n*   All subsequences have a length of `3` **or more**.\n\nReturn `true` _if you can split_ `nums` _according to the above conditions, or_ `false` _otherwise_.\n\nA **subsequence** of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., `[1,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,3,2]` is not).\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,3,4,5\\]\n**Output:** true\n**Explanation:** nums can be split into the following subsequences:\n\\[**1**,**2**,**3**,3,4,5\\] --> 1, 2, 3\n\\[1,2,3,**3**,**4**,**5**\\] --> 3, 4, 5\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,3,4,4,5,5\\]\n**Output:** true\n**Explanation:** nums can be split into the following subsequences:\n\\[**1**,**2**,**3**,3,**4**,4,**5**,5\\] --> 1, 2, 3, 4, 5\n\\[1,2,3,**3**,4,**4**,5,**5**\\] --> 3, 4, 5\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,4,5\\]\n**Output:** false\n**Explanation:** It is impossible to split nums into consecutive increasing subsequences of length 3 or more.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-1000 <= nums[i] <= 1000`\n*   `nums` is sorted in **non-decreasing** order.", "java": "\n    ```java\npublic boolean canSplit(int[] nums) {\n    int[] freq = new int[20001], needed = new int[20001];\n    for (int n : nums)\n        freq[n]++;\n    for (int n : nums) {\n        if (freq[n] == 0) continue;\n        if (needed[n - 1] == 0) {\n            if (freq[n + 1] > 0 && freq[n + 2] > 0) {\n                freq[n]--; freq[n + 1]--; freq[n + 2]--;\n                needed[n + 2]++;\n            } else return false;\n        } else {\n            freq[n]--; needed[n - 1]--;\n            needed[n]++;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Create two arrays, one to store the frequency of elements in the given input `nums`, and another to store the number of elements needed to create a valid sequence.\n2. Iterate through the input `nums`, filling up the frequency array.\n3. Iterate through the input `nums` again. For each non-zero frequency element in the input `nums`:\n   - If it's not needed to create a valid sequence, check if it can form a new sequence with its next two elements in the sorted order. If yes, decrement the frequencies of those three elements and increment the needed count of third elements by 1. If not, return false.\n   - If it's needed for a valid sequence, decrement its frequency and the needed count of its previous element, and increment the needed count of the element itself by 1.\n4. At the end of this iteration, if all conditions are met, return true.\n\nThis algorithm checks if the given sorted array can be split into subsequences of at least three consecutive integers. If any of the conditions mentioned are not met, it returns false. If all conditions are fulfilled, it returns true.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool canSplit(vector<int>& nums) {\n    vector<int> freq(20001, 0), needed(20001, 0);\n    for (int n : nums)\n        freq[n]++;\n    for (int n : nums) {\n        if (!freq[n]) continue;\n        if (!needed[n - 1]) {\n            if (freq[n + 1] && freq[n + 2]) {\n                freq[n]--; freq[n + 1]--; freq[n + 2]--;\n                needed[n + 2]++;\n            } else return false;\n        } else {\n            freq[n]--; needed[n - 1]--;\n            needed[n]++;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Create two arrays, one to store the frequency of elements in the given input `nums`, and another to store the number of elements needed to create a valid sequence.\n2. Iterate through the input `nums`, filling up the frequency array.\n3. Iterate through the input `nums` again. For each non-zero frequency element in the input `nums`:\n   - If it's not needed to create a valid sequence, check if it can form a new sequence with its next two elements in the sorted order. If yes, decrement the frequencies of those three elements and increment the needed count of third elements by 1. If not, return false.\n   - If it's needed for a valid sequence, decrement its frequency and the needed count of its previous element, and increment the needed count of the element itself by 1.\n4. At the end of this iteration, if all conditions are met, return true.\n\nThis algorithm checks if the given sorted array can be split into subsequences of at least three consecutive integers. If any of the conditions mentioned are not met, it returns false. If all conditions are fulfilled, it returns true.\n    ", "python": "\n    ```python\ndef can_split(nums):\n    freq = [0] * 20001\n    needed = [0] * 20001\n    for n in nums:\n        freq[n] += 1\n    for n in nums:\n        if not freq[n]: continue\n        if not needed[n - 1]:\n            if freq[n + 1] and freq[n + 2]:\n                freq[n] -= 1; freq[n + 1] -= 1; freq[n + 2] -= 1;\n                needed[n + 2] += 1\n            else: return False\n        else:\n            freq[n] -= 1; needed[n - 1] -= 1;\n            needed[n] += 1\n    return True\n```\n    \n    The algorithm works as follows:\n1. Create two arrays, one to store the frequency of elements in the given input `nums`, and another to store the number of elements needed to create a valid sequence.\n2. Iterate through the input `nums`, filling up the frequency array.\n3. Iterate through the input `nums` again. For each non-zero frequency element in the input `nums`:\n   - If it's not needed to create a valid sequence, check if it can form a new sequence with its next two elements in the sorted order. If yes, decrement the frequencies of those three elements and increment the needed count of third elements by 1. If not, return false.\n   - If it's needed for a valid sequence, decrement its frequency and the needed count of its previous element, and increment the needed count of the element itself by 1.\n4. At the end of this iteration, if all conditions are met, return true.\n\nThis algorithm checks if the given sorted array can be split into subsequences of at least three consecutive integers. If any of the conditions mentioned are not met, it returns false. If all conditions are fulfilled, it returns true.\n    ", "javascript": "\n    ```javascript\nfunction canSplit(nums) {\n    const freq = new Array(20001).fill(0), needed = new Array(20001).fill(0);\n    for (let n of nums)\n        freq[n]++;\n    for (let n of nums) {\n        if (!freq[n]) continue;\n        if (!needed[n - 1]) {\n            if (freq[n + 1] && freq[n + 2]) {\n                freq[n]--; freq[n + 1]--; freq[n + 2]--;\n                needed[n + 2]++;\n            } else return false;\n        } else {\n            freq[n]--; needed[n - 1]--;\n            needed[n]++;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Create two arrays, one to store the frequency of elements in the given input `nums`, and another to store the number of elements needed to create a valid sequence.\n2. Iterate through the input `nums`, filling up the frequency array.\n3. Iterate through the input `nums` again. For each non-zero frequency element in the input `nums`:\n   - If it's not needed to create a valid sequence, check if it can form a new sequence with its next two elements in the sorted order. If yes, decrement the frequencies of those three elements and increment the needed count of third elements by 1. If not, return false.\n   - If it's needed for a valid sequence, decrement its frequency and the needed count of its previous element, and increment the needed count of the element itself by 1.\n4. At the end of this iteration, if all conditions are met, return true.\n\nThis algorithm checks if the given sorted array can be split into subsequences of at least three consecutive integers. If any of the conditions mentioned are not met, it returns false. If all conditions are fulfilled, it returns true.\n    "}
{"id": 670, "slug": "maximum-swap", "title": "Maximum Swap", "difficulty": "Medium", "content": "You are given an integer `num`. You can swap two digits at most once to get the maximum valued number.\n\nReturn _the maximum valued number you can get_.\n\n**Example 1:**\n\n**Input:** num = 2736\n**Output:** 7236\n**Explanation:** Swap the number 2 and the number 7.\n\n**Example 2:**\n\n**Input:** num = 9973\n**Output:** 9973\n**Explanation:** No swap.\n\n**Constraints:**\n\n*   `0 <= num <= 108`", "java": "\n    ```java\npublic int maximumSwap(int num) {\n    char[] num_str = Integer.toString(num).toCharArray();\n    int[] last = new int[10];\n    \n    for (int i = 0; i < num_str.length; i++) {\n        last[num_str[i] - '0'] = i;\n    }\n    \n    for (int i = 0; i < num_str.length; i++) {\n        for (int d = 9; d > num_str[i] - '0'; d--) {\n            if (last[d] > i) {\n                swap(num_str, i, last[d]);\n                return Integer.parseInt(new String(num_str));\n            }\n        }\n    }\n    \n    return num;\n}\n\nprivate void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n```\n    \n    1. Convert the input number to a string (num_str) so that we can manipulate individual digits easily.\n2. Create an array (last) to store the last occurrences of each digit, and populate it by iterating through num_str.\n3. Iterate through num_str; for each digit, check if there is a larger digit that appears later in the number.\n   - If there is, swap the current digit with the larger digit and return the result as an integer.\n4. If no suitable pair of digits is found to swap, return the original input.\n    ", "c++": "\n    ```cpp\nint maximumSwap(int num) {\n    string num_str = to_string(num);\n    vector<int> last(10, 0);\n    \n    for (int i = 0; i < num_str.size(); i++) {\n        last[num_str[i] - '0'] = i;\n    }\n    \n    for (int i = 0; i < num_str.size(); i++) {\n        for (int d = 9; d > num_str[i] - '0'; d--) {\n            if (last[d] > i) {\n                swap(num_str[i], num_str[last[d]]);\n                return stoi(num_str);\n            }\n        }\n    }\n    \n    return num;\n}\n```\n    \n    1. Convert the input number to a string (num_str) so that we can manipulate individual digits easily.\n2. Create an array (last) to store the last occurrences of each digit, and populate it by iterating through num_str.\n3. Iterate through num_str; for each digit, check if there is a larger digit that appears later in the number.\n   - If there is, swap the current digit with the larger digit and return the result as an integer.\n4. If no suitable pair of digits is found to swap, return the original input.\n    ", "python": "\n    ```python\ndef maximumSwap(num):\n    num_str = list(str(num))\n    last = {int(v): i for i, v in enumerate(num_str)}\n\n    for i, v in enumerate(num_str):\n        for d in range(9, int(v), -1):\n            if last.get(d, -1) > i:\n                num_str[i], num_str[last[d]] = num_str[last[d]], num_str[i]\n                return int(\"\".join(num_str))\n\n    return num\n```\n    \n    1. Convert the input number to a string (num_str) so that we can manipulate individual digits easily.\n2. Create an array (last) to store the last occurrences of each digit, and populate it by iterating through num_str.\n3. Iterate through num_str; for each digit, check if there is a larger digit that appears later in the number.\n   - If there is, swap the current digit with the larger digit and return the result as an integer.\n4. If no suitable pair of digits is found to swap, return the original input.\n    ", "javascript": "\n    ```javascript\nfunction maximumSwap(num) {\n    let num_str = Array.from(num.toString());\n    let last = new Array(10).fill(0);\n    \n    for (let i = 0; i < num_str.length; i++) {\n        last[parseInt(num_str[i])] = i;\n    }\n    \n    for (let i = 0; i < num_str.length; i++) {\n        for (let d = 9; d > parseInt(num_str[i]); d--) {\n            if (last[d] > i) {\n                [num_str[i], num_str[last[d]]] = [num_str[last[d]], num_str[i]];\n                return parseInt(num_str.join(''));\n            }\n        }\n    }\n    \n    return num;\n}\n```\n    \n    1. Convert the input number to a string (num_str) so that we can manipulate individual digits easily.\n2. Create an array (last) to store the last occurrences of each digit, and populate it by iterating through num_str.\n3. Iterate through num_str; for each digit, check if there is a larger digit that appears later in the number.\n   - If there is, swap the current digit with the larger digit and return the result as an integer.\n4. If no suitable pair of digits is found to swap, return the original input.\n    "}
{"id": 678, "slug": "valid-parenthesis-string", "title": "Valid Parenthesis String", "difficulty": "Medium", "content": "Given a string `s` containing only three types of characters: `'('`, `')'` and `'*'`, return `true` _if_ `s` _is **valid**_.\n\nThe following rules define a **valid** string:\n\n*   Any left parenthesis `'('` must have a corresponding right parenthesis `')'`.\n*   Any right parenthesis `')'` must have a corresponding left parenthesis `'('`.\n*   Left parenthesis `'('` must go before the corresponding right parenthesis `')'`.\n*   `'*'` could be treated as a single right parenthesis `')'` or a single left parenthesis `'('` or an empty string `\" \"`.\n\n**Example 1:**\n\n**Input:** s = \"()\"\n**Output:** true\n\n**Example 2:**\n\n**Input:** s = \"(\\*)\"\n**Output:** true\n\n**Example 3:**\n\n**Input:** s = \"(\\*))\"\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s[i]` is `'('`, `')'` or `'*'`.", "java": "\n    ```java\npublic boolean checkValidString(String s) {\n    int left_balance = 0, right_balance = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        left_balance += (s.charAt(i) == '(' || s.charAt(i) == '*') ? 1 : -1;\n        right_balance += (s.charAt(s.length() - 1 - i) == ')' || s.charAt(s.length() - 1 - i) == '*') ? 1 : -1;\n\n        if (left_balance < 0 || right_balance < 0)\n            return false;\n    }\n\n    return true;\n}\n```\n\n    \n    The algorithm uses the greedy approach by keeping count of the possible balance of left and right parentheses with two variables `left_balance` and `right_balance`. \n\nWe iterate through the string in both forward and reverse direction looking at balance of the parentheses. The '*' character is treated as a left parenthesis when iterating forward, and as a right parenthesis when iterating in reverse. If at any point either balance is negative, we return false, as it is not a valid string.\n\nIf we successfully finish the iteration without returning false, it means the string is valid, and we return true.\n    ", "c++": "\n    ```cpp\nbool checkValidString(string s) {\n    int left_balance = 0, right_balance = 0;\n\n    for (int i = 0; i < s.size(); i++) {\n        left_balance += (s[i] == '(' || s[i] == '*') ? 1 : -1;\n        right_balance += (s[s.size() - 1 - i] == ')' || s[s.size() - 1 - i] == '*') ? 1 : -1;\n\n        if (left_balance < 0 || right_balance < 0)\n            return false;\n    }\n\n    return true;\n}\n```\n\n    \n    The algorithm uses the greedy approach by keeping count of the possible balance of left and right parentheses with two variables `left_balance` and `right_balance`. \n\nWe iterate through the string in both forward and reverse direction looking at balance of the parentheses. The '*' character is treated as a left parenthesis when iterating forward, and as a right parenthesis when iterating in reverse. If at any point either balance is negative, we return false, as it is not a valid string.\n\nIf we successfully finish the iteration without returning false, it means the string is valid, and we return true.\n    ", "python": "\n    ```python\ndef checkValidString(s: str) -> bool:\n    left_balance, right_balance = 0, 0\n\n    for i in range(len(s)):\n        left_balance += 1 if s[i] == '(' or s[i] == '*' else -1\n        right_balance += 1 if s[len(s) - 1 - i] == ')' or s[len(s) - 1 - i] == '*' else -1\n\n        if left_balance < 0 or right_balance < 0:\n            return False\n\n    return True\n```\n\n    \n    The algorithm uses the greedy approach by keeping count of the possible balance of left and right parentheses with two variables `left_balance` and `right_balance`. \n\nWe iterate through the string in both forward and reverse direction looking at balance of the parentheses. The '*' character is treated as a left parenthesis when iterating forward, and as a right parenthesis when iterating in reverse. If at any point either balance is negative, we return false, as it is not a valid string.\n\nIf we successfully finish the iteration without returning false, it means the string is valid, and we return true.\n    ", "javascript": "\n    ```javascript\nfunction checkValidString(s) {\n    let left_balance = 0, right_balance = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        left_balance += (s[i] === '(' || s[i] === '*') ? 1 : -1;\n        right_balance += (s[s.length - 1 - i] === ')' || s[s.length - 1 - i] === '*') ? 1 : -1;\n\n        if (left_balance < 0 || right_balance < 0)\n            return false;\n    }\n\n    return true;\n}\n```\n\n    \n    The algorithm uses the greedy approach by keeping count of the possible balance of left and right parentheses with two variables `left_balance` and `right_balance`. \n\nWe iterate through the string in both forward and reverse direction looking at balance of the parentheses. The '*' character is treated as a left parenthesis when iterating forward, and as a right parenthesis when iterating in reverse. If at any point either balance is negative, we return false, as it is not a valid string.\n\nIf we successfully finish the iteration without returning false, it means the string is valid, and we return true.\n    "}
{"id": 680, "slug": "valid-palindrome-ii", "title": "Valid Palindrome II", "difficulty": "Easy", "content": "Given a string `s`, return `true` _if the_ `s` _can be palindrome after deleting **at most one** character from it_.\n\n**Example 1:**\n\n**Input:** s =  \"aba \"\n**Output:** true\n\n**Example 2:**\n\n**Input:** s =  \"abca \"\n**Output:** true\n**Explanation:** You could delete the character 'c'.\n\n**Example 3:**\n\n**Input:** s =  \"abc \"\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters.", "java": "\n    ```java\npublic boolean validPalindrome(String s) {\n    for (int i = 0, j = s.length() - 1; i < j; i++, j--) {\n        if (s.charAt(i) != s.charAt(j)) {\n            int temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && s.charAt(temp1) == s.charAt(temp2)) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && s.charAt(temp1) == s.charAt(temp2)) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n            \n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize two pointers, `i` at the start and `j` at the end of the input string `s`.\n2. Check if characters at positions `i` and `j` are equal. If they are not,\n   1. Check if the resulting substring `s[i+1, j]` is a palindrome.\n   2. If it is not, check if the resulting substring `s[i, j-1]` is a palindrome.\n   3. If neither of the substrings is a palindrome, return false.\n3. Move both pointers towards each other and repeat step 2.\n4. If the pointers crossed each other or met, the entire string `s` can be a palindrome after deleting at most one character, so return true. \n\nThe functions for all four languages follow the same logic as explained above.\n    ", "c++": "\n    ```cpp\nbool validPalindrome(string s) {\n    for (int i = 0, j = s.size() - 1; i < j; i++, j--) {\n        if (s[i] != s[j]) {\n            int temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize two pointers, `i` at the start and `j` at the end of the input string `s`.\n2. Check if characters at positions `i` and `j` are equal. If they are not,\n   1. Check if the resulting substring `s[i+1, j]` is a palindrome.\n   2. If it is not, check if the resulting substring `s[i, j-1]` is a palindrome.\n   3. If neither of the substrings is a palindrome, return false.\n3. Move both pointers towards each other and repeat step 2.\n4. If the pointers crossed each other or met, the entire string `s` can be a palindrome after deleting at most one character, so return true. \n\nThe functions for all four languages follow the same logic as explained above.\n    ", "python": "\n    ```python\ndef validPalindrome(s: str) -> bool:\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            temp1, temp2 = i + 1, j\n            while temp1 < temp2 and s[temp1] == s[temp2]:\n                temp1 += 1\n                temp2 -= 1\n            if temp1 >= temp2:\n                return True\n\n            temp1, temp2 = i, j - 1\n            while temp1 < temp2 and s[temp1] == s[temp2]:\n                temp1 += 1\n                temp2 -= 1\n            if temp1 >= temp2:\n                return True\n\n            return False\n        i += 1\n        j -= 1\n    return True\n```\n    \n    The algorithm works as follows:\n1. Initialize two pointers, `i` at the start and `j` at the end of the input string `s`.\n2. Check if characters at positions `i` and `j` are equal. If they are not,\n   1. Check if the resulting substring `s[i+1, j]` is a palindrome.\n   2. If it is not, check if the resulting substring `s[i, j-1]` is a palindrome.\n   3. If neither of the substrings is a palindrome, return false.\n3. Move both pointers towards each other and repeat step 2.\n4. If the pointers crossed each other or met, the entire string `s` can be a palindrome after deleting at most one character, so return true. \n\nThe functions for all four languages follow the same logic as explained above.\n    ", "javascript": "\n    ```javascript\nfunction validPalindrome(s) {\n    for (let i = 0, j = s.length - 1; i < j; i++, j--) {\n        if (s[i] != s[j]) {\n            let temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n            \n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize two pointers, `i` at the start and `j` at the end of the input string `s`.\n2. Check if characters at positions `i` and `j` are equal. If they are not,\n   1. Check if the resulting substring `s[i+1, j]` is a palindrome.\n   2. If it is not, check if the resulting substring `s[i, j-1]` is a palindrome.\n   3. If neither of the substrings is a palindrome, return false.\n3. Move both pointers towards each other and repeat step 2.\n4. If the pointers crossed each other or met, the entire string `s` can be a palindrome after deleting at most one character, so return true. \n\nThe functions for all four languages follow the same logic as explained above.\n    "}
{"id": 714, "slug": "best-time-to-buy-and-sell-stock-with-transaction-fee", "title": "Best Time to Buy and Sell Stock with Transaction Fee", "difficulty": "Medium", "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `fee` representing a transaction fee.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n**Example 1:**\n\n**Input:** prices = \\[1,3,2,8,4,9\\], fee = 2\n**Output:** 8\n**Explanation:** The maximum profit can be achieved by:\n- Buying at prices\\[0\\] = 1\n- Selling at prices\\[3\\] = 8\n- Buying at prices\\[4\\] = 4\n- Selling at prices\\[5\\] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n\n**Example 2:**\n\n**Input:** prices = \\[1,3,7,5,10,3\\], fee = 3\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= prices.length <= 5 * 104`\n*   `1 <= prices[i] < 5 * 104`\n*   `0 <= fee < 5 * 104`", "java": "\n    ```java\npublic int maxProfit(int[] prices, int fee) {\n    int cash = 0, hold = -prices[0];\n    for (int price : prices) {\n        int temp = cash;\n        cash = Math.max(cash, hold + price - fee);\n        hold = Math.max(hold, temp - price);\n    }\n    return cash;\n}\n```\n    \n    The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit.\n    ", "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices, int fee) {\n    int cash = 0, hold = -prices[0];\n    for (int price : prices) {\n        int temp = cash;\n        cash = max(cash, hold + price - fee);\n        hold = max(hold, temp - price);\n    }\n    return cash;\n}\n```\n    \n    The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit.\n    ", "python": "\n    ```python\ndef maxProfit(prices, fee):\n    cash, hold = 0, -prices[0]\n    for price in prices:\n        temp = cash\n        cash = max(cash, hold + price - fee)\n        hold = max(hold, temp - price)\n    return cash\n```\n    \n    The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit.\n    ", "javascript": "\n    ```javascript\nfunction maxProfit(prices, fee) {\n    let cash = 0, hold = -prices[0];\n    for (const price of prices) {\n        let temp = cash;\n        cash = Math.max(cash, hold + price - fee);\n        hold = Math.max(hold, temp - price);\n    }\n    return cash;\n}\n```\n    \n    The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit.\n    "}
{"id": 738, "slug": "monotone-increasing-digits", "title": "Monotone Increasing Digits", "difficulty": "Medium", "content": "An integer has **monotone increasing digits** if and only if each pair of adjacent digits `x` and `y` satisfy `x <= y`.\n\nGiven an integer `n`, return _the largest number that is less than or equal to_ `n` _with **monotone increasing digits**_.\n\n**Example 1:**\n\n**Input:** n = 10\n**Output:** 9\n\n**Example 2:**\n\n**Input:** n = 1234\n**Output:** 1234\n\n**Example 3:**\n\n**Input:** n = 332\n**Output:** 299\n\n**Constraints:**\n\n*   `0 <= n <= 109`", "java": "\n    ```java\npublic int monotoneIncreasingDigits(int n) {\n    char[] n_str = String.valueOf(n).toCharArray();\n    int n_len = n_str.length;\n\n    int i = n_len - 1;\n    while (i > 0) {\n        if (n_str[i] < n_str[i - 1]) {\n            n_str[i - 1] -= 1;\n            for (int j = i; j < n_len; ++j) {\n                n_str[j] = '9';\n            }\n        }\n        --i;\n    }\n\n    return Integer.parseInt(new String(n_str));\n}\n```\n    \n    1. Convert the input integer to a string for easier manipulation of individual digits, and get its length.\n2. Initialize counter `i` starting at the right-most digit and going left.\n3. If the current digit is less than the previous one, we decrement the previous digit by 1 as it must be less than or equal, then set all digits to the right of the modified digit to 9 (so that the number remains the largest possible).\n4. Continue with step 3 until every previous digit has been checked, adjusting digits as needed.\n5. Convert the string of digits back to an integer and return it.\n    ", "c++": "\n    ```cpp\nint monotoneIncreasingDigits(int n) {\n    string n_str = to_string(n);\n    int n_len = n_str.size();\n\n    int i = n_len - 1;\n    while (i > 0) {\n        if (n_str[i] < n_str[i - 1]) {\n            n_str[i - 1] -= 1;\n            for (int j = i; j < n_len; ++j) {\n                n_str[j] = '9';\n            }\n        }\n        --i;\n    }\n\n    return stoi(n_str);\n}\n```\n    \n    1. Convert the input integer to a string for easier manipulation of individual digits, and get its length.\n2. Initialize counter `i` starting at the right-most digit and going left.\n3. If the current digit is less than the previous one, we decrement the previous digit by 1 as it must be less than or equal, then set all digits to the right of the modified digit to 9 (so that the number remains the largest possible).\n4. Continue with step 3 until every previous digit has been checked, adjusting digits as needed.\n5. Convert the string of digits back to an integer and return it.\n    ", "python": "\n    ```python\ndef monotoneIncreasingDigits(n: int) -> int:\n    n_str = [c for c in str(n)]\n\n    i = len(n_str) - 1\n    while i > 0:\n        if n_str[i] < n_str[i - 1]:\n            n_str[i - 1] = chr(ord(n_str[i - 1]) - 1)\n            for j in range(i, len(n_str)):\n                n_str[j] = '9'\n        i -= 1\n\n    return int(''.join(n_str))\n```\n    \n    1. Convert the input integer to a string for easier manipulation of individual digits, and get its length.\n2. Initialize counter `i` starting at the right-most digit and going left.\n3. If the current digit is less than the previous one, we decrement the previous digit by 1 as it must be less than or equal, then set all digits to the right of the modified digit to 9 (so that the number remains the largest possible).\n4. Continue with step 3 until every previous digit has been checked, adjusting digits as needed.\n5. Convert the string of digits back to an integer and return it.\n    ", "javascript": "\n    ```javascript\nfunction monotoneIncreasingDigits(n) {\n    let n_str = n.toString();\n    let n_len = n_str.length;\n\n    let i = n_len - 1;\n    while (i > 0) {\n        if (n_str.charAt(i) < n_str.charAt(i - 1)) {\n            n_str = n_str.slice(0, i-1) + String.fromCharCode(n_str.charCodeAt(i-1) - 1) + '9'.repeat(n_len - i);\n        }\n        --i;\n    }\n\n    return parseInt(n_str);\n}\n```\n\n    \n    1. Convert the input integer to a string for easier manipulation of individual digits, and get its length.\n2. Initialize counter `i` starting at the right-most digit and going left.\n3. If the current digit is less than the previous one, we decrement the previous digit by 1 as it must be less than or equal, then set all digits to the right of the modified digit to 9 (so that the number remains the largest possible).\n4. Continue with step 3 until every previous digit has been checked, adjusting digits as needed.\n5. Convert the string of digits back to an integer and return it.\n    "}
{"id": 757, "slug": "set-intersection-size-at-least-two", "title": "Set Intersection Size At Least Two", "difficulty": "Hard", "content": "You are given a 2D integer array `intervals` where `intervals[i] = [starti, endi]` represents all the integers from `starti` to `endi` inclusively.\n\nA **containing set** is an array `nums` where each interval from `intervals` has **at least two** integers in `nums`.\n\n*   For example, if `intervals = [[1,3], [3,7], [8,9]]`, then `[1,2,4,7,8,9]` and `[2,3,4,8,9]` are **containing sets**.\n\nReturn _the minimum possible size of a containing set_.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[3,7\\],\\[8,9\\]\\]\n**Output:** 5\n**Explanation:** let nums = \\[2, 3, 4, 8, 9\\].\nIt can be shown that there cannot be any containing array of size 4.\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[3,5\\]\\]\n**Output:** 3\n**Explanation:** let nums = \\[2, 3, 4\\].\nIt can be shown that there cannot be any containing array of size 2.\n\n**Example 3:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\],\\[4,5\\]\\]\n**Output:** 5\n**Explanation:** let nums = \\[1, 2, 3, 4, 5\\].\nIt can be shown that there cannot be any containing array of size 4.\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 3000`\n*   `intervals[i].length == 2`\n*   `0 <= starti < endi <= 108`", "java": "\n    ```java\nimport java.util.*;\n\npublic boolean pyramidTransition(String bottom, List<String> allowed) {\n    Map<String, List<Character>> mapping = new HashMap<>();\n    for (String s : allowed) {\n        String key = s.substring(0, 2);\n        if (!mapping.containsKey(key)) {\n            mapping.put(key, new ArrayList<>());\n        }\n        mapping.get(key).add(s.charAt(2));\n    }\n    return dfs(\"\", bottom, mapping);\n}\n\npublic boolean dfs(String curr, String bottom, Map<String, List<Character>> mapping) {\n    if (bottom.length() == 1) return true;\n    for (int i = 0; i < bottom.length() - 1; ++i) {\n        if (!mapping.containsKey(bottom.substring(i, i + 2))) return false;\n    }\n    curr = \"\";\n    for (int i = 0; i < bottom.length() - 1; ++i) {\n        curr += mapping.get(bottom.substring(i, i + 2)).get(0);\n    }\n    return dfs(curr, curr, mapping);\n}\n```\n\n    \n    1. Create a mapping, with the allowed patterns, which maps bottom two characters of allowed string to their respective top character.\n2. Define a function dfs, which loops through the current bottom to find the mapping for the subsequent row.\n3. If it can create a subsequent row fully from the mappings without any error, it calls the dfs again recursively with the new row as the bottom row.\n4. If, finally, a single character row(bottom.length==1) is formed at the top, it returns true; otherwise, it returns false.\n5. Call dfs with the original bottom row and return the result.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nbool dfs(std::string curr, std::string bottom, std::unordered_map<std::string, std::vector<char>>& mapping) {\n    if (bottom.size() == 1) return true;\n\n    for (int i = 0; i < bottom.size() - 1; ++i) {\n        std::string s = bottom.substr(i, 2);\n        if (mapping.count(s) == 0) return false;\n    }\n\n    curr = \"\";\n    for (int i = 0; i < bottom.size() - 1; ++i) {\n        curr += mapping[bottom.substr(i, 2)][0];\n    }\n\n    return dfs(curr, curr, mapping);\n}\n\nbool pyramidTransition(std::string bottom, std::vector<std::string>& allowed) {\n    std::unordered_map<std::string, std::vector<char>> mapping;\n    for (std::string& s : allowed) {\n        mapping[s.substr(0, 2)].emplace_back(s[2]);\n    }\n    return dfs(\"\", bottom, mapping);\n}\n```\n\n    \n    1. Create a mapping, with the allowed patterns, which maps bottom two characters of allowed string to their respective top character.\n2. Define a function dfs, which loops through the current bottom to find the mapping for the subsequent row.\n3. If it can create a subsequent row fully from the mappings without any error, it calls the dfs again recursively with the new row as the bottom row.\n4. If, finally, a single character row(bottom.length==1) is formed at the top, it returns true; otherwise, it returns false.\n5. Call dfs with the original bottom row and return the result.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\n\ndef pyramidTransition(bottom, allowed):\n    mapping = defaultdict(list)\n    for s in allowed:\n        mapping[s[:2]].append(s[2])\n    return dfs(\"\", bottom, mapping)\n\ndef dfs(curr, bottom, mapping):\n    if len(bottom) == 1:\n        return True\n    for i in range(len(bottom) - 1):\n        if bottom[i:i+2] not in mapping:\n            return False\n    curr = \"\".join(mapping[bottom[i:i + 2]][0] for i in range(len(bottom) - 1))\n    return dfs(curr, curr, mapping)\n```\n\n    \n    1. Create a mapping, with the allowed patterns, which maps bottom two characters of allowed string to their respective top character.\n2. Define a function dfs, which loops through the current bottom to find the mapping for the subsequent row.\n3. If it can create a subsequent row fully from the mappings without any error, it calls the dfs again recursively with the new row as the bottom row.\n4. If, finally, a single character row(bottom.length==1) is formed at the top, it returns true; otherwise, it returns false.\n5. Call dfs with the original bottom row and return the result.\n    ", "javascript": "\n    ```javascript\nfunction pyramidTransition(bottom, allowed) {\n    const mapping = {};\n    for (const s of allowed) {\n        const key = s.slice(0, 2);\n        if (!(key in mapping)) {\n            mapping[key] = [];\n        }\n        mapping[key].push(s[2]);\n    }\n    return dfs(\"\", bottom, mapping);\n}\n\nfunction dfs(curr, bottom, mapping) {\n    if (bottom.length === 1) {\n        return true;\n    }\n    for (let i = 0; i < bottom.length - 1; ++i) {\n        if (!(bottom.slice(i, i + 2) in mapping)) {\n            return false;\n        }\n    }\n    curr = \"\";\n    for (let i = 0; i < bottom.length - 1; ++i) {\n        curr += mapping[bottom.slice(i, i + 2)][0];\n    }\n    return dfs(curr, curr, mapping);\n}\n```\n\n    \n    1. Create a mapping, with the allowed patterns, which maps bottom two characters of allowed string to their respective top character.\n2. Define a function dfs, which loops through the current bottom to find the mapping for the subsequent row.\n3. If it can create a subsequent row fully from the mappings without any error, it calls the dfs again recursively with the new row as the bottom row.\n4. If, finally, a single character row(bottom.length==1) is formed at the top, it returns true; otherwise, it returns false.\n5. Call dfs with the original bottom row and return the result.\n    "}
{"id": 763, "slug": "partition-labels", "title": "Partition Labels", "difficulty": "Medium", "content": "You are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.\n\nReturn _a list of integers representing the size of these parts_.\n\n**Example 1:**\n\n**Input:** s =  \"ababcbacadefegdehijhklij \"\n**Output:** \\[9,7,8\\]\n**Explanation:**\nThe partition is  \"ababcbaca \",  \"defegde \",  \"hijhklij \".\nThis is a partition so that each letter appears in at most one part.\nA partition like  \"ababcbacadefegde \",  \"hijhklij \" is incorrect, because it splits s into less parts.\n\n**Example 2:**\n\n**Input:** s =  \"eccbbbbdec \"\n**Output:** \\[10\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `s` consists of lowercase English letters.", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<Integer> partitionLabels(String s) {\n    Map<Character, Integer> last = new HashMap<>();\n    for (int i = 0; i < s.length(); i++) {\n        last.put(s.charAt(i), i);\n    }\n    List<Integer> ans = new ArrayList<>();\n    int j = 0, anchor = 0;\n    for (int i = 0; i < s.length(); i++) {\n        j = Math.max(j, last.get(s.charAt(i)));\n        if (i == j) {\n            ans.add(i - anchor + 1);\n            anchor = i + 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a greedy approach to solve the problem. In the first step, we loop through the input string and keep track of the last index of each character in a dictionary/hashmap. Then, we loop through the string again and keep track of the farthest index of the encountered characters. If the current index is equal to the farthest index of the encountered characters, then we know that we can partition the string at this index. We append the partition length to the answer list and update the anchor variable to the index after the current index. We continue this process for the entire input string and return the list of partition lengths.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> partitionLabels(std::string s) {\n    std::unordered_map<char, int> last;\n    for (int i = 0; i < s.size(); i++) {\n        last[s[i]] = i;\n    }\n    std::vector<int> ans;\n    int j = 0, anchor = 0;\n    for (int i = 0; i < s.size(); i++) {\n        j = std::max(j, last[s[i]]);\n        if (i == j) {\n            ans.push_back(i - anchor + 1);\n            anchor = i + 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a greedy approach to solve the problem. In the first step, we loop through the input string and keep track of the last index of each character in a dictionary/hashmap. Then, we loop through the string again and keep track of the farthest index of the encountered characters. If the current index is equal to the farthest index of the encountered characters, then we know that we can partition the string at this index. We append the partition length to the answer list and update the anchor variable to the index after the current index. We continue this process for the entire input string and return the list of partition lengths.\n    ", "python": "\n    ```python\ndef partition_labels(s):\n    last = {c:i for i, c in enumerate(s)}\n    ans = []\n    j = anchor = 0\n    for i, c in enumerate(s):\n        j = max(j, last[c])\n        if i == j:\n            ans.append(i - anchor + 1)\n            anchor = i + 1\n    return ans\n```\n    \n    The algorithm uses a greedy approach to solve the problem. In the first step, we loop through the input string and keep track of the last index of each character in a dictionary/hashmap. Then, we loop through the string again and keep track of the farthest index of the encountered characters. If the current index is equal to the farthest index of the encountered characters, then we know that we can partition the string at this index. We append the partition length to the answer list and update the anchor variable to the index after the current index. We continue this process for the entire input string and return the list of partition lengths.\n    ", "javascript": "\n    ```javascript\nfunction partitionLabels(s) {\n    const last = {};\n    for (let i = 0; i < s.length; i++) {\n        last[s[i]] = i;\n    }\n    const ans = [];\n    let j = 0, anchor = 0;\n    for (let i = 0; i < s.length; i++) {\n        j = Math.max(j, last[s[i]]);\n        if (i === j) {\n            ans.push(i - anchor + 1);\n            anchor = i + 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a greedy approach to solve the problem. In the first step, we loop through the input string and keep track of the last index of each character in a dictionary/hashmap. Then, we loop through the string again and keep track of the farthest index of the encountered characters. If the current index is equal to the farthest index of the encountered characters, then we know that we can partition the string at this index. We append the partition length to the answer list and update the anchor variable to the index after the current index. We continue this process for the entire input string and return the list of partition lengths.\n    "}
{"id": 765, "slug": "couples-holding-hands", "title": "Couples Holding Hands", "difficulty": "Hard", "content": "There are `n` couples sitting in `2n` seats arranged in a row and want to hold hands.\n\nThe people and seats are represented by an integer array `row` where `row[i]` is the ID of the person sitting in the `ith` seat. The couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2n - 2, 2n - 1)`.\n\nReturn _the minimum number of swaps so that every couple is sitting side by side_. A swap consists of choosing any two people, then they stand up and switch seats.\n\n**Example 1:**\n\n**Input:** row = \\[0,2,1,3\\]\n**Output:** 1\n**Explanation:** We only need to swap the second (row\\[1\\]) and third (row\\[2\\]) person.\n\n**Example 2:**\n\n**Input:** row = \\[3,2,0,1\\]\n**Output:** 0\n**Explanation:** All couples are already seated side by side.\n\n**Constraints:**\n\n*   `2n == row.length`\n*   `2 <= n <= 30`\n*   `n` is even.\n*   `0 <= row[i] < 2n`\n*   All the elements of `row` are **unique**.", "java": "\n    ```java\npublic int minSwapsCouples(int[] row) {\n    int n = row.length;\n    int[] position = new int[n];\n    for (int i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    int swaps = 0;\n    for (int i = 0; i < n; i += 2) {\n        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != partner) {\n            int temp = row[position[partner]];\n            row[position[partner]] = row[i + 1];\n            row[i + 1] = temp;\n            \n            temp = position[row[i + 1]];\n            position[row[i + 1]] = position[partner];\n            position[partner] = temp;\n            \n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ", "c++": "\n    ```cpp\nint minSwapsCouples(vector<int>& row) {\n    int n = row.size();\n    vector<int> position(n);\n    for (int i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    int swaps = 0;\n    for (int i = 0; i < n; i += 2) {\n        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != partner) {\n            swap(row[position[partner]], row[i + 1]);\n            swap(position[row[i + 1]], position[partner]);\n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ", "python": "\n    ```python\ndef minSwapsCouples(row):\n    n = len(row)\n    position = [0] * n\n    for i in range(n):\n        position[row[i]] = i\n\n    swaps = 0\n    for i in range(0, n, 2):\n        partner = row[i] + 1 if row[i] % 2 == 0 else row[i] - 1\n        if row[i + 1] != partner:\n            row[position[partner]], row[i + 1] = row[i + 1], row[position[partner]]\n            position[row[i + 1]], position[partner] = position[partner], position[row[i + 1]]\n            swaps += 1\n    return swaps\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ", "javascript": "\n    ```javascript\nfunction minSwapsCouples(row) {\n    const n = row.length;\n    const position = new Array(n);\n    for (let i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    let swaps = 0;\n    for (let i = 0; i < n; i += 2) {\n        const partner = row[i] % 2 === 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] !== partner) {\n            [row[position[partner]], row[i + 1]] = [row[i + 1], row[position[partner]]];\n            [position[row[i + 1]], position[partner]] = [position[partner], position[row[i + 1]]];\n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    "}
{"id": 767, "slug": "reorganize-string", "title": "Reorganize String", "difficulty": "Medium", "content": "Given a string `s`, rearrange the characters of `s` so that any two adjacent characters are not the same.\n\nReturn _any possible rearrangement of_ `s` _or return_ `\" \"` _if not possible_.\n\n**Example 1:**\n\n**Input:** s = \"aab\"\n**Output:** \"aba\"\n\n**Example 2:**\n\n**Input:** s = \"aaab\"\n**Output:** \"\"\n\n**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `s` consists of lowercase English letters.", "java": "\n    ```java\npublic boolean isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\npublic int countPrimeSetBits(int left, int right) {\n    int count = 0;\n    for (int i = left; i <= right; i++) {\n        int bits = Integer.bitCount(i);\n        if (isPrime(bits)) count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm consists of two functions: `is_prime` which checks if a given number is prime, and `count_prime_set_bits` which iterates through the range [left, right] and counts the numbers with a prime number of set bits in their binary representation.\n\nThe `is_prime` function checks if a number is prime by iterating through the range [2, sqrt(n)] and checking if n is divisible by any of these numbers. If it's divisible by any of these numbers, then it's not prime (returns false) otherwise, it's prime (returns true).\n\nIn the `count_prime_set_bits` function, we iterate through the range [left, right]. For each number, we count the number of set bits (1's) in its binary representation using an appropriate bit counting function/method for each language. We then check if the resulting count is prime using the `is_prime` function. If it is, we increment the counter.\n\nFinally, we return the counter after iterating through the range.\n    ", "c++": "\n    ```cpp\n#include <bitset>\n#include <vector>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint count_prime_set_bits(int left, int right) {\n    int count = 0;\n    for (int i = left; i <= right; i++) {\n        if (is_prime(std::bitset<32>(i).count())) count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm consists of two functions: `is_prime` which checks if a given number is prime, and `count_prime_set_bits` which iterates through the range [left, right] and counts the numbers with a prime number of set bits in their binary representation.\n\nThe `is_prime` function checks if a number is prime by iterating through the range [2, sqrt(n)] and checking if n is divisible by any of these numbers. If it's divisible by any of these numbers, then it's not prime (returns false) otherwise, it's prime (returns true).\n\nIn the `count_prime_set_bits` function, we iterate through the range [left, right]. For each number, we count the number of set bits (1's) in its binary representation using an appropriate bit counting function/method for each language. We then check if the resulting count is prime using the `is_prime` function. If it is, we increment the counter.\n\nFinally, we return the counter after iterating through the range.\n    ", "python": "\n    ```python\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef count_prime_set_bits(left: int, right: int) -> int:\n    count = 0\n    for i in range(left, right + 1):\n        bits = bin(i).count('1')\n        if is_prime(bits):\n            count += 1\n    return count\n```\n    \n    The algorithm consists of two functions: `is_prime` which checks if a given number is prime, and `count_prime_set_bits` which iterates through the range [left, right] and counts the numbers with a prime number of set bits in their binary representation.\n\nThe `is_prime` function checks if a number is prime by iterating through the range [2, sqrt(n)] and checking if n is divisible by any of these numbers. If it's divisible by any of these numbers, then it's not prime (returns false) otherwise, it's prime (returns true).\n\nIn the `count_prime_set_bits` function, we iterate through the range [left, right]. For each number, we count the number of set bits (1's) in its binary representation using an appropriate bit counting function/method for each language. We then check if the resulting count is prime using the `is_prime` function. If it is, we increment the counter.\n\nFinally, we return the counter after iterating through the range.\n    ", "javascript": "\n    ```javascript\nfunction isPrime(n) {\n    if (n <= 1) return false;\n    for (let i = 2; i * i <= n; i++) {\n        if (n % i === 0) return false;\n    }\n    return true;\n}\n\nfunction countPrimeSetBits(left, right) {\n    let count = 0;\n    for (let i = left; i <= right; i++) {\n        let bits = i.toString(2).split('1').length - 1;\n        if (isPrime(bits)) count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm consists of two functions: `is_prime` which checks if a given number is prime, and `count_prime_set_bits` which iterates through the range [left, right] and counts the numbers with a prime number of set bits in their binary representation.\n\nThe `is_prime` function checks if a number is prime by iterating through the range [2, sqrt(n)] and checking if n is divisible by any of these numbers. If it's divisible by any of these numbers, then it's not prime (returns false) otherwise, it's prime (returns true).\n\nIn the `count_prime_set_bits` function, we iterate through the range [left, right]. For each number, we count the number of set bits (1's) in its binary representation using an appropriate bit counting function/method for each language. We then check if the resulting count is prime using the `is_prime` function. If it is, we increment the counter.\n\nFinally, we return the counter after iterating through the range.\n    "}
{"id": 768, "slug": "max-chunks-to-make-sorted-ii", "title": "Max Chunks To Make Sorted II", "difficulty": "Hard", "content": "You are given an integer array `arr`.\n\nWe split `arr` into some number of **chunks** (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.\n\nReturn _the largest number of chunks we can make to sort the array_.\n\n**Example 1:**\n\n**Input:** arr = \\[5,4,3,2,1\\]\n**Output:** 1\n**Explanation:**\nSplitting into two or more chunks will not return the required result.\nFor example, splitting into \\[5, 4\\], \\[3, 2, 1\\] will result in \\[4, 5, 1, 2, 3\\], which isn't sorted.\n\n**Example 2:**\n\n**Input:** arr = \\[2,1,3,4,4\\]\n**Output:** 4\n**Explanation:**\nWe can split into two chunks, such as \\[2, 1\\], \\[3, 4, 4\\].\nHowever, splitting into \\[2, 1\\], \\[3\\], \\[4\\], \\[4\\] is the highest number of chunks possible.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 2000`\n*   `0 <= arr[i] <= 108`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic List<Integer> partitionLabels(String s) {\n    HashMap<Character, Integer> lastPos = new HashMap<>();\n    for (int i = 0; i < s.length(); i++) {\n        lastPos.put(s.charAt(i), i);\n    }\n\n    List<Integer> partitions = new ArrayList<>();\n    int start = 0, end = 0;\n    for (int i = 0; i < s.length(); i++) {\n        end = Math.max(end, lastPos.get(s.charAt(i)));\n        if (i == end) {\n            partitions.add(end - start + 1);\n            start = i + 1;\n        }\n    }\n    return partitions;\n}\n```\n\n    \n    1. Create a dictionary `lastPos` to store the last position for each character in the string.\n2. Iterate over the string, and for each character, store its last position in the `lastPos` dictionary.\n3. Create a list `partitions` to store the partition sizes.\n4. Initialize two variables `start` and `end` with value 0.\n5. Iterate over the string again:\n   a. For each character, update `end` with the maximum value between `end` and its last position from the `lastPos` dictionary.\n   b. If the current index is equal to `end`, calculate the length of the current partition, append it to `partitions`, and update `start` to the next index.\n6. Return the `partitions` list.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> partitionLabels(const std::string& s) {\n    std::unordered_map<char, int> lastPos;\n    for (int i = 0; i < s.size(); i++) {\n        lastPos[s[i]] = i;\n    }\n\n    std::vector<int> partitions;\n    int start = 0, end = 0;\n    for (int i = 0; i < s.size(); i++) {\n        end = std::max(end, lastPos[s[i]]);\n        if (i == end) {\n            partitions.push_back(end - start + 1);\n            start = i + 1;\n        }\n    }\n    return partitions;\n}\n```\n\n    \n    1. Create a dictionary `lastPos` to store the last position for each character in the string.\n2. Iterate over the string, and for each character, store its last position in the `lastPos` dictionary.\n3. Create a list `partitions` to store the partition sizes.\n4. Initialize two variables `start` and `end` with value 0.\n5. Iterate over the string again:\n   a. For each character, update `end` with the maximum value between `end` and its last position from the `lastPos` dictionary.\n   b. If the current index is equal to `end`, calculate the length of the current partition, append it to `partitions`, and update `start` to the next index.\n6. Return the `partitions` list.\n    ", "python": "\n    ```python\ndef partition_labels(s: str) -> list[int]:\n    last_pos = {}\n    for i, c in enumerate(s):\n        last_pos[c] = i\n\n    partitions = []\n    start, end = 0, 0\n    for i, c in enumerate(s):\n        end = max(end, last_pos[c])\n        if i == end:\n            partitions.append(end - start + 1)\n            start = i + 1\n    return partitions\n```\n\n    \n    1. Create a dictionary `lastPos` to store the last position for each character in the string.\n2. Iterate over the string, and for each character, store its last position in the `lastPos` dictionary.\n3. Create a list `partitions` to store the partition sizes.\n4. Initialize two variables `start` and `end` with value 0.\n5. Iterate over the string again:\n   a. For each character, update `end` with the maximum value between `end` and its last position from the `lastPos` dictionary.\n   b. If the current index is equal to `end`, calculate the length of the current partition, append it to `partitions`, and update `start` to the next index.\n6. Return the `partitions` list.\n    ", "javascript": "\n    ```javascript\nfunction partitionLabels(s) {\n    const lastPos = {};\n    for (let i = 0; i < s.length; i++) {\n        lastPos[s[i]] = i;\n    }\n\n    const partitions = [];\n    let start = 0, end = 0;\n    for (let i = 0; i < s.length; i++) {\n        end = Math.max(end, lastPos[s[i]]);\n        if (i === end) {\n            partitions.push(end - start + 1);\n            start = i + 1;\n        }\n    }\n    return partitions;\n}\n```\n\n    \n    1. Create a dictionary `lastPos` to store the last position for each character in the string.\n2. Iterate over the string, and for each character, store its last position in the `lastPos` dictionary.\n3. Create a list `partitions` to store the partition sizes.\n4. Initialize two variables `start` and `end` with value 0.\n5. Iterate over the string again:\n   a. For each character, update `end` with the maximum value between `end` and its last position from the `lastPos` dictionary.\n   b. If the current index is equal to `end`, calculate the length of the current partition, append it to `partitions`, and update `start` to the next index.\n6. Return the `partitions` list.\n    "}
{"id": 769, "slug": "max-chunks-to-make-sorted", "title": "Max Chunks To Make Sorted", "difficulty": "Medium", "content": "You are given an integer array `arr` of length `n` that represents a permutation of the integers in the range `[0, n - 1]`.\n\nWe split `arr` into some number of **chunks** (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.\n\nReturn _the largest number of chunks we can make to sort the array_.\n\n**Example 1:**\n\n**Input:** arr = \\[4,3,2,1,0\\]\n**Output:** 1\n**Explanation:**\nSplitting into two or more chunks will not return the required result.\nFor example, splitting into \\[4, 3\\], \\[2, 1, 0\\] will result in \\[3, 4, 0, 1, 2\\], which isn't sorted.\n\n**Example 2:**\n\n**Input:** arr = \\[1,0,2,3,4\\]\n**Output:** 4\n**Explanation:**\nWe can split into two chunks, such as \\[1, 0\\], \\[2, 3, 4\\].\nHowever, splitting into \\[1, 0\\], \\[2\\], \\[3\\], \\[4\\] is the highest number of chunks possible.\n\n**Constraints:**\n\n*   `n == arr.length`\n*   `1 <= n <= 10`\n*   `0 <= arr[i] < n`\n*   All the elements of `arr` are **unique**.", "java": "\n    ```java\npublic int orderOfLargestPlusSign(int n, int[][] mines) {\n    int[][] grid = new int[n][n];\n    for (int[] row : grid) Arrays.fill(row, 1);\n    for (int[] mine : mines) grid[mine[0]][mine[1]] = 0;\n    \n    int[][][] dp = new int[n][n][4];\n    for (int i=0; i<n; ++i)\n        for (int j=0; j<n; ++j)\n            if (grid[i][j] > 0) {\n                dp[i][j][0] = i > 0 ? dp[i - 1][j][0] + 1 : 1;\n                dp[i][j][1] = j > 0 ? dp[i][j - 1][1] + 1 : 1;\n            }\n                \n    int ans = 0;\n    for (int i=n-1; i>=0; --i)\n        for (int j=n-1; j>=0; --j)\n            if (grid[i][j] > 0) {\n                dp[i][j][2] = i < n - 1 ? dp[i + 1][j][2] + 1 : 1;\n                dp[i][j][3] = j < n - 1 ? dp[i][j + 1][3] + 1 : 1;\n                int cur = Collections.min(Arrays.asList(dp[i][j]));\n                ans = Math.max(ans, cur);\n            }\n                \n    return ans;\n}\n```\n\n    \n    1. Initialize a grid of n x n with all 1's and set the elements at the indices given in mines as 0.\n2. Create four matrices called left, right, up, and down which are copies of the grid.\n3. Iterate through the grid left to right, top to bottom and update the left and up matrices based on the grid values.\n4. Iterate through the grid right to left, bottom to top and update the right and down matrices based on the grid values.\n5. Iterate through the grid again and calculate the minimum value at each position between the left, right, up, and down matrices.\n6. Return the maximum value seen during step 5 which is the largest axis-aligned plus sign order.\n    ", "c++": "\n    ```cpp\nint orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\n    vector<vector<int>> grid(n, vector<int>(n, 1));\n    for (const auto& mine : mines)\n        grid[mine[0]][mine[1]] = 0;\n        \n    vector<vector<int>> left(grid), right(grid), up(grid), down(grid);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j]) {\n                left[i][j] = j > 0 ? left[i][j - 1] + 1 : 1;\n                up[i][j] = i > 0 ? up[i - 1][j] + 1 : 1;\n            }\n            if (grid[n - i - 1][n - j - 1]) {\n                right[n - i - 1][n - j - 1] = j > 0 ? right[n - i - 1][n - j] + 1 : 1;\n                down[n - i - 1][n - j - 1] = i > 0 ? down[n - i][n - j - 1] + 1 : 1;\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            ans = max(ans, min({left[i][j], right[i][j], up[i][j], down[i][j]}));\n    return ans;\n}\n```\n\n    \n    1. Initialize a grid of n x n with all 1's and set the elements at the indices given in mines as 0.\n2. Create four matrices called left, right, up, and down which are copies of the grid.\n3. Iterate through the grid left to right, top to bottom and update the left and up matrices based on the grid values.\n4. Iterate through the grid right to left, bottom to top and update the right and down matrices based on the grid values.\n5. Iterate through the grid again and calculate the minimum value at each position between the left, right, up, and down matrices.\n6. Return the maximum value seen during step 5 which is the largest axis-aligned plus sign order.\n    ", "python": "\n    ```python\ndef orderOfLargestPlusSign(n, mines):\n    grid = [[1] * n for _ in range(n)]\n    for mine in mines:\n        grid[mine[0]][mine[1]] = 0\n        \n    left, right, up, down = [list(grid) for _ in range(4)]\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j]:\n                left[i][j] = 1 + (left[i][j - 1] if j > 0 else 0)\n                up[i][j] = 1 + (up[i - 1][j] if i > 0 else 0)\n\n    ans = 0\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if grid[i][j]:\n                right[i][j] = 1 + (right[i][j + 1] if j < n - 1 else 0)\n                down[i][j] = 1 + (down[i + 1][j] if i < n - 1 else 0)\n                ans = max(ans, min([left[i][j], right[i][j], up[i][j], down[i][j]]))\n\n    return ans\n```\n\n    \n    1. Initialize a grid of n x n with all 1's and set the elements at the indices given in mines as 0.\n2. Create four matrices called left, right, up, and down which are copies of the grid.\n3. Iterate through the grid left to right, top to bottom and update the left and up matrices based on the grid values.\n4. Iterate through the grid right to left, bottom to top and update the right and down matrices based on the grid values.\n5. Iterate through the grid again and calculate the minimum value at each position between the left, right, up, and down matrices.\n6. Return the maximum value seen during step 5 which is the largest axis-aligned plus sign order.\n    ", "javascript": "\n    ```javascript\nfunction orderOfLargestPlusSign(n, mines) {\n    const grid = Array.from({ length: n }, () => Array(n).fill(1));\n    for (const mine of mines)\n        grid[mine[0]][mine[1]] = 0;\n\n    const left = grid.map(row => [...row]);\n    const right = grid.map(row => [...row]);\n    const up = grid.map(row => [...row]);\n    const down = grid.map(row => [...row]);\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (grid[i][j]) {\n                left[i][j] = j > 0 ? left[i][j - 1] + 1 : 1;\n                up[i][j] = i > 0 ? up[i - 1][j] + 1 : 1;\n            }\n            if (grid[n - i - 1][n - j - 1]) {\n                right[n - i - 1][n - j - 1] = j > 0 ? right[n - i - 1][n - j] + 1 : 1;\n                down[n - i - 1][n - j - 1] = i > 0 ? down[n - i][n - j - 1] + 1 : 1;\n            }\n        }\n    }\n\n    let ans = 0;\n    for (let i = 0; i < n; ++i)\n        for (let j = 0; j < n; ++j)\n            ans = Math.max(ans, Math.min(left[i][j], right[i][j], up[i][j], down[i][j]));\n\n    return ans;\n}\n```\n\n    \n    1. Initialize a grid of n x n with all 1's and set the elements at the indices given in mines as 0.\n2. Create four matrices called left, right, up, and down which are copies of the grid.\n3. Iterate through the grid left to right, top to bottom and update the left and up matrices based on the grid values.\n4. Iterate through the grid right to left, bottom to top and update the right and down matrices based on the grid values.\n5. Iterate through the grid again and calculate the minimum value at each position between the left, right, up, and down matrices.\n6. Return the maximum value seen during step 5 which is the largest axis-aligned plus sign order.\n    "}
{"id": 781, "slug": "rabbits-in-forest", "title": "Rabbits in Forest", "difficulty": "Medium", "content": "There is a forest with an unknown number of rabbits. We asked n rabbits **\"How many rabbits have the same color as you? \"** and collected the answers in an integer array `answers` where `answers[i]` is the answer of the `ith` rabbit.\n\nGiven the array `answers`, return _the minimum number of rabbits that could be in the forest_.\n\n**Example 1:**\n\n**Input:** answers = \\[1,1,2\\]\n**Output:** 5\n**Explanation:**\nThe two rabbits that answered  \"1 \" could both be the same color, say red.\nThe rabbit that answered  \"2 \" can't be red or the answers would be inconsistent.\nSay the rabbit that answered  \"2 \" was blue.\nThen there should be 2 other blue rabbits in the forest that didn't answer into the array.\nThe smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.\n\n**Example 2:**\n\n**Input:** answers = \\[10,10,10\\]\n**Output:** 11\n\n**Constraints:**\n\n*   `1 <= answers.length <= 1000`\n*   `0 <= answers[i] < 1000`", "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int numRabbits(int[] answers) {\n    HashMap<Integer, Integer> count = new HashMap<>();\n    int rabbits = 0;\n    for(int ans : answers) {\n        count.put(ans, count.getOrDefault(ans, 0) + 1);\n    }\n    for(int key : count.keySet()) {\n        int cnt = count.get(key);\n        rabbits += (key + cnt) / (key + 1) * (key + 1);\n    }\n    return rabbits;\n}\n```\n\n    \n    The algorithm uses a hashmap (Counter in python) to count the frequency of each answer. For each answer, because rabbits of the same color give the same answer `k`, there can be `k+1` rabbits, i.e., if they all belong to the same group, there can be `k+1` rabbits of the same color. The algorithm calculates the total number of rabbits i.e. total_rabbits = required number of rabbits in each answer group * number of groups (calculated by dividing the count of the answer by k+1) * (k + 1).\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint numRabbits(vector<int>& answers) {\n    unordered_map<int, int> count;\n    int rabbits = 0;\n    for (int ans : answers) {\n        count[ans]++;\n    }\n    for (auto& [ans, cnt] : count) {\n        rabbits += (ans + cnt) / (ans + 1) * (ans + 1);\n    }\n    return rabbits;\n}\n```\n\n    \n    The algorithm uses a hashmap (Counter in python) to count the frequency of each answer. For each answer, because rabbits of the same color give the same answer `k`, there can be `k+1` rabbits, i.e., if they all belong to the same group, there can be `k+1` rabbits of the same color. The algorithm calculates the total number of rabbits i.e. total_rabbits = required number of rabbits in each answer group * number of groups (calculated by dividing the count of the answer by k+1) * (k + 1).\n    ", "python": "\n    ```python\nfrom collections import Counter\n\ndef numRabbits(answers):\n    count = Counter(answers)\n    rabbits = 0\n    for ans, cnt in count.items():\n        rabbits += (ans + cnt)//(ans + 1) * (ans + 1)\n    return rabbits\n```\n\n    \n    The algorithm uses a hashmap (Counter in python) to count the frequency of each answer. For each answer, because rabbits of the same color give the same answer `k`, there can be `k+1` rabbits, i.e., if they all belong to the same group, there can be `k+1` rabbits of the same color. The algorithm calculates the total number of rabbits i.e. total_rabbits = required number of rabbits in each answer group * number of groups (calculated by dividing the count of the answer by k+1) * (k + 1).\n    ", "javascript": "\n    ```javascript\nfunction numRabbits(answers) {\n    const count = new Map();\n    let rabbits = 0;\n    for(let ans of answers) {\n        count.set(ans, (count.get(ans) || 0) + 1);\n    }\n    for(let [ans, cnt] of count.entries()) {\n        rabbits += Math.floor((ans + cnt) / (ans + 1)) * (ans + 1);\n    }\n    return rabbits;\n}\n```\n\n    \n    The algorithm uses a hashmap (Counter in python) to count the frequency of each answer. For each answer, because rabbits of the same color give the same answer `k`, there can be `k+1` rabbits, i.e., if they all belong to the same group, there can be `k+1` rabbits of the same color. The algorithm calculates the total number of rabbits i.e. total_rabbits = required number of rabbits in each answer group * number of groups (calculated by dividing the count of the answer by k+1) * (k + 1).\n    "}
{"id": 807, "slug": "max-increase-to-keep-city-skyline", "title": "Max Increase to Keep City Skyline", "difficulty": "Medium", "content": "There is a city composed of `n x n` blocks, where each block contains a single building shaped like a vertical square prism. You are given a **0-indexed** `n x n` integer matrix `grid` where `grid[r][c]` represents the **height** of the building located in the block at row `r` and column `c`.\n\nA city's **skyline** is the outer contour formed by all the building when viewing the side of the city from a distance. The **skyline** from each cardinal direction north, east, south, and west may be different.\n\nWe are allowed to increase the height of **any number of buildings by any amount** (the amount can be different per building). The height of a `0`\\-height building can also be increased. However, increasing the height of a building should **not** affect the city's **skyline** from any cardinal direction.\n\nReturn _the **maximum total sum** that the height of the buildings can be increased by **without** changing the city's **skyline** from any cardinal direction_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[3,0,8,4\\],\\[2,4,5,7\\],\\[9,2,6,3\\],\\[0,3,1,0\\]\\]\n**Output:** 35\n**Explanation:** The building heights are shown in the center of the above image.\nThe skylines when viewed from each cardinal direction are drawn in red.\nThe grid after increasing the height of buildings without affecting skylines is:\ngridNew = \\[ \\[8, 4, 8, 7\\],\n            \\[7, 4, 7, 7\\],\n            \\[9, 4, 8, 7\\],\n            \\[3, 3, 3, 3\\] \\]\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[0,0,0\\],\\[0,0,0\\]\\]\n**Output:** 0\n**Explanation:** Increasing the height of any building will result in the skyline changing.\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[r].length`\n*   `2 <= n <= 50`\n*   `0 <= grid[r][c] <= 100`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic class Solution {\n    public String customSortString(String order, String s) {\n        Character[] sArray = s.chars().mapToObj(c -> (char)c).toArray(Character[]::new);\n        Arrays.sort(sArray, (a, b) -> order.indexOf(a) - order.indexOf(b));\n        return Arrays.stream(sArray).map(String::valueOf).collect(Collectors.joining());\n    }\n}\n```\n\n    \n    The key idea of this algorithm is to sort the characters in the string `s` based on the ordering specified by the string `order`. We can achieve this by passing a custom comparing function to the `sort` function for each language implementation used here. \n\nIn C++, the custom comparator is provided as a lambda function that takes two characters, `a` and `b`, and compares their positions in the `order` string using `order.find(a) < order.find(b)`.\n\nIn Java, we follow a similar approach. First, we convert the string `s` to a Character array. Then, we provide the custom comparator as a lambda function `(a, b) -> order.indexOf(a) - order.indexOf(b)`. Finally, we concatenate the elements of the sorted array to form the result string.\n\nIn Python, we use the `sorted()` function with a custom lambda function for the `key` parameter: `order.index(x) if x in order else len(order)`. This ensures that if the character is not in `order`, it will be at the end of the sorted string.\n\nIn JavaScript, we first split the string `s` into an array of characters, then use the `sort()` function by providing a custom comparator as a lambda function `(a, b) => order.indexOf(a) - order.indexOf(b)`, and finally join the sorted array back into a string.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring customSortString(string order, string s) {\n    sort(s.begin(), s.end(), [&](char a, char b) { return order.find(a) < order.find(b); });\n    return s;\n}\n```\n\n    \n    The key idea of this algorithm is to sort the characters in the string `s` based on the ordering specified by the string `order`. We can achieve this by passing a custom comparing function to the `sort` function for each language implementation used here. \n\nIn C++, the custom comparator is provided as a lambda function that takes two characters, `a` and `b`, and compares their positions in the `order` string using `order.find(a) < order.find(b)`.\n\nIn Java, we follow a similar approach. First, we convert the string `s` to a Character array. Then, we provide the custom comparator as a lambda function `(a, b) -> order.indexOf(a) - order.indexOf(b)`. Finally, we concatenate the elements of the sorted array to form the result string.\n\nIn Python, we use the `sorted()` function with a custom lambda function for the `key` parameter: `order.index(x) if x in order else len(order)`. This ensures that if the character is not in `order`, it will be at the end of the sorted string.\n\nIn JavaScript, we first split the string `s` into an array of characters, then use the `sort()` function by providing a custom comparator as a lambda function `(a, b) => order.indexOf(a) - order.indexOf(b)`, and finally join the sorted array back into a string.\n    ", "python": "\n    ```python\ndef custom_sort_string(order, s):\n    return ''.join(sorted(s, key=lambda x: order.index(x) if x in order else len(order)))\n```\n\n    \n    The key idea of this algorithm is to sort the characters in the string `s` based on the ordering specified by the string `order`. We can achieve this by passing a custom comparing function to the `sort` function for each language implementation used here. \n\nIn C++, the custom comparator is provided as a lambda function that takes two characters, `a` and `b`, and compares their positions in the `order` string using `order.find(a) < order.find(b)`.\n\nIn Java, we follow a similar approach. First, we convert the string `s` to a Character array. Then, we provide the custom comparator as a lambda function `(a, b) -> order.indexOf(a) - order.indexOf(b)`. Finally, we concatenate the elements of the sorted array to form the result string.\n\nIn Python, we use the `sorted()` function with a custom lambda function for the `key` parameter: `order.index(x) if x in order else len(order)`. This ensures that if the character is not in `order`, it will be at the end of the sorted string.\n\nIn JavaScript, we first split the string `s` into an array of characters, then use the `sort()` function by providing a custom comparator as a lambda function `(a, b) => order.indexOf(a) - order.indexOf(b)`, and finally join the sorted array back into a string.\n    ", "javascript": "\n    ```javascript\nfunction customSortString(order, s) {\n    return s.split('').sort((a, b) => order.indexOf(a) - order.indexOf(b)).join('');\n}\n```\n\n    \n    The key idea of this algorithm is to sort the characters in the string `s` based on the ordering specified by the string `order`. We can achieve this by passing a custom comparing function to the `sort` function for each language implementation used here. \n\nIn C++, the custom comparator is provided as a lambda function that takes two characters, `a` and `b`, and compares their positions in the `order` string using `order.find(a) < order.find(b)`.\n\nIn Java, we follow a similar approach. First, we convert the string `s` to a Character array. Then, we provide the custom comparator as a lambda function `(a, b) -> order.indexOf(a) - order.indexOf(b)`. Finally, we concatenate the elements of the sorted array to form the result string.\n\nIn Python, we use the `sorted()` function with a custom lambda function for the `key` parameter: `order.index(x) if x in order else len(order)`. This ensures that if the character is not in `order`, it will be at the end of the sorted string.\n\nIn JavaScript, we first split the string `s` into an array of characters, then use the `sort()` function by providing a custom comparator as a lambda function `(a, b) => order.indexOf(a) - order.indexOf(b)`, and finally join the sorted array back into a string.\n    "}
{"id": 826, "slug": "most-profit-assigning-work", "title": "Most Profit Assigning Work", "difficulty": "Medium", "content": "You have `n` jobs and `m` workers. You are given three arrays: `difficulty`, `profit`, and `worker` where:\n\n*   `difficulty[i]` and `profit[i]` are the difficulty and the profit of the `ith` job, and\n*   `worker[j]` is the ability of `jth` worker (i.e., the `jth` worker can only complete a job with difficulty at most `worker[j]`).\n\nEvery worker can be assigned **at most one job**, but one job can be **completed multiple times**.\n\n*   For example, if three workers attempt the same job that pays `$1`, then the total profit will be `$3`. If a worker cannot complete any job, their profit is `$0`.\n\nReturn the maximum profit we can achieve after assigning the workers to the jobs.\n\n**Example 1:**\n\n**Input:** difficulty = \\[2,4,6,8,10\\], profit = \\[10,20,30,40,50\\], worker = \\[4,5,6,7\\]\n**Output:** 100\n**Explanation:** Workers are assigned jobs of difficulty \\[4,4,6,6\\] and they get a profit of \\[20,20,30,30\\] separately.\n\n**Example 2:**\n\n**Input:** difficulty = \\[85,47,57\\], profit = \\[24,66,99\\], worker = \\[40,25,25\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == difficulty.length`\n*   `n == profit.length`\n*   `m == worker.length`\n*   `1 <= n, m <= 104`\n*   `1 <= difficulty[i], profit[i], worker[i] <= 105`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\n    int n = difficulty.length;\n    int[][] jobs = new int[n][2];\n\n    for (int i = 0; i < n; ++i) {\n        jobs[i] = new int[]{difficulty[i], profit[i]};\n    }\n\n    Arrays.sort(jobs, (a, b) -> a[0] - b[0]);\n    Arrays.sort(worker);\n\n    int max_profit = 0;\n    int total_profit = 0;\n    int job_idx = 0;\n\n    for (int w : worker) {\n        while (job_idx < n && w >= jobs[job_idx][0]) {\n            max_profit = Math.max(max_profit, jobs[job_idx][1]);\n            job_idx++;\n        }\n        total_profit += max_profit;\n    }\n\n    return total_profit;\n}\n```\n    \n    1. Combine the difficulty and profit arrays into one array, called jobs, containing pairs of the values (in JavaScript, arrays of arrays), and sort it based on the difficulty values.\n2. Sort the worker array in ascending order.\n3. Initially, set the max_profit and total_profit to 0, and job_idx to 0.\n4. Iterate over the worker array.\n   a. Inside the loop, while job_idx is less than n (number of jobs) and the current worker's ability is greater than or equal to the current job's difficulty, update the max_profit to be the maximum of the current max_profit and the current job's profit, and increment job_idx.\n   b. After the inner loop, add max_profit to the total_profit.\n5. Return the total_profit.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxProfitAssignment(std::vector<int>& difficulty, std::vector<int>& profit, std::vector<int>& worker) {\n    int n = difficulty.size();\n    std::vector<std::pair<int, int>> jobs(n);\n\n    for (int i = 0; i < n; ++i) {\n        jobs[i] = {difficulty[i], profit[i]};\n    }\n\n    std::sort(jobs.begin(), jobs.end());\n    std::sort(worker.begin(), worker.end());\n\n    int max_profit = 0;\n    int total_profit = 0;\n    int job_idx = 0;\n\n    for (int w : worker) {\n        while (job_idx < n && w >= jobs[job_idx].first) {\n            max_profit = std::max(max_profit, jobs[job_idx].second);\n            job_idx++;\n        }\n        total_profit += max_profit;\n    }\n\n    return total_profit;\n}\n```\n    \n    1. Combine the difficulty and profit arrays into one array, called jobs, containing pairs of the values (in JavaScript, arrays of arrays), and sort it based on the difficulty values.\n2. Sort the worker array in ascending order.\n3. Initially, set the max_profit and total_profit to 0, and job_idx to 0.\n4. Iterate over the worker array.\n   a. Inside the loop, while job_idx is less than n (number of jobs) and the current worker's ability is greater than or equal to the current job's difficulty, update the max_profit to be the maximum of the current max_profit and the current job's profit, and increment job_idx.\n   b. After the inner loop, add max_profit to the total_profit.\n5. Return the total_profit.\n    ", "python": "\n    ```python\ndef maxProfitAssignment(difficulty, profit, worker):\n    n = len(difficulty)\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    max_profit = 0\n    total_profit = 0\n    job_idx = 0\n\n    for w in worker:\n        while job_idx < n and w >= jobs[job_idx][0]:\n            max_profit = max(max_profit, jobs[job_idx][1])\n            job_idx += 1\n        total_profit += max_profit\n\n    return total_profit\n```\n    \n    1. Combine the difficulty and profit arrays into one array, called jobs, containing pairs of the values (in JavaScript, arrays of arrays), and sort it based on the difficulty values.\n2. Sort the worker array in ascending order.\n3. Initially, set the max_profit and total_profit to 0, and job_idx to 0.\n4. Iterate over the worker array.\n   a. Inside the loop, while job_idx is less than n (number of jobs) and the current worker's ability is greater than or equal to the current job's difficulty, update the max_profit to be the maximum of the current max_profit and the current job's profit, and increment job_idx.\n   b. After the inner loop, add max_profit to the total_profit.\n5. Return the total_profit.\n    ", "javascript": "\n    ```javascript\nfunction maxProfitAssignment(difficulty, profit, worker) {\n    const n = difficulty.length;\n    const jobs = difficulty.map((d, i) => [d, profit[i]]).sort((a, b) => a[0] - b[0]);\n\n    worker.sort((a, b) => a - b);\n\n    let max_profit = 0;\n    let total_profit = 0;\n    let job_idx = 0;\n\n    for (const w of worker) {\n        while (job_idx < n && w >= jobs[job_idx][0]) {\n            max_profit = Math.max(max_profit, jobs[job_idx][1]);\n            job_idx++;\n        }\n        total_profit += max_profit;\n    }\n\n    return total_profit;\n}\n```\n\n    \n    1. Combine the difficulty and profit arrays into one array, called jobs, containing pairs of the values (in JavaScript, arrays of arrays), and sort it based on the difficulty values.\n2. Sort the worker array in ascending order.\n3. Initially, set the max_profit and total_profit to 0, and job_idx to 0.\n4. Iterate over the worker array.\n   a. Inside the loop, while job_idx is less than n (number of jobs) and the current worker's ability is greater than or equal to the current job's difficulty, update the max_profit to be the maximum of the current max_profit and the current job's profit, and increment job_idx.\n   b. After the inner loop, add max_profit to the total_profit.\n5. Return the total_profit.\n    "}
{"id": 846, "slug": "hand-of-straights", "title": "Hand of Straights", "difficulty": "Medium", "content": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size `groupSize`, and consists of `groupSize` consecutive cards.\n\nGiven an integer array `hand` where `hand[i]` is the value written on the `ith` card and an integer `groupSize`, return `true` if she can rearrange the cards, or `false` otherwise.\n\n**Example 1:**\n\n**Input:** hand = \\[1,2,3,6,2,3,4,7,8\\], groupSize = 3\n**Output:** true\n**Explanation:** Alice's hand can be rearranged as \\[1,2,3\\],\\[2,3,4\\],\\[6,7,8\\]\n\n**Example 2:**\n\n**Input:** hand = \\[1,2,3,4,5\\], groupSize = 4\n**Output:** false\n**Explanation:** Alice's hand can not be rearranged into groups of 4.\n\n**Constraints:**\n\n*   `1 <= hand.length <= 104`\n*   `0 <= hand[i] <= 109`\n*   `1 <= groupSize <= hand.length`\n\n**Note:** This question is the same as 1296: [https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/](https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/)", "java": "\n    ```java\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic boolean isPossibleDivide(int[] hand, int groupSize) {\n    Map<Integer, Integer> cardCount = new TreeMap<>();\n    for (int card : hand) {\n        cardCount.put(card, cardCount.getOrDefault(card, 0) + 1);\n    }\n\n    for (int card : cardCount.keySet()) {\n        int count = cardCount.get(card);\n        if (count > 0) {\n            for (int i = 1; i < groupSize; ++i) {\n                int tmp = cardCount.getOrDefault(card + i, 0) - count;\n                if (tmp < 0) {\n                    return false;\n                }\n                cardCount.put(card + i, tmp);\n            }\n        }\n    }\n\n    return true;\n}\n```\n\n    \n    The algorithm counts the occurrence of each card value and stores it in a map. Then, it iterates through the sorted card values in the map. For each card with a count greater than 0, it checks if it can decrement the count for the next `groupSize - 1` card values by the current count without going below 0. If it's possible to do so for all card values, then the cards can be divided into groups of size `groupSize` with consecutive values.\n\nThe algorithm has a time complexity of O(n * log(n)) due to the sorting process, where n is the length of the hand array.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <map>\n\nbool isPossibleDivide(std::vector<int>& hand, int groupSize) {\n    std::map<int, int> cardCount;\n    for (int card : hand) {\n        cardCount[card]++;\n    }\n\n    for (auto it = cardCount.begin(); it != cardCount.end(); ++it) {\n        if (it->second > 0) {\n            int count = it->second;\n            for (int i = 1; i < groupSize; ++i) {\n                cardCount[it->first + i] -= count;\n                if (cardCount[it->first + i] < 0) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```\n\n    \n    The algorithm counts the occurrence of each card value and stores it in a map. Then, it iterates through the sorted card values in the map. For each card with a count greater than 0, it checks if it can decrement the count for the next `groupSize - 1` card values by the current count without going below 0. If it's possible to do so for all card values, then the cards can be divided into groups of size `groupSize` with consecutive values.\n\nThe algorithm has a time complexity of O(n * log(n)) due to the sorting process, where n is the length of the hand array.\n    ", "python": "\n    ```python\nfrom collections import Counter\n\ndef is_possible_divide(hand, group_size):\n    card_count = Counter(hand)\n\n    for card in sorted(card_count):\n        if card_count[card] > 0:\n            count = card_count[card]\n            for i in range(1, group_size):\n                if card_count[card + i] < count:\n                    return False\n                card_count[card + i] -= count\n\n    return True\n```\n\n    \n    The algorithm counts the occurrence of each card value and stores it in a map. Then, it iterates through the sorted card values in the map. For each card with a count greater than 0, it checks if it can decrement the count for the next `groupSize - 1` card values by the current count without going below 0. If it's possible to do so for all card values, then the cards can be divided into groups of size `groupSize` with consecutive values.\n\nThe algorithm has a time complexity of O(n * log(n)) due to the sorting process, where n is the length of the hand array.\n    ", "javascript": "\n    ```javascript\nfunction isPossibleDivide(hand, groupSize) {\n    const cardCount = new Map();\n    for (const card of hand) {\n        cardCount.set(card, (cardCount.get(card) || 0) + 1);\n    }\n\n    for (const [card, count] of Array.from(cardCount.entries()).sort((a, b) => a[0] - b[0])) {\n        if (count > 0) {\n            for (let i = 1; i < groupSize; ++i) {\n                const tmp = (cardCount.get(card + i) || 0) - count;\n                if (tmp < 0) {\n                    return false;\n                }\n                cardCount.set(card + i, tmp);\n            }\n        }\n    }\n\n    return true;\n}\n```\n\n    \n    The algorithm counts the occurrence of each card value and stores it in a map. Then, it iterates through the sorted card values in the map. For each card with a count greater than 0, it checks if it can decrement the count for the next `groupSize - 1` card values by the current count without going below 0. If it's possible to do so for all card values, then the cards can be divided into groups of size `groupSize` with consecutive values.\n\nThe algorithm has a time complexity of O(n * log(n)) due to the sorting process, where n is the length of the hand array.\n    "}
{"id": 857, "slug": "minimum-cost-to-hire-k-workers", "title": "Minimum Cost to Hire K Workers", "difficulty": "Hard", "content": "There are `n` workers. You are given two integer arrays `quality` and `wage` where `quality[i]` is the quality of the `ith` worker and `wage[i]` is the minimum wage expectation for the `ith` worker.\n\nWe want to hire exactly `k` workers to form a paid group. To hire a group of `k` workers, we must pay them according to the following rules:\n\n1.  Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n2.  Every worker in the paid group must be paid at least their minimum wage expectation.\n\nGiven the integer `k`, return _the least amount of money needed to form a paid group satisfying the above conditions_. Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** quality = \\[10,20,5\\], wage = \\[70,50,30\\], k = 2\n**Output:** 105.00000\n**Explanation:** We pay 70 to 0th worker and 35 to 2nd worker.\n\n**Example 2:**\n\n**Input:** quality = \\[3,1,10,10,1\\], wage = \\[4,8,2,2,7\\], k = 3\n**Output:** 30.66667\n**Explanation:** We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately.\n\n**Constraints:**\n\n*   `n == quality.length == wage.length`\n*   `1 <= k <= n <= 104`\n*   `1 <= quality[i], wage[i] <= 104`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> largeGroupPositions(String s) {\n    List<List<Integer>> result = new ArrayList<>();\n    int start = 0;\n    for (int i = 1; i < s.length(); ++i) {\n        if (s.charAt(i) != s.charAt(start)) {\n            if (i - start >= 3) {\n                List<Integer> interval = new ArrayList<>();\n                interval.add(start);\n                interval.add(i - 1);\n                result.add(interval);\n            }\n            start = i;\n        }\n    }\n    if (s.length() - start >= 3) {\n        List<Integer> interval = new ArrayList<>();\n        interval.add(start);\n        interval.add(s.length() - 1);\n        result.add(interval);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm used is very simple. We initialize a variable `start` that keeps track of the index of the first character of the current group, and iterate `i` through the string `s`. When the character at position `i` is different from the character at position `start`, we know that the group ends at `i - 1`, so if the group length is greater or equal to 3, we add the interval `[start, i - 1]` to the result list. After that, we update the value of `start` to the current index `i`. To make sure we include the last group in our result, we need to do the check for the group length outside of the loop (after it completes).\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<vector<int>> largeGroupPositions(string s) {\n    vector<vector<int>> result;\n    int start = 0;\n    for (int i = 1; i < s.size(); ++i) {\n        if (s[i] != s[start]) {\n            if (i - start >= 3) {\n                result.push_back({start, i - 1});\n            }\n            start = i;\n        }\n    }\n    if (s.size() - start >= 3) {\n        result.push_back({start, static_cast<int>(s.size()) - 1});\n    }\n    return result;\n}\n```\n\n    \n    The algorithm used is very simple. We initialize a variable `start` that keeps track of the index of the first character of the current group, and iterate `i` through the string `s`. When the character at position `i` is different from the character at position `start`, we know that the group ends at `i - 1`, so if the group length is greater or equal to 3, we add the interval `[start, i - 1]` to the result list. After that, we update the value of `start` to the current index `i`. To make sure we include the last group in our result, we need to do the check for the group length outside of the loop (after it completes).\n    ", "python": "\n    ```python\ndef largeGroupPositions(s: str):\n    result = []\n    start = 0\n    for i in range(1, len(s)):\n        if s[i] != s[start]:\n            if i - start >= 3:\n                result.append([start, i - 1])\n            start = i\n    if len(s) - start >= 3:\n        result.append([start, len(s) - 1])\n    return result\n```\n\n    \n    The algorithm used is very simple. We initialize a variable `start` that keeps track of the index of the first character of the current group, and iterate `i` through the string `s`. When the character at position `i` is different from the character at position `start`, we know that the group ends at `i - 1`, so if the group length is greater or equal to 3, we add the interval `[start, i - 1]` to the result list. After that, we update the value of `start` to the current index `i`. To make sure we include the last group in our result, we need to do the check for the group length outside of the loop (after it completes).\n    ", "javascript": "\n    ```javascript\nfunction largeGroupPositions(s) {\n    const result = [];\n    let start = 0;\n    for (let i = 1; i < s.length; ++i) {\n        if (s.charAt(i) !== s.charAt(start)) {\n            if (i - start >= 3) {\n                result.push([start, i - 1]);\n            }\n            start = i;\n        }\n    }\n    if (s.length - start >= 3) {\n        result.push([start, s.length - 1]);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm used is very simple. We initialize a variable `start` that keeps track of the index of the first character of the current group, and iterate `i` through the string `s`. When the character at position `i` is different from the character at position `start`, we know that the group ends at `i - 1`, so if the group length is greater or equal to 3, we add the interval `[start, i - 1]` to the result list. After that, we update the value of `start` to the current index `i`. To make sure we include the last group in our result, we need to do the check for the group length outside of the loop (after it completes).\n    "}
{"id": 860, "slug": "lemonade-change", "title": "Lemonade Change", "difficulty": "Easy", "content": "At a lemonade stand, each lemonade costs `$5`. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a `$5`, `$10`, or `$20` bill. You must provide the correct change to each customer so that the net transaction is that the customer pays `$5`.\n\nNote that you do not have any change in hand at first.\n\nGiven an integer array `bills` where `bills[i]` is the bill the `ith` customer pays, return `true` _if you can provide every customer with the correct change, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** bills = \\[5,5,5,10,20\\]\n**Output:** true\n**Explanation:** \nFrom the first 3 customers, we collect three $5 bills in order.\nFrom the fourth customer, we collect a $10 bill and give back a $5.\nFrom the fifth customer, we give a $10 bill and a $5 bill.\nSince all customers got correct change, we output true.\n\n**Example 2:**\n\n**Input:** bills = \\[5,5,10,10,20\\]\n**Output:** false\n**Explanation:** \nFrom the first two customers in order, we collect two $5 bills.\nFor the next two customers in order, we collect a $10 bill and give back a $5 bill.\nFor the last customer, we can not give the change of $15 back because we only have two $10 bills.\nSince not every customer received the correct change, the answer is false.\n\n**Constraints:**\n\n*   `1 <= bills.length <= 105`\n*   `bills[i]` is either `5`, `10`, or `20`.", "java": "\n    ```java\nclass MyCircularQueue {\n    private int[] data;\n    private int head, tail, size, capacity;\n\n    public MyCircularQueue(int k) {\n        data = new int[k];\n        head = 0;\n        tail = -1;\n        size = 0;\n        capacity = k;\n    }\n\n    public boolean enQueue(int value) {\n        if (isFull()) {\n            return false;\n        }\n        tail = (tail + 1) % capacity;\n        data[tail] = value;\n        size++;\n        return true;\n    }\n\n    public boolean deQueue() {\n        if (isEmpty()) {\n            return false;\n        }\n        head = (head + 1) % capacity;\n        size--;\n        return true;\n    }\n\n    public int Front() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return data[head];\n    }\n\n    public int Rear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return data[tail];\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public boolean isFull() {\n        return size == capacity;\n    }\n}\n```\n    \n    The circular queue is implemented using an array with fixed capacity. The operations are performed based on FIFO principle, and the last position is connected back to the first position to make a circle. We keep a head and tail pointer, as well as the current size of the queue. Whenever an element is enqueued, we move the tail pointer forward (circulating back to the start of the array when necessary) and increase the size. When an element is dequeued, we move the head pointer forward and decrease the size. We can check if the queue is empty by comparing the size to 0 and check if the queue is full by comparing the size to the capacity. All operations have O(1) time complexity. \n    ", "c++": "\n    ```c++\nclass MyCircularQueue {\npublic:\n    MyCircularQueue(int k) {\n        data.resize(k);\n        head = 0;\n        tail = -1;\n        size = 0;\n        capacity = k;\n    }\n    \n    bool enQueue(int value) {\n        if (isFull()) {\n            return false;\n        }\n        tail = (tail + 1) % capacity;\n        data[tail] = value;\n        size++;\n        return true;\n    }\n    \n    bool deQueue() {\n        if (isEmpty()) {\n            return false;\n        }\n        head = (head + 1) % capacity;\n        size--;\n        return true;\n    }\n    \n    int Front() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return data[head];\n    }\n    \n    int Rear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return data[tail];\n    }\n    \n    bool isEmpty() {\n        return size == 0;\n    }\n    \n    bool isFull() {\n        return size == capacity;\n    }\n\nprivate:\n    vector<int> data;\n    int head, tail, size, capacity;\n};\n```\n    \n    The circular queue is implemented using an array with fixed capacity. The operations are performed based on FIFO principle, and the last position is connected back to the first position to make a circle. We keep a head and tail pointer, as well as the current size of the queue. Whenever an element is enqueued, we move the tail pointer forward (circulating back to the start of the array when necessary) and increase the size. When an element is dequeued, we move the head pointer forward and decrease the size. We can check if the queue is empty by comparing the size to 0 and check if the queue is full by comparing the size to the capacity. All operations have O(1) time complexity. \n    ", "python": "\n    ```python\nclass MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.data = [0] * k\n        self.head = 0\n        self.tail = -1\n        self.size = 0\n        self.capacity = k\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.tail = (self.tail + 1) % self.capacity\n        self.data[self.tail] = value\n        self.size += 1\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def Front(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.data[self.head]\n\n    def Rear(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.data[self.tail]\n\n    def isEmpty(self) -> bool:\n        return self.size == 0\n\n    def isFull(self) -> bool:\n        return self.size == self.capacity\n```\n    \n    The circular queue is implemented using an array with fixed capacity. The operations are performed based on FIFO principle, and the last position is connected back to the first position to make a circle. We keep a head and tail pointer, as well as the current size of the queue. Whenever an element is enqueued, we move the tail pointer forward (circulating back to the start of the array when necessary) and increase the size. When an element is dequeued, we move the head pointer forward and decrease the size. We can check if the queue is empty by comparing the size to 0 and check if the queue is full by comparing the size to the capacity. All operations have O(1) time complexity. \n    ", "javascript": "\n    ```javascript\nclass MyCircularQueue {\n    constructor(k) {\n        this.data = new Array(k);\n        this.head = 0;\n        this.tail = -1;\n        this.size = 0;\n        this.capacity = k;\n    }\n\n    enQueue(value) {\n        if (this.isFull()) {\n            return false;\n        }\n        this.tail = (this.tail + 1) % this.capacity;\n        this.data[this.tail] = value;\n        this.size++;\n        return true;\n    }\n\n    deQueue() {\n        if (this.isEmpty()) {\n            return false;\n        }\n        this.head = (this.head + 1) % this.capacity;\n        this.size--;\n        return true;\n    }\n\n    Front() {\n        if (this.isEmpty()) {\n            return -1;\n        }\n        return this.data[this.head];\n    }\n\n    Rear() {\n        if (this.isEmpty()) {\n            return -1;\n        }\n        return this.data[this.tail];\n    }\n\n    isEmpty() {\n        return this.size === 0;\n    }\n\n    isFull() {\n        return this.size === this.capacity;\n    }\n}\n```\n    \n    The circular queue is implemented using an array with fixed capacity. The operations are performed based on FIFO principle, and the last position is connected back to the first position to make a circle. We keep a head and tail pointer, as well as the current size of the queue. Whenever an element is enqueued, we move the tail pointer forward (circulating back to the start of the array when necessary) and increase the size. When an element is dequeued, we move the head pointer forward and decrease the size. We can check if the queue is empty by comparing the size to 0 and check if the queue is full by comparing the size to the capacity. All operations have O(1) time complexity. \n    "}
{"id": 861, "slug": "score-after-flipping-matrix", "title": "Score After Flipping Matrix", "difficulty": "Medium", "content": "You are given an `m x n` binary matrix `grid`.\n\nA **move** consists of choosing any row or column and toggling each value in that row or column (i.e., changing all `0`'s to `1`'s, and all `1`'s to `0`'s).\n\nEvery row of the matrix is interpreted as a binary number, and the **score** of the matrix is the sum of these numbers.\n\nReturn _the highest possible **score** after making any number of **moves** (including zero moves)_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,1,1\\],\\[1,0,1,0\\],\\[1,1,0,0\\]\\]\n**Output:** 39\n**Explanation:** 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 20`\n*   `grid[i][j]` is either `0` or `1`.", "java": "\n    ```java\nclass Solution {\n    public int[][] flipAndInvertImage(int[][] image) {\n        for (int[] row : image) {\n            int n = row.length;\n            for (int i = 0; i < (n + 1) / 2; i++) {\n                int temp = 1 - row[i];\n                row[i] = 1 - row[n - 1 - i];\n                row[n - 1 - i] = temp;\n            }\n        }\n        return image;\n    }\n}\n```\n    \n    The algorithm for this problem is to first flip each row of the given binary image horizontally and then invert the image. To flip the row horizontally, we can simply reverse the row. In languages that don't have a built-in reverse function, we can swap elements at the beginning and end of the row and move inward.\n\nAfter reversing the row, we iterate through each element (pixel) in the row, and if it's a 0, we replace it with a 1, and if it's a 1, we replace it with a 0. This can be achieved by simply doing \"1 - element\".\nWe need to perform the above operations for each row in the image.\n\nThe time complexity of this algorithm is O(n * m), where n is the number of rows and m is the number of columns of the image. In this case, since it's given as an n x n binary matrix, the complexity can also be considered O(n^2).\n\nThe space complexity is O(1), since we modify the given image in-place.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\n    for (auto &row : image) {\n        reverse(row.begin(), row.end());\n        for (int &pixel : row) {\n            pixel = 1 - pixel;\n        }\n    }\n    return image;\n}\n```\n    \n    The algorithm for this problem is to first flip each row of the given binary image horizontally and then invert the image. To flip the row horizontally, we can simply reverse the row. In languages that don't have a built-in reverse function, we can swap elements at the beginning and end of the row and move inward.\n\nAfter reversing the row, we iterate through each element (pixel) in the row, and if it's a 0, we replace it with a 1, and if it's a 1, we replace it with a 0. This can be achieved by simply doing \"1 - element\".\nWe need to perform the above operations for each row in the image.\n\nThe time complexity of this algorithm is O(n * m), where n is the number of rows and m is the number of columns of the image. In this case, since it's given as an n x n binary matrix, the complexity can also be considered O(n^2).\n\nThe space complexity is O(1), since we modify the given image in-place.\n    ", "python": "\n    ```python\ndef flipAndInvertImage(image):\n    for row in image:\n        row.reverse()\n        for j in range(len(row)):\n            row[j] = 1 - row[j]\n    return image\n```\n    \n    The algorithm for this problem is to first flip each row of the given binary image horizontally and then invert the image. To flip the row horizontally, we can simply reverse the row. In languages that don't have a built-in reverse function, we can swap elements at the beginning and end of the row and move inward.\n\nAfter reversing the row, we iterate through each element (pixel) in the row, and if it's a 0, we replace it with a 1, and if it's a 1, we replace it with a 0. This can be achieved by simply doing \"1 - element\".\nWe need to perform the above operations for each row in the image.\n\nThe time complexity of this algorithm is O(n * m), where n is the number of rows and m is the number of columns of the image. In this case, since it's given as an n x n binary matrix, the complexity can also be considered O(n^2).\n\nThe space complexity is O(1), since we modify the given image in-place.\n    ", "javascript": "\n    ```javascript\nfunction flipAndInvertImage(image) {\n    for (let row of image) {\n        row.reverse();\n        for (let j = 0; j < row.length; j++) {\n            row[j] = 1 - row[j];\n        }\n    }\n    return image;\n}\n```\n    \n    The algorithm for this problem is to first flip each row of the given binary image horizontally and then invert the image. To flip the row horizontally, we can simply reverse the row. In languages that don't have a built-in reverse function, we can swap elements at the beginning and end of the row and move inward.\n\nAfter reversing the row, we iterate through each element (pixel) in the row, and if it's a 0, we replace it with a 1, and if it's a 1, we replace it with a 0. This can be achieved by simply doing \"1 - element\".\nWe need to perform the above operations for each row in the image.\n\nThe time complexity of this algorithm is O(n * m), where n is the number of rows and m is the number of columns of the image. In this case, since it's given as an n x n binary matrix, the complexity can also be considered O(n^2).\n\nThe space complexity is O(1), since we modify the given image in-place.\n    "}
{"id": 870, "slug": "advantage-shuffle", "title": "Advantage Shuffle", "difficulty": "Medium", "content": "You are given two integer arrays `nums1` and `nums2` both of the same length. The **advantage** of `nums1` with respect to `nums2` is the number of indices `i` for which `nums1[i] > nums2[i]`.\n\nReturn _any permutation of_ `nums1` _that maximizes its **advantage** with respect to_ `nums2`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[2,7,11,15\\], nums2 = \\[1,10,4,11\\]\n**Output:** \\[2,11,7,15\\]\n\n**Example 2:**\n\n**Input:** nums1 = \\[12,24,8,32\\], nums2 = \\[13,25,32,11\\]\n**Output:** \\[24,32,8,12\\]\n\n**Constraints:**\n\n*   `1 <= nums1.length <= 105`\n*   `nums2.length == nums1.length`\n*   `0 <= nums1[i], nums2[i] <= 109`", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int[] advantageCount(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        int[] result = new int[n];\n        TreeSet<Integer> set = new TreeSet<>();\n        for (int num : nums1) set.add(num);\n        for (int i = 0; i < n; i++) {\n            Integer greater = set.higher(nums2[i]);\n            if (greater == null) {\n                greater = set.first();\n            }\n            set.remove(greater);\n            result[i] = greater;\n        }\n        return result;\n    }\n}\n```\n    \n    1. Create a sorted data structure (`multiset` in C++, `TreeSet` in Java, `SortedList` in Python, and a sorted array in JavaScript) from nums1.\n2. For each number `num` in nums2, find the smallest element in the sorted data structure that is greater than `num`. If there is no such element, select the smallest element in the sorted data structure.\n3. Remove the selected element from the sorted data structure and append it to the result list/array.\n4. Return the result list/array after processing all elements in nums2.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n\nstd::vector<int> advantageCount(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::multiset<int> s(nums1.begin(), nums1.end());\n    std::vector<int> res;\n    for (int i : nums2) {\n        auto it = s.upper_bound(i);\n        if (it == s.end()) it = s.begin();\n        res.push_back(*it);\n        s.erase(it);\n    }\n    return res;\n}\n```\n    \n    1. Create a sorted data structure (`multiset` in C++, `TreeSet` in Java, `SortedList` in Python, and a sorted array in JavaScript) from nums1.\n2. For each number `num` in nums2, find the smallest element in the sorted data structure that is greater than `num`. If there is no such element, select the smallest element in the sorted data structure.\n3. Remove the selected element from the sorted data structure and append it to the result list/array.\n4. Return the result list/array after processing all elements in nums2.\n    ", "python": "\n    ```python\nfrom sortedcontainers import SortedList\n\ndef advantage_count(nums1, nums2):\n    nums1_sorted = SortedList(nums1)\n    result = []\n    for num in nums2:\n        index = nums1_sorted.bisect_right(num)\n        if index == len(nums1_sorted):\n            val = nums1_sorted.pop(0)\n        else:\n            val = nums1_sorted.pop(index)\n        result.append(val)\n    return result\n```\n    \n    1. Create a sorted data structure (`multiset` in C++, `TreeSet` in Java, `SortedList` in Python, and a sorted array in JavaScript) from nums1.\n2. For each number `num` in nums2, find the smallest element in the sorted data structure that is greater than `num`. If there is no such element, select the smallest element in the sorted data structure.\n3. Remove the selected element from the sorted data structure and append it to the result list/array.\n4. Return the result list/array after processing all elements in nums2.\n    ", "javascript": "\n    ```javascript\nfunction advantageCount(nums1, nums2) {\n    const sortedNums1 = [...nums1].sort((a, b) => a - b);\n    const result = [];\n    for (const num of nums2) {\n        let index = sortedNums1.findIndex(el => el > num);\n        if (index === -1) index = 0;\n        result.push(sortedNums1[index]);\n        sortedNums1.splice(index, 1);\n    }\n    return result;\n}\n```\n    \n    1. Create a sorted data structure (`multiset` in C++, `TreeSet` in Java, `SortedList` in Python, and a sorted array in JavaScript) from nums1.\n2. For each number `num` in nums2, find the smallest element in the sorted data structure that is greater than `num`. If there is no such element, select the smallest element in the sorted data structure.\n3. Remove the selected element from the sorted data structure and append it to the result list/array.\n4. Return the result list/array after processing all elements in nums2.\n    "}
{"id": 871, "slug": "minimum-number-of-refueling-stops", "title": "Minimum Number of Refueling Stops", "difficulty": "Hard", "content": "A car travels from a starting position to a destination which is `target` miles east of the starting position.\n\nThere are gas stations along the way. The gas stations are represented as an array `stations` where `stations[i] = [positioni, fueli]` indicates that the `ith` gas station is `positioni` miles east of the starting position and has `fueli` liters of gas.\n\nThe car starts with an infinite tank of gas, which initially has `startFuel` liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\n\nReturn _the minimum number of refueling stops the car must make in order to reach its destination_. If it cannot reach the destination, return `-1`.\n\nNote that if the car reaches a gas station with `0` fuel left, the car can still refuel there. If the car reaches the destination with `0` fuel left, it is still considered to have arrived.\n\n**Example 1:**\n\n**Input:** target = 1, startFuel = 1, stations = \\[\\]\n**Output:** 0\n**Explanation:** We can reach the target without refueling.\n\n**Example 2:**\n\n**Input:** target = 100, startFuel = 1, stations = \\[\\[10,100\\]\\]\n**Output:** -1\n**Explanation:** We can not reach the target (or even the first gas station).\n\n**Example 3:**\n\n**Input:** target = 100, startFuel = 10, stations = \\[\\[10,60\\],\\[20,30\\],\\[30,30\\],\\[60,40\\]\\]\n**Output:** 2\n**Explanation:** We start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2.\n\n**Constraints:**\n\n*   `1 <= target, startFuel <= 109`\n*   `0 <= stations.length <= 500`\n*   `1 <= positioni < positioni+1 < target`\n*   `1 <= fueli < 109`", "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Stack;\n\npublic boolean canVisitAllRooms(List<List<Integer>> rooms) {\n    HashSet<Integer> visited = new HashSet<>();\n    Stack<Integer> stack = new Stack<>();\n    stack.push(0);\n\n    while (!stack.isEmpty()) {\n        int currentRoom = stack.pop();\n\n        visited.add(currentRoom);\n\n        for (int key : rooms.get(currentRoom)) {\n            if (!visited.contains(key)) {\n                stack.push(key);\n            }\n        }\n    }\n\n    return visited.size() == rooms.size();\n}\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n\nbool canVisitAllRooms(const std::vector<std::vector<int>>& rooms) {\n    std::unordered_set<int> visited;\n    std::vector<int> stack = {0};\n\n    while (!stack.empty()) {\n        int currentRoom = stack.back();\n        stack.pop_back();\n\n        visited.insert(currentRoom);\n\n        for (int key : rooms[currentRoom]) {\n            if (!visited.count(key)) {\n                stack.push_back(key);\n            }\n        }\n    }\n\n    return visited.size() == rooms.size();\n}\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    ", "python": "\n    ```python\ndef can_visit_all_rooms(rooms):\n    visited = set()\n    stack = [0]\n\n    while stack:\n        current_room = stack.pop()\n\n        visited.add(current_room)\n\n        for key in rooms[current_room]:\n            if key not in visited:\n                stack.append(key)\n\n    return len(visited) == len(rooms)\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    ", "javascript": "\n    ```javascript\nfunction canVisitAllRooms(rooms) {\n    const visited = new Set();\n    const stack = [0];\n\n    while (stack.length > 0) {\n        const currentRoom = stack.pop();\n\n        visited.add(currentRoom);\n\n        for (const key of rooms[currentRoom]) {\n            if (!visited.has(key)) {\n                stack.push(key);\n            }\n        }\n    }\n\n    return visited.size === rooms.length;\n}\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    "}
{"id": 881, "slug": "boats-to-save-people", "title": "Boats to Save People", "difficulty": "Medium", "content": "You are given an array `people` where `people[i]` is the weight of the `ith` person, and an **infinite number of boats** where each boat can carry a maximum weight of `limit`. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most `limit`.\n\nReturn _the minimum number of boats to carry every given person_.\n\n**Example 1:**\n\n**Input:** people = \\[1,2\\], limit = 3\n**Output:** 1\n**Explanation:** 1 boat (1, 2)\n\n**Example 2:**\n\n**Input:** people = \\[3,2,2,1\\], limit = 3\n**Output:** 3\n**Explanation:** 3 boats (1, 2), (2) and (3)\n\n**Example 3:**\n\n**Input:** people = \\[3,5,3,4\\], limit = 5\n**Output:** 4\n**Explanation:** 4 boats (3), (3), (4), (5)\n\n**Constraints:**\n\n*   `1 <= people.length <= 5 * 104`\n*   `1 <= people[i] <= limit <= 3 * 104`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic int[] loudAndRich(int[][] richer, int[] quiet) {\n    int n = quiet.length;\n    List<Integer>[] graph = new ArrayList[n];\n    for (int i = 0; i < n; ++i)\n        graph[i] = new ArrayList<>();\n\n    for (int[] entry : richer)\n        graph[entry[1]].add(entry[0]);\n\n    int[] answer = new int[n];\n    Arrays.fill(answer, -1);\n    for (int i = 0; i < n; ++i)\n        dfs(i, graph, quiet, answer);\n\n    return answer;\n}\n\nprivate void dfs(int x, List<Integer>[] graph, int[] quiet, int[] answer) {\n    if (answer[x] != -1) return;\n    answer[x] = x;\n    for (int y : graph[x]) {\n        dfs(y, graph, quiet, answer);\n        if (quiet[answer[y]] < quiet[answer[x]])\n            answer[x] = answer[y];\n    }\n}\n```\n\n    \n    For this problem, we will use Depth-First Search algorithm (DFS). The main idea is to represent richer relationships as a directed graph, where the edge a -> b means the person 'a' has more money than the person 'b'. Then, for each person 'x', we want to find the smallest value of quiet[y] for all 'y' who have equal or more money than 'x'.\n\n1. First, convert the richer array into the adjacency list representation graph where graph[i] contains an integer list of people who are richer than the person i.\n2. Initialize an answer list with all values as -1.\n3. Define a DFS function, in which:\n   - If the DFS for a person x is already calculated, return the result.\n   - Set answer[x] = x\n   - For each neighbor y in graph[x], call DFS(y).\n   - If quiet[answer[y]] < quiet[answer[x]], update answer[x] with answer[y].\n   - Return answer[x].\n4. Iterate through all people (0 to n-1), and call the DFS function for each person.\n5. The final answer array will have values equal to the least quiet person among all people who definitely have equal to or more money than the person x.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvoid dfs(int x, vector<vector<int>>& graph, vector<int>& quiet, vector<int>& answer) {\n    if (answer[x] != -1) return;\n    answer[x] = x;\n\n    for (int y : graph[x]) {\n        dfs(y, graph, quiet, answer);\n        if (quiet[answer[y]] < quiet[answer[x]])\n            answer[x] = answer[y];\n    }\n}\n\nvector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\n    int n = quiet.size();\n    vector<vector<int>> graph(n);\n    for (auto& entry : richer)\n        graph[entry[1]].push_back(entry[0]);\n\n    vector<int> answer(n, -1);\n    for (int i = 0; i < n; ++i)\n        dfs(i, graph, quiet, answer);\n\n    return answer;\n}\n```\n\n    \n    For this problem, we will use Depth-First Search algorithm (DFS). The main idea is to represent richer relationships as a directed graph, where the edge a -> b means the person 'a' has more money than the person 'b'. Then, for each person 'x', we want to find the smallest value of quiet[y] for all 'y' who have equal or more money than 'x'.\n\n1. First, convert the richer array into the adjacency list representation graph where graph[i] contains an integer list of people who are richer than the person i.\n2. Initialize an answer list with all values as -1.\n3. Define a DFS function, in which:\n   - If the DFS for a person x is already calculated, return the result.\n   - Set answer[x] = x\n   - For each neighbor y in graph[x], call DFS(y).\n   - If quiet[answer[y]] < quiet[answer[x]], update answer[x] with answer[y].\n   - Return answer[x].\n4. Iterate through all people (0 to n-1), and call the DFS function for each person.\n5. The final answer array will have values equal to the least quiet person among all people who definitely have equal to or more money than the person x.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\n\ndef loudAndRich(richer, quiet):\n    n = len(quiet)\n    graph = defaultdict(list)\n    for r in richer:\n        graph[r[1]].append(r[0])\n\n    answer = [-1] * n\n\n    def dfs(x):\n        if answer[x] != -1:\n            return answer[x]\n        answer[x] = x\n        for y in graph[x]:\n            cand = dfs(y)\n            if quiet[cand] < quiet[answer[x]]:\n                answer[x] = cand\n        return answer[x]\n\n    for i in range(n):\n        dfs(i)\n\n    return answer\n```\n\n    \n    For this problem, we will use Depth-First Search algorithm (DFS). The main idea is to represent richer relationships as a directed graph, where the edge a -> b means the person 'a' has more money than the person 'b'. Then, for each person 'x', we want to find the smallest value of quiet[y] for all 'y' who have equal or more money than 'x'.\n\n1. First, convert the richer array into the adjacency list representation graph where graph[i] contains an integer list of people who are richer than the person i.\n2. Initialize an answer list with all values as -1.\n3. Define a DFS function, in which:\n   - If the DFS for a person x is already calculated, return the result.\n   - Set answer[x] = x\n   - For each neighbor y in graph[x], call DFS(y).\n   - If quiet[answer[y]] < quiet[answer[x]], update answer[x] with answer[y].\n   - Return answer[x].\n4. Iterate through all people (0 to n-1), and call the DFS function for each person.\n5. The final answer array will have values equal to the least quiet person among all people who definitely have equal to or more money than the person x.\n    ", "javascript": "\n    ```javascript\nfunction loudAndRich(richer, quiet) {\n    const n = quiet.length;\n    const graph = Array.from({ length: n }, () => []);\n    richer.forEach(([a, b]) => graph[b].push(a));\n\n    const answer = Array(n).fill(-1);\n\n    function dfs(x) {\n        if (answer[x] != -1) return answer[x];\n        answer[x] = x;\n        for (const y of graph[x]) {\n            const cand = dfs(y)\n            if (quiet[cand] < quiet[answer[x]])\n                answer[x] = cand;\n        }\n        return answer[x];\n    }\n\n    for (let i = 0; i < n; ++i)\n        dfs(i)\n\n    return answer;\n}\n```\n\n    \n    For this problem, we will use Depth-First Search algorithm (DFS). The main idea is to represent richer relationships as a directed graph, where the edge a -> b means the person 'a' has more money than the person 'b'. Then, for each person 'x', we want to find the smallest value of quiet[y] for all 'y' who have equal or more money than 'x'.\n\n1. First, convert the richer array into the adjacency list representation graph where graph[i] contains an integer list of people who are richer than the person i.\n2. Initialize an answer list with all values as -1.\n3. Define a DFS function, in which:\n   - If the DFS for a person x is already calculated, return the result.\n   - Set answer[x] = x\n   - For each neighbor y in graph[x], call DFS(y).\n   - If quiet[answer[y]] < quiet[answer[x]], update answer[x] with answer[y].\n   - Return answer[x].\n4. Iterate through all people (0 to n-1), and call the DFS function for each person.\n5. The final answer array will have values equal to the least quiet person among all people who definitely have equal to or more money than the person x.\n    "}
{"id": 910, "slug": "smallest-range-ii", "title": "Smallest Range II", "difficulty": "Medium", "content": "You are given an integer array `nums` and an integer `k`.\n\nFor each index `i` where `0 <= i < nums.length`, change `nums[i]` to be either `nums[i] + k` or `nums[i] - k`.\n\nThe **score** of `nums` is the difference between the maximum and minimum elements in `nums`.\n\nReturn _the minimum **score** of_ `nums` _after changing the values at each index_.\n\n**Example 1:**\n\n**Input:** nums = \\[1\\], k = 0\n**Output:** 0\n**Explanation:** The score is max(nums) - min(nums) = 1 - 1 = 0.\n\n**Example 2:**\n\n**Input:** nums = \\[0,10\\], k = 2\n**Output:** 6\n**Explanation:** Change nums to be \\[2, 8\\]. The score is max(nums) - min(nums) = 8 - 2 = 6.\n\n**Example 3:**\n\n**Input:** nums = \\[1,3,6\\], k = 3\n**Output:** 3\n**Explanation:** Change nums to be \\[4, 6, 3\\]. The score is max(nums) - min(nums) = 6 - 3 = 3.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 104`\n*   `0 <= k <= 104`", "java": "\n    ```java\npublic int nthMagicalNumber(int n, int a, int b) {\n    long mod = 1000000007;\n    long lcm = a * b / gcd(a, b);\n    long left = 1, right = (long)1e14, mid;\n    while(left < right) {\n        mid = left + (right - left) / 2;\n        if ((mid / a + mid / b - mid / lcm) < n) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return (int)(left % mod);\n}\n\npublic int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n```\n    \n    We use binary search for this problem. We set the initial search interval which is between 1 and 10^14, where 10^14 is an arbitrary maximum value that can adjust based on the input constraints. We find the LCM (Least Common Multiple) of a and b to count their common divisors.\n\nIn each step of the binary search, we first get the middle value `mid` between `left` and `right`. Then, we check the condition, if the sum of (`mid` divided by a) and (`mid` divided by b) minus (`mid` divided by LCM) is less than `n`. If it is less than `n`, we set `left` equal to `mid` plus 1, else we set `right` equal to `mid`. We keep reducing the search interval until `left` becomes equal to or greater than `right`. Finally, we return the `left` value modulo 109 + 7.\n    ", "c++": "\n    ```cpp\nint nthMagicalNumber(int n, int a, int b) {\n    long long mod = 1000000007, lcm = a * b / __gcd(a, b);\n    long long left = 1, right = 1e14, mid;\n    while(left < right) {\n        mid = left + (right - left) / 2;\n        if ((mid / a + mid / b - mid / lcm) < n) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left % mod;\n}\n```\n    \n    We use binary search for this problem. We set the initial search interval which is between 1 and 10^14, where 10^14 is an arbitrary maximum value that can adjust based on the input constraints. We find the LCM (Least Common Multiple) of a and b to count their common divisors.\n\nIn each step of the binary search, we first get the middle value `mid` between `left` and `right`. Then, we check the condition, if the sum of (`mid` divided by a) and (`mid` divided by b) minus (`mid` divided by LCM) is less than `n`. If it is less than `n`, we set `left` equal to `mid` plus 1, else we set `right` equal to `mid`. We keep reducing the search interval until `left` becomes equal to or greater than `right`. Finally, we return the `left` value modulo 109 + 7.\n    ", "python": "\n    ```python\ndef nthMagicalNumber(n, a, b):\n    mod = 1000000007\n    lcm = a * b // gcd(a, b)\n    left, right = 1, 10**14\n    while left < right:\n        mid = left + (right - left) // 2\n        if (mid // a + mid // b - mid // lcm) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left % mod\n\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n```\n    \n    We use binary search for this problem. We set the initial search interval which is between 1 and 10^14, where 10^14 is an arbitrary maximum value that can adjust based on the input constraints. We find the LCM (Least Common Multiple) of a and b to count their common divisors.\n\nIn each step of the binary search, we first get the middle value `mid` between `left` and `right`. Then, we check the condition, if the sum of (`mid` divided by a) and (`mid` divided by b) minus (`mid` divided by LCM) is less than `n`. If it is less than `n`, we set `left` equal to `mid` plus 1, else we set `right` equal to `mid`. We keep reducing the search interval until `left` becomes equal to or greater than `right`. Finally, we return the `left` value modulo 109 + 7.\n    ", "javascript": "\n    ```javascript\nfunction nthMagicalNumber(n, a, b) {\n    const mod = 1e9 + 7;\n    const lcm = a * b / gcd(a, b);\n    let left = 1, right = 1e14, mid;\n    while(left < right) {\n        mid = left + Math.trunc((right - left) / 2);\n        if (Math.trunc(mid / a + mid / b - mid / lcm) < n) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left % mod;\n}\n\nfunction gcd(a, b) {\n    return b === 0 ? a : gcd(b, a % b);\n}\n```\n    \n    We use binary search for this problem. We set the initial search interval which is between 1 and 10^14, where 10^14 is an arbitrary maximum value that can adjust based on the input constraints. We find the LCM (Least Common Multiple) of a and b to count their common divisors.\n\nIn each step of the binary search, we first get the middle value `mid` between `left` and `right`. Then, we check the condition, if the sum of (`mid` divided by a) and (`mid` divided by b) minus (`mid` divided by LCM) is less than `n`. If it is less than `n`, we set `left` equal to `mid` plus 1, else we set `right` equal to `mid`. We keep reducing the search interval until `left` becomes equal to or greater than `right`. Finally, we return the `left` value modulo 109 + 7.\n    "}
{"id": 921, "slug": "minimum-add-to-make-parentheses-valid", "title": "Minimum Add to Make Parentheses Valid", "difficulty": "Medium", "content": "A parentheses string is valid if and only if:\n\n*   It is the empty string,\n*   It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid strings, or\n*   It can be written as `(A)`, where `A` is a valid string.\n\nYou are given a parentheses string `s`. In one move, you can insert a parenthesis at any position of the string.\n\n*   For example, if `s = \"())) \"`, you can insert an opening parenthesis to be `\"(**(**))) \"` or a closing parenthesis to be `\"())**)**) \"`.\n\nReturn _the minimum number of moves required to make_ `s` _valid_.\n\n**Example 1:**\n\n**Input:** s =  \"()) \"\n**Output:** 1\n\n**Example 2:**\n\n**Input:** s =  \"((( \"\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` is either `'('` or `')'`.", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic ArrayList<int[]> spiral_walk(int rows, int cols, int rStart, int cStart) {\n    ArrayList<int[]> result = new ArrayList<>();\n    int[] dr = {0, 1, 0, -1};\n    int[] dc = {1, 0, -1, 0};\n    int moves = rows * cols;\n    int r = rStart, c = cStart, dir = 0;\n    \n    while (result.size() < moves) {\n        result.add(new int[]{r, c});\n        r += dr[dir];\n        c += dc[dir];\n        \n        if (r < 0 || r >= rows || c < 0 || c >= cols) {\n            r -= dr[dir];\n            c -= dc[dir];\n            dir = (dir + 1) % 4;\n            r += dr[dir];\n            c += dc[dir];\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Initialize an empty result array and arrays dr, dc to indicate the direction to move (right, down, left, up).\n2. Calculate the total number of moves required to visit every cell in the grid.\n3. Initialize starting position (r, c), direction dir=0 (east).\n4. While the length of result is less than the total number of moves:\n   - Add the current position (r, c) to the result.\n   - Update the r and c position according to the current direction.\n   - Check if the new position (r, c) is out of the grid's boundary.\n   - If it is, revert the last move of r and c, update the direction by taking the next direction in dr and dc arrays, and update the position (r, c) according to the new direction.\n5. Return the result array containing the visited cell positions.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<std::vector<int>> spiral_walk(int rows, int cols, int rStart, int cStart) {\n    std::vector<std::vector<int>> result;\n    int dr[] = {0, 1, 0, -1};\n    int dc[] = {1, 0, -1, 0};\n    int moves = rows * cols;\n    int r = rStart, c = cStart, dir = 0;\n    \n    while (result.size() < moves) {\n        result.push_back({r, c});\n        r += dr[dir];\n        c += dc[dir];\n        \n        if (r < 0 || r >= rows || c < 0 || c >= cols) {\n            r -= dr[dir];\n            c -= dc[dir];\n            dir = (dir + 1) % 4;\n            r += dr[dir];\n            c += dc[dir];\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Initialize an empty result array and arrays dr, dc to indicate the direction to move (right, down, left, up).\n2. Calculate the total number of moves required to visit every cell in the grid.\n3. Initialize starting position (r, c), direction dir=0 (east).\n4. While the length of result is less than the total number of moves:\n   - Add the current position (r, c) to the result.\n   - Update the r and c position according to the current direction.\n   - Check if the new position (r, c) is out of the grid's boundary.\n   - If it is, revert the last move of r and c, update the direction by taking the next direction in dr and dc arrays, and update the position (r, c) according to the new direction.\n5. Return the result array containing the visited cell positions.\n    ", "python": "\n    ```python\ndef spiral_walk(rows, cols, rStart, cStart):\n    result = []\n    dr = [0, 1, 0, -1]\n    dc = [1, 0, -1, 0]\n    moves = rows * cols\n    r, c, dir = rStart, cStart, 0\n    \n    while len(result) < moves:\n        result.append([r, c])\n        r += dr[dir]\n        c += dc[dir]\n        \n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            r -= dr[dir]\n            c -= dc[dir]\n            dir = (dir + 1) % 4\n            r += dr[dir]\n            c += dc[dir]\n\n    return result\n```\n    \n    1. Initialize an empty result array and arrays dr, dc to indicate the direction to move (right, down, left, up).\n2. Calculate the total number of moves required to visit every cell in the grid.\n3. Initialize starting position (r, c), direction dir=0 (east).\n4. While the length of result is less than the total number of moves:\n   - Add the current position (r, c) to the result.\n   - Update the r and c position according to the current direction.\n   - Check if the new position (r, c) is out of the grid's boundary.\n   - If it is, revert the last move of r and c, update the direction by taking the next direction in dr and dc arrays, and update the position (r, c) according to the new direction.\n5. Return the result array containing the visited cell positions.\n    ", "javascript": "\n    ```javascript\nfunction spiral_walk(rows, cols, rStart, cStart) {\n    let result = [];\n    let dr = [0, 1, 0, -1];\n    let dc = [1, 0, -1, 0];\n    let moves = rows * cols;\n    let r = rStart, c = cStart, dir = 0;\n    \n    while (result.length < moves) {\n        result.push([r, c]);\n        r += dr[dir];\n        c += dc[dir];\n        \n        if (r < 0 || r >= rows || c < 0 || c >= cols) {\n            r -= dr[dir];\n            c -= dc[dir];\n            dir = (dir + 1) % 4;\n            r += dr[dir];\n            c += dc[dir];\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Initialize an empty result array and arrays dr, dc to indicate the direction to move (right, down, left, up).\n2. Calculate the total number of moves required to visit every cell in the grid.\n3. Initialize starting position (r, c), direction dir=0 (east).\n4. While the length of result is less than the total number of moves:\n   - Add the current position (r, c) to the result.\n   - Update the r and c position according to the current direction.\n   - Check if the new position (r, c) is out of the grid's boundary.\n   - If it is, revert the last move of r and c, update the direction by taking the next direction in dr and dc arrays, and update the position (r, c) according to the new direction.\n5. Return the result array containing the visited cell positions.\n    "}
{"id": 936, "slug": "stamping-the-sequence", "title": "Stamping The Sequence", "difficulty": "Hard", "content": "You are given two strings `stamp` and `target`. Initially, there is a string `s` of length `target.length` with all `s[i] == '?'`.\n\nIn one turn, you can place `stamp` over `s` and replace every letter in the `s` with the corresponding letter from `stamp`.\n\n*   For example, if `stamp = \"abc \"` and `target = \"abcba \"`, then `s` is `\"????? \"` initially. In one turn you can:\n    \n    *   place `stamp` at index `0` of `s` to obtain `\"abc?? \"`,\n    *   place `stamp` at index `1` of `s` to obtain `\"?abc? \"`, or\n    *   place `stamp` at index `2` of `s` to obtain `\"??abc \"`.\n    \n    Note that `stamp` must be fully contained in the boundaries of `s` in order to stamp (i.e., you cannot place `stamp` at index `3` of `s`).\n\nWe want to convert `s` to `target` using **at most** `10 * target.length` turns.\n\nReturn _an array of the index of the left-most letter being stamped at each turn_. If we cannot obtain `target` from `s` within `10 * target.length` turns, return an empty array.\n\n**Example 1:**\n\n**Input:** stamp =  \"abc \", target =  \"ababc \"\n**Output:** \\[0,2\\]\n**Explanation:** Initially s =  \"????? \".\n- Place stamp at index 0 to get  \"abc?? \".\n- Place stamp at index 2 to get  \"ababc \".\n\\[1,0,2\\] would also be accepted as an answer, as well as some other answers.\n\n**Example 2:**\n\n**Input:** stamp =  \"abca \", target =  \"aabcaca \"\n**Output:** \\[3,0,1\\]\n**Explanation:** Initially s =  \"??????? \".\n- Place stamp at index 3 to get  \"???abca \".\n- Place stamp at index 0 to get  \"abcabca \".\n- Place stamp at index 1 to get  \"aabcaca \".\n\n**Constraints:**\n\n*   `1 <= stamp.length <= target.length <= 1000`\n*   `stamp` and `target` consist of lowercase English letters.", "java": "\n    ```java\nclass RLEIterator {\n    private int[] encoding;\n    private int index;\n\n    public RLEIterator(int[] encoding) {\n        this.encoding = encoding;\n        this.index = 0;\n    }\n    \n    public int next(int n) {\n        while (index < encoding.length) {\n            if (n <= encoding[index]) {\n                encoding[index] -= n;\n                return encoding[index + 1];\n            }\n            n -= encoding[index];\n            index += 2;\n        }\n        return -1;\n    }\n}\n```\n    \n    The RLEIterator class creates an iterator for a given run-length encoded array. In the constructor, it initializes the class with the `encoding` array and initializes the `index` variable to 0.\n\nThe `next` function takes an integer `n` and iterates through the run-length encoded array to find the value at the given position. If `n` is less than or equal to the current run's count (`encoding[index]), we update the run count by subtracting n and return the corresponding value. If `n` is greater than the run's count, we subtract the run count from `n` and move to the next run by incrementing the index by 2. If the iterator reaches the end of the encoding array, it returns -1.\n    ", "c++": "\n    ```cpp\nclass RLEIterator {\npublic:\n    RLEIterator(vector<int>& encoding) {\n        data = encoding;\n        index = 0;\n    }\n    \n    int next(int n) {\n        while (index < data.size()) {\n            if (n <= data[index]) {\n                data[index] -= n;\n                return data[index + 1];\n            }\n            n -= data[index];\n            index += 2;\n        }\n        return -1;\n    }\n\nprivate:\n    vector<int> data;\n    int index;\n};\n```\n    \n    The RLEIterator class creates an iterator for a given run-length encoded array. In the constructor, it initializes the class with the `encoding` array and initializes the `index` variable to 0.\n\nThe `next` function takes an integer `n` and iterates through the run-length encoded array to find the value at the given position. If `n` is less than or equal to the current run's count (`encoding[index]), we update the run count by subtracting n and return the corresponding value. If `n` is greater than the run's count, we subtract the run count from `n` and move to the next run by incrementing the index by 2. If the iterator reaches the end of the encoding array, it returns -1.\n    ", "python": "\n    ```python\nclass RLEIterator:\n    def __init__(self, encoding):\n        self.encoding = encoding\n        self.index = 0\n\n    def next(self, n):\n        while self.index < len(self.encoding):\n            if n <= self.encoding[self.index]:\n                self.encoding[self.index] -= n\n                return self.encoding[self.index + 1]\n            n -= self.encoding[self.index]\n            self.index += 2\n        return -1\n```\n    \n    The RLEIterator class creates an iterator for a given run-length encoded array. In the constructor, it initializes the class with the `encoding` array and initializes the `index` variable to 0.\n\nThe `next` function takes an integer `n` and iterates through the run-length encoded array to find the value at the given position. If `n` is less than or equal to the current run's count (`encoding[index]), we update the run count by subtracting n and return the corresponding value. If `n` is greater than the run's count, we subtract the run count from `n` and move to the next run by incrementing the index by 2. If the iterator reaches the end of the encoding array, it returns -1.\n    ", "javascript": "\n    ```javascript\nclass RLEIterator {\n    constructor(encoding) {\n        this.encoding = encoding;\n        this.index = 0;\n    }\n\n    next(n) {\n        while (this.index < this.encoding.length) {\n            if (n <= this.encoding[this.index]) {\n                this.encoding[this.index] -= n;\n                return this.encoding[this.index + 1];\n            }\n            n -= this.encoding[this.index];\n            this.index += 2;\n        }\n        return -1;\n    }\n}\n```\n    \n    The RLEIterator class creates an iterator for a given run-length encoded array. In the constructor, it initializes the class with the `encoding` array and initializes the `index` variable to 0.\n\nThe `next` function takes an integer `n` and iterates through the run-length encoded array to find the value at the given position. If `n` is less than or equal to the current run's count (`encoding[index]), we update the run count by subtracting n and return the corresponding value. If `n` is greater than the run's count, we subtract the run count from `n` and move to the next run by incrementing the index by 2. If the iterator reaches the end of the encoding array, it returns -1.\n    "}
{"id": 942, "slug": "di-string-match", "title": "DI String Match", "difficulty": "Easy", "content": "A permutation `perm` of `n + 1` integers of all the integers in the range `[0, n]` can be represented as a string `s` of length `n` where:\n\n*   `s[i] == 'I'` if `perm[i] < perm[i + 1]`, and\n*   `s[i] == 'D'` if `perm[i] > perm[i + 1]`.\n\nGiven a string `s`, reconstruct the permutation `perm` and return it. If there are multiple valid permutations perm, return **any of them**.\n\n**Example 1:**\n\n**Input:** s = \"IDID\"\n**Output:** \\[0,4,1,3,2\\]\n\n**Example 2:**\n\n**Input:** s = \"III\"\n**Output:** \\[0,1,2,3\\]\n\n**Example 3:**\n\n**Input:** s = \"DDI\"\n**Output:** \\[3,2,0,1\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'I'` or `'D'`.", "java": "\n    ```java\nboolean isPalindrome(long num) {\n    String str = Long.toString(num);\n    String revStr = new StringBuilder(str).reverse().toString();\n    return str.equals(revStr);\n}\n\nint superpalindromesInRange(String left, String right) {\n    long l = Long.parseLong(left);\n    long r = Long.parseLong(right);\n    int cnt = 0;\n    for (long base = 1; base * base <= r; ++base) {\n        if (isPalindrome(base) && isPalindrome(base * base)) {\n            if (base * base >= l) {\n                cnt++;\n            }\n        }\n    }\n    return cnt;\n}\n```\n\n    \n    To solve the problem, we will do the following steps:\n1. Create a helper function `isPalindrome` to check if a given number is a palindrome.\n2. Iterate over all the possible palindrome base numbers. For each base, check if the base and the square of the base are both palindromes. If they are, check if the square of the base is within the range [l, r] and increment a counter for each valid super-palindrome found.\n3. Return the counter as the final result.\n    ", "c++": "\n    ```cpp\nbool isPalindrome(long num) {\n    string str = to_string(num);\n    string revStr = str;\n    reverse(revStr.begin(), revStr.end());\n    return str == revStr;\n}\n\nint superpalindromesInRange(string left, string right) {\n    long l = stol(left);\n    long r = stol(right);\n    int cnt = 0;\n    for (long base = 1; base * base <= r; ++base) {\n        if (isPalindrome(base) && isPalindrome(base * base)) {\n            if (base * base >= l) {\n                cnt++;\n            }\n        }\n    }\n    return cnt;\n}\n```\n\n    \n    To solve the problem, we will do the following steps:\n1. Create a helper function `isPalindrome` to check if a given number is a palindrome.\n2. Iterate over all the possible palindrome base numbers. For each base, check if the base and the square of the base are both palindromes. If they are, check if the square of the base is within the range [l, r] and increment a counter for each valid super-palindrome found.\n3. Return the counter as the final result.\n    ", "python": "\n    ```python\ndef isPalindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef superpalindromesInRange(left: str, right: str) -> int:\n    l = int(left)\n    r = int(right)\n    cnt = 0\n    base = 1\n    while base * base <= r:\n        if isPalindrome(base) and isPalindrome(base * base):\n            if base * base >= l:\n                cnt += 1\n        base += 1\n    return cnt\n```\n\n    \n    To solve the problem, we will do the following steps:\n1. Create a helper function `isPalindrome` to check if a given number is a palindrome.\n2. Iterate over all the possible palindrome base numbers. For each base, check if the base and the square of the base are both palindromes. If they are, check if the square of the base is within the range [l, r] and increment a counter for each valid super-palindrome found.\n3. Return the counter as the final result.\n    ", "javascript": "\n    ```javascript\nfunction isPalindrome(num) {\n    const str = num.toString();\n    const revStr = str.split('').reverse().join('');\n    return str === revStr;\n}\n\nfunction superpalindromesInRange(left, right) {\n    const l = parseInt(left);\n    const r = parseInt(right);\n    let cnt = 0;\n    for (let base = 1; base * base <= r; ++base) {\n        if (isPalindrome(base) && isPalindrome(base * base)) {\n            if (base * base >= l) {\n                cnt++;\n            }\n        }\n    }\n    return cnt;\n}\n```\n\n    \n    To solve the problem, we will do the following steps:\n1. Create a helper function `isPalindrome` to check if a given number is a palindrome.\n2. Iterate over all the possible palindrome base numbers. For each base, check if the base and the square of the base are both palindromes. If they are, check if the square of the base is within the range [l, r] and increment a counter for each valid super-palindrome found.\n3. Return the counter as the final result.\n    "}
{"id": 945, "slug": "minimum-increment-to-make-array-unique", "title": "Minimum Increment to Make Array Unique", "difficulty": "Medium", "content": "You are given an integer array `nums`. In one move, you can pick an index `i` where `0 <= i < nums.length` and increment `nums[i]` by `1`.\n\nReturn _the minimum number of moves to make every value in_ `nums` _**unique**_.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,2\\]\n**Output:** 1\n**Explanation:** After 1 move, the array could be \\[1, 2, 3\\].\n\n**Example 2:**\n\n**Input:** nums = \\[3,2,1,2,1,7\\]\n**Output:** 6\n**Explanation:** After 6 moves, the array could be \\[3, 4, 1, 2, 5, 7\\].\nIt can be shown with 5 or less moves that it is impossible for the array to have all unique values.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 105`", "java": "\n    ```java\npublic int snakesAndLadders(int[][] board) {\n    int n = board.length;\n    int[] flattenedBoard = new int[n * n + 1];\n    boolean isRight = true;\n    int idx = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        if (isRight) {\n            for (int j = 0; j < n; j++) {\n                flattenedBoard[idx++] = board[i][j];\n            }\n        } else {\n            for (int j = n - 1; j >= 0; j--) {\n                flattenedBoard[idx++] = board[i][j];\n            }\n        }\n        isRight = !isRight;\n    }\n\n    int[] moves = new int[n * n + 1];\n    Arrays.fill(moves, -1);\n    moves[1] = 0;\n    for (int i = 0; i < moves.length; i++) {\n        if (moves[i] != -1) {\n            for (int j = 1; j <= 6 && i + j < moves.length; j++) {\n                int nextPos = i + j;\n                int value = flattenedBoard[nextPos];\n                if (value == -1) {\n                    value = nextPos;\n                }\n                if (moves[value] == -1) {\n                    moves[value] = moves[i] + 1;\n                }\n            }\n        }\n    }\n    return moves[n * n];\n}\n```\n\n    \n    1. First, initialize a visited array to keep track of the visited squares.\n2. Use a queue for the BFS traversal, starting from square 1 with the initial number of steps as 0.\n3. Write a helper function `getPosition` to get the row and column indices of a given square position in the Boustrophedon style.\n4. While there are still squares left in the queue, perform BFS by checking all possible 1 to 6 steps from the current position.\n5. If the destination square has a snake or ladder (i.e., != -1), move to the corresponding index on the board.\n6. If the next position to visit is the target square (n^2), return the steps taken.\n7. If the next position has not been visited yet, add it to the queue and mark it as visited.\n8. If no path is found to reach the target square, return -1.\n    ", "c++": "\n    ```cpp\nint snakesAndLadders(vector<vector<int>> &board) {\n    int n = board.size();\n    auto getRowCol = [&](int x) {\n        int r = (x - 1) / n, c = (x - 1) % n;\n        if (r % 2) c = n - 1 - c;\n        return make_pair(n - 1 - r, c);\n    };\n\n    vector<bool> visited(n * n + 1, false);\n    queue<pair<int, int>> q;\n    q.push({1, 0});\n    visited[1] = true;\n\n    while (!q.empty()) {\n        auto cur = q.front(); q.pop();\n        int x = cur.first;\n        int steps = cur.second;\n        for (int jump = 1; jump <= 6; jump++) {\n            int next_x = x + jump;\n            if (next_x > n * n) break;\n            auto nextRC = getRowCol(next_x);\n            if (board[nextRC.first][nextRC.second] != -1) {\n                next_x = board[nextRC.first][nextRC.second];\n            }\n            if (next_x == n * n) return steps + 1;\n            if (!visited[next_x]) {\n                visited[next_x] = true;\n                q.push({next_x, steps + 1});\n            }\n        }\n    }\n    return -1;\n}\n```\n\n    \n    1. First, initialize a visited array to keep track of the visited squares.\n2. Use a queue for the BFS traversal, starting from square 1 with the initial number of steps as 0.\n3. Write a helper function `getPosition` to get the row and column indices of a given square position in the Boustrophedon style.\n4. While there are still squares left in the queue, perform BFS by checking all possible 1 to 6 steps from the current position.\n5. If the destination square has a snake or ladder (i.e., != -1), move to the corresponding index on the board.\n6. If the next position to visit is the target square (n^2), return the steps taken.\n7. If the next position has not been visited yet, add it to the queue and mark it as visited.\n8. If no path is found to reach the target square, return -1.\n    ", "python": "\n    ```python\ndef snakesAndLadders(board):\n    n = len(board)\n    visited = [False] * (n*n + 1)\n    queue = [(1, 0)]  # starting at position 1\n    visited[1] = True\n\n    def get_position(pos):\n        r = (pos - 1) // n\n        c = (pos - 1) % n\n        if r % 2 == 1:\n            c = n - 1 - c\n        r = n - r - 1\n        return r, c\n\n    while queue:\n        pos, steps = queue.pop(0)\n        for jump in range(1, 7):\n            next_pos = pos + jump\n            if next_pos > n*n:\n                break\n            r, c = get_position(next_pos)\n            if board[r][c] != -1:\n                next_pos = board[r][c]\n            if next_pos == n*n:\n                return steps + 1\n            if not visited[next_pos]:\n                visited[next_pos] = True\n                queue.append((next_pos, steps + 1))\n\n    return -1\n```\n\n    \n    1. First, initialize a visited array to keep track of the visited squares.\n2. Use a queue for the BFS traversal, starting from square 1 with the initial number of steps as 0.\n3. Write a helper function `getPosition` to get the row and column indices of a given square position in the Boustrophedon style.\n4. While there are still squares left in the queue, perform BFS by checking all possible 1 to 6 steps from the current position.\n5. If the destination square has a snake or ladder (i.e., != -1), move to the corresponding index on the board.\n6. If the next position to visit is the target square (n^2), return the steps taken.\n7. If the next position has not been visited yet, add it to the queue and mark it as visited.\n8. If no path is found to reach the target square, return -1.\n    ", "javascript": "\n    ```javascript\nfunction snakesAndLadders(board) {\n  const n = board.length;\n  const visited = new Array(n * n + 1).fill(false);\n  const queue = [{ pos: 1, steps: 0 }];\n  visited[1] = true;\n\n  function getPosition(pos) {\n    const row = Math.ceil(pos / n);\n    let col = ((row % 2) === 0) ? n - (pos % n) : (pos % n) + 1;\n    if (col === n + 1) {\n      col = 1;\n    }\n    return [n - row, col - 1];\n  }\n\n  while (queue.length) {\n    const { pos, steps } = queue.shift();\n\n    for (let jump = 1; jump <= 6; jump++) {\n      let nextPos = pos + jump;\n      if (nextPos > n * n) break;\n      const [r, c] = getPosition(nextPos);\n      if (board[r][c] !== -1) {\n        nextPos = board[r][c];\n      }\n      if (nextPos === n * n) return steps + 1;\n      if (!visited[nextPos]) {\n        visited[nextPos] = true;\n        queue.push({ pos: nextPos, steps: steps + 1 });\n      }\n    }\n  }\n  return -1;\n}\n```\n\n    \n    1. First, initialize a visited array to keep track of the visited squares.\n2. Use a queue for the BFS traversal, starting from square 1 with the initial number of steps as 0.\n3. Write a helper function `getPosition` to get the row and column indices of a given square position in the Boustrophedon style.\n4. While there are still squares left in the queue, perform BFS by checking all possible 1 to 6 steps from the current position.\n5. If the destination square has a snake or ladder (i.e., != -1), move to the corresponding index on the board.\n6. If the next position to visit is the target square (n^2), return the steps taken.\n7. If the next position has not been visited yet, add it to the queue and mark it as visited.\n8. If no path is found to reach the target square, return -1.\n    "}
{"id": 948, "slug": "bag-of-tokens", "title": "Bag of Tokens", "difficulty": "Medium", "content": "You have an initial **power** of `power`, an initial **score** of `0`, and a bag of `tokens` where `tokens[i]` is the value of the `ith` token (0-indexed).\n\nYour goal is to maximize your total **score** by potentially playing each token in one of two ways:\n\n*   If your current **power** is at least `tokens[i]`, you may play the `ith` token face up, losing `tokens[i]` **power** and gaining `1` **score**.\n*   If your current **score** is at least `1`, you may play the `ith` token face down, gaining `tokens[i]` **power** and losing `1` **score**.\n\nEach token may be played **at most** once and **in any order**. You do **not** have to play all the tokens.\n\nReturn _the largest possible **score** you can achieve after playing any number of tokens_.\n\n**Example 1:**\n\n**Input:** tokens = \\[100\\], power = 50\n**Output:** 0\n**Explanation****:** Playing the only token in the bag is impossible because you either have too little power or too little score.\n\n**Example 2:**\n\n**Input:** tokens = \\[100,200\\], power = 150\n**Output:** 1\n**Explanation:** Play the 0th token (100) face up, your power becomes 50 and score becomes 1.\nThere is no need to play the 1st token since you cannot play it face up to add to your score.\n\n**Example 3:**\n\n**Input:** tokens = \\[100,200,300,400\\], power = 200\n**Output:** 2\n**Explanation:** Play the tokens in this order to get a score of 2:\n1. Play the 0th token (100) face up, your power becomes 100 and score becomes 1.\n2. Play the 3rd token (400) face down, your power becomes 500 and score becomes 0.\n3. Play the 1st token (200) face up, your power becomes 300 and score becomes 1.\n4. Play the 2nd token (300) face up, your power becomes 0 and score becomes 2.\n\n**Constraints:**\n\n*   `0 <= tokens.length <= 1000`\n*   `0 <= tokens[i], power < 104`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic void sortArray(int[] nums) {\n    Arrays.sort(nums);\n}\n```\n    \n    The algorithm for each language uses the built-in sorting function provided by the language's standard library to sort the given array of integers in ascending order.\n\n- In C++, the `std::sort` function from the `<algorithm>` library is used.\n- In Java, the `Arrays.sort` method from the `java.util` package is used.\n- In Python, the in-built `sort` method of the list object (nums) is used.\n- In JavaScript, the `Array.prototype.sort` method is used with a custom comparator function `(a, b) => a - b` to ensure numeric sorting instead of lexicographic sorting (the default behavior of JavaScript's sort).\n\nAll these built-in methods use efficient sorting algorithms underneath, with average-case complexity of O(n log n).\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nvoid sortArray(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n}\n```\n    \n    The algorithm for each language uses the built-in sorting function provided by the language's standard library to sort the given array of integers in ascending order.\n\n- In C++, the `std::sort` function from the `<algorithm>` library is used.\n- In Java, the `Arrays.sort` method from the `java.util` package is used.\n- In Python, the in-built `sort` method of the list object (nums) is used.\n- In JavaScript, the `Array.prototype.sort` method is used with a custom comparator function `(a, b) => a - b` to ensure numeric sorting instead of lexicographic sorting (the default behavior of JavaScript's sort).\n\nAll these built-in methods use efficient sorting algorithms underneath, with average-case complexity of O(n log n).\n    ", "python": "\n    ```python\ndef sortArray(nums):\n    nums.sort()\n```\n    \n    The algorithm for each language uses the built-in sorting function provided by the language's standard library to sort the given array of integers in ascending order.\n\n- In C++, the `std::sort` function from the `<algorithm>` library is used.\n- In Java, the `Arrays.sort` method from the `java.util` package is used.\n- In Python, the in-built `sort` method of the list object (nums) is used.\n- In JavaScript, the `Array.prototype.sort` method is used with a custom comparator function `(a, b) => a - b` to ensure numeric sorting instead of lexicographic sorting (the default behavior of JavaScript's sort).\n\nAll these built-in methods use efficient sorting algorithms underneath, with average-case complexity of O(n log n).\n    ", "javascript": "\n    ```javascript\nfunction sortArray(nums) {\n    nums.sort((a, b) => a - b);\n}\n```\n    \n    The algorithm for each language uses the built-in sorting function provided by the language's standard library to sort the given array of integers in ascending order.\n\n- In C++, the `std::sort` function from the `<algorithm>` library is used.\n- In Java, the `Arrays.sort` method from the `java.util` package is used.\n- In Python, the in-built `sort` method of the list object (nums) is used.\n- In JavaScript, the `Array.prototype.sort` method is used with a custom comparator function `(a, b) => a - b` to ensure numeric sorting instead of lexicographic sorting (the default behavior of JavaScript's sort).\n\nAll these built-in methods use efficient sorting algorithms underneath, with average-case complexity of O(n log n).\n    "}
{"id": 954, "slug": "array-of-doubled-pairs", "title": "Array of Doubled Pairs", "difficulty": "Medium", "content": "Given an integer array of even length `arr`, return `true` _if it is possible to reorder_ `arr` _such that_ `arr[2 * i + 1] = 2 * arr[2 * i]` _for every_ `0 <= i < len(arr) / 2`_, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** arr = \\[3,1,3,6\\]\n**Output:** false\n\n**Example 2:**\n\n**Input:** arr = \\[2,1,2,6\\]\n**Output:** false\n\n**Example 3:**\n\n**Input:** arr = \\[4,-2,2,-4\\]\n**Output:** true\n**Explanation:** We can take two groups, \\[-2,-4\\] and \\[2,4\\] to form \\[-2,-4,2,4\\] or \\[2,4,-2,-4\\].\n\n**Constraints:**\n\n*   `2 <= arr.length <= 3 * 104`\n*   `arr.length` is even.\n*   `-105 <= arr[i] <= 105`", "java": "\n    ```java\npublic boolean canReorderDoubled(int[] arr) {\n    Map<Integer, Integer> count = new TreeMap<>();\n    for (int a : arr) {\n        count.put(a, count.getOrDefault(a, 0) + 1);\n    }\n    \n    for (int a : count.keySet()) {\n        if (count.get(a) > 0) {\n            int target = a < 0 ? a / 2 : a * 2;\n            if (count.getOrDefault(target, 0) < count.get(a)) return false;\n            count.put(target, count.get(target) - count.get(a));\n        }\n    }\n\n    return true;\n}\n```\n    \n    1. Count values in the dataArray using a map / dictionary / counter.\n2. For each value in the dataArray, in ascending order of magnitude (Take care of negative values properly):\n     - Check if we have sufficient values to match the count.\n     - If we do, remove the required count and continue. Else, return False.\n3. If our loop encounters no issues, return True.\n    ", "c++": "\n    ```cpp\nbool canReorderDoubled(vector<int>& arr) {\n    map<int, int> count;\n    for (int a : arr) {\n        count[a]++;\n    }\n    \n    for (const auto& [a, c] : count) {\n        if (c > 0) {\n            int target = a < 0 ? a / 2 : a * 2;\n            if (count[target] < c) return false;\n            count[target] -= c;\n        }\n    }\n\n    return true;\n}\n```\n    \n    1. Count values in the dataArray using a map / dictionary / counter.\n2. For each value in the dataArray, in ascending order of magnitude (Take care of negative values properly):\n     - Check if we have sufficient values to match the count.\n     - If we do, remove the required count and continue. Else, return False.\n3. If our loop encounters no issues, return True.\n    ", "python": "\n    ```python\ndef canReorderDoubled(arr):\n    count = collections.Counter(arr)\n    \n    for a in sorted(count, key=abs):\n        if count[a] > 0:\n            target = a * 2\n            if count[target] < count[a]:\n                return False\n            count[target] -= count[a]\n\n    return True\n```\n    \n    1. Count values in the dataArray using a map / dictionary / counter.\n2. For each value in the dataArray, in ascending order of magnitude (Take care of negative values properly):\n     - Check if we have sufficient values to match the count.\n     - If we do, remove the required count and continue. Else, return False.\n3. If our loop encounters no issues, return True.\n    ", "javascript": "\n    ```javascript\nvar canReorderDoubled = function(arr) {\n    const count = new Map();\n    arr.sort((a, b) => Math.abs(a) - Math.abs(b));\n    \n    for (const a of arr) {\n        if (!count.has(a)) {\n            count.set(a, 0);\n        }\n        count.set(a, count.get(a) + 1);\n    }\n    \n    for (const a of count.keys()) {\n        if (count.get(a) > 0) {\n            const target = a < 0 ? a / 2 : a * 2;\n            if (!count.has(target) || count.get(target) < count.get(a)) {\n                return false;\n            }\n            count.set(target, count.get(target) - count.get(a));\n        }\n    }\n\n    return true;\n};\n```\n    \n    1. Count values in the dataArray using a map / dictionary / counter.\n2. For each value in the dataArray, in ascending order of magnitude (Take care of negative values properly):\n     - Check if we have sufficient values to match the count.\n     - If we do, remove the required count and continue. Else, return False.\n3. If our loop encounters no issues, return True.\n    "}
{"id": 955, "slug": "delete-columns-to-make-sorted-ii", "title": "Delete Columns to Make Sorted II", "difficulty": "Medium", "content": "You are given an array of `n` strings `strs`, all of the same length.\n\nWe may choose any deletion indices, and we delete all the characters in those indices for each string.\n\nFor example, if we have `strs = [ \"abcdef \", \"uvwxyz \"]` and deletion indices `{0, 2, 3}`, then the final array after deletions is `[ \"bef \", \"vyz \"]`.\n\nSuppose we chose a set of deletion indices `answer` such that after deletions, the final array has its elements in **lexicographic** order (i.e., `strs[0] <= strs[1] <= strs[2] <= ... <= strs[n - 1]`). Return _the minimum possible value of_ `answer.length`.\n\n**Example 1:**\n\n**Input:** strs = \\[ \"ca \", \"bb \", \"ac \"\\]\n**Output:** 1\n**Explanation:** \nAfter deleting the first column, strs = \\[ \"a \",  \"b \",  \"c \"\\].\nNow strs is in lexicographic order (ie. strs\\[0\\] <= strs\\[1\\] <= strs\\[2\\]).\nWe require at least 1 deletion since initially strs was not in lexicographic order, so the answer is 1.\n\n**Example 2:**\n\n**Input:** strs = \\[ \"xc \", \"yb \", \"za \"\\]\n**Output:** 0\n**Explanation:** \nstrs is already in lexicographic order, so we do not need to delete anything.\nNote that the rows of strs are not necessarily in lexicographic order:\ni.e., it is NOT necessarily true that (strs\\[0\\]\\[0\\] <= strs\\[0\\]\\[1\\] <= ...)\n\n**Example 3:**\n\n**Input:** strs = \\[ \"zyx \", \"wvu \", \"tsr \"\\]\n**Output:** 3\n**Explanation:** We have to delete every column.\n\n**Constraints:**\n\n*   `n == strs.length`\n*   `1 <= n <= 100`\n*   `1 <= strs[i].length <= 100`\n*   `strs[i]` consists of lowercase English letters.", "java": "\n    ```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass CBTInserter {\n    TreeNode root;\n    Queue<TreeNode> q;\n\n    public CBTInserter(TreeNode root) {\n        this.root = root;\n        q = new LinkedList<>();\n        q.add(root);\n        while (true) {\n            TreeNode node = q.peek();\n            if (node.left == null || node.right == null) break;\n            q.add(node.left);\n            q.add(node.right);\n            q.poll();\n        }\n    }\n\n    public int insert(int v) {\n        TreeNode newNode = new TreeNode(v);\n        TreeNode parentNode = q.peek();\n        if (parentNode.left == null) {\n            parentNode.left = newNode;\n        } else {\n            parentNode.right = newNode;\n            q.add(parentNode.left);\n            q.add(parentNode.right);\n            q.poll();\n        }\n        return parentNode.val;\n    }\n\n    public TreeNode get_root() {\n        return root;\n    }\n}\n```\n\n    \n    The algorithm starts by initializing a queue with the given root node. At each step, it checks if the front node from the queue has an empty left or right child. If so, the algorithm breaks from the loop as it found the first node with an empty child.\n\nTo insert a new node, it creates a new node with the provided value and checks if the left child of the front node from the queue is empty. If so, it assigns the new node as the left child. Otherwise, it assigns the new node as the right child, push both left and right children of the front node to the queue, and removes the front node from the queue. It returns the value of the parent node.\n\nThe get_root method returns the root of the tree.\n    ", "c++": "\n    ```cpp\n#include <queue>\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass CBTInserter {\npublic:\n    TreeNode* root;\n    std::queue<TreeNode*> q;\n    \n    CBTInserter(TreeNode* root) {\n        this->root = root;\n        q.push(root);\n        while (!q.empty()) {\n            TreeNode* node = q.front();\n            if (!node->left || !node->right) break;\n            q.push(node->left);\n            q.push(node->right);\n            q.pop();\n        }\n    }\n    \n    int insert(int v) {\n        TreeNode* newNode = new TreeNode(v);\n        TreeNode* parentNode = q.front();\n        if (!parentNode->left) {\n            parentNode->left = newNode;\n        } else {\n            parentNode->right = newNode;\n            q.push(parentNode->left);\n            q.push(parentNode->right);\n            q.pop();\n        }\n        return parentNode->val;\n    }\n    \n    TreeNode* get_root() {\n        return root;\n    }\n};\n```\n\n    \n    The algorithm starts by initializing a queue with the given root node. At each step, it checks if the front node from the queue has an empty left or right child. If so, the algorithm breaks from the loop as it found the first node with an empty child.\n\nTo insert a new node, it creates a new node with the provided value and checks if the left child of the front node from the queue is empty. If so, it assigns the new node as the left child. Otherwise, it assigns the new node as the right child, push both left and right children of the front node to the queue, and removes the front node from the queue. It returns the value of the parent node.\n\nThe get_root method returns the root of the tree.\n    ", "python": "\n    ```python\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass CBTInserter:\n    def __init__(self, root: TreeNode):\n        self.root = root\n        self.q = deque([root])\n        while True:\n            node = self.q[0]\n            if not node.left or not node.right:\n                break\n            self.q.append(node.left)\n            self.q.append(node.right)\n            self.q.popleft()\n\n    def insert(self, v: int) -> int:\n        newNode = TreeNode(v)\n        parentNode = self.q[0]\n        if not parentNode.left:\n            parentNode.left = newNode\n        else:\n            parentNode.right = newNode\n            self.q.append(parentNode.left)\n            self.q.append(parentNode.right)\n            self.q.popleft()\n        return parentNode.val\n\n    def get_root(self) -> TreeNode:\n        return self.root\n```\n\n    \n    The algorithm starts by initializing a queue with the given root node. At each step, it checks if the front node from the queue has an empty left or right child. If so, the algorithm breaks from the loop as it found the first node with an empty child.\n\nTo insert a new node, it creates a new node with the provided value and checks if the left child of the front node from the queue is empty. If so, it assigns the new node as the left child. Otherwise, it assigns the new node as the right child, push both left and right children of the front node to the queue, and removes the front node from the queue. It returns the value of the parent node.\n\nThe get_root method returns the root of the tree.\n    ", "javascript": "\n    ```javascript\nclass TreeNode {\n    constructor(x) {\n        this.val = x;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass CBTInserter {\n    constructor(root) {\n        this.root = root;\n        this.q = [root];\n        while (true) {\n            let node = this.q[0];\n            if (!node.left || !node.right) break;\n            this.q.push(node.left);\n            this.q.push(node.right);\n            this.q.shift();\n        }\n    }\n\n    insert(v) {\n        const newNode = new TreeNode(v);\n        const parentNode = this.q[0];\n        if (!parentNode.left) {\n            parentNode.left = newNode;\n        } else {\n            parentNode.right = newNode;\n            this.q.push(parentNode.left);\n            this.q.push(parentNode.right);\n            this.q.shift();\n        }\n        return parentNode.val;\n    }\n\n    get_root() {\n        return this.root;\n    }\n}\n```\n\n    \n    The algorithm starts by initializing a queue with the given root node. At each step, it checks if the front node from the queue has an empty left or right child. If so, the algorithm breaks from the loop as it found the first node with an empty child.\n\nTo insert a new node, it creates a new node with the provided value and checks if the left child of the front node from the queue is empty. If so, it assigns the new node as the left child. Otherwise, it assigns the new node as the right child, push both left and right children of the front node to the queue, and removes the front node from the queue. It returns the value of the parent node.\n\nThe get_root method returns the root of the tree.\n    "}
{"id": 969, "slug": "pancake-sorting", "title": "Pancake Sorting", "difficulty": "Medium", "content": "Given an array of integers `arr`, sort the array by performing a series of **pancake flips**.\n\nIn one pancake flip we do the following steps:\n\n*   Choose an integer `k` where `1 <= k <= arr.length`.\n*   Reverse the sub-array `arr[0...k-1]` (**0-indexed**).\n\nFor example, if `arr = [3,2,1,4]` and we performed a pancake flip choosing `k = 3`, we reverse the sub-array `[3,2,1]`, so `arr = [1,2,3,4]` after the pancake flip at `k = 3`.\n\nReturn _an array of the_ `k`_\\-values corresponding to a sequence of pancake flips that sort_ `arr`. Any valid answer that sorts the array within `10 * arr.length` flips will be judged as correct.\n\n**Example 1:**\n\n**Input:** arr = \\[3,2,4,1\\]\n**Output:** \\[4,2,4,3\\]\n**Explanation:** \nWe perform 4 pancake flips, with k values 4, 2, 4, and 3.\nStarting state: arr = \\[3, 2, 4, 1\\]\nAfter 1st flip (k = 4): arr = \\[1, 4, 2, 3\\]\nAfter 2nd flip (k = 2): arr = \\[4, 1, 2, 3\\]\nAfter 3rd flip (k = 4): arr = \\[3, 2, 1, 4\\]\nAfter 4th flip (k = 3): arr = \\[1, 2, 3, 4\\], which is sorted.\n\n**Example 2:**\n\n**Input:** arr = \\[1,2,3\\]\n**Output:** \\[\\]\n**Explanation:** The input is already sorted, so there is no need to flip anything.\nNote that other answers, such as \\[3, 3\\], would also be accepted.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 100`\n*   `1 <= arr[i] <= arr.length`\n*   All integers in `arr` are unique (i.e. `arr` is a permutation of the integers from `1` to `arr.length`).", "java": "\n    ```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass RecentCounter {\n    Queue<Integer> requests;\n\n    public RecentCounter() {\n        requests = new LinkedList<>();\n    }\n\n    public int ping(int t) {\n        requests.add(t);\n        while (requests.peek() < t - 3000) {\n            requests.poll();\n        }\n        return requests.size();\n    }\n}\n```\n    \n    The algorithm for the RecentCounter class uses a data structure known as a Queue (in C++ and Java, `deque` is used) to store request timestamps. \n\nThe core steps of the algorithm include:\n1. Initialize an empty Queue (or deque) to store request timestamps.\n2. When `ping` is called process it with the timestamp `t`:\n   a. Add `t` to the end of the request timestamps queue.\n   b. Remove all requests from the front of the queue that have a timestamp less than `t - 3000`, because these are not considered recent requests.\n3. Finally, return the length of the queue, which represents the number of recent requests within the time frame.\n\nThis algorithm efficiently processes the requests in O(1) time complexity for each request since all operations on the deque or queue take constant time, although it can be O(n) in the worst case where n is the number of ping calls, the better average case makes it a good choice.\n    ", "c++": "\n    ```cpp\n#include <deque>\n\nclass RecentCounter {\npublic:\n    std::deque<int> requests;\n    \n    RecentCounter() { }\n    \n    int ping(int t) {\n        requests.push_back(t);\n        while (requests.front() < t - 3000) {\n            requests.pop_front();\n        }\n        return requests.size();\n    }\n};\n```\n    \n    The algorithm for the RecentCounter class uses a data structure known as a Queue (in C++ and Java, `deque` is used) to store request timestamps. \n\nThe core steps of the algorithm include:\n1. Initialize an empty Queue (or deque) to store request timestamps.\n2. When `ping` is called process it with the timestamp `t`:\n   a. Add `t` to the end of the request timestamps queue.\n   b. Remove all requests from the front of the queue that have a timestamp less than `t - 3000`, because these are not considered recent requests.\n3. Finally, return the length of the queue, which represents the number of recent requests within the time frame.\n\nThis algorithm efficiently processes the requests in O(1) time complexity for each request since all operations on the deque or queue take constant time, although it can be O(n) in the worst case where n is the number of ping calls, the better average case makes it a good choice.\n    ", "python": "\n    ```python\nfrom collections import deque\n\nclass RecentCounter:\n    def __init__(self):\n        self.requests = deque()\n\n    def ping(self, t: int) -> int:\n        self.requests.append(t)\n        while self.requests[0] < t - 3000:\n            self.requests.popleft()\n        return len(self.requests)\n```\n    \n    The algorithm for the RecentCounter class uses a data structure known as a Queue (in C++ and Java, `deque` is used) to store request timestamps. \n\nThe core steps of the algorithm include:\n1. Initialize an empty Queue (or deque) to store request timestamps.\n2. When `ping` is called process it with the timestamp `t`:\n   a. Add `t` to the end of the request timestamps queue.\n   b. Remove all requests from the front of the queue that have a timestamp less than `t - 3000`, because these are not considered recent requests.\n3. Finally, return the length of the queue, which represents the number of recent requests within the time frame.\n\nThis algorithm efficiently processes the requests in O(1) time complexity for each request since all operations on the deque or queue take constant time, although it can be O(n) in the worst case where n is the number of ping calls, the better average case makes it a good choice.\n    ", "javascript": "\n    ```javascript\nclass RecentCounter {\n    constructor() {\n        this.requests = [];\n    }\n\n    ping(t) {\n        this.requests.push(t);\n        while (this.requests[0] < t - 3000) {\n            this.requests.shift();\n        }\n        return this.requests.length;\n    }\n}\n```\n    \n    The algorithm for the RecentCounter class uses a data structure known as a Queue (in C++ and Java, `deque` is used) to store request timestamps. \n\nThe core steps of the algorithm include:\n1. Initialize an empty Queue (or deque) to store request timestamps.\n2. When `ping` is called process it with the timestamp `t`:\n   a. Add `t` to the end of the request timestamps queue.\n   b. Remove all requests from the front of the queue that have a timestamp less than `t - 3000`, because these are not considered recent requests.\n3. Finally, return the length of the queue, which represents the number of recent requests within the time frame.\n\nThis algorithm efficiently processes the requests in O(1) time complexity for each request since all operations on the deque or queue take constant time, although it can be O(n) in the worst case where n is the number of ping calls, the better average case makes it a good choice.\n    "}
{"id": 976, "slug": "largest-perimeter-triangle", "title": "Largest Perimeter Triangle", "difficulty": "Easy", "content": "Given an integer array `nums`, return _the largest perimeter of a triangle with a non-zero area, formed from three of these lengths_. If it is impossible to form any triangle of a non-zero area, return `0`.\n\n**Example 1:**\n\n**Input:** nums = \\[2,1,2\\]\n**Output:** 5\n**Explanation:** You can form a triangle with three side lengths: 1, 2, and 2.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,1,10\\]\n**Output:** 0\n**Explanation:** \nYou cannot use the side lengths 1, 1, and 2 to form a triangle.\nYou cannot use the side lengths 1, 1, and 10 to form a triangle.\nYou cannot use the side lengths 1, 2, and 10 to form a triangle.\nAs we cannot use any three side lengths to form a triangle of non-zero area, we return 0.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 104`\n*   `1 <= nums[i] <= 106`", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int minAreaRect(int[][] points) {\n        Set<Pair<Integer, Integer>> pointSet = new HashSet<>();\n        for (int[] point : points) {\n            pointSet.add(new Pair<>(point[0], point[1]));\n        }\n\n        int minArea = Integer.MAX_VALUE;\n        for (int[] p1 : points) {\n            for (int[] p2 : points) {\n                if (p1[0] != p2[0] && p1[1] != p2[1]) {\n                    if (pointSet.contains(new Pair<>(p1[0], p2[1])) && pointSet.contains(new Pair<>(p2[0], p1[1]))) {\n                        minArea = Math.min(minArea, Math.abs((p1[0] - p2[0]) * (p1[1] - p2[1])));\n                    }\n                }\n            }\n        }\n\n        return minArea == Integer.MAX_VALUE ? 0 : minArea;\n    }\n}\n```\n\n    \n    1. Convert the given points into a set for efficient lookups.\n2. Initialize `min_area` to an infinitely large value initially.\n3. Iterate through each pair of distinct points `p1` and `p2` in the set, and check if two other points `p3` and `p4` exist such that p3.x = p1.x, p3.y = p2.y, p4.x = p2.x, p4.y = p1.y.\n4. If such points exist, calculate the area between `p1` and `p2` and update `min_area` with the minimum value between current `min_area` and calculated area.\n5. After the iteration, if `min_area` still holds the initial value (indicating no rectangles were found), return 0; otherwise, return the `min_area`.\n    ", "c++": "\n    ```cpp\n#include <set>\n#include <vector>\n\ndouble minAreaRect(std::vector<std::vector<int>>& points) {\n    std::set<std::pair<int, int>> point_set;\n    for (const auto& point : points) {\n        point_set.emplace(point[0], point[1]);\n    }\n\n    double min_area = INT32_MAX;\n    for (const auto& p1 : point_set) {\n        for (const auto& p2 : point_set) {\n            if (p1.first != p2.first && p1.second != p2.second) {\n                if (point_set.count({p1.first, p2.second}) && point_set.count({p2.first, p1.second})) {\n                    min_area = std::min(min_area, abs((p1.first - p2.first) * (p1.second - p2.second)));\n                }\n            }\n        }\n    }\n\n    return min_area == INT32_MAX ? 0 : min_area;\n}\n```\n\n    \n    1. Convert the given points into a set for efficient lookups.\n2. Initialize `min_area` to an infinitely large value initially.\n3. Iterate through each pair of distinct points `p1` and `p2` in the set, and check if two other points `p3` and `p4` exist such that p3.x = p1.x, p3.y = p2.y, p4.x = p2.x, p4.y = p1.y.\n4. If such points exist, calculate the area between `p1` and `p2` and update `min_area` with the minimum value between current `min_area` and calculated area.\n5. After the iteration, if `min_area` still holds the initial value (indicating no rectangles were found), return 0; otherwise, return the `min_area`.\n    ", "python": "\n    ```python\ndef min_area_rect(points):\n    point_set = {(x, y) for x, y in points}\n    min_area = float('inf')\n\n    for p1 in point_set:\n        for p2 in point_set:\n            if p1[0] != p2[0] and p1[1] != p2[1]:\n                if (p1[0], p2[1]) in point_set and (p2[0], p1[1]) in point_set:\n                    min_area = min(min_area, abs((p1[0] - p2[0]) * (p1[1] - p2[1])))\n\n    return min_area if min_area != float('inf') else 0\n```\n\n    \n    1. Convert the given points into a set for efficient lookups.\n2. Initialize `min_area` to an infinitely large value initially.\n3. Iterate through each pair of distinct points `p1` and `p2` in the set, and check if two other points `p3` and `p4` exist such that p3.x = p1.x, p3.y = p2.y, p4.x = p2.x, p4.y = p1.y.\n4. If such points exist, calculate the area between `p1` and `p2` and update `min_area` with the minimum value between current `min_area` and calculated area.\n5. After the iteration, if `min_area` still holds the initial value (indicating no rectangles were found), return 0; otherwise, return the `min_area`.\n    ", "javascript": "\n    ```javascript\nfunction minAreaRect(points) {\n  const pointSet = new Set(points.map(point => point.join(',')));\n  let minArea = Infinity;\n\n  for (const p1 of points) {\n    for (const p2 of points) {\n      if (p1[0] !== p2[0] && p1[1] !== p2[1]) {\n        if (pointSet.has([p1[0], p2[1]].join(',')) && pointSet.has([p2[0], p1[1]].join(','))) {\n          minArea = Math.min(minArea, Math.abs((p1[0] - p2[0]) * (p1[1] - p2[1])));\n        }\n      }\n    }\n  }\n\n  return minArea === Infinity ? 0 : minArea;\n}\n```\n\n    \n    1. Convert the given points into a set for efficient lookups.\n2. Initialize `min_area` to an infinitely large value initially.\n3. Iterate through each pair of distinct points `p1` and `p2` in the set, and check if two other points `p3` and `p4` exist such that p3.x = p1.x, p3.y = p2.y, p4.x = p2.x, p4.y = p1.y.\n4. If such points exist, calculate the area between `p1` and `p2` and update `min_area` with the minimum value between current `min_area` and calculated area.\n5. After the iteration, if `min_area` still holds the initial value (indicating no rectangles were found), return 0; otherwise, return the `min_area`.\n    "}
{"id": 984, "slug": "string-without-aaa-or-bbb", "title": "String Without AAA or BBB", "difficulty": "Medium", "content": "Given two integers `a` and `b`, return **any** string `s` such that:\n\n*   `s` has length `a + b` and contains exactly `a` `'a'` letters, and exactly `b` `'b'` letters,\n*   The substring `'aaa'` does not occur in `s`, and\n*   The substring `'bbb'` does not occur in `s`.\n\n**Example 1:**\n\n**Input:** a = 1, b = 2\n**Output:**  \"abb \"\n**Explanation:**  \"abb \",  \"bab \" and  \"bba \" are all correct answers.\n\n**Example 2:**\n\n**Input:** a = 4, b = 1\n**Output:**  \"aabaa \"\n\n**Constraints:**\n\n*   `0 <= a, b <= 100`\n*   It is guaranteed such an `s` exists for the given `a` and `b`.", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int removeStones(int[][] stones) {\n        int n = stones.length;\n        Map<Integer, Integer> row_groups = new HashMap<>();\n        Map<Integer, Integer> col_groups = new HashMap<>();\n        int group_count = 0;\n\n        int[][] groups = new int[n * 2][n];\n        int[] group_sizes = new int[n * 2];\n\n        for (int i = 0; i < n; i++) {\n            int x = stones[i][0], y = stones[i][1];\n            int groupId_x = row_groups.computeIfAbsent(x, (key) -> group_count++);\n            int groupId_y = col_groups.computeIfAbsent(y + 10001, (key) -> group_count++); // Offset by max row index\n\n            groups[groupId_x][group_sizes[groupId_x]++] = groupId_y;\n            groups[groupId_y][group_sizes[groupId_y]++] = groupId_x;\n        }\n\n        boolean[] visited = new boolean[group_count];\n\n        int max_stones = 0;\n        for (int groupId = 0; groupId < group_count; groupId++) {\n            if (!visited[groupId]) {\n                Stack<Integer> stack = new Stack<>();\n                stack.push(groupId);\n                visited[groupId] = true;\n                int size = 0;\n\n                while (!stack.isEmpty()) {\n                    int curr = stack.pop();\n                    size++;\n                    for (int i = 0; i < group_sizes[curr]; i++) {\n                        int neighbor = groups[curr][i];\n                        if (!visited[neighbor]) {\n                            stack.push(neighbor);\n                            visited[neighbor] = true;\n                        }\n                    }\n                }\n\n                max_stones += size - 1;\n            }\n        }\n\n        return max_stones;\n    }\n}\n```\n    \n    Each stone marked by a coordinate (x, y) on the plane is represented by two groups, one for the row and one for the column. We use the group counts as groupId in the group maps. First, we iterate through the stones and update the row and col groups.\n\nNext, we create a graph represented by \"groups\". Each groupId has a list of connected groupIds. We connect the row's groupId to the column's groupId.\n\nAfter constructing the graph, we perform a depth-first search (DFS) and track the connected groupId sizes. The number of stones that can be removed is the sum of connected components' sizes minus 1. This is because only (size - 1) edges connect the connected components; therefore, we can remove only (size - 1) stones without breaking the connections.\n\nWe apply the DFS in every defined language and return the max_stones which is the maximum number of stones that can be removed.\n    ", "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n\nint removeStones(std::vector<std::vector<int>>& stones) {\n    std::unordered_map<int, int> row_groups, col_groups;\n    int group_count = 0;\n\n    std::function<int(int, bool)> getGroupId = [&](int idx, bool isRow) -> int {\n        auto& groups = isRow ? row_groups : col_groups;\n        if (!groups.count(idx)) {\n            groups[idx] = group_count++;\n        }\n        return groups[idx];\n    };\n\n    std::vector<std::vector<int>> groups(group_count);\n    for (auto& [x, y] : stones) {\n        int group_x = getGroupId(x, true);\n        int group_y = getGroupId(10001 + y, false); // Offset by max row index\n        groups[group_x].push_back(group_y);\n        groups[group_y].push_back(group_x);\n    }\n\n    int max_stones = 0;\n    std::vector<bool> visited(group_count);\n\n    auto dfs = [&](int groupId, auto& dfs_ref) -> int {\n        if (visited[groupId]) return 0;\n        visited[groupId] = true;\n        int size = 1;\n        for (int neighbor : groups[groupId]) {\n            size += dfs_ref(neighbor, dfs_ref);\n        }\n        return size;\n    };\n\n    for (int groupId = 0; groupId < group_count; groupId++) {\n        max_stones += dfs(groupId, dfs) - 1;\n    }\n\n    return max_stones;\n}\n```\n    \n    Each stone marked by a coordinate (x, y) on the plane is represented by two groups, one for the row and one for the column. We use the group counts as groupId in the group maps. First, we iterate through the stones and update the row and col groups.\n\nNext, we create a graph represented by \"groups\". Each groupId has a list of connected groupIds. We connect the row's groupId to the column's groupId.\n\nAfter constructing the graph, we perform a depth-first search (DFS) and track the connected groupId sizes. The number of stones that can be removed is the sum of connected components' sizes minus 1. This is because only (size - 1) edges connect the connected components; therefore, we can remove only (size - 1) stones without breaking the connections.\n\nWe apply the DFS in every defined language and return the max_stones which is the maximum number of stones that can be removed.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\n\ndef removeStones(stones):\n    row_groups = defaultdict(int)\n    col_groups = defaultdict(int)\n    group_count = 0\n    \n    groups = defaultdict(list)\n    \n    for x, y in stones:\n        if x not in row_groups:\n            row_groups[x] = group_count\n            group_count += 1\n        if y + 10001 not in col_groups: # Offset by max row index\n            col_groups[y + 10001] = group_count\n            group_count += 1\n            \n        group_x, group_y = row_groups[x], col_groups[y + 10001]\n        groups[group_x].append(group_y)\n        groups[group_y].append(group_x)\n    \n    visited = [False] * group_count\n    \n    def dfs(groupId):\n        if visited[groupId]:\n            return 0\n        visited[groupId] = True\n        size = 1\n        for neighbor in groups[groupId]:\n            size += dfs(neighbor)\n        return size\n    \n    max_stones = 0\n    for groupId in range(group_count):\n        max_stones += dfs(groupId) - 1\n    \n    return max_stones\n```\n    \n    Each stone marked by a coordinate (x, y) on the plane is represented by two groups, one for the row and one for the column. We use the group counts as groupId in the group maps. First, we iterate through the stones and update the row and col groups.\n\nNext, we create a graph represented by \"groups\". Each groupId has a list of connected groupIds. We connect the row's groupId to the column's groupId.\n\nAfter constructing the graph, we perform a depth-first search (DFS) and track the connected groupId sizes. The number of stones that can be removed is the sum of connected components' sizes minus 1. This is because only (size - 1) edges connect the connected components; therefore, we can remove only (size - 1) stones without breaking the connections.\n\nWe apply the DFS in every defined language and return the max_stones which is the maximum number of stones that can be removed.\n    ", "javascript": "\n    ```javascript\nfunction removeStones(stones) {\n    let row_groups = new Map(),\n        col_groups = new Map(),\n        groups = new Map(),\n        group_count = 0;\n\n    for (const [x, y] of stones) {\n        if (!row_groups.has(x)) {\n            row_groups.set(x, group_count++);\n        }\n        if (!col_groups.has(y + 10001)) { // Offset by max row index\n            col_groups.set(y + 10001, group_count++);\n        }\n        let group_x = row_groups.get(x),\n            group_y = col_groups.get(y + 10001);\n\n        if (!groups.has(group_x)) {\n            groups.set(group_x, []);\n        }\n        if (!groups.has(group_y)) {\n            groups.set(group_y, []);\n        }\n        groups.get(group_x).push(group_y);\n        groups.get(group_y).push(group_x);\n    }\n\n    let visited = new Array(group_count).fill(false);\n\n    function dfs(groupId) {\n        if (visited[groupId]) {\n            return 0;\n        }\n        visited[groupId] = true;\n        let size = 1;\n\n        for (const neighbor of groups.get(groupId)) {\n            size += dfs(neighbor);\n        }\n\n        return size;\n    }\n\n    let max_stones = 0;\n    for (let groupId = 0; groupId < group_count; groupId++) {\n        max_stones += dfs(groupId) - 1;\n    }\n\n    return max_stones;\n}\n```\n    \n    Each stone marked by a coordinate (x, y) on the plane is represented by two groups, one for the row and one for the column. We use the group counts as groupId in the group maps. First, we iterate through the stones and update the row and col groups.\n\nNext, we create a graph represented by \"groups\". Each groupId has a list of connected groupIds. We connect the row's groupId to the column's groupId.\n\nAfter constructing the graph, we perform a depth-first search (DFS) and track the connected groupId sizes. The number of stones that can be removed is the sum of connected components' sizes minus 1. This is because only (size - 1) edges connect the connected components; therefore, we can remove only (size - 1) stones without breaking the connections.\n\nWe apply the DFS in every defined language and return the max_stones which is the maximum number of stones that can be removed.\n    "}
{"id": 991, "slug": "broken-calculator", "title": "Broken Calculator", "difficulty": "Medium", "content": "There is a broken calculator that has the integer `startValue` on its display initially. In one operation, you can:\n\n*   multiply the number on display by `2`, or\n*   subtract `1` from the number on display.\n\nGiven two integers `startValue` and `target`, return _the minimum number of operations needed to display_ `target` _on the calculator_.\n\n**Example 1:**\n\n**Input:** startValue = 2, target = 3\n**Output:** 2\n**Explanation:** Use double operation and then decrement operation {2 -> 4 -> 3}.\n\n**Example 2:**\n\n**Input:** startValue = 5, target = 8\n**Output:** 2\n**Explanation:** Use decrement and then double {5 -> 4 -> 8}.\n\n**Example 3:**\n\n**Input:** startValue = 3, target = 10\n**Output:** 3\n**Explanation:** Use double, decrement and double {3 -> 6 -> 5 -> 10}.\n\n**Constraints:**\n\n*   `1 <= startValue, target <= 109`", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic boolean canReorderArray(int[] arr) {\n    HashMap<Integer, Integer> count = new HashMap<>();\n    for (int n : arr) {\n        count.put(n, count.getOrDefault(n, 0) + 1);\n    }\n    Arrays.sort(arr);\n    for (int x : arr) {\n        if (count.get(x) == 0) {\n            continue;\n        }\n        if (count.getOrDefault(2 * x, 0) > 0) {\n            count.put(x, count.get(x) - 1);\n            count.put(2 * x, count.get(2 * x) - 1);\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm first counts the occurrences of each number in the input array `arr` by creating a hash map called `count`. Then sort the input array in ascending order. Then we iterate through the sorted array, checking if there's a number twice as large as the current number available in the hash map. If so, we decrement the counts for both the current number and twice the current number. If not, we return false because it's not possible to reorder the array as required. If all the numbers have been processed and the condition was satisfied for all, return true.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nbool canReorderArray(std::vector<int>& arr) {\n    std::unordered_map<int, int> count;\n    for (int n : arr) {\n        count[n]++;\n    }\n    sort(arr.begin(), arr.end());\n    for (int x : arr) {\n        if (count[x] == 0) {\n            continue;\n        }\n        if (count[2 * x] > 0) {\n            count[x]--;\n            count[2 * x]--;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm first counts the occurrences of each number in the input array `arr` by creating a hash map called `count`. Then sort the input array in ascending order. Then we iterate through the sorted array, checking if there's a number twice as large as the current number available in the hash map. If so, we decrement the counts for both the current number and twice the current number. If not, we return false because it's not possible to reorder the array as required. If all the numbers have been processed and the condition was satisfied for all, return true.\n    ", "python": "\n    ```python\ndef can_reorder_array(arr):\n    from collections import Counter\n    \n    count = Counter(arr)\n    arr = sorted(arr)\n    for x in arr:\n        if count[x] == 0:\n            continue\n        if count[2 * x] > 0:\n            count[x] -= 1\n            count[2 * x] -= 1\n        else:\n            return False\n    return True\n```\n    \n    The algorithm first counts the occurrences of each number in the input array `arr` by creating a hash map called `count`. Then sort the input array in ascending order. Then we iterate through the sorted array, checking if there's a number twice as large as the current number available in the hash map. If so, we decrement the counts for both the current number and twice the current number. If not, we return false because it's not possible to reorder the array as required. If all the numbers have been processed and the condition was satisfied for all, return true.\n    ", "javascript": "\n    ```javascript\nfunction canReorderArray(arr) {\n    const count = {};\n    for (const n of arr) {\n        count[n] = (count[n] || 0) + 1;\n    }\n    arr.sort((a, b) => a - b);\n    for (const x of arr) {\n        if (count[x] === 0) {\n            continue;\n        }\n        if (count[2 * x] > 0) {\n            count[x]--;\n            count[2 * x]--;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm first counts the occurrences of each number in the input array `arr` by creating a hash map called `count`. Then sort the input array in ascending order. Then we iterate through the sorted array, checking if there's a number twice as large as the current number available in the hash map. If so, we decrement the counts for both the current number and twice the current number. If not, we return false because it's not possible to reorder the array as required. If all the numbers have been processed and the condition was satisfied for all, return true.\n    "}
{"id": 1005, "slug": "maximize-sum-of-array-after-k-negations", "title": "Maximize Sum Of Array After K Negations", "difficulty": "Easy", "content": "Given an integer array `nums` and an integer `k`, modify the array in the following way:\n\n*   choose an index `i` and replace `nums[i]` with `-nums[i]`.\n\nYou should apply this process exactly `k` times. You may choose the same index `i` multiple times.\n\nReturn _the largest possible sum of the array after modifying it in this way_.\n\n**Example 1:**\n\n**Input:** nums = \\[4,2,3\\], k = 1\n**Output:** 5\n**Explanation:** Choose index 1 and nums becomes \\[4,-2,3\\].\n\n**Example 2:**\n\n**Input:** nums = \\[3,-1,0,2\\], k = 3\n**Output:** 6\n**Explanation:** Choose indices (1, 2, 2) and nums becomes \\[3,1,0,2\\].\n\n**Example 3:**\n\n**Input:** nums = \\[2,-3,-1,5,-4\\], k = 2\n**Output:** 13\n**Explanation:** Choose indices (1, 4) and nums becomes \\[2,3,-1,5,4\\].\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-100 <= nums[i] <= 100`\n*   `1 <= k <= 104`", "java": "\n    ```java\npublic boolean isUnivalued(TreeNode root) {\n    return isUnivalued(root, -1);\n}\n\nprivate boolean isUnivalued(TreeNode root, int val) {\n    if (root == null) return true;\n    if (val == -1) val = root.val;\n    return root.val == val && isUnivalued(root.left, val) && isUnivalued(root.right, val);\n}\n```\n    \n    The algorithm first checks if the root node is null, if it is, the function returns true as an empty tree is uni-valued. If this is the first call to the function (indicated by default value for val), it sets the val to the root node's value. For all other calls, val is already set, and it only checks if the current node's value is equal to val. If it is equal, it recursively calls for the left and right sub-trees. If all calls return true, the tree is uni-valued, otherwise it's not.\n    ", "c++": "\n    ```cpp\nbool isUnivalued(TreeNode* root, int val = -1) {\n    if (!root) return true;\n    if (val == -1) val = root->val;\n    return root->val == val && isUnivalued(root->left, val) && isUnivalued(root->right, val);\n}\n```\n    \n    The algorithm first checks if the root node is null, if it is, the function returns true as an empty tree is uni-valued. If this is the first call to the function (indicated by default value for val), it sets the val to the root node's value. For all other calls, val is already set, and it only checks if the current node's value is equal to val. If it is equal, it recursively calls for the left and right sub-trees. If all calls return true, the tree is uni-valued, otherwise it's not.\n    ", "python": "\n    ```python\ndef is_univalued(root, val=None):\n    if not root:\n        return True\n    if val is None:\n        val = root.val\n    return root.val == val and is_univalued(root.left, val) and is_univalued(root.right, val)\n```\n    \n    The algorithm first checks if the root node is null, if it is, the function returns true as an empty tree is uni-valued. If this is the first call to the function (indicated by default value for val), it sets the val to the root node's value. For all other calls, val is already set, and it only checks if the current node's value is equal to val. If it is equal, it recursively calls for the left and right sub-trees. If all calls return true, the tree is uni-valued, otherwise it's not.\n    ", "javascript": "\n    ```javascript\nfunction isUnivalued(root, val = null) {\n    if (!root) return true;\n    if (val === null) val = root.val;\n    return root.val === val && isUnivalued(root.left, val) && isUnivalued(root.right, val);\n}\n```\n    \n    The algorithm first checks if the root node is null, if it is, the function returns true as an empty tree is uni-valued. If this is the first call to the function (indicated by default value for val), it sets the val to the root node's value. For all other calls, val is already set, and it only checks if the current node's value is equal to val. If it is equal, it recursively calls for the left and right sub-trees. If all calls return true, the tree is uni-valued, otherwise it's not.\n    "}
{"id": 1007, "slug": "minimum-domino-rotations-for-equal-row", "title": "Minimum Domino Rotations For Equal Row", "difficulty": "Medium", "content": "In a row of dominoes, `tops[i]` and `bottoms[i]` represent the top and bottom halves of the `ith` domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\n\nWe may rotate the `ith` domino, so that `tops[i]` and `bottoms[i]` swap values.\n\nReturn the minimum number of rotations so that all the values in `tops` are the same, or all the values in `bottoms` are the same.\n\nIf it cannot be done, return `-1`.\n\n**Example 1:**\n\n**Input:** tops = \\[2,1,2,4,2,2\\], bottoms = \\[5,2,6,2,3,2\\]\n**Output:** 2\n**Explanation:** \nThe first figure represents the dominoes as given by tops and bottoms: before we do any rotations.\nIf we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.\n\n**Example 2:**\n\n**Input:** tops = \\[3,5,1,2,3\\], bottoms = \\[3,6,3,3,4\\]\n**Output:** -1\n**Explanation:** \nIn this case, it is not possible to rotate the dominoes to make one row of values equal.\n\n**Constraints:**\n\n*   `2 <= tops.length <= 2 * 104`\n*   `bottoms.length == tops.length`\n*   `1 <= tops[i], bottoms[i] <= 6`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> numsSameConsecDiff(int n, int k) {\n    List<Integer> result = new ArrayList<>();\n    if (n == 1) result.add(0);\n\n    void dfs(String current) {\n        if (current.length() == n) {\n            result.add(Integer.parseInt(current));\n            return;\n        }\n\n        char last_digit = current.charAt(current.length() - 1);\n        if (last_digit - k >= '0') dfs(current + (char) (last_digit - k));\n        if (k != 0 && last_digit + k <= '9') dfs(current + (char) (last_digit + k));\n    }\n\n    for (char i = '1'; i <= '9'; ++i) {\n        dfs(Character.toString(i));\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses depth-first search (DFS) to explore all possible numbers that meet the condition. \n\n1. If `n == 1`, add 0 to the result as a single-digit number is valid.\n2. Define a DFS function that takes the current number as a string.\n   - If the length of the current number equals `n`, convert it to an integer and add it to the result.\n   - For the last digit of the current number, calculate the next two possible digits: the last digit minus `k` and the last digit plus `k`.\n   - If the calculated digits are valid (not negative and not more than 9), call the DFS function recursively with the new digits.\n3. Initialize the DFS search starting from digits 1 to 9 to avoid leading zeros.\n\nThe algorithm explores all possible numbers using DFS, ensuring that the absolute difference between every two consecutive digits is `k`. Finally, it returns a list of valid numbers.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> numsSameConsecDiff(int n, int k) {\n    std::vector<int> result;\n    if (n == 1) result.push_back(0);\n\n    std::function<void(std::string)> dfs = [&](std::string current) {\n        if (current.size() == n) {\n            result.push_back(stoi(current));\n            return;\n        }\n\n        char last_digit = current.back();\n        if (last_digit - k >= '0') dfs(current + static_cast<char>(last_digit - k));\n        if (k != 0 && last_digit + k <= '9') dfs(current + static_cast<char>(last_digit + k));\n    };\n\n    for (char i = '1'; i <= '9'; ++i) {\n        dfs(std::string(1, i));\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses depth-first search (DFS) to explore all possible numbers that meet the condition. \n\n1. If `n == 1`, add 0 to the result as a single-digit number is valid.\n2. Define a DFS function that takes the current number as a string.\n   - If the length of the current number equals `n`, convert it to an integer and add it to the result.\n   - For the last digit of the current number, calculate the next two possible digits: the last digit minus `k` and the last digit plus `k`.\n   - If the calculated digits are valid (not negative and not more than 9), call the DFS function recursively with the new digits.\n3. Initialize the DFS search starting from digits 1 to 9 to avoid leading zeros.\n\nThe algorithm explores all possible numbers using DFS, ensuring that the absolute difference between every two consecutive digits is `k`. Finally, it returns a list of valid numbers.\n    ", "python": "\n    ```python\ndef numsSameConsecDiff(n, k):\n    result = []\n    if n == 1: result.append(0)\n\n    def dfs(current):\n        if len(current) == n:\n            result.append(int(current))\n            return\n\n        last_digit = current[-1]\n        if last_digit - k >= 0: dfs(current + str(last_digit - k))\n        if k != 0 and last_digit + k <= 9: dfs(current + str(last_digit + k))\n\n    for i in range(1, 10):\n        dfs(str(i))\n\n    return result\n```\n    \n    The algorithm uses depth-first search (DFS) to explore all possible numbers that meet the condition. \n\n1. If `n == 1`, add 0 to the result as a single-digit number is valid.\n2. Define a DFS function that takes the current number as a string.\n   - If the length of the current number equals `n`, convert it to an integer and add it to the result.\n   - For the last digit of the current number, calculate the next two possible digits: the last digit minus `k` and the last digit plus `k`.\n   - If the calculated digits are valid (not negative and not more than 9), call the DFS function recursively with the new digits.\n3. Initialize the DFS search starting from digits 1 to 9 to avoid leading zeros.\n\nThe algorithm explores all possible numbers using DFS, ensuring that the absolute difference between every two consecutive digits is `k`. Finally, it returns a list of valid numbers.\n    ", "javascript": "\n    ```javascript\nfunction numsSameConsecDiff(n, k) {\n    let result = [];\n    if (n === 1) result.push(0);\n\n    function dfs(current) {\n        if (current.length === n) {\n            result.push(Number(current));\n            return;\n        }\n\n        let last_digit = current[current.length - 1];\n        if (last_digit - k >= 0) dfs(current + (last_digit - k));\n        if (k !== 0 && last_digit + k <= 9) dfs(current + (last_digit + k));\n    }\n\n    for (let i = 1; i <= 9; ++i) {\n        dfs(String(i));\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses depth-first search (DFS) to explore all possible numbers that meet the condition. \n\n1. If `n == 1`, add 0 to the result as a single-digit number is valid.\n2. Define a DFS function that takes the current number as a string.\n   - If the length of the current number equals `n`, convert it to an integer and add it to the result.\n   - For the last digit of the current number, calculate the next two possible digits: the last digit minus `k` and the last digit plus `k`.\n   - If the calculated digits are valid (not negative and not more than 9), call the DFS function recursively with the new digits.\n3. Initialize the DFS search starting from digits 1 to 9 to avoid leading zeros.\n\nThe algorithm explores all possible numbers using DFS, ensuring that the absolute difference between every two consecutive digits is `k`. Finally, it returns a list of valid numbers.\n    "}
{"id": 1013, "slug": "partition-array-into-three-parts-with-equal-sum", "title": "Partition Array Into Three Parts With Equal Sum", "difficulty": "Easy", "content": "Given an array of integers `arr`, return `true` if we can partition the array into three **non-empty** parts with equal sums.\n\nFormally, we can partition the array if we can find indexes `i + 1 < j` with `(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])`\n\n**Example 1:**\n\n**Input:** arr = \\[0,2,1,-6,6,-7,9,1,2,0,1\\]\n**Output:** true\n**Explanation:** 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n\n**Example 2:**\n\n**Input:** arr = \\[0,2,1,-6,6,7,9,-1,2,0,1\\]\n**Output:** false\n\n**Example 3:**\n\n**Input:** arr = \\[3,3,6,5,-2,2,5,1,-9,4\\]\n**Output:** true\n**Explanation:** 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4\n\n**Constraints:**\n\n*   `3 <= arr.length <= 5 * 104`\n*   `-104 <= arr[i] <= 104`", "java": "\n    ```java\npublic int fib(int n) {\n    if (n <= 1)\n        return n;\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm iterates from 2 to n using a loop that calculates the current Fibonacci number by adding the two previous ones. It uses three variables a, b, and c, representing the two previous Fibonacci numbers and the current one, respectively. At each iteration, the algorithm calculates the current Fibonacci number, updates a and b, and repeats. This minimizes the extra space needed and avoids recursion, resulting in an efficient O(n) time complexity solution.\n    ", "c++": "\n    ```cpp\nint fib(int n) {\n    if (n <= 1)\n        return n;\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm iterates from 2 to n using a loop that calculates the current Fibonacci number by adding the two previous ones. It uses three variables a, b, and c, representing the two previous Fibonacci numbers and the current one, respectively. At each iteration, the algorithm calculates the current Fibonacci number, updates a and b, and repeats. This minimizes the extra space needed and avoids recursion, resulting in an efficient O(n) time complexity solution.\n    ", "python": "\n    ```python\ndef fib(n):\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n```\n    \n    The algorithm iterates from 2 to n using a loop that calculates the current Fibonacci number by adding the two previous ones. It uses three variables a, b, and c, representing the two previous Fibonacci numbers and the current one, respectively. At each iteration, the algorithm calculates the current Fibonacci number, updates a and b, and repeats. This minimizes the extra space needed and avoids recursion, resulting in an efficient O(n) time complexity solution.\n    ", "javascript": "\n    ```javascript\nfunction fib(n) {\n    if (n <= 1)\n        return n;\n    let a = 0, b = 1, c;\n    for (let i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm iterates from 2 to n using a loop that calculates the current Fibonacci number by adding the two previous ones. It uses three variables a, b, and c, representing the two previous Fibonacci numbers and the current one, respectively. At each iteration, the algorithm calculates the current Fibonacci number, updates a and b, and repeats. This minimizes the extra space needed and avoids recursion, resulting in an efficient O(n) time complexity solution.\n    "}
{"id": 1024, "slug": "video-stitching", "title": "Video Stitching", "difficulty": "Medium", "content": "You are given a series of video clips from a sporting event that lasted `time` seconds. These video clips can be overlapping with each other and have varying lengths.\n\nEach video clip is described by an array `clips` where `clips[i] = [starti, endi]` indicates that the ith clip started at `starti` and ended at `endi`.\n\nWe can cut these clips into segments freely.\n\n*   For example, a clip `[0, 7]` can be cut into segments `[0, 1] + [1, 3] + [3, 7]`.\n\nReturn _the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event_ `[0, time]`. If the task is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** clips = \\[\\[0,2\\],\\[4,6\\],\\[8,10\\],\\[1,9\\],\\[1,5\\],\\[5,9\\]\\], time = 10\n**Output:** 3\n**Explanation:** We take the clips \\[0,2\\], \\[8,10\\], \\[1,9\\]; a total of 3 clips.\nThen, we can reconstruct the sporting event as follows:\nWe cut \\[1,9\\] into segments \\[1,2\\] + \\[2,8\\] + \\[8,9\\].\nNow we have segments \\[0,2\\] + \\[2,8\\] + \\[8,10\\] which cover the sporting event \\[0, 10\\].\n\n**Example 2:**\n\n**Input:** clips = \\[\\[0,1\\],\\[1,2\\]\\], time = 5\n**Output:** -1\n**Explanation:** We cannot cover \\[0,5\\] with only \\[0,1\\] and \\[1,2\\].\n\n**Example 3:**\n\n**Input:** clips = \\[\\[0,1\\],\\[6,8\\],\\[0,2\\],\\[5,6\\],\\[0,4\\],\\[0,3\\],\\[6,7\\],\\[1,3\\],\\[4,7\\],\\[1,4\\],\\[2,5\\],\\[2,6\\],\\[3,4\\],\\[4,5\\],\\[5,7\\],\\[6,9\\]\\], time = 9\n**Output:** 3\n**Explanation:** We can take clips \\[0,4\\], \\[4,7\\], and \\[6,9\\].\n\n**Constraints:**\n\n*   `1 <= clips.length <= 100`\n*   `0 <= starti <= endi <= 100`\n*   `1 <= time <= 100`\n\n0 <= i < j < k < nums.length, and nums\\[i\\] & nums\\[j\\] & nums\\[k\\] != 0. (\\`&\\` represents the bitwise AND operation.)", "java": "\n    ```java\nint countAndTriples(int[] nums) {\n    int count = 0;\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            for (int k = j + 1; k < nums.length; k++) {\n                if ((nums[i] & nums[j] & nums[k]) != 0)\n                    count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm simply uses three nested loops to iterate over each possible combination of three integers, (i, j, k) in the input array 'nums'. If the bitwise AND operation of the three integers at the indices (i, j, k) is non-zero, the count is increased by 1. Finally, the algorithm returns the count which is the number of AND triples in the input array.\n    ", "c++": "\n    ```cpp\nint countAndTriples(vector<int>& nums) {\n    int count = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        for (int j = i + 1; j < nums.size(); ++j) {\n            for (int k = j + 1; k < nums.size(); ++k) {\n                if (nums[i] & nums[j] & nums[k])\n                    ++count;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm simply uses three nested loops to iterate over each possible combination of three integers, (i, j, k) in the input array 'nums'. If the bitwise AND operation of the three integers at the indices (i, j, k) is non-zero, the count is increased by 1. Finally, the algorithm returns the count which is the number of AND triples in the input array.\n    ", "python": "\n    ```python\ndef count_and_triples(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] & nums[j] & nums[k] != 0:\n                    count += 1\n    return count\n```\n    \n    The algorithm simply uses three nested loops to iterate over each possible combination of three integers, (i, j, k) in the input array 'nums'. If the bitwise AND operation of the three integers at the indices (i, j, k) is non-zero, the count is increased by 1. Finally, the algorithm returns the count which is the number of AND triples in the input array.\n    ", "javascript": "\n    ```javascript\nfunction countAndTriples(nums) {\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            for (let k = j + 1; k < nums.length; k++) {\n                if (nums[i] & nums[j] & nums[k] !== 0)\n                    count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm simply uses three nested loops to iterate over each possible combination of three integers, (i, j, k) in the input array 'nums'. If the bitwise AND operation of the three integers at the indices (i, j, k) is non-zero, the count is increased by 1. Finally, the algorithm returns the count which is the number of AND triples in the input array.\n    "}
{"id": 1029, "slug": "two-city-scheduling", "title": "Two City Scheduling", "difficulty": "Medium", "content": "A company is planning to interview `2n` people. Given the array `costs` where `costs[i] = [aCosti, bCosti]`, the cost of flying the `ith` person to city `a` is `aCosti`, and the cost of flying the `ith` person to city `b` is `bCosti`.\n\nReturn _the minimum cost to fly every person to a city_ such that exactly `n` people arrive in each city.\n\n**Example 1:**\n\n**Input:** costs = \\[\\[10,20\\],\\[30,200\\],\\[400,50\\],\\[30,20\\]\\]\n**Output:** 110\n**Explanation:** \nThe first person goes to city A for a cost of 10.\nThe second person goes to city A for a cost of 30.\nThe third person goes to city B for a cost of 50.\nThe fourth person goes to city B for a cost of 20.\n\nThe total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.\n\n**Example 2:**\n\n**Input:** costs = \\[\\[259,770\\],\\[448,54\\],\\[926,667\\],\\[184,139\\],\\[840,118\\],\\[577,469\\]\\]\n**Output:** 1859\n\n**Example 3:**\n\n**Input:** costs = \\[\\[515,563\\],\\[451,713\\],\\[537,709\\],\\[343,819\\],\\[855,779\\],\\[457,60\\],\\[650,359\\],\\[631,42\\]\\]\n**Output:** 3086\n\n**Constraints:**\n\n*   `2 * n == costs.length`\n*   `2 <= costs.length <= 100`\n*   `costs.length` is even.\n*   `1 <= aCosti, bCosti <= 1000`", "java": "\n    ```java\nimport java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic List<List<Integer>> verticalTraversal(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n    \n    Map<Integer, TreeMap<Integer, PriorityQueue<Integer>>> columns = new TreeMap<>();\n    Queue<TreeNode> nodeQueue = new LinkedList<>();\n    Queue<int[]> posQueue = new LinkedList<>();\n\n    nodeQueue.offer(root);\n    posQueue.offer(new int[]{0, 0});\n\n    while (!nodeQueue.isEmpty()) {\n        TreeNode node = nodeQueue.poll();\n        int[] pos = posQueue.poll();\n        int row = pos[0], col = pos[1];\n\n        columns.putIfAbsent(col, new TreeMap<>());\n        columns.get(col).putIfAbsent(row, new PriorityQueue<>());\n        columns.get(col).get(row).offer(node.val);\n\n        if (node.left != null) {\n            nodeQueue.offer(node.left);\n            posQueue.offer(new int[]{row + 1, col - 1});\n        }\n\n        if (node.right != null) {\n            nodeQueue.offer(node.right);\n            posQueue.offer(new int[]{row + 1, col + 1});\n        }\n    }\n\n    for (TreeMap<Integer, PriorityQueue<Integer>> columnData : columns.values()) {\n        List<Integer> column = new ArrayList<>();\n        for (PriorityQueue<Integer> nodes : columnData.values()) {\n            while (!nodes.isEmpty()) {\n                column.add(nodes.poll());\n            }\n        }\n        result.add(column);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm starts by initializing a map called `columns`, which will store the nodes by their column and row indexes. We also create a queue `q` to store the nodes with their row and column positions. The root is initially added to the queue with a position of `(0, 0)`.\n\nWe then loop through the nodes in the queue. For each node, we create a nested map in `columns` that maps column indexes to row indexes, and row indexes to a list (or multiset, or priority queue, depending on the language) of node values. We insert the current node's value into the list of its corresponding row and column indexes. If the current node has left or right children, we add them to the queue with their respective positions.\n\nFinally, we build the vertical order traversal by iterating through the column index map `columns`. For each column, we create a new list and append the node values from each row in the column, in row order. This vertical list is then added to the final result.\n\nThe verticalTraversal function returns the result, which is a list of top-to-bottom orderings for each column index in the binary tree.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <map>\n#include <queue>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nstd::vector<std::vector<int>> verticalTraversal(TreeNode* root) {\n    std::vector<std::vector<int>> result;\n    if (!root) return result;\n    \n    std::map<int, std::map<int, std::multiset<int>>> columns;\n    std::queue<std::tuple<TreeNode*, int, int>> q;\n    q.push({root, 0, 0});\n    \n    while (!q.empty()) {\n        auto [node, row, col] = q.front();\n        q.pop();\n        columns[col][row].insert(node->val);\n        \n        if (node->left) q.push({node->left, row + 1, col - 1});\n        if (node->right) q.push({node->right, row + 1, col + 1});\n    }\n    \n    for (auto &[_, columnData] : columns) {\n        result.emplace_back();\n        for (auto &[_, nodes] : columnData) {\n            result.back().insert(result.back().end(), nodes.begin(), nodes.end());\n        }\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm starts by initializing a map called `columns`, which will store the nodes by their column and row indexes. We also create a queue `q` to store the nodes with their row and column positions. The root is initially added to the queue with a position of `(0, 0)`.\n\nWe then loop through the nodes in the queue. For each node, we create a nested map in `columns` that maps column indexes to row indexes, and row indexes to a list (or multiset, or priority queue, depending on the language) of node values. We insert the current node's value into the list of its corresponding row and column indexes. If the current node has left or right children, we add them to the queue with their respective positions.\n\nFinally, we build the vertical order traversal by iterating through the column index map `columns`. For each column, we create a new list and append the node values from each row in the column, in row order. This vertical list is then added to the final result.\n\nThe verticalTraversal function returns the result, which is a list of top-to-bottom orderings for each column index in the binary tree.\n    ", "python": "\n    ```python\nfrom collections import defaultdict, deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef verticalTraversal(root):\n    if not root:\n        return []\n\n    columns = defaultdict(lambda: defaultdict(list))\n    q = deque([(root, 0, 0)])\n\n    while q:\n        node, row, col = q.popleft()\n        columns[col][row].append(node.val)\n        columns[col][row].sort()\n\n        if node.left:\n            q.append((node.left, row + 1, col - 1))\n        if node.right:\n            q.append((node.right, row + 1, col + 1))\n\n    return [[val for row in column_data.values() for val in row] for column_data in sorted(columns.values())]\n```\n    \n    The algorithm starts by initializing a map called `columns`, which will store the nodes by their column and row indexes. We also create a queue `q` to store the nodes with their row and column positions. The root is initially added to the queue with a position of `(0, 0)`.\n\nWe then loop through the nodes in the queue. For each node, we create a nested map in `columns` that maps column indexes to row indexes, and row indexes to a list (or multiset, or priority queue, depending on the language) of node values. We insert the current node's value into the list of its corresponding row and column indexes. If the current node has left or right children, we add them to the queue with their respective positions.\n\nFinally, we build the vertical order traversal by iterating through the column index map `columns`. For each column, we create a new list and append the node values from each row in the column, in row order. This vertical list is then added to the final result.\n\nThe verticalTraversal function returns the result, which is a list of top-to-bottom orderings for each column index in the binary tree.\n    ", "javascript": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction verticalTraversal(root) {\n    if (!root) return [];\n    \n    const columns = new Map();\n    \n    const q = [[root, 0, 0]];\n    \n    while (q.length) {\n        const [node, row, col] = q.shift();\n        \n        if (!columns.has(col)) columns.set(col, new Map());\n        if (!columns.get(col).has(row)) columns.get(col).set(row, []);\n        columns.get(col).get(row).push(node.val);\n        columns.get(col).get(row).sort((a, b) => a - b);\n\n        if (node.left) q.push([node.left, row + 1, col - 1]);\n        if (node.right) q.push([node.right, row + 1, col + 1]);\n    }\n    \n    const result = [];\n\n    for (const columnData of [...columns.entries()].sort((a, b) => a[0] - b[0])) {\n        const column = [];\n        for (const nodes of columnData[1].values()) {\n            column.push(...nodes);\n        }\n        result.push(column);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm starts by initializing a map called `columns`, which will store the nodes by their column and row indexes. We also create a queue `q` to store the nodes with their row and column positions. The root is initially added to the queue with a position of `(0, 0)`.\n\nWe then loop through the nodes in the queue. For each node, we create a nested map in `columns` that maps column indexes to row indexes, and row indexes to a list (or multiset, or priority queue, depending on the language) of node values. We insert the current node's value into the list of its corresponding row and column indexes. If the current node has left or right children, we add them to the queue with their respective positions.\n\nFinally, we build the vertical order traversal by iterating through the column index map `columns`. For each column, we create a new list and append the node values from each row in the column, in row order. This vertical list is then added to the final result.\n\nThe verticalTraversal function returns the result, which is a list of top-to-bottom orderings for each column index in the binary tree.\n    "}
{"id": 1053, "slug": "previous-permutation-with-one-swap", "title": "Previous Permutation With One Swap", "difficulty": "Medium", "content": "Given an array of positive integers `arr` (not necessarily distinct), return _the_ _lexicographically_ _largest permutation that is smaller than_ `arr`, that can be **made with exactly one swap**. If it cannot be done, then return the same array.\n\n**Note** that a _swap_ exchanges the positions of two numbers `arr[i]` and `arr[j]`\n\n**Example 1:**\n\n**Input:** arr = \\[3,2,1\\]\n**Output:** \\[3,1,2\\]\n**Explanation:** Swapping 2 and 1.\n\n**Example 2:**\n\n**Input:** arr = \\[1,1,5\\]\n**Output:** \\[1,1,5\\]\n**Explanation:** This is already the smallest permutation.\n\n**Example 3:**\n\n**Input:** arr = \\[1,9,4,6,7\\]\n**Output:** \\[1,7,4,6,9\\]\n**Explanation:** Swapping 9 and 7.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `1 <= arr[i] <= 104`", "java": "\n    ```java\npublic int[] prevPermOpt1(int[] arr) {\n    int n = arr.length;\n    for (int i = n - 2; i >= 0; i--) {\n        if (arr[i] > arr[i + 1]) {\n            int j = i + 1;\n            while (j < n && arr[j] < arr[i]) j++;\n            int temp = arr[i];\n            arr[i] = arr[j - 1];\n            arr[j - 1] = temp;\n            break;\n        }\n    }\n    return arr;\n}\n```\n\n    \n    The algorithm consists of iterating through the array from right to left to find the first number `arr[i]` that's greater than its immediate right adjacent number, `arr[i + 1]`. Then, it iterates rightwards starting from the `arr[i]` until it finds the number just smaller than `arr[i]`, and it swaps them. This gives the lexicographically largest permutation smaller than `arr` in exactly one swap. If no such number `arr[i]` is found, it means the given array `arr` is already the smallest permutation possible, and the same array is returned.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> prevPermOpt1(vector<int>& arr) {\n    int n = arr.size();\n    for (int i = n - 2; i >= 0; i--) {\n        if (arr[i] > arr[i + 1]) {\n            int j = i + 1;\n            while (j < n && arr[j] < arr[i]) j++;\n            swap(arr[i], arr[j - 1]);\n            break;\n        }\n    }\n    return arr;\n}\n```\n\n    \n    The algorithm consists of iterating through the array from right to left to find the first number `arr[i]` that's greater than its immediate right adjacent number, `arr[i + 1]`. Then, it iterates rightwards starting from the `arr[i]` until it finds the number just smaller than `arr[i]`, and it swaps them. This gives the lexicographically largest permutation smaller than `arr` in exactly one swap. If no such number `arr[i]` is found, it means the given array `arr` is already the smallest permutation possible, and the same array is returned.\n    ", "python": "\n    ```python\ndef prevPermOpt1(arr):\n    n = len(arr)\n    for i in range(n - 2, -1, -1):\n        if arr[i] > arr[i + 1]:\n            j = i + 1\n            while j < n and arr[j] < arr[i]:\n                j += 1\n            arr[i], arr[j - 1] = arr[j - 1], arr[i]\n            break\n    return arr\n```\n\n    \n    The algorithm consists of iterating through the array from right to left to find the first number `arr[i]` that's greater than its immediate right adjacent number, `arr[i + 1]`. Then, it iterates rightwards starting from the `arr[i]` until it finds the number just smaller than `arr[i]`, and it swaps them. This gives the lexicographically largest permutation smaller than `arr` in exactly one swap. If no such number `arr[i]` is found, it means the given array `arr` is already the smallest permutation possible, and the same array is returned.\n    ", "javascript": "\n    ```javascript\nfunction prevPermOpt1(arr) {\n    const n = arr.length;\n    for (let i = n - 2; i >= 0; i--) {\n        if (arr[i] > arr[i + 1]) {\n            let j = i + 1;\n            while (j < n && arr[j] < arr[i]) j++;\n            [arr[i], arr[j - 1]] = [arr[j - 1], arr[i]];\n            break;\n        }\n    }\n    return arr;\n}\n```\n\n    \n    The algorithm consists of iterating through the array from right to left to find the first number `arr[i]` that's greater than its immediate right adjacent number, `arr[i + 1]`. Then, it iterates rightwards starting from the `arr[i]` until it finds the number just smaller than `arr[i]`, and it swaps them. This gives the lexicographically largest permutation smaller than `arr` in exactly one swap. If no such number `arr[i]` is found, it means the given array `arr` is already the smallest permutation possible, and the same array is returned.\n    "}
{"id": 1054, "slug": "distant-barcodes", "title": "Distant Barcodes", "difficulty": "Medium", "content": "In a warehouse, there is a row of barcodes, where the `ith` barcode is `barcodes[i]`.\n\nRearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.\n\n**Example 1:**\n\n**Input:** barcodes = \\[1,1,1,2,2,2\\]\n**Output:** \\[2,1,2,1,2,1\\]\n\n**Example 2:**\n\n**Input:** barcodes = \\[1,1,1,1,2,2,3,3\\]\n**Output:** \\[1,3,1,3,1,2,1,2\\]\n\n**Constraints:**\n\n*   `1 <= barcodes.length <= 10000`\n*   `1 <= barcodes[i] <= 10000`", "java": "\n    ```java\npublic int bitwiseComplement(int n) {\n    int x = 1;\n    while (n > x) {\n        x = x * 2 + 1;\n    }\n    return x - n;\n}\n```\n    \n    The algorithm starts by setting an integer `x` to 1. Then, we use a while loop to keep multiplying `x` by 2 and adding 1 until it becomes greater than the given number `n`. This results in a number `x` which has all 1s in its binary representation and has the same number of binary digits (or greater) as the given number `n`. Finally, we return the difference between `x` and `n`, which flip-flops 0s and 1s and gives the complement of `n`.\n    ", "c++": "\n    ```cpp\nint bitwiseComplement(int n) {\n    int x = 1;\n    while (n > x) {\n        x = x * 2 + 1;\n    }\n    return x - n;\n}\n```\n    \n    The algorithm starts by setting an integer `x` to 1. Then, we use a while loop to keep multiplying `x` by 2 and adding 1 until it becomes greater than the given number `n`. This results in a number `x` which has all 1s in its binary representation and has the same number of binary digits (or greater) as the given number `n`. Finally, we return the difference between `x` and `n`, which flip-flops 0s and 1s and gives the complement of `n`.\n    ", "python": "\n    ```python\ndef bitwise_complement(n):\n    x = 1\n    while n > x:\n        x = x * 2 + 1\n    return x - n\n```\n    \n    The algorithm starts by setting an integer `x` to 1. Then, we use a while loop to keep multiplying `x` by 2 and adding 1 until it becomes greater than the given number `n`. This results in a number `x` which has all 1s in its binary representation and has the same number of binary digits (or greater) as the given number `n`. Finally, we return the difference between `x` and `n`, which flip-flops 0s and 1s and gives the complement of `n`.\n    ", "javascript": "\n    ```javascript\nfunction bitwiseComplement(n) {\n    let x = 1;\n    while (n > x) {\n        x = x * 2 + 1;\n    }\n    return x - n;\n}\n```\n    \n    The algorithm starts by setting an integer `x` to 1. Then, we use a while loop to keep multiplying `x` by 2 and adding 1 until it becomes greater than the given number `n`. This results in a number `x` which has all 1s in its binary representation and has the same number of binary digits (or greater) as the given number `n`. Finally, we return the difference between `x` and `n`, which flip-flops 0s and 1s and gives the complement of `n`.\n    "}
{"id": 1055, "slug": "shortest-way-to-form-string", "title": "Shortest Way to Form String", "difficulty": "Medium", "content": "A **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not).\n\nGiven two strings `source` and `target`, return _the minimum number of **subsequences** of_ `source` _such that their concatenation equals_ `target`. If the task is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** source =  \"abc \", target =  \"abcbc \"\n**Output:** 2\n**Explanation:** The target  \"abcbc \" can be formed by  \"abc \" and  \"bc \", which are subsequences of source  \"abc \".\n\n**Example 2:**\n\n**Input:** source =  \"abc \", target =  \"acdbc \"\n**Output:** -1\n**Explanation:** The target string cannot be constructed from the subsequences of source string due to the character  \"d \" in target string.\n\n**Example 3:**\n\n**Input:** source =  \"xyz \", target =  \"xzyxz \"\n**Output:** 3\n**Explanation:** The target string can be constructed as follows  \"xz \" +  \"y \" +  \"xz \".\n\n**Constraints:**\n\n*   `1 <= source.length, target.length <= 1000`\n*   `source` and `target` consist of lowercase English letters.", "java": "\n    ```java\npublic int numPairsDivisibleBy60(int[] time) {\n    int[] count = new int[60];\n    int pairs = 0;\n\n    for (int t : time) {\n        int mod = t % 60;\n        pairs += count[(60 - mod) % 60];\n        count[mod]++;\n    }\n\n    return pairs;\n}\n```\n    \n    The algorithm calculates the modulus (`t % 60`) for each song duration and stores the frequency in the `count` array. When iterating through the song durations, if the durations have moduluses that sum to 60, they meet the pair condition. Therefore, for each song duration, it adds the frequency of the required modulus (`(60 - mod) % 60`) to the count of pairs. This way, the algorithm counts all valid pairs for each song duration.\n\nThe algorithm only requires one pass through the input list; thus, its time complexity is O(n), where n is the number of songs in the input list. The extra space needed is the `count` array, which has a constant size of 60; hence, the space complexity is O(1).\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint numPairsDivisibleBy60(vector<int>& time) {\n    int count[60] = {0};\n    int pairs = 0;\n\n    for (int t : time) {\n        int mod = t % 60;\n        pairs += count[(60 - mod) % 60];\n        count[mod]++;\n    }\n\n    return pairs;\n}\n```\n    \n    The algorithm calculates the modulus (`t % 60`) for each song duration and stores the frequency in the `count` array. When iterating through the song durations, if the durations have moduluses that sum to 60, they meet the pair condition. Therefore, for each song duration, it adds the frequency of the required modulus (`(60 - mod) % 60`) to the count of pairs. This way, the algorithm counts all valid pairs for each song duration.\n\nThe algorithm only requires one pass through the input list; thus, its time complexity is O(n), where n is the number of songs in the input list. The extra space needed is the `count` array, which has a constant size of 60; hence, the space complexity is O(1).\n    ", "python": "\n    ```python\ndef num_pairs_divisible_by60(time):\n    count = [0] * 60\n    pairs = 0\n\n    for t in time:\n        mod = t % 60\n        pairs += count[(60 - mod) % 60]\n        count[mod] += 1\n\n    return pairs\n```\n    \n    The algorithm calculates the modulus (`t % 60`) for each song duration and stores the frequency in the `count` array. When iterating through the song durations, if the durations have moduluses that sum to 60, they meet the pair condition. Therefore, for each song duration, it adds the frequency of the required modulus (`(60 - mod) % 60`) to the count of pairs. This way, the algorithm counts all valid pairs for each song duration.\n\nThe algorithm only requires one pass through the input list; thus, its time complexity is O(n), where n is the number of songs in the input list. The extra space needed is the `count` array, which has a constant size of 60; hence, the space complexity is O(1).\n    ", "javascript": "\n    ```javascript\nfunction numPairsDivisibleBy60(time) {\n    let count = new Array(60).fill(0);\n    let pairs = 0;\n\n    for (let t of time) {\n        let mod = t % 60;\n        pairs += count[(60 - mod) % 60];\n        count[mod]++;\n    }\n\n    return pairs;\n}\n```\n    \n    The algorithm calculates the modulus (`t % 60`) for each song duration and stores the frequency in the `count` array. When iterating through the song durations, if the durations have moduluses that sum to 60, they meet the pair condition. Therefore, for each song duration, it adds the frequency of the required modulus (`(60 - mod) % 60`) to the count of pairs. This way, the algorithm counts all valid pairs for each song duration.\n\nThe algorithm only requires one pass through the input list; thus, its time complexity is O(n), where n is the number of songs in the input list. The extra space needed is the `count` array, which has a constant size of 60; hence, the space complexity is O(1).\n    "}
{"id": 1057, "slug": "campus-bikes", "title": "Campus Bikes", "difficulty": "Medium", "content": "On a campus represented on the X-Y plane, there are `n` workers and `m` bikes, with `n <= m`.\n\nYou are given an array `workers` of length `n` where `workers[i] = [xi, yi]` is the position of the `ith` worker. You are also given an array `bikes` of length `m` where `bikes[j] = [xj, yj]` is the position of the `jth` bike. All the given positions are **unique**.\n\nAssign a bike to each worker. Among the available bikes and workers, we choose the `(workeri, bikej)` pair with the shortest **Manhattan distance** between each other and assign the bike to that worker.\n\nIf there are multiple `(workeri, bikej)` pairs with the same shortest **Manhattan distance**, we choose the pair with **the smallest worker index**. If there are multiple ways to do that, we choose the pair with **the smallest bike index**. Repeat this process until there are no available workers.\n\nReturn _an array_ `answer` _of length_ `n`_, where_ `answer[i]` _is the index (**0-indexed**) of the bike that the_ `ith` _worker is assigned to_.\n\nThe **Manhattan distance** between two points `p1` and `p2` is `Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|`.\n\n**Example 1:**\n\n**Input:** workers = \\[\\[0,0\\],\\[2,1\\]\\], bikes = \\[\\[1,2\\],\\[3,3\\]\\]\n**Output:** \\[1,0\\]\n**Explanation:** Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is \\[1, 0\\].\n\n**Example 2:**\n\n**Input:** workers = \\[\\[0,0\\],\\[1,1\\],\\[2,0\\]\\], bikes = \\[\\[1,0\\],\\[2,2\\],\\[2,1\\]\\]\n**Output:** \\[0,2,1\\]\n**Explanation:** Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is \\[0,2,1\\].\n\n**Constraints:**\n\n*   `n == workers.length`\n*   `m == bikes.length`\n*   `1 <= n <= m <= 1000`\n*   `workers[i].length == bikes[j].length == 2`\n*   `0 <= xi, yi < 1000`\n*   `0 <= xj, yj < 1000`\n*   All worker and bike locations are **unique**.", "java": "\n    ```java\nimport java.util.HashSet;\n\npublic int numDupDigitsAtMostN(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        HashSet<Integer> digits = new HashSet<>();\n        int num = i;\n        while (num != 0) {\n            int digit = num % 10;\n            if (digits.contains(digit)) {\n                count++;\n                break;\n            } else {\n                digits.add(digit);\n            }\n            num /= 10;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over the range of numbers from 1 to n inclusive. For each number, it extracts the digits by taking the remainder when dividing by 10 (`num % 10`) and adds it to a set (or hash set in Java) of digits. If a digit is already present in the set, it means that the digit is repeated, so we increment the count and break this iteration. At the end, we return the count of numbers with at least one repeated digit.\n    ", "c++": "\n    ```cpp\n#include <set>\nusing namespace std;\n\nint numDupDigitsAtMostN(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        set<int> digits;\n        int num = i;\n        while (num != 0) {\n            int digit = num % 10;\n            if (digits.count(digit)) {\n                count++;\n                break;\n            } else {\n                digits.insert(digit);\n            }\n            num /= 10;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over the range of numbers from 1 to n inclusive. For each number, it extracts the digits by taking the remainder when dividing by 10 (`num % 10`) and adds it to a set (or hash set in Java) of digits. If a digit is already present in the set, it means that the digit is repeated, so we increment the count and break this iteration. At the end, we return the count of numbers with at least one repeated digit.\n    ", "python": "\n    ```python\ndef num_dup_digits_at_most_n(n):\n    count = 0\n    for i in range(1, n + 1):\n        digits = set()\n        num = i\n        while num != 0:\n            digit = num % 10\n            if digit in digits:\n                count += 1\n                break\n            else:\n                digits.add(digit)\n            num //= 10\n    return count\n```\n    \n    The algorithm iterates over the range of numbers from 1 to n inclusive. For each number, it extracts the digits by taking the remainder when dividing by 10 (`num % 10`) and adds it to a set (or hash set in Java) of digits. If a digit is already present in the set, it means that the digit is repeated, so we increment the count and break this iteration. At the end, we return the count of numbers with at least one repeated digit.\n    ", "javascript": "\n    ```javascript\nfunction numDupDigitsAtMostN(n) {\n    let count = 0;\n    for (let i = 1; i <= n; i++) {\n        let digits = new Set();\n        let num = i;\n        while (num !== 0) {\n            let digit = num % 10;\n            if (digits.has(digit)) {\n                count++;\n                break;\n            } else {\n                digits.add(digit);\n            }\n            num = Math.floor(num / 10);\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over the range of numbers from 1 to n inclusive. For each number, it extracts the digits by taking the remainder when dividing by 10 (`num % 10`) and adds it to a set (or hash set in Java) of digits. If a digit is already present in the set, it means that the digit is repeated, so we increment the count and break this iteration. At the end, we return the count of numbers with at least one repeated digit.\n    "}
{"id": 1058, "slug": "minimize-rounding-error-to-meet-target", "title": "Minimize Rounding Error to Meet Target", "difficulty": "Medium", "content": "Given an array of `prices` `[p1,p2...,pn]` and a `target`, round each price `pi` to `Roundi(pi)` so that the rounded array `[Round1(p1),Round2(p2)...,Roundn(pn)]` sums to the given `target`. Each operation `Roundi(pi)` could be either `Floor(pi)` or `Ceil(pi)`.\n\nReturn the string `\"-1 \"` if the rounded array is impossible to sum to `target`. Otherwise, return the smallest rounding error, which is defined as `\u03a3 |Roundi(pi) - (pi)|` for `i` from `1` to `n`, as a string with three places after the decimal.\n\n**Example 1:**\n\n**Input:** prices = \\[ \"0.700 \", \"2.800 \", \"4.900 \"\\], target = 8\n**Output:**  \"1.000 \"\n**Explanation:**\nUse Floor, Ceil and Ceil operations to get (0.7 - 0) + (3 - 2.8) + (5 - 4.9) = 0.7 + 0.2 + 0.1 = 1.0 .\n\n**Example 2:**\n\n**Input:** prices = \\[ \"1.500 \", \"2.500 \", \"3.500 \"\\], target = 10\n**Output:**  \"-1 \"\n**Explanation:** It is impossible to meet the target.\n\n**Example 3:**\n\n**Input:** prices = \\[ \"1.500 \", \"2.500 \", \"3.500 \"\\], target = 9\n**Output:**  \"1.500 \"\n\n**Constraints:**\n\n*   `1 <= prices.length <= 500`\n*   Each string `prices[i]` represents a real number in the range `[0.0, 1000.0]` and has exactly 3 decimal places.\n*   `0 <= target <= 106`", "java": "\n    ```java\nimport java.text.DecimalFormat;\nimport java.math.BigDecimal;\n\npublic String findRoundingError(String[] prices, int target) {\n    int n = prices.length;\n    BigDecimal[] decimals = new BigDecimal[n];\n    int roundedSum = 0;\n    BigDecimal errorSum = BigDecimal.ZERO;\n\n    for (int i = 0; i < n; i++) {\n        BigDecimal price = new BigDecimal(prices[i]);\n        decimals[i] = price.subtract(price.setScale(0, BigDecimal.ROUND_DOWN));\n        roundedSum += price.setScale(0, BigDecimal.ROUND_DOWN).intValue();\n        errorSum = errorSum.add(decimals[i]);\n    }\n\n    if (target < roundedSum || target > roundedSum + n) {\n        return \"-1 \";\n    }\n\n    int ceilCount = target - roundedSum;\n    BigDecimal roundingError = BigDecimal.ZERO;\n\n    for (int i = 0; i < n; i++) {\n        if (ceilCount > 0) {\n            roundingError = roundingError.add(BigDecimal.ONE.subtract(decimals[i]));\n            ceilCount--;\n        } else {\n            roundingError = roundingError.add(decimals[i]);\n        }\n    }\n\n    DecimalFormat df = new DecimalFormat(\"#.000\");\n    return df.format(roundingError) + \" \";\n}\n```\n\n    \n    1. Convert the input `prices` to decimal numbers, and calculate the decimal parts (decimal array) using flooring or subtraction from the integer value.\n2. Compute the sum of the floors (rounded sum) of the `prices`.\n3. Check if the target is reachable (i.e., in the range of the rounded sum and the rounded sum + number of prices). If not, return \"-1 \".\n4. Calculate the number of ceiling operations needed (ceil_count).\n5. Compute the smallest rounding error by iterating over the decimal array, subtracting the decimal value (using ceil operation) or adding it to the rounding error. The condition should depend on whether ceil_count is positive or not.\n6. Return the result as a string with three decimal places.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nstring findRoundingError(vector<string>& prices, int target) {\n    int n = prices.size();\n    vector<double> decimals(n);\n    int rounded_sum = 0;\n    double error_sum = 0.0;\n\n    for (int i = 0; i < n; ++i) {\n        double price = stod(prices[i]);\n        decimals[i] = price - floor(price);\n        rounded_sum += floor(price);\n        error_sum += decimals[i];\n    }\n\n    if (target < rounded_sum || target > rounded_sum + n) {\n        return \"-1 \";\n    }\n\n    int ceil_count = target - rounded_sum;\n    double rounding_error = 0.0;\n\n    for (int i = 0; i < n; ++i) {\n        if (ceil_count > 0) {\n            rounding_error += 1 - decimals[i];\n            --ceil_count;\n        } else {\n            rounding_error += decimals[i];\n        }\n    }\n\n    return to_string(rounding_error).substr(0, 5) + \" \";\n}\n```\n\n    \n    1. Convert the input `prices` to decimal numbers, and calculate the decimal parts (decimal array) using flooring or subtraction from the integer value.\n2. Compute the sum of the floors (rounded sum) of the `prices`.\n3. Check if the target is reachable (i.e., in the range of the rounded sum and the rounded sum + number of prices). If not, return \"-1 \".\n4. Calculate the number of ceiling operations needed (ceil_count).\n5. Compute the smallest rounding error by iterating over the decimal array, subtracting the decimal value (using ceil operation) or adding it to the rounding error. The condition should depend on whether ceil_count is positive or not.\n6. Return the result as a string with three decimal places.\n    ", "python": "\n    ```python\nfrom math import floor, ceil\n\ndef find_rounding_error(prices, target):\n    n = len(prices)\n    decimals = [float(price) - floor(float(price)) for price in prices]\n    rounded_sum = sum(floor(float(price)) for price in prices)\n\n    if target < rounded_sum or target > rounded_sum + n:\n        return \"-1 \"\n\n    ceil_count = target - rounded_sum\n    rounding_error = 0.0\n\n    for d in decimals:\n        if ceil_count > 0:\n            rounding_error += 1 - d\n            ceil_count -= 1\n        else:\n            rounding_error += d\n\n    return f\"{rounding_error:.3f} \"\n```\n\n    \n    1. Convert the input `prices` to decimal numbers, and calculate the decimal parts (decimal array) using flooring or subtraction from the integer value.\n2. Compute the sum of the floors (rounded sum) of the `prices`.\n3. Check if the target is reachable (i.e., in the range of the rounded sum and the rounded sum + number of prices). If not, return \"-1 \".\n4. Calculate the number of ceiling operations needed (ceil_count).\n5. Compute the smallest rounding error by iterating over the decimal array, subtracting the decimal value (using ceil operation) or adding it to the rounding error. The condition should depend on whether ceil_count is positive or not.\n6. Return the result as a string with three decimal places.\n    ", "javascript": "\n    ```javascript\nfunction findRoundingError(prices, target) {\n    const n = prices.length;\n    const decimals = prices.map(price => {\n        let num = parseFloat(price);\n        return num - Math.floor(num);\n    });\n\n    const roundedSum = prices.reduce((sum, price) => {\n        return sum + Math.floor(parseFloat(price));\n    }, 0);\n\n    if (target < roundedSum || target > roundedSum + n) {\n        return '-1 ';\n    }\n\n    let ceilCount = target - roundedSum;\n    let roundingError = 0;\n\n    for (let d of decimals) {\n        if (ceilCount > 0) {\n            roundingError += 1 - d;\n            ceilCount--;\n        } else {\n            roundingError += d;\n        }\n    }\n    roundingError = roundingError.toFixed(3);\n    return roundingError.toString() + \" \";\n}\n```\n\n    \n    1. Convert the input `prices` to decimal numbers, and calculate the decimal parts (decimal array) using flooring or subtraction from the integer value.\n2. Compute the sum of the floors (rounded sum) of the `prices`.\n3. Check if the target is reachable (i.e., in the range of the rounded sum and the rounded sum + number of prices). If not, return \"-1 \".\n4. Calculate the number of ceiling operations needed (ceil_count).\n5. Compute the smallest rounding error by iterating over the decimal array, subtracting the decimal value (using ceil operation) or adding it to the rounding error. The condition should depend on whether ceil_count is positive or not.\n6. Return the result as a string with three decimal places.\n    "}
{"id": 1081, "slug": "smallest-subsequence-of-distinct-characters", "title": "Smallest Subsequence of Distinct Characters", "difficulty": "Medium", "content": "Given a string `s`, return _the_ _lexicographically smallest_ _subsequence_ _of_ `s` _that contains all the distinct characters of_ `s` _exactly once_.\n\n**Example 1:**\n\n**Input:** s =  \"bcabc \"\n**Output:**  \"abc \"\n\n**Example 2:**\n\n**Input:** s =  \"cbacdcbc \"\n**Output:**  \"acdb \"\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of lowercase English letters.\n\n**Note:** This question is the same as 316: [https://leetcode.com/problems/remove-duplicate-letters/](https://leetcode.com/problems/remove-duplicate-letters/)", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int videoStitching(int[][] clips, int time) {\n    int[] dp = new int[time + 1];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    dp[0] = 0;\n    for (int i = 1; i <= time; ++i) {\n        for (int[] clip : clips) {\n            if (clip[0] < i && i <= clip[1]) {\n                dp[i] = Math.min(dp[i], dp[clip[0]] + 1);\n            }\n        }\n    }\n    return dp[time] == Integer.MAX_VALUE ? -1 : dp[time];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create an array `dp` of length `time + 1` and initialize it with infinity, except for `dp[0]`, which we set to 0. To find the minimum number of clips needed to cover the entire sporting event, we iterate through the range from 1 to `time` (inclusive). For each value `i`, we loop through all the clips, and if we found a clip that can contribute to the current value of 'i', we update the `dp[i]` value with the minimum of itself and the value of `dp[clip[0]] + 1`. This ensures that we take the minimum possible number of clips to reach the current segment. Finally, we return the value of `dp[time]`, or `-1` if it is still infinity, which indicates that the task is impossible.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint videoStitching(vector<vector<int>>& clips, int time) {\n    vector<int> dp(time + 1, INT_MAX);\n    dp[0] = 0;\n    for (int i = 1; i <= time; ++i) {\n        for (const auto& clip : clips) {\n            if (clip[0] < i && i <= clip[1]) {\n                dp[i] = min(dp[i], dp[clip[0]] + 1);\n            }\n        }\n    }\n    return dp[time] == INT_MAX ? -1 : dp[time];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create an array `dp` of length `time + 1` and initialize it with infinity, except for `dp[0]`, which we set to 0. To find the minimum number of clips needed to cover the entire sporting event, we iterate through the range from 1 to `time` (inclusive). For each value `i`, we loop through all the clips, and if we found a clip that can contribute to the current value of 'i', we update the `dp[i]` value with the minimum of itself and the value of `dp[clip[0]] + 1`. This ensures that we take the minimum possible number of clips to reach the current segment. Finally, we return the value of `dp[time]`, or `-1` if it is still infinity, which indicates that the task is impossible.\n    ", "python": "\n    ```python\ndef videoStitching(clips, time):\n    dp = [float('inf')] * (time + 1)\n    dp[0] = 0\n    for i in range(1, time + 1):\n        for clip in clips:\n            if clip[0] < i and i <= clip[1]:\n                dp[i] = min(dp[i], dp[clip[0]] + 1)\n    return -1 if dp[time] == float('inf') else dp[time]\n```\n    \n    We use dynamic programming to solve this problem. We create an array `dp` of length `time + 1` and initialize it with infinity, except for `dp[0]`, which we set to 0. To find the minimum number of clips needed to cover the entire sporting event, we iterate through the range from 1 to `time` (inclusive). For each value `i`, we loop through all the clips, and if we found a clip that can contribute to the current value of 'i', we update the `dp[i]` value with the minimum of itself and the value of `dp[clip[0]] + 1`. This ensures that we take the minimum possible number of clips to reach the current segment. Finally, we return the value of `dp[time]`, or `-1` if it is still infinity, which indicates that the task is impossible.\n    ", "javascript": "\n    ```javascript\nfunction videoStitching(clips, time) {\n    let dp = new Array(time + 1).fill(Number.MAX_SAFE_INTEGER);\n    dp[0] = 0;\n    for (let i = 1; i <= time; ++i) {\n        for (const clip of clips) {\n            if (clip[0] < i && i <= clip[1]) {\n                dp[i] = Math.min(dp[i], dp[clip[0]] + 1);\n            }\n        }\n    }\n    return dp[time] === Number.MAX_SAFE_INTEGER ? -1 : dp[time];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create an array `dp` of length `time + 1` and initialize it with infinity, except for `dp[0]`, which we set to 0. To find the minimum number of clips needed to cover the entire sporting event, we iterate through the range from 1 to `time` (inclusive). For each value `i`, we loop through all the clips, and if we found a clip that can contribute to the current value of 'i', we update the `dp[i]` value with the minimum of itself and the value of `dp[clip[0]] + 1`. This ensures that we take the minimum possible number of clips to reach the current segment. Finally, we return the value of `dp[time]`, or `-1` if it is still infinity, which indicates that the task is impossible.\n    "}
{"id": 1090, "slug": "largest-values-from-labels", "title": "Largest Values From Labels", "difficulty": "Medium", "content": "There is a set of `n` items. You are given two integer arrays `values` and `labels` where the value and the label of the `ith` element are `values[i]` and `labels[i]` respectively. You are also given two integers `numWanted` and `useLimit`.\n\nChoose a subset `s` of the `n` elements such that:\n\n*   The size of the subset `s` is **less than or equal to** `numWanted`.\n*   There are **at most** `useLimit` items with the same label in `s`.\n\nThe **score** of a subset is the sum of the values in the subset.\n\nReturn _the maximum **score** of a subset_ `s`.\n\n**Example 1:**\n\n**Input:** values = \\[5,4,3,2,1\\], labels = \\[1,1,2,2,3\\], numWanted = 3, useLimit = 1\n**Output:** 9\n**Explanation:** The subset chosen is the first, third, and fifth items.\n\n**Example 2:**\n\n**Input:** values = \\[5,4,3,2,1\\], labels = \\[1,3,3,3,2\\], numWanted = 3, useLimit = 2\n**Output:** 12\n**Explanation:** The subset chosen is the first, second, and third items.\n\n**Example 3:**\n\n**Input:** values = \\[9,8,8,7,6\\], labels = \\[0,0,0,1,1\\], numWanted = 3, useLimit = 1\n**Output:** 16\n**Explanation:** The subset chosen is the first and fourth items.\n\n**Constraints:**\n\n*   `n == values.length == labels.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= values[i], labels[i] <= 2 * 104`\n*   `1 <= numWanted, useLimit <= n`", "java": "\n    ```java\nimport java.util.*;\n\npublic int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {\n    int n = values.length;\n    int[][] items = new int[n][2];\n    for (int i = 0; i < n; ++i) {\n        items[i][0] = values[i];\n        items[i][1] = labels[i];\n    }\n\n    Arrays.sort(items, (a, b) -> Integer.compare(b[0], a[0]));\n\n    Map<Integer, Integer> labelCount = new HashMap<>();\n    int ans = 0;\n\n    for (int[] item : items) {\n        labelCount.putIfAbsent(item[1], 0);\n        if (labelCount.get(item[1]) < useLimit) {\n            ans += item[0];\n            labelCount.put(item[1], labelCount.get(item[1]) + 1);\n            if (--numWanted == 0) break;\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    1. Create a list of pairs containing value and label.\n2. Sort the list of pairs based on the value in decreasing order.\n3. Initialize an empty hash table called 'labelCount' to store the count of each label in the selected subset.\n4. Initialize 'ans' to 0, which will store the result of maximum score.\n5. Iterate through the sorted list of pairs:\n   a. If the label is not in 'labelCount', set the label count as 0.\n   b. If the count of the current label is less than the 'useLimit', add the value to 'ans', increment the count of the label, and decrement 'numWanted'.\n   c. If 'numWanted' becomes 0, break the loop.\n6. Return 'ans'.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint largestValsFromLabels(std::vector<int>& values, std::vector<int>& labels, int numWanted, int useLimit) {\n    std::vector<std::pair<int, int>> items;\n    for (int i = 0; i < values.size(); ++i) {\n        items.push_back({values[i], labels[i]});\n    }\n\n    std::sort(items.begin(), items.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n        return a.first > b.first;\n    });\n\n    std::unordered_map<int, int> labelCount;\n    int ans = 0;\n\n    for (const auto& item : items) {\n        if (labelCount[item.second] < useLimit) {\n            ans += item.first;\n            labelCount[item.second]++;\n            if (--numWanted == 0) break;\n        }\n    }\n    return ans;\n}\n```\n\n    \n    1. Create a list of pairs containing value and label.\n2. Sort the list of pairs based on the value in decreasing order.\n3. Initialize an empty hash table called 'labelCount' to store the count of each label in the selected subset.\n4. Initialize 'ans' to 0, which will store the result of maximum score.\n5. Iterate through the sorted list of pairs:\n   a. If the label is not in 'labelCount', set the label count as 0.\n   b. If the count of the current label is less than the 'useLimit', add the value to 'ans', increment the count of the label, and decrement 'numWanted'.\n   c. If 'numWanted' becomes 0, break the loop.\n6. Return 'ans'.\n    ", "python": "\n    ```python\nfrom typing import List\n\ndef largestValsFromLabels(values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:\n    items = list(zip(values, labels))\n    items.sort(key=lambda x: x[0], reverse=True)\n\n    label_count = {}\n    ans = 0\n\n    for value, label in items:\n        if label not in label_count:\n            label_count[label] = 0\n        if label_count[label] < useLimit:\n            ans += value\n            label_count[label] += 1\n            numWanted -= 1\n            if numWanted == 0:\n                break\n\n    return ans\n```\n\n    \n    1. Create a list of pairs containing value and label.\n2. Sort the list of pairs based on the value in decreasing order.\n3. Initialize an empty hash table called 'labelCount' to store the count of each label in the selected subset.\n4. Initialize 'ans' to 0, which will store the result of maximum score.\n5. Iterate through the sorted list of pairs:\n   a. If the label is not in 'labelCount', set the label count as 0.\n   b. If the count of the current label is less than the 'useLimit', add the value to 'ans', increment the count of the label, and decrement 'numWanted'.\n   c. If 'numWanted' becomes 0, break the loop.\n6. Return 'ans'.\n    ", "javascript": "\n    ```javascript\nfunction largestValsFromLabels(values, labels, numWanted, useLimit) {\n    const items = values.map((value, i) => [value, labels[i]]);\n    items.sort((a, b) => b[0] - a[0]);\n\n    const labelCount = {};\n    let ans = 0;\n\n    for (const [value, label] of items) {\n        if (!labelCount.hasOwnProperty(label)) {\n            labelCount[label] = 0;\n        }\n        if (labelCount[label] < useLimit) {\n            ans += value;\n            labelCount[label]++;\n            numWanted--;\n            if (numWanted === 0) break;\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    1. Create a list of pairs containing value and label.\n2. Sort the list of pairs based on the value in decreasing order.\n3. Initialize an empty hash table called 'labelCount' to store the count of each label in the selected subset.\n4. Initialize 'ans' to 0, which will store the result of maximum score.\n5. Iterate through the sorted list of pairs:\n   a. If the label is not in 'labelCount', set the label count as 0.\n   b. If the count of the current label is less than the 'useLimit', add the value to 'ans', increment the count of the label, and decrement 'numWanted'.\n   c. If 'numWanted' becomes 0, break the loop.\n6. Return 'ans'.\n    "}
{"id": 1130, "slug": "minimum-cost-tree-from-leaf-values", "title": "Minimum Cost Tree From Leaf Values", "difficulty": "Medium", "content": "Given an array `arr` of positive integers, consider all binary trees such that:\n\n*   Each node has either `0` or `2` children;\n*   The values of `arr` correspond to the values of each **leaf** in an in-order traversal of the tree.\n*   The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.\n\nAmong all possible binary trees considered, return _the smallest possible sum of the values of each non-leaf node_. It is guaranteed this sum fits into a **32-bit** integer.\n\nA node is a **leaf** if and only if it has zero children.\n\n**Example 1:**\n\n**Input:** arr = \\[6,2,4\\]\n**Output:** 32\n**Explanation:** There are two possible trees shown.\nThe first has a non-leaf node sum 36, and the second has non-leaf node sum 32.\n\n**Example 2:**\n\n**Input:** arr = \\[4,11\\]\n**Output:** 44\n\n**Constraints:**\n\n*   `2 <= arr.length <= 40`\n*   `1 <= arr[i] <= 15`\n*   It is guaranteed that the answer fits into a **32-bit** signed integer (i.e., it is less than 231).", "java": "\n    ```java\npublic int lastStoneWeight(int[] stones) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n    for (int stone : stones) {\n        pq.add(stone);\n    }\n    while (pq.size() > 1) {\n        int x = pq.poll();\n        int y = pq.poll();\n        if (x != y) {\n            pq.add(y - x);\n        }\n    }\n    return pq.isEmpty() ? 0 : pq.peek();\n}\n```\n    \n    The algorithm makes use of a max priority queue to store the stones' weights. In each iteration, we dequeue the two largest stones (x and y) and smash them together. If their weights aren't the same, we enqueue the leftover weight (y - x) back into the priority queue. We repeat this process until there's only one stone left or no stone left in the queue. Finally, we return the weight of the remaining stone or 0 if there's none.\n\nNote: In the _JavaScript_ implementation, you need to use an external library for priority queue such as \"priorityqueuejs\", or you can create your own implementation of max priority queue.\n    ", "c++": "\n    ```cpp\nint lastStoneWeight(vector<int>& stones) {\n    priority_queue<int> pq(stones.begin(), stones.end());\n    while (pq.size() > 1) {\n        int x = pq.top(); pq.pop();\n        int y = pq.top(); pq.pop();\n        if (x != y) {\n            pq.push(y - x);\n        }\n    }\n    return pq.empty() ? 0 : pq.top();\n}\n```\n    \n    The algorithm makes use of a max priority queue to store the stones' weights. In each iteration, we dequeue the two largest stones (x and y) and smash them together. If their weights aren't the same, we enqueue the leftover weight (y - x) back into the priority queue. We repeat this process until there's only one stone left or no stone left in the queue. Finally, we return the weight of the remaining stone or 0 if there's none.\n\nNote: In the _JavaScript_ implementation, you need to use an external library for priority queue such as \"priorityqueuejs\", or you can create your own implementation of max priority queue.\n    ", "python": "\n    ```python\nimport heapq\n\ndef lastStoneWeight(stones):\n    stones = [-stone for stone in stones]\n    heapq.heapify(stones)\n    while len(stones) > 1:\n        y = -heapq.heappop(stones)\n        x = -heapq.heappop(stones)\n        if x != y:\n            heapq.heappush(stones, -(y - x))\n    return -stones[0] if stones else 0\n```\n    \n    The algorithm makes use of a max priority queue to store the stones' weights. In each iteration, we dequeue the two largest stones (x and y) and smash them together. If their weights aren't the same, we enqueue the leftover weight (y - x) back into the priority queue. We repeat this process until there's only one stone left or no stone left in the queue. Finally, we return the weight of the remaining stone or 0 if there's none.\n\nNote: In the _JavaScript_ implementation, you need to use an external library for priority queue such as \"priorityqueuejs\", or you can create your own implementation of max priority queue.\n    ", "javascript": "\n    ```javascript\nfunction lastStoneWeight(stones) {\n    const pq = new MinPriorityQueue({ priority: x => -x });\n    stones.forEach(stone => pq.enqueue(stone));\n    while (pq.size() > 1) {\n        const x = pq.dequeue().element;\n        const y = pq.dequeue().element;\n        if (x !== y) {\n            pq.enqueue(y - x);\n        }\n    }\n    return pq.isEmpty() ? 0 : pq.front().element;\n}\n```\n    \n    The algorithm makes use of a max priority queue to store the stones' weights. In each iteration, we dequeue the two largest stones (x and y) and smash them together. If their weights aren't the same, we enqueue the leftover weight (y - x) back into the priority queue. We repeat this process until there's only one stone left or no stone left in the queue. Finally, we return the weight of the remaining stone or 0 if there's none.\n\nNote: In the _JavaScript_ implementation, you need to use an external library for priority queue such as \"priorityqueuejs\", or you can create your own implementation of max priority queue.\n    "}
{"id": 1144, "slug": "decrease-elements-to-make-array-zigzag", "title": "Decrease Elements To Make Array Zigzag", "difficulty": "Medium", "content": "Given an array `nums` of integers, a _move_ consists of choosing any element and **decreasing it by 1**.\n\nAn array `A` is a _zigzag array_ if either:\n\n*   Every even-indexed element is greater than adjacent elements, ie. `A[0] > A[1] < A[2] > A[3] < A[4] > ...`\n*   OR, every odd-indexed element is greater than adjacent elements, ie. `A[0] < A[1] > A[2] < A[3] > A[4] < ...`\n\nReturn the minimum number of moves to transform the given array `nums` into a zigzag array.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 2\n**Explanation:** We can decrease 2 to 0 or 3 to 1.\n\n**Example 2:**\n\n**Input:** nums = \\[9,6,1,6,2\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 1000`", "java": "\n    ```java\npublic int movesToMakeZigzag(int[] nums) {\n    int evenMoves = 0, oddMoves = 0;\n    for (int i = 0; i < nums.length; i++) {\n        int left = i > 0 ? nums[i - 1] : 1001;\n        int right = i < nums.length - 1 ? nums[i + 1] : 1001;\n        int minValue = Math.min(left, right);\n        if (nums[i] >= minValue) {\n            if (i % 2 == 0) {\n                evenMoves += nums[i] - minValue + 1;\n            } else {\n                oddMoves += nums[i] - minValue + 1;\n            }\n        }\n    }\n    return Math.min(evenMoves, oddMoves);\n}\n```\n    \n    The algorithm first initializes two counters: one for the number of moves for making a zigzag array starting at an even position, and another for starting at an odd position. Then, we iterate through the array and check the left and right neighbours of each element. If the current element is larger than or equal to any of its neighbours, we need to decrease it. The number of moves needed is the difference between the current element and the minimum adjacent value, plus one. Depending on the index of the element, we add the number of moves to the corresponding counter (even or odd). Finally, we return the minimum between the two counters.\n    ", "c++": "\n    ```cpp\nint movesToMakeZigzag(std::vector<int>& nums) {\n    int evenMoves = 0, oddMoves = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        int left = i > 0 ? nums[i - 1] : 1001;\n        int right = i < nums.size() - 1 ? nums[i + 1] : 1001;\n        int minValue = std::min(left, right);\n        if (nums[i] >= minValue) {\n            if (i % 2 == 0) {\n                evenMoves += nums[i] - minValue + 1;\n            } else {\n                oddMoves += nums[i] - minValue + 1;\n            }\n        }\n    }\n    return std::min(evenMoves, oddMoves);\n}\n```\n    \n    The algorithm first initializes two counters: one for the number of moves for making a zigzag array starting at an even position, and another for starting at an odd position. Then, we iterate through the array and check the left and right neighbours of each element. If the current element is larger than or equal to any of its neighbours, we need to decrease it. The number of moves needed is the difference between the current element and the minimum adjacent value, plus one. Depending on the index of the element, we add the number of moves to the corresponding counter (even or odd). Finally, we return the minimum between the two counters.\n    ", "python": "\n    ```python\ndef movesToMakeZigzag(nums):\n    even_moves, odd_moves = 0, 0\n    for i in range(len(nums)):\n        left = nums[i - 1] if i > 0 else 1001\n        right = nums[i + 1] if i < len(nums) - 1 else 1001\n        min_value = min(left, right)\n        if nums[i] >= min_value:\n            if i % 2 == 0:\n                even_moves += nums[i] - min_value + 1\n            else:\n                odd_moves += nums[i] - min_value + 1\n    return min(even_moves, odd_moves)\n```\n    \n    The algorithm first initializes two counters: one for the number of moves for making a zigzag array starting at an even position, and another for starting at an odd position. Then, we iterate through the array and check the left and right neighbours of each element. If the current element is larger than or equal to any of its neighbours, we need to decrease it. The number of moves needed is the difference between the current element and the minimum adjacent value, plus one. Depending on the index of the element, we add the number of moves to the corresponding counter (even or odd). Finally, we return the minimum between the two counters.\n    ", "javascript": "\n    ```javascript\nfunction movesToMakeZigzag(nums) {\n    let evenMoves = 0, oddMoves = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let left = i > 0 ? nums[i - 1] : 1001;\n        let right = i < nums.length - 1 ? nums[i + 1] : 1001;\n        let minValue = Math.min(left, right);\n        if (nums[i] >= minValue) {\n            if (i % 2 === 0) {\n                evenMoves += nums[i] - minValue + 1;\n            } else {\n                oddMoves += nums[i] - minValue + 1;\n            }\n        }\n    }\n    return Math.min(evenMoves, oddMoves);\n}\n```\n    \n    The algorithm first initializes two counters: one for the number of moves for making a zigzag array starting at an even position, and another for starting at an odd position. Then, we iterate through the array and check the left and right neighbours of each element. If the current element is larger than or equal to any of its neighbours, we need to decrease it. The number of moves needed is the difference between the current element and the minimum adjacent value, plus one. Depending on the index of the element, we add the number of moves to the corresponding counter (even or odd). Finally, we return the minimum between the two counters.\n    "}
{"id": 1147, "slug": "longest-chunked-palindrome-decomposition", "title": "Longest Chunked Palindrome Decomposition", "difficulty": "Hard", "content": "You are given a string `text`. You should split it to k substrings `(subtext1, subtext2, ..., subtextk)` such that:\n\n*   `subtexti` is a **non-empty** string.\n*   The concatenation of all the substrings is equal to `text` (i.e., `subtext1 + subtext2 + ... + subtextk == text`).\n*   `subtexti == subtextk - i + 1` for all valid values of `i` (i.e., `1 <= i <= k`).\n\nReturn the largest possible value of `k`.\n\n**Example 1:**\n\n**Input:** text =  \"ghiabcdefhelloadamhelloabcdefghi \"\n**Output:** 7\n**Explanation:** We can split the string on  \"(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi) \".\n\n**Example 2:**\n\n**Input:** text =  \"merchant \"\n**Output:** 1\n**Explanation:** We can split the string on  \"(merchant) \".\n\n**Example 3:**\n\n**Input:** text =  \"antaprezatepzapreanta \"\n**Output:** 11\n**Explanation:** We can split the string on  \"(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a) \".\n\n**Constraints:**\n\n*   `1 <= text.length <= 1000`\n*   `text` consists only of lowercase English characters.", "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int maxEqualRowsAfterFlips(int[][] matrix) {\n    Map<String, Integer> count = new HashMap<>();\n    for (int[] row : matrix) {\n        StringBuilder row_str = new StringBuilder();\n        int first = row[0];\n        for (int val : row) {\n            row_str.append(first == 1 ? 1 - val : val);\n        }\n        count.put(row_str.toString(), count.getOrDefault(row_str.toString(), 0) + 1);\n    }\n    int res = 0;\n    for (int value : count.values()) {\n        res = Math.max(res, value);\n    }\n    return res;\n}\n```\n    \n    The algorithm initializes an empty map (or dictionary) for counting rows. For each row in the matrix, the algorithm generates a string composed of the XOR of the first element in the row with every element in that row. This operation helps to represent the rows that can be flipped to be equal. The row string is stored as a key in the dictionary, and the count of such rows is incremented.\n\nFinally, the algorithm iterates through the values in the dictionary and returns the maximum count encountered. This is the maximum number of rows that become equal after some number of flips.\n\nThe time complexity of this algorithm is O(m * n), where m is the number of rows and n is the number of columns in the matrix, as it iterates through every cell of the matrix.\n    ", "c++": "\n    ```cpp\nint maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {\n    unordered_map<string, int> count;\n    for (auto& row : matrix) {\n        string row_str;\n        if (row[0] == 1) {\n            for (int val : row)\n                row_str += '0' + 1 - val;\n        } else {\n            for (int val : row)\n                row_str += '0' + val;\n        }\n        count[row_str]++;\n    }\n    int res = 0;\n    for (auto& [key, value] : count)\n        res = max(res, value);\n    return res;\n}\n```\n    \n    The algorithm initializes an empty map (or dictionary) for counting rows. For each row in the matrix, the algorithm generates a string composed of the XOR of the first element in the row with every element in that row. This operation helps to represent the rows that can be flipped to be equal. The row string is stored as a key in the dictionary, and the count of such rows is incremented.\n\nFinally, the algorithm iterates through the values in the dictionary and returns the maximum count encountered. This is the maximum number of rows that become equal after some number of flips.\n\nThe time complexity of this algorithm is O(m * n), where m is the number of rows and n is the number of columns in the matrix, as it iterates through every cell of the matrix.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\n\ndef maxEqualRowsAfterFlips(matrix):\n    count = defaultdict(int)\n    for row in matrix:\n        row_str = \"\".join(str(row[0] ^ val) for val in row)\n        count[row_str] += 1\n    return max(count.values())\n```\n    \n    The algorithm initializes an empty map (or dictionary) for counting rows. For each row in the matrix, the algorithm generates a string composed of the XOR of the first element in the row with every element in that row. This operation helps to represent the rows that can be flipped to be equal. The row string is stored as a key in the dictionary, and the count of such rows is incremented.\n\nFinally, the algorithm iterates through the values in the dictionary and returns the maximum count encountered. This is the maximum number of rows that become equal after some number of flips.\n\nThe time complexity of this algorithm is O(m * n), where m is the number of rows and n is the number of columns in the matrix, as it iterates through every cell of the matrix.\n    ", "javascript": "\n    ```javascript\nfunction maxEqualRowsAfterFlips(matrix) {\n    const count = new Map();\n    for (const row of matrix) {\n        const rowStr = row.map(val => row[0] ^ val).join('');\n        count.set(rowStr, (count.get(rowStr) || 0) + 1);\n    }\n    let res = 0;\n    for (const value of count.values()) {\n        res = Math.max(res, value);\n    }\n    return res;\n}\n```\n    \n    The algorithm initializes an empty map (or dictionary) for counting rows. For each row in the matrix, the algorithm generates a string composed of the XOR of the first element in the row with every element in that row. This operation helps to represent the rows that can be flipped to be equal. The row string is stored as a key in the dictionary, and the count of such rows is incremented.\n\nFinally, the algorithm iterates through the values in the dictionary and returns the maximum count encountered. This is the maximum number of rows that become equal after some number of flips.\n\nThe time complexity of this algorithm is O(m * n), where m is the number of rows and n is the number of columns in the matrix, as it iterates through every cell of the matrix.\n    "}
{"id": 1167, "slug": "minimum-cost-to-connect-sticks", "title": "Minimum Cost to Connect Sticks", "difficulty": "Medium", "content": "You have some number of sticks with positive integer lengths. These lengths are given as an array `sticks`, where `sticks[i]` is the length of the `ith` stick.\n\nYou can connect any two sticks of lengths `x` and `y` into one stick by paying a cost of `x + y`. You must connect all the sticks until there is only one stick remaining.\n\nReturn _the minimum cost of connecting all the given sticks into one stick in this way_.\n\n**Example 1:**\n\n**Input:** sticks = \\[2,4,3\\]\n**Output:** 14\n**Explanation:** You start with sticks = \\[2,4,3\\].\n1. Combine sticks 2 and 3 for a cost of 2 + 3 = 5. Now you have sticks = \\[5,4\\].\n2. Combine sticks 5 and 4 for a cost of 5 + 4 = 9. Now you have sticks = \\[9\\].\nThere is only one stick left, so you are done. The total cost is 5 + 9 = 14.\n\n**Example 2:**\n\n**Input:** sticks = \\[1,8,3,5\\]\n**Output:** 30\n**Explanation:** You start with sticks = \\[1,8,3,5\\].\n1. Combine sticks 1 and 3 for a cost of 1 + 3 = 4. Now you have sticks = \\[4,8,5\\].\n2. Combine sticks 4 and 5 for a cost of 4 + 5 = 9. Now you have sticks = \\[9,8\\].\n3. Combine sticks 9 and 8 for a cost of 9 + 8 = 17. Now you have sticks = \\[17\\].\nThere is only one stick left, so you are done. The total cost is 4 + 9 + 17 = 30.\n\n**Example 3:**\n\n**Input:** sticks = \\[5\\]\n**Output:** 0\n**Explanation:** There is only one stick, so you don't need to do anything. The total cost is 0.\n\n**Constraints:**\n\n*   `1 <= sticks.length <= 104`\n*   `1 <= sticks[i] <= 104`", "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int connectSticks(int[] sticks) {\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    \n    for (int stick : sticks) {\n        minHeap.offer(stick);\n    }\n    \n    int cost = 0;\n    while (minHeap.size() > 1) {\n        int first = minHeap.poll();\n        int second = minHeap.poll();\n        cost += first + second;\n        minHeap.offer(first + second);\n    }\n    return cost;\n}\n```\n    \n    The algorithm works by turning the input array `sticks` into a min heap, a data structure that allows for efficient retrieval of the smallest element in the heap. The algorithm then iterates until there is only one stick left, removing the two smallest sticks from the heap, combining them and adding their sum back into the heap. The cost of combining the two sticks is added to the total cost. After all the sticks have been combined, the function returns the total cost. The algorithm has a time complexity of O(n log n) where n is the number of elements in the input array, as each operation in the heap takes O(log n) time, and we perform about n operations.\n    ", "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\n\nint connectSticks(std::vector<int>& sticks) {\n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;\n\n    for (int stick : sticks) {\n        min_heap.push(stick);\n    }\n\n    int cost = 0;\n    while (min_heap.size() > 1) {\n        int first = min_heap.top();\n        min_heap.pop();\n        int second = min_heap.top();\n        min_heap.pop();\n        cost += first + second;\n        min_heap.push(first + second);\n    }\n    return cost;\n}\n```\n    \n    The algorithm works by turning the input array `sticks` into a min heap, a data structure that allows for efficient retrieval of the smallest element in the heap. The algorithm then iterates until there is only one stick left, removing the two smallest sticks from the heap, combining them and adding their sum back into the heap. The cost of combining the two sticks is added to the total cost. After all the sticks have been combined, the function returns the total cost. The algorithm has a time complexity of O(n log n) where n is the number of elements in the input array, as each operation in the heap takes O(log n) time, and we perform about n operations.\n    ", "python": "\n    ```python\nimport heapq\n\ndef connectSticks(sticks):\n    heapq.heapify(sticks)\n    cost = 0\n    while len(sticks) > 1:\n        first = heapq.heappop(sticks)\n        second = heapq.heappop(sticks)\n        cost += first + second\n        heapq.heappush(sticks, first + second)\n    return cost\n```\n    \n    The algorithm works by turning the input array `sticks` into a min heap, a data structure that allows for efficient retrieval of the smallest element in the heap. The algorithm then iterates until there is only one stick left, removing the two smallest sticks from the heap, combining them and adding their sum back into the heap. The cost of combining the two sticks is added to the total cost. After all the sticks have been combined, the function returns the total cost. The algorithm has a time complexity of O(n log n) where n is the number of elements in the input array, as each operation in the heap takes O(log n) time, and we perform about n operations.\n    ", "javascript": "\n    ```javascript\nfunction connectSticks(sticks) {\n    const minHeap = new MinHeap(sticks);\n    \n    let cost = 0;\n    while (minHeap.size() > 1) {\n        const first = minHeap.poll();\n        const second = minHeap.poll();\n        cost += first + second;\n        minHeap.offer(first + second);\n    }\n    return cost;\n}\n\nclass MinHeap {\n    constructor(items) {\n        this.heap = [];\n        for (const item of items) {\n            this.offer(item);\n        }\n    }\n    \n    offer(value) {\n        this.heap.push(value);\n        this.bubbleUp(this.heap.length - 1);\n    }\n    \n    poll() {\n        const min = this.heap[0];\n        this.heap[0] = this.heap.pop();\n        this.bubbleDown(0);\n        return min;\n    }\n    \n    size() {\n        return this.heap.length;\n    }\n    \n    bubbleUp(index) {\n        if (index === 0) return;\n        const parentIndex = Math.floor((index - 1) / 2);\n        if (this.heap[parentIndex] > this.heap[index]) {\n            [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];\n            this.bubbleUp(parentIndex);\n        }\n    }\n    \n    bubbleDown(index) {\n        const leftChildIndex = 2 * index + 1;\n        const rightChildIndex = 2 * index + 2;\n        \n        let minIndex = index;\n        if (leftChildIndex < this.heap.length && this.heap[leftChildIndex] < this.heap[minIndex]) {\n            minIndex = leftChildIndex;\n        }\n        \n        if (rightChildIndex < this.heap.length && this.heap[rightChildIndex] < this.heap[minIndex]) {\n            minIndex = rightChildIndex;\n        }\n        \n        if (minIndex !== index) {\n            [this.heap[minIndex], this.heap[index]] = [this.heap[index], this.heap[minIndex]];\n            this.bubbleDown(minIndex);\n        }\n    }\n}\n```\n    \n    The algorithm works by turning the input array `sticks` into a min heap, a data structure that allows for efficient retrieval of the smallest element in the heap. The algorithm then iterates until there is only one stick left, removing the two smallest sticks from the heap, combining them and adding their sum back into the heap. The cost of combining the two sticks is added to the total cost. After all the sticks have been combined, the function returns the total cost. The algorithm has a time complexity of O(n log n) where n is the number of elements in the input array, as each operation in the heap takes O(log n) time, and we perform about n operations.\n    "}
{"id": 1183, "slug": "maximum-number-of-ones", "title": "Maximum Number of Ones", "difficulty": "Hard", "content": "Consider a matrix `M` with dimensions `width * height`, such that every cell has value `0` or `1`, and any **square** sub-matrix of `M` of size `sideLength * sideLength` has at most `maxOnes` ones.\n\nReturn the maximum possible number of ones that the matrix `M` can have.\n\n**Example 1:**\n\n**Input:** width = 3, height = 3, sideLength = 2, maxOnes = 1\n**Output:** 4\n**Explanation:**\nIn a 3\\*3 matrix, no 2\\*2 sub-matrix can have more than 1 one.\nThe best solution that has 4 ones is:\n\\[1,0,1\\]\n\\[0,0,0\\]\n\\[1,0,1\\]\n\n**Example 2:**\n\n**Input:** width = 3, height = 3, sideLength = 2, maxOnes = 2\n**Output:** 6\n**Explanation:**\n\\[1,0,1\\]\n\\[1,0,1\\]\n\\[1,0,1\\]\n\n**Constraints:**\n\n*   `1 <= width, height <= 100`\n*   `1 <= sideLength <= width, height`\n*   `0 <= maxOnes <= sideLength * sideLength`", "java": "\n    ```java\npublic double[] sampleStats(int[] count) {\n    double minVal = -1, maxVal = -1, mode = 0, median = 0, mean = 0;\n    long totalCount = 0, modeCount = 0, curCount = 0;\n    double sum = 0;\n\n    for (int i = 0; i <= 255; i++) {\n        if (count[i] > 0) {\n            if (minVal == -1) minVal = i;\n            maxVal = i;\n            sum += (double) i * count[i];\n            totalCount += count[i];\n            if (count[i] > modeCount) {\n                modeCount = count[i];\n                mode = i;\n            }\n        }\n    }\n\n    mean = sum / totalCount;\n    boolean isEven = (totalCount % 2 == 0);\n    long mid1 = totalCount / 2, mid2 = mid1 - 1;\n    if (isEven) mid2++;\n\n    for (int i = 0; i <= 255; i++) {\n        curCount += count[i];\n        if (isEven && curCount >= mid2) {\n            median += i;\n            mid2 = totalCount;\n            isEven = false;\n        }\n\n        if (curCount >= mid1) {\n            median += i;\n            break;\n        }\n    }\n\n    if (!isEven) median /= 2;\n    return new double[]{minVal, maxVal, mean, median, mode};\n}\n```\n    \n    The algorithm starts by initializing variables for min, max, mean, mode, and median, as well as some others used for calculations. It then iterates through the count array from 0 to 255. For each value, it updates the min and max values if necessary, calculates the sum of the elements and total count (which will be used to calculate the mean later), and updates the mode if the count for that value is greater than the current mode count.\n\nAfter the initial loop, the mean is calculated by dividing the sum by the total count. The median is calculated by finding the middle value(s) using the total count. If the total count is even, it will be the average of the two middle values; otherwise, it will be just the middle value. This is done by keeping track of the current count of values visited, and adding the index i to the median whenever any of the middle values are reached. The median is then divided by 2 if there was only one middle value, to account for the fact that it was added twice during the median calculation loop.\n\nFinally, the results are returned in an array with the format [minimum, maximum, mean, median, mode].\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<double> sampleStats(std::vector<int>& count) {\n    double minVal = -1, maxVal = -1, mode = 0, median = 0, mean = 0;\n    long long totalCount = 0, modeCount = 0, curCount = 0;\n    double sum = 0;\n\n    for (int i = 0; i <= 255; i++) {\n        if (count[i] > 0) {\n            if (minVal == -1) minVal = i;\n            maxVal = i;\n            sum += static_cast<double>(i) * count[i];\n            totalCount += count[i];\n            if (count[i] > modeCount) {\n                modeCount = count[i];\n                mode = i;\n            }\n        }\n    }\n\n    mean = sum / totalCount;\n    bool isEven = (totalCount % 2 == 0);\n    long long mid1 = totalCount / 2, mid2 = mid1 - 1;\n    if (isEven) mid2++;\n\n    for (int i = 0; i <= 255; i++) {\n        curCount += count[i];\n        if (isEven && curCount >= mid2) {\n            median += i;\n            mid2 = totalCount;\n            isEven = false;\n        }\n\n        if (curCount >= mid1) {\n            median += i;\n            break;\n        }\n    }\n\n    if (!isEven) median /= 2;\n    return {minVal, maxVal, mean, median, mode};\n}\n```\n    \n    The algorithm starts by initializing variables for min, max, mean, mode, and median, as well as some others used for calculations. It then iterates through the count array from 0 to 255. For each value, it updates the min and max values if necessary, calculates the sum of the elements and total count (which will be used to calculate the mean later), and updates the mode if the count for that value is greater than the current mode count.\n\nAfter the initial loop, the mean is calculated by dividing the sum by the total count. The median is calculated by finding the middle value(s) using the total count. If the total count is even, it will be the average of the two middle values; otherwise, it will be just the middle value. This is done by keeping track of the current count of values visited, and adding the index i to the median whenever any of the middle values are reached. The median is then divided by 2 if there was only one middle value, to account for the fact that it was added twice during the median calculation loop.\n\nFinally, the results are returned in an array with the format [minimum, maximum, mean, median, mode].\n    ", "python": "\n    ```python\ndef sampleStats(count):\n    minVal, maxVal, mode, median, mean = -1, -1, 0, 0, 0\n    totalCount, modeCount, curCount = 0, 0, 0\n    sum = 0\n\n    for i in range(256):\n        if count[i] > 0:\n            if minVal == -1:\n                minVal = i\n            maxVal = i\n            sum += i * count[i]\n            totalCount += count[i]\n            if count[i] > modeCount:\n                modeCount = count[i]\n                mode = i\n\n    mean = sum / totalCount\n    isEven = (totalCount % 2 == 0)\n    mid1 = totalCount // 2\n    mid2 = mid1 - 1\n    if isEven:\n        mid2 += 1\n\n    for i in range(256):\n        curCount += count[i]\n        if isEven and curCount >= mid2:\n            median += i\n            mid2 = totalCount\n            isEven = False\n\n        if curCount >= mid1:\n            median += i\n            break\n\n    if not isEven:\n        median /= 2\n    return [minVal, maxVal, mean, median, mode]\n```\n    \n    The algorithm starts by initializing variables for min, max, mean, mode, and median, as well as some others used for calculations. It then iterates through the count array from 0 to 255. For each value, it updates the min and max values if necessary, calculates the sum of the elements and total count (which will be used to calculate the mean later), and updates the mode if the count for that value is greater than the current mode count.\n\nAfter the initial loop, the mean is calculated by dividing the sum by the total count. The median is calculated by finding the middle value(s) using the total count. If the total count is even, it will be the average of the two middle values; otherwise, it will be just the middle value. This is done by keeping track of the current count of values visited, and adding the index i to the median whenever any of the middle values are reached. The median is then divided by 2 if there was only one middle value, to account for the fact that it was added twice during the median calculation loop.\n\nFinally, the results are returned in an array with the format [minimum, maximum, mean, median, mode].\n    ", "javascript": "\n    ```javascript\nfunction sampleStats(count) {\n    let minVal = -1, maxVal = -1, mode = 0, median = 0, mean = 0;\n    let totalCount = 0, modeCount = 0, curCount = 0;\n    let sum = 0;\n\n    for (let i = 0; i <= 255; i++) {\n        if (count[i] > 0) {\n            if (minVal === -1) minVal = i;\n            maxVal = i;\n            sum += i * count[i];\n            totalCount += count[i];\n            if (count[i] > modeCount) {\n                modeCount = count[i];\n                mode = i;\n            }\n        }\n    }\n\n    mean = sum / totalCount;\n    let isEven = (totalCount % 2 === 0);\n    let mid1 = Math.floor(totalCount / 2), mid2 = mid1 - 1;\n    if (isEven) mid2++;\n\n    for (let i = 0; i <= 255; i++) {\n        curCount += count[i];\n        if (isEven && curCount >= mid2) {\n            median += i;\n            mid2 = totalCount;\n            isEven = false;\n        }\n\n        if (curCount >= mid1) {\n            median += i;\n            break;\n        }\n    }\n\n    if (!isEven) median /= 2;\n    return [minVal, maxVal, mean, median, mode];\n}\n```\n    \n    The algorithm starts by initializing variables for min, max, mean, mode, and median, as well as some others used for calculations. It then iterates through the count array from 0 to 255. For each value, it updates the min and max values if necessary, calculates the sum of the elements and total count (which will be used to calculate the mean later), and updates the mode if the count for that value is greater than the current mode count.\n\nAfter the initial loop, the mean is calculated by dividing the sum by the total count. The median is calculated by finding the middle value(s) using the total count. If the total count is even, it will be the average of the two middle values; otherwise, it will be just the middle value. This is done by keeping track of the current count of values visited, and adding the index i to the median whenever any of the middle values are reached. The median is then divided by 2 if there was only one middle value, to account for the fact that it was added twice during the median calculation loop.\n\nFinally, the results are returned in an array with the format [minimum, maximum, mean, median, mode].\n    "}
{"id": 1196, "slug": "how-many-apples-can-you-put-into-the-basket", "title": "How Many Apples Can You Put into the Basket", "difficulty": "Easy", "content": "You have some apples and a basket that can carry up to `5000` units of weight.\n\nGiven an integer array `weight` where `weight[i]` is the weight of the `ith` apple, return _the maximum number of apples you can put in the basket_.\n\n**Example 1:**\n\n**Input:** weight = \\[100,200,150,1000\\]\n**Output:** 4\n**Explanation:** All 4 apples can be carried by the basket since their sum of weights is 1450.\n\n**Example 2:**\n\n**Input:** weight = \\[900,950,800,1000,700,800\\]\n**Output:** 5\n**Explanation:** The sum of weights of the 6 apples exceeds 5000 so we choose any 5 of them.\n\n**Constraints:**\n\n*   `1 <= weight.length <= 103`\n*   `1 <= weight[i] <= 103`", "java": "\n    ```java\npublic int minHeightShelves(int[][] books, int shelfWidth) {\n    int n = books.length;\n    int[] dp = new int[n + 1];\n    Arrays.fill(dp, 1000000);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        int width = 0, height = 0;\n        for (int j = i; j >= 1; j--) {\n            width += books[j - 1][0];\n            height = Math.max(height, books[j - 1][1]);\n            \n            if (width <= shelfWidth)\n                dp[i] = Math.min(dp[i], dp[j - 1] + height);\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    We can solve this problem using dynamic programming. We create a DP array dp where dp[i] represents the minimum height of the bookshelf after placing the first i books. We initialize the DP array with a large number (e.g., 1000000) except for dp[0], which we set to 0.\n\nWe iterate over the books from 1 to n, and for each book, we go through another loop in reverse order from i to 1. In this inner loop, we keep track of the width and maximum height of the books we've seen so far. We calculate the width by adding the thickness of the current book (books[j - 1][0]) to the width accumulator, and update the maximum height (height) if the height of the current book (books[j - 1][1]) is greater than the previously stored maximum height.\n\nIf the width of the books we've seen does not exceed shelfWidth, we update dp[i] with the minimum between dp[i] and the sum of the height we would get by placing a new bookshelf below the current one (dp[j - 1] + height). We do this for every iteration in both loops.\n\nFinally, we return the value of dp[n], which represents the minimum height of the bookshelf after placing all the books.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint minHeightShelves(std::vector<std::vector<int>>& books, int shelfWidth) {\n    int n = books.size();\n    std::vector<int> dp(n + 1, 1000000);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        int width = 0, height = 0;\n        for (int j = i; j >= 1; --j) {\n            width += books[j - 1][0];\n            height = std::max(height, books[j - 1][1]);\n            \n            if (width <= shelfWidth)\n                dp[i] = std::min(dp[i], dp[j - 1] + height);\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    We can solve this problem using dynamic programming. We create a DP array dp where dp[i] represents the minimum height of the bookshelf after placing the first i books. We initialize the DP array with a large number (e.g., 1000000) except for dp[0], which we set to 0.\n\nWe iterate over the books from 1 to n, and for each book, we go through another loop in reverse order from i to 1. In this inner loop, we keep track of the width and maximum height of the books we've seen so far. We calculate the width by adding the thickness of the current book (books[j - 1][0]) to the width accumulator, and update the maximum height (height) if the height of the current book (books[j - 1][1]) is greater than the previously stored maximum height.\n\nIf the width of the books we've seen does not exceed shelfWidth, we update dp[i] with the minimum between dp[i] and the sum of the height we would get by placing a new bookshelf below the current one (dp[j - 1] + height). We do this for every iteration in both loops.\n\nFinally, we return the value of dp[n], which represents the minimum height of the bookshelf after placing all the books.\n    ", "python": "\n    ```python\ndef minHeightShelves(books, shelfWidth):\n    n = len(books)\n    dp = [1000000] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        width = 0\n        height = 0\n        j = i\n        while j >= 1:\n            width += books[j - 1][0]\n            height = max(height, books[j - 1][1])\n            \n            if width <= shelfWidth:\n                dp[i] = min(dp[i], dp[j - 1] + height)\n            j -= 1\n    \n    return dp[n]\n```\n    \n    We can solve this problem using dynamic programming. We create a DP array dp where dp[i] represents the minimum height of the bookshelf after placing the first i books. We initialize the DP array with a large number (e.g., 1000000) except for dp[0], which we set to 0.\n\nWe iterate over the books from 1 to n, and for each book, we go through another loop in reverse order from i to 1. In this inner loop, we keep track of the width and maximum height of the books we've seen so far. We calculate the width by adding the thickness of the current book (books[j - 1][0]) to the width accumulator, and update the maximum height (height) if the height of the current book (books[j - 1][1]) is greater than the previously stored maximum height.\n\nIf the width of the books we've seen does not exceed shelfWidth, we update dp[i] with the minimum between dp[i] and the sum of the height we would get by placing a new bookshelf below the current one (dp[j - 1] + height). We do this for every iteration in both loops.\n\nFinally, we return the value of dp[n], which represents the minimum height of the bookshelf after placing all the books.\n    ", "javascript": "\n    ```javascript\nfunction minHeightShelves(books, shelfWidth) {\n    const n = books.length;\n    const dp = new Array(n + 1).fill(1000000);\n    dp[0] = 0;\n    \n    for (let i = 1; i <= n; i++) {\n        let width = 0, height = 0;\n        for (let j = i; j >= 1; j--) {\n            width += books[j - 1][0];\n            height = Math.max(height, books[j - 1][1]);\n            \n            if (width <= shelfWidth)\n                dp[i] = Math.min(dp[i], dp[j - 1] + height);\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    We can solve this problem using dynamic programming. We create a DP array dp where dp[i] represents the minimum height of the bookshelf after placing the first i books. We initialize the DP array with a large number (e.g., 1000000) except for dp[0], which we set to 0.\n\nWe iterate over the books from 1 to n, and for each book, we go through another loop in reverse order from i to 1. In this inner loop, we keep track of the width and maximum height of the books we've seen so far. We calculate the width by adding the thickness of the current book (books[j - 1][0]) to the width accumulator, and update the maximum height (height) if the height of the current book (books[j - 1][1]) is greater than the previously stored maximum height.\n\nIf the width of the books we've seen does not exceed shelfWidth, we update dp[i] with the minimum between dp[i] and the sum of the height we would get by placing a new bookshelf below the current one (dp[j - 1] + height). We do this for every iteration in both loops.\n\nFinally, we return the value of dp[n], which represents the minimum height of the bookshelf after placing all the books.\n    "}
{"id": 1199, "slug": "minimum-time-to-build-blocks", "title": "Minimum Time to Build Blocks", "difficulty": "Hard", "content": "You are given a list of blocks, where `blocks[i] = t` means that the `i`\\-th block needs `t` units of time to be built. A block can only be built by exactly one worker.\n\nA worker can either split into two workers (number of workers increases by one) or build a block then go home. Both decisions cost some time.\n\nThe time cost of spliting one worker into two workers is given as an integer `split`. Note that if two workers split at the same time, they split in parallel so the cost would be `split`.\n\nOutput the minimum time needed to build all blocks.\n\nInitially, there is only **one** worker.\n\n**Example 1:**\n\n**Input:** blocks = \\[1\\], split = 1\n**Output:** 1\n**Explanation:** We use 1 worker to build 1 block in 1 time unit.\n\n**Example 2:**\n\n**Input:** blocks = \\[1,2\\], split = 5\n**Output:** 7\n**Explanation:** We split the worker into 2 workers in 5 time units then assign each of them to a block so the cost is 5 + max(1, 2) = 7.\n\n**Example 3:**\n\n**Input:** blocks = \\[1,2,3\\], split = 1\n**Output:** 4\n**Explanation:** Split 1 worker into 2, then assign the first worker to the last block and split the second worker into 2.\nThen, use the two unassigned workers to build the first two blocks.\nThe cost is 1 + max(3, 1 + max(1, 2)) = 4.\n\n**Constraints:**\n\n*   `1 <= blocks.length <= 1000`\n*   `1 <= blocks[i] <= 10^5`\n*   `1 <= split <= 100`", "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int minBuildTime(int[] blocks, int split) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\n    \n    for (int block : blocks) {\n        pq.add(block);\n    }\n    \n    while (pq.size() > 1) {\n        int a = pq.poll();\n        int b = pq.poll();\n        pq.add(b + split);\n    }\n    \n    return pq.poll();\n}\n```\n    \n    We use a priority queue to get the smallest time units of the blocks. In each iteration, we get the two smallest time units and insert the larger one plus the split time back into the priority queue. This is repeated until there is only one element left in the priority queue.\n\nThis results in the workers splitting and working on the blocks with the smallest time units.\n\nInitially, we insert all blocks' time units into the priority queue. Then we enter a loop where we get the two smallest elements (a and b), pop them from the priority queue, and add (b + split) back into the priority queue. We keep doing this until there's only one element left in the priority queue.\n\nFinally, we return the last remaining element as the minimum time needed to build all blocks.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nint minBuildTime(std::vector<int>& blocks, int split) {\n    std::priority_queue<int, std::vector<int>, greater<int>> pq(blocks.begin(), blocks.end());\n    \n    while (pq.size() > 1) {\n        int a = pq.top();\n        pq.pop();\n        int b = pq.top();\n        pq.pop();\n        pq.push(b + split);\n    }\n    \n    return pq.top();\n}\n```\n    \n    We use a priority queue to get the smallest time units of the blocks. In each iteration, we get the two smallest time units and insert the larger one plus the split time back into the priority queue. This is repeated until there is only one element left in the priority queue.\n\nThis results in the workers splitting and working on the blocks with the smallest time units.\n\nInitially, we insert all blocks' time units into the priority queue. Then we enter a loop where we get the two smallest elements (a and b), pop them from the priority queue, and add (b + split) back into the priority queue. We keep doing this until there's only one element left in the priority queue.\n\nFinally, we return the last remaining element as the minimum time needed to build all blocks.\n    ", "python": "\n    ```python\nimport heapq\n\ndef min_build_time(blocks, split):\n    heapq.heapify(blocks)\n    \n    while len(blocks) > 1:\n        a = heapq.heappop(blocks)\n        b = heapq.heappop(blocks)\n        heapq.heappush(blocks, b + split)\n    \n    return blocks[0]\n```\n    \n    We use a priority queue to get the smallest time units of the blocks. In each iteration, we get the two smallest time units and insert the larger one plus the split time back into the priority queue. This is repeated until there is only one element left in the priority queue.\n\nThis results in the workers splitting and working on the blocks with the smallest time units.\n\nInitially, we insert all blocks' time units into the priority queue. Then we enter a loop where we get the two smallest elements (a and b), pop them from the priority queue, and add (b + split) back into the priority queue. We keep doing this until there's only one element left in the priority queue.\n\nFinally, we return the last remaining element as the minimum time needed to build all blocks.\n    ", "javascript": "\n    ```javascript\nfunction minBuildTime(blocks, split) {\n    const pq = new PriorityQueue();\n    for (const block of blocks) {\n        pq.add(block);\n    }\n    \n    while (pq.size() > 1) {\n        const a = pq.poll();\n        const b = pq.poll();\n        pq.add(b + split);\n    }\n    \n    return pq.poll();\n}\n```\n    \n    We use a priority queue to get the smallest time units of the blocks. In each iteration, we get the two smallest time units and insert the larger one plus the split time back into the priority queue. This is repeated until there is only one element left in the priority queue.\n\nThis results in the workers splitting and working on the blocks with the smallest time units.\n\nInitially, we insert all blocks' time units into the priority queue. Then we enter a loop where we get the two smallest elements (a and b), pop them from the priority queue, and add (b + split) back into the priority queue. We keep doing this until there's only one element left in the priority queue.\n\nFinally, we return the last remaining element as the minimum time needed to build all blocks.\n    "}
{"id": 1217, "slug": "minimum-cost-to-move-chips-to-the-same-position", "title": "Minimum Cost to Move Chips to The Same Position", "difficulty": "Easy", "content": "We have `n` chips, where the position of the `ith` chip is `position[i]`.\n\nWe need to move all the chips to **the same position**. In one step, we can change the position of the `ith` chip from `position[i]` to:\n\n*   `position[i] + 2` or `position[i] - 2` with `cost = 0`.\n*   `position[i] + 1` or `position[i] - 1` with `cost = 1`.\n\nReturn _the minimum cost_ needed to move all the chips to the same position.\n\n**Example 1:**\n\n**Input:** position = \\[1,2,3\\]\n**Output:** 1\n**Explanation:** First step: Move the chip at position 3 to position 1 with cost = 0.\nSecond step: Move the chip at position 2 to position 1 with cost = 1.\nTotal cost is 1.\n\n**Example 2:**\n\n**Input:** position = \\[2,2,2,3,3\\]\n**Output:** 2\n**Explanation:** We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.\n\n**Example 3:**\n\n**Input:** position = \\[1,1000000000\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= position.length <= 100`\n*   `1 <= position[i] <= 10^9`", "java": "\n    ```java\npublic void sortArray(int[] arr1, int[] arr2) {\n    HashMap<Integer, Integer> counts = new HashMap<>();\n\n    for (int num : arr1) {\n        counts.put(num, counts.getOrDefault(num, 0) + 1);\n    }\n\n    int index = 0;\n    for (int num : arr2) {\n        while (counts.get(num) > 0) {\n            arr1[index++] = num;\n            counts.put(num, counts.get(num) - 1);\n        }\n    }\n\n    Arrays.sort(arr1, index, arr1.length);\n}\n```\n    \n    1. Create a dictionary `counts` to store the count of each number in `arr1`.\n2. Iterate through the elements of `arr2`. For each element, add that element to the result `n` times where `n` is the count of that element in `arr1`. Remove the element from the `counts` dictionary.\n3. Iterate through the sorted keys of the remaining elements in `counts`. For each key, append the key to the result `n` times where `n` is the count of that element in `arr1`.\n4. Return the resulting sorted array.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <map>\n#include <algorithm>\n\nvoid sortArray(vector<int>& arr1, vector<int>& arr2) {\n    map<int, int> counts;\n\n    for (int num : arr1) {\n        counts[num]++;\n    }\n    int index = 0;\n    for (int num : arr2) {\n        while (counts[num]--) {\n            arr1[index++] = num;\n        }\n    }\n    for (auto &pair : counts) {\n        while (pair.second--) {\n            arr1[index++] = pair.first;\n        }\n    }\n}\n```\n    \n    1. Create a dictionary `counts` to store the count of each number in `arr1`.\n2. Iterate through the elements of `arr2`. For each element, add that element to the result `n` times where `n` is the count of that element in `arr1`. Remove the element from the `counts` dictionary.\n3. Iterate through the sorted keys of the remaining elements in `counts`. For each key, append the key to the result `n` times where `n` is the count of that element in `arr1`.\n4. Return the resulting sorted array.\n    ", "python": "\n    ```python\ndef sort_array(arr1, arr2):\n    counts = {}\n    result = []\n\n    for num in arr1:\n        counts[num] = counts.get(num, 0) + 1\n\n    for num in arr2:\n        if num in counts:\n            result.extend([num] * counts[num])\n            del counts[num]\n\n    for num in sorted(counts.keys()):\n        result.extend([num] * counts[num])\n\n    return result\n```\n    \n    1. Create a dictionary `counts` to store the count of each number in `arr1`.\n2. Iterate through the elements of `arr2`. For each element, add that element to the result `n` times where `n` is the count of that element in `arr1`. Remove the element from the `counts` dictionary.\n3. Iterate through the sorted keys of the remaining elements in `counts`. For each key, append the key to the result `n` times where `n` is the count of that element in `arr1`.\n4. Return the resulting sorted array.\n    ", "javascript": "\n    ```javascript\nfunction sortArray(arr1, arr2) {\n    const counts = new Map();\n\n    for (const num of arr1) {\n        counts.set(num, (counts.get(num) || 0) + 1);\n    }\n\n    const result = [];\n\n    for (const num of arr2) {\n        while (counts.get(num) > 0) {\n            result.push(num);\n            counts.set(num, counts.get(num) - 1);\n        }\n    }\n\n    Array.from(counts.entries())\n        .sort(([a], [b]) => a - b)\n        .forEach(([num, count]) => {\n            while (count--) {\n                result.push(num);\n            }\n        });\n\n    return result;\n}\n```\n    \n    1. Create a dictionary `counts` to store the count of each number in `arr1`.\n2. Iterate through the elements of `arr2`. For each element, add that element to the result `n` times where `n` is the count of that element in `arr1`. Remove the element from the `counts` dictionary.\n3. Iterate through the sorted keys of the remaining elements in `counts`. For each key, append the key to the result `n` times where `n` is the count of that element in `arr1`.\n4. Return the resulting sorted array.\n    "}
{"id": 1221, "slug": "split-a-string-in-balanced-strings", "title": "Split a String in Balanced Strings", "difficulty": "Easy", "content": "**Balanced** strings are those that have an equal quantity of `'L'` and `'R'` characters.\n\nGiven a **balanced** string `s`, split it into some number of substrings such that:\n\n*   Each substring is balanced.\n\nReturn _the **maximum** number of balanced strings you can obtain._\n\n**Example 1:**\n\n**Input:** s =  \"RLRRLLRLRL \"\n**Output:** 4\n**Explanation:** s can be split into  \"RL \",  \"RRLL \",  \"RL \",  \"RL \", each substring contains same number of 'L' and 'R'.\n\n**Example 2:**\n\n**Input:** s =  \"RLRRRLLRLL \"\n**Output:** 2\n**Explanation:** s can be split into  \"RL \",  \"RRRLLRLL \", each substring contains same number of 'L' and 'R'.\nNote that s cannot be split into  \"RL \",  \"RR \",  \"RL \",  \"LR \",  \"LL \", because the 2nd and 5th substrings are not balanced.\n\n**Example 3:**\n\n**Input:** s =  \"LLLLRRRR \"\n**Output:** 1\n**Explanation:** s can be split into  \"LLLLRRRR \".\n\n**Constraints:**\n\n*   `2 <= s.length <= 1000`\n*   `s[i]` is either `'L'` or `'R'`.\n*   `s` is a **balanced** string.", "java": "\n    ```java\npublic int findSpecialInteger(int[] arr) {\n    int n = arr.length, requiredCount = n / 4;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == arr[i + requiredCount]) {\n            return arr[i];\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through the sorted array once. At each iteration, it compares the current integer with the integer that's \"requiredCount\" positions ahead (where \"requiredCount\" is the number of elements divided by 4). If the two integers are the same, it means that the integer occurs more than 25% of the time in the array, and it is returned. If no such integer is found, the algorithm returns -1, which should not happen according to the problem constraints. The time complexity is O(n), where n is the number of elements in the array.\n    ", "c++": "\n    ```cpp\nint findSpecialInteger(const vector<int>& arr) {\n    int n = arr.size(), requiredCount = n / 4;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == arr[i + requiredCount]) {\n            return arr[i];\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through the sorted array once. At each iteration, it compares the current integer with the integer that's \"requiredCount\" positions ahead (where \"requiredCount\" is the number of elements divided by 4). If the two integers are the same, it means that the integer occurs more than 25% of the time in the array, and it is returned. If no such integer is found, the algorithm returns -1, which should not happen according to the problem constraints. The time complexity is O(n), where n is the number of elements in the array.\n    ", "python": "\n    ```python\ndef find_special_integer(arr):\n    n = len(arr)\n    required_count = n // 4\n    for i in range(n):\n        if arr[i] == arr[i + required_count]:\n            return arr[i]\n    return -1\n```\n    \n    The algorithm iterates through the sorted array once. At each iteration, it compares the current integer with the integer that's \"requiredCount\" positions ahead (where \"requiredCount\" is the number of elements divided by 4). If the two integers are the same, it means that the integer occurs more than 25% of the time in the array, and it is returned. If no such integer is found, the algorithm returns -1, which should not happen according to the problem constraints. The time complexity is O(n), where n is the number of elements in the array.\n    ", "javascript": "\n    ```javascript\nfunction findSpecialInteger(arr) {\n    let n = arr.length, requiredCount = Math.floor(n / 4);\n    for (let i = 0; i < n; i++) {\n        if (arr[i] === arr[i + requiredCount]) {\n            return arr[i];\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through the sorted array once. At each iteration, it compares the current integer with the integer that's \"requiredCount\" positions ahead (where \"requiredCount\" is the number of elements divided by 4). If the two integers are the same, it means that the integer occurs more than 25% of the time in the array, and it is returned. If no such integer is found, the algorithm returns -1, which should not happen according to the problem constraints. The time complexity is O(n), where n is the number of elements in the array.\n    "}
{"id": 1247, "slug": "minimum-swaps-to-make-strings-equal", "title": "Minimum Swaps to Make Strings Equal", "difficulty": "Medium", "content": "You are given two strings `s1` and `s2` of equal length consisting of letters `\"x \"` and `\"y \"` **only**. Your task is to make these two strings equal to each other. You can swap any two characters that belong to **different** strings, which means: swap `s1[i]` and `s2[j]`.\n\nReturn the minimum number of swaps required to make `s1` and `s2` equal, or return `-1` if it is impossible to do so.\n\n**Example 1:**\n\n**Input:** s1 =  \"xx \", s2 =  \"yy \"\n**Output:** 1\n**Explanation:** Swap s1\\[0\\] and s2\\[1\\], s1 =  \"yx \", s2 =  \"yx \".\n\n**Example 2:**\n\n**Input:** s1 =  \"xy \", s2 =  \"yx \"\n**Output:** 2\n**Explanation:** Swap s1\\[0\\] and s2\\[0\\], s1 =  \"yy \", s2 =  \"xx \".\nSwap s1\\[0\\] and s2\\[1\\], s1 =  \"xy \", s2 =  \"xy \".\nNote that you cannot swap s1\\[0\\] and s1\\[1\\] to make s1 equal to  \"yx \", cause we can only swap chars in different strings.\n\n**Example 3:**\n\n**Input:** s1 =  \"xx \", s2 =  \"xy \"\n**Output:** -1\n\n**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 1000`\n*   `s1.length == s2.length`\n*   `s1, s2` only contain `'x'` or `'y'`.", "java": "\n    ```java\nint movesToMakeZigzag(int[] nums) {\n    int moves1 = 0, moves2 = 0;\n    for (int i = 0; i < nums.length; i++) {\n        int left = i > 0 ? nums[i - 1] : Integer.MAX_VALUE;\n        int right = i + 1 < nums.length ? nums[i + 1] : Integer.MAX_VALUE;\n        int diff1 = nums[i] - Math.min(left, right) + 1;\n        int diff2 = nums[i] - Math.min(left, right) + 1;\n        if (i % 2 == 0) {\n            moves1 += Math.max(0, diff1);\n        } else {\n            moves2 += Math.max(0, diff2);\n        }\n    }\n    return Math.min(moves1, moves2);\n}\n```\n    \n    The algorithm iterates through the input array and calculates the number of moves required to create a zigzag pattern for both even and odd positions. At each position i, it calculates the minimum value between the left and right neighbors and then the difference between the current value and the minimum neighbor value. The difference is added to the total moves for even and odd positions depending on the index. Finally, the minimum of the total moves for both even and odd positions is returned as the result.\n    ", "c++": "\n    ```cpp\nint movesToMakeZigzag(std::vector<int>& nums) {\n    int moves1 = 0, moves2 = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        int left = i > 0 ? nums[i - 1] : INT_MAX;\n        int right = i + 1 < nums.size() ? nums[i + 1] : INT_MAX;\n        int diff1 = nums[i] - std::min(left, right) + 1;\n        int diff2 = nums[i] - std::min(left, right) + 1;\n        if (i % 2 == 0) {\n            moves1 += std::max(0, diff1);\n        } else {\n            moves2 += std::max(0, diff2);\n        }\n    }\n    return std::min(moves1, moves2);\n}\n```\n    \n    The algorithm iterates through the input array and calculates the number of moves required to create a zigzag pattern for both even and odd positions. At each position i, it calculates the minimum value between the left and right neighbors and then the difference between the current value and the minimum neighbor value. The difference is added to the total moves for even and odd positions depending on the index. Finally, the minimum of the total moves for both even and odd positions is returned as the result.\n    ", "python": "\n    ```python\ndef moves_to_make_zigzag(nums):\n    moves1, moves2 = 0, 0\n    for i in range(len(nums)):\n        left = nums[i - 1] if i > 0 else float('inf')\n        right = nums[i + 1] if i + 1 < len(nums) else float('inf')\n        diff1 = nums[i] - min(left, right) + 1\n        diff2 = nums[i] - min(left, right) + 1\n        if i % 2 == 0:\n            moves1 += max(0, diff1)\n        else:\n            moves2 += max(0, diff2)\n    return min(moves1, moves2)\n```\n    \n    The algorithm iterates through the input array and calculates the number of moves required to create a zigzag pattern for both even and odd positions. At each position i, it calculates the minimum value between the left and right neighbors and then the difference between the current value and the minimum neighbor value. The difference is added to the total moves for even and odd positions depending on the index. Finally, the minimum of the total moves for both even and odd positions is returned as the result.\n    ", "javascript": "\n    ```javascript\nfunction movesToMakeZigzag(nums) {\n    let moves1 = 0, moves2 = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let left = i > 0 ? nums[i - 1] : Number.MAX_VALUE;\n        let right = i + 1 < nums.length ? nums[i + 1] : Number.MAX_VALUE;\n        let diff1 = nums[i] - Math.min(left, right) + 1;\n        let diff2 = nums[i] - Math.min(left, right) + 1;\n        if (i % 2 === 0) {\n            moves1 += Math.max(0, diff1);\n        } else {\n            moves2 += Math.max(0, diff2);\n        }\n    }\n    return Math.min(moves1, moves2);\n}\n```\n    \n    The algorithm iterates through the input array and calculates the number of moves required to create a zigzag pattern for both even and odd positions. At each position i, it calculates the minimum value between the left and right neighbors and then the difference between the current value and the minimum neighbor value. The difference is added to the total moves for even and odd positions depending on the index. Finally, the minimum of the total moves for both even and odd positions is returned as the result.\n    "}
{"id": 1253, "slug": "reconstruct-a-2-row-binary-matrix", "title": "Reconstruct a 2-Row Binary Matrix", "difficulty": "Medium", "content": "Given the following details of a matrix with `n` columns and `2` rows :\n\n*   The matrix is a binary matrix, which means each element in the matrix can be `0` or `1`.\n*   The sum of elements of the 0-th(upper) row is given as `upper`.\n*   The sum of elements of the 1-st(lower) row is given as `lower`.\n*   The sum of elements in the i-th column(0-indexed) is `colsum[i]`, where `colsum` is given as an integer array with length `n`.\n\nYour task is to reconstruct the matrix with `upper`, `lower` and `colsum`.\n\nReturn it as a 2-D integer array.\n\nIf there are more than one valid solution, any of them will be accepted.\n\nIf no valid solution exists, return an empty 2-D array.\n\n**Example 1:**\n\n**Input:** upper = 2, lower = 1, colsum = \\[1,1,1\\]\n**Output:** \\[\\[1,1,0\\],\\[0,0,1\\]\\]\n**Explanation:** \\[\\[1,0,1\\],\\[0,1,0\\]\\], and \\[\\[0,1,1\\],\\[1,0,0\\]\\] are also correct answers.\n\n**Example 2:**\n\n**Input:** upper = 2, lower = 3, colsum = \\[2,2,1,1\\]\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** upper = 5, lower = 5, colsum = \\[2,1,2,0,1,0,1,2,0,1\\]\n**Output:** \\[\\[1,1,1,0,1,0,0,1,0,0\\],\\[1,0,1,0,0,0,1,1,0,1\\]\\]\n\n**Constraints:**\n\n*   `1 <= colsum.length <= 10^5`\n*   `0 <= upper, lower <= colsum.length`\n*   `0 <= colsum[i] <= 2`", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int[][] diagonalSort(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        for (int i = 0; i < m; ++i) {\n            PriorityQueue<Integer> pq = new PriorityQueue<>();\n            int row = i, col = 0;\n            while (row < m && col < n) {\n                pq.offer(mat[row++][col++]);\n            }\n            row = i; col = 0;\n            while (row < m && col < n) {\n                mat[row++][col++] = pq.poll();\n            }\n        }\n        for (int i = 1; i < n; ++i) {\n            PriorityQueue<Integer> pq = new PriorityQueue<>();\n            int row = 0, col = i;\n            while (row < m && col < n) {\n                pq.offer(mat[row++][col++]);\n            }\n            row = 0; col = i;\n            while (row < m && col < n) {\n                mat[row++][col++] = pq.poll();\n            }\n        }\n        return mat;\n    }\n}\n```\n\n    \n    For each starting cells `(i, 0)` (top row) and `(0, j)` (left column), we first iterate through the cells that belong to its diagonal and push their values into a min heap (priority queue). This way, we have the values sorted in ascending order for each diagonal. After that, we iterate again over the same cells, popping from the priority queue and replacing the cell values with the sorted values. We do this process for all the diagonals.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\n    int m = mat.size(), n = mat[0].size();\n    for (int i = 0; i < m; ++i) {\n        priority_queue<int, vector<int>, greater<>> pq;\n        int row = i, col = 0;\n        while (row < m && col < n) {\n            pq.push(mat[row++][col++]);\n        }\n        row = i, col = 0;\n        while (row < m && col < n) {\n            mat[row++][col++] = pq.top();\n            pq.pop();\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        priority_queue<int, vector<int>, greater<>> pq;\n        int row = 0, col = i;\n        while (row < m && col < n) {\n            pq.push(mat[row++][col++]);\n        }\n        row = 0, col = i;\n        while (row < m && col < n) {\n            mat[row++][col++] = pq.top();\n            pq.pop();\n        }\n    }\n    return mat;\n}\n```\n\n    \n    For each starting cells `(i, 0)` (top row) and `(0, j)` (left column), we first iterate through the cells that belong to its diagonal and push their values into a min heap (priority queue). This way, we have the values sorted in ascending order for each diagonal. After that, we iterate again over the same cells, popping from the priority queue and replacing the cell values with the sorted values. We do this process for all the diagonals.\n    ", "python": "\n    ```python\nfrom heapq import heappush, heappop\n\ndef diagonalSort(mat):\n    m, n = len(mat), len(mat[0])\n    for i in range(m):\n        pq = []\n        row, col = i, 0\n        while row < m and col < n:\n            heappush(pq, mat[row][col])\n            row += 1\n            col += 1\n        row, col = i, 0\n        while row < m and col < n:\n            mat[row][col] = heappop(pq)\n            row += 1\n            col += 1\n        \n    for i in range(1, n):\n        pq = []\n        row, col = 0, i\n        while row < m and col < n:\n            heappush(pq, mat[row][col])\n            row += 1\n            col += 1\n        row, col = 0, i\n        while row < m and col < n:\n            mat[row][col] = heappop(pq)\n            row += 1\n            col += 1\n    return mat\n```\n\n    \n    For each starting cells `(i, 0)` (top row) and `(0, j)` (left column), we first iterate through the cells that belong to its diagonal and push their values into a min heap (priority queue). This way, we have the values sorted in ascending order for each diagonal. After that, we iterate again over the same cells, popping from the priority queue and replacing the cell values with the sorted values. We do this process for all the diagonals.\n    ", "javascript": "\n    ```javascript\nfunction diagonalSort(mat) {\n    const m = mat.length, n = mat[0].length;\n    for (let i = 0; i < m; ++i) {\n        let pq = [];\n        let [row, col] = [i, 0];\n        while (row < m && col < n) {\n            pq.push(mat[row++][col++]);\n        }\n        pq.sort((a, b) => a - b);\n        [row, col] = [i, 0];\n        while (row < m && col < n) {\n            mat[row++][col++] = pq.shift();\n        }\n    }\n    for (let i = 1; i < n; ++i) {\n        let pq = [];\n        let [row, col] = [0, i];\n        while (row < m && col < n) {\n            pq.push(mat[row++][col++]);\n        }\n        pq.sort((a, b) => a - b);\n        [row, col] = [0, i];\n        while (row < m && col < n) {\n            mat[row++][col++] = pq.shift();\n        }\n    }\n    return mat;\n}\n```\n\n    \n    For each starting cells `(i, 0)` (top row) and `(0, j)` (left column), we first iterate through the cells that belong to its diagonal and push their values into a min heap (priority queue). This way, we have the values sorted in ascending order for each diagonal. After that, we iterate again over the same cells, popping from the priority queue and replacing the cell values with the sorted values. We do this process for all the diagonals.\n    "}
{"id": 1262, "slug": "greatest-sum-divisible-by-three", "title": "Greatest Sum Divisible by Three", "difficulty": "Medium", "content": "Given an integer array `nums`, return _the **maximum possible sum** of elements of the array such that it is divisible by three_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,6,5,1,8\\]\n**Output:** 18\n**Explanation:** Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).\n\n**Example 2:**\n\n**Input:** nums = \\[4\\]\n**Output:** 0\n**Explanation:** Since 4 is not divisible by 3, do not pick any number.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,4\\]\n**Output:** 12\n**Explanation:** Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).\n\n**Constraints:**\n\n*   `1 <= nums.length <= 4 * 104`\n*   `1 <= nums[i] <= 104`", "java": "\n    ```java\nimport java.util.*;\n\nclass MajorityChecker {\n    Map<Integer, List<Integer>> positions;\n    int[] arr;\n\n    public MajorityChecker(int[] arr) {\n        this.arr = arr;\n        positions = new HashMap<>();\n        for(int i = 0; i < arr.length; i++) {\n            positions.computeIfAbsent(arr[i], x -> new ArrayList<>()).add(i);\n        }\n    }\n\n    public int query(int left, int right, int threshold) {\n        Random rnd = new Random();\n        for(int i = 0; i < 20; i++) {\n            int randomIndex = rnd.nextInt(right - left + 1) + left;\n            int num = positions.get(arr[randomIndex]).size();\n            if (num >= threshold) {\n                int lb = Collections.binarySearch(positions.get(arr[randomIndex]), left);\n                int ub = Collections.binarySearch(positions.get(arr[randomIndex]), right + 1);\n                if(lb < 0) lb = ~lb;\n                if(ub < 0) ub = ~ub;\n                if(ub - lb >= threshold) return arr[randomIndex];\n            }\n        }\n        return -1;\n    }\n}  \n```\n    \n    The MajorityChecker class utilizes an unordered_map (in C++) / HashMap (in Java) / defaultdict (in Python) / Map (in JS) to store the positions of each element in the array. When initializing the class, the positions map is built accordingly. When querying the majority element, we use the Boyer-Moore Majority Vote algorithm with randomization:\n\n1. Select a random index within the range of the subarray.\n2. Check if the selected element occurs threshold times or more in the whole array (using the size of the stored positions).\n3. If it occurs threshold times or more, check if it occurs threshold times or more in the subarray (using the lower_bound and upper_bound functions).\n4. If it occurs threshold times or more within the subarray, return the element as majority.\n5. Repeat steps 1-4 for 20 iterations. If no majority element is found, return -1 as no majority found.\n\nThe lower_bound and upper_bound functions help to find the first index at which the target is greater than or equal to the existing element and the first index which is greater than the target, respectively.\n\nThe algorithm works effectively as the majority element occurs more than half of the times, so the probability of picking it randomly in the 20 iterations is very high.\n    ", "c++": "\n    ```cpp\nclass MajorityChecker {\npublic:\n    MajorityChecker(vector<int>& arr) {\n        for(int i = 0; i < arr.size(); i++) {\n            positions[arr[i]].push_back(i);\n        }\n    }\n    \n    int query(int left, int right, int threshold) {\n        for(int i = 0; i < 20; i++) {\n            int randomIndex = rand() % (right - left + 1) + left;\n            int num = positions[arr[randomIndex]].size();\n            if (num >= threshold) {\n                auto lb = lower_bound(positions[arr[randomIndex]].begin(), positions[arr[randomIndex]].end(), left);\n                auto ub = upper_bound(positions[arr[randomIndex]].begin(), positions[arr[randomIndex]].end(), right);\n                if(ub - lb >= threshold) return arr[randomIndex];\n            }\n        }\n        return -1;\n    }\nprivate:\n    unordered_map<int, vector<int>> positions;\n};\n```\n    \n    The MajorityChecker class utilizes an unordered_map (in C++) / HashMap (in Java) / defaultdict (in Python) / Map (in JS) to store the positions of each element in the array. When initializing the class, the positions map is built accordingly. When querying the majority element, we use the Boyer-Moore Majority Vote algorithm with randomization:\n\n1. Select a random index within the range of the subarray.\n2. Check if the selected element occurs threshold times or more in the whole array (using the size of the stored positions).\n3. If it occurs threshold times or more, check if it occurs threshold times or more in the subarray (using the lower_bound and upper_bound functions).\n4. If it occurs threshold times or more within the subarray, return the element as majority.\n5. Repeat steps 1-4 for 20 iterations. If no majority element is found, return -1 as no majority found.\n\nThe lower_bound and upper_bound functions help to find the first index at which the target is greater than or equal to the existing element and the first index which is greater than the target, respectively.\n\nThe algorithm works effectively as the majority element occurs more than half of the times, so the probability of picking it randomly in the 20 iterations is very high.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\nfrom random import randint\n\nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.positions = defaultdict(list)\n        for i, num in enumerate(arr):\n            self.positions[num].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for _ in range(20):\n            randomIndex = randint(left, right)\n            num = self.arr[randomIndex]\n            lb = self.lower_bound(self.positions[num], left)\n            ub = self.upper_bound(self.positions[num], right)\n            if ub - lb >= threshold:\n                return num\n        return -1\n\n    def lower_bound(self, nums, target):\n        l, r = 0, len(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid\n        return l\n\n    def upper_bound(self, nums, target):\n        l, r = 0, len(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] <= target:\n                l = mid + 1\n            else:\n                r = mid\n        return l\n```\n    \n    The MajorityChecker class utilizes an unordered_map (in C++) / HashMap (in Java) / defaultdict (in Python) / Map (in JS) to store the positions of each element in the array. When initializing the class, the positions map is built accordingly. When querying the majority element, we use the Boyer-Moore Majority Vote algorithm with randomization:\n\n1. Select a random index within the range of the subarray.\n2. Check if the selected element occurs threshold times or more in the whole array (using the size of the stored positions).\n3. If it occurs threshold times or more, check if it occurs threshold times or more in the subarray (using the lower_bound and upper_bound functions).\n4. If it occurs threshold times or more within the subarray, return the element as majority.\n5. Repeat steps 1-4 for 20 iterations. If no majority element is found, return -1 as no majority found.\n\nThe lower_bound and upper_bound functions help to find the first index at which the target is greater than or equal to the existing element and the first index which is greater than the target, respectively.\n\nThe algorithm works effectively as the majority element occurs more than half of the times, so the probability of picking it randomly in the 20 iterations is very high.\n    ", "javascript": "\n    ```javascript\nclass MajorityChecker {\n    constructor(arr) {\n        this.arr = arr;\n        this.positions = new Map();\n        for(let i = 0; i < arr.length; i++) {\n            if (!this.positions.has(arr[i])) this.positions.set(arr[i], []);\n            this.positions.get(arr[i]).push(i);\n        }\n    }\n\n    query(left, right, threshold) {\n        for(let i = 0; i < 20; i++) {\n            let randomIndex = Math.floor(Math.random() * (right - left + 1)) + left;\n            let num = this.positions.get(this.arr[randomIndex]).length;\n            if (num >= threshold) {\n                let lb = this.lower_bound(this.positions.get(this.arr[randomIndex]), left);\n                let ub = this.upper_bound(this.positions.get(this.arr[randomIndex]), right);\n                if(ub - lb >= threshold) return this.arr[randomIndex];\n            }\n        }\n        return -1;\n    }\n\n    lower_bound(nums, target) {\n        let l = 0, r = nums.length;\n        while (l < r) {\n            let mid = Math.floor((l + r) / 2);\n            if (nums[mid] < target) l = mid + 1;\n            else r = mid;\n        }\n        return l;\n    }\n\n    upper_bound(nums, target) {\n        let l = 0, r = nums.length;\n        while (l < r) {\n            let mid = Math.floor((l + r) / 2);\n            if (nums[mid] <= target) l = mid + 1;\n            else r = mid;\n        }\n        return l;\n    }\n}\n```\n    \n    The MajorityChecker class utilizes an unordered_map (in C++) / HashMap (in Java) / defaultdict (in Python) / Map (in JS) to store the positions of each element in the array. When initializing the class, the positions map is built accordingly. When querying the majority element, we use the Boyer-Moore Majority Vote algorithm with randomization:\n\n1. Select a random index within the range of the subarray.\n2. Check if the selected element occurs threshold times or more in the whole array (using the size of the stored positions).\n3. If it occurs threshold times or more, check if it occurs threshold times or more in the subarray (using the lower_bound and upper_bound functions).\n4. If it occurs threshold times or more within the subarray, return the element as majority.\n5. Repeat steps 1-4 for 20 iterations. If no majority element is found, return -1 as no majority found.\n\nThe lower_bound and upper_bound functions help to find the first index at which the target is greater than or equal to the existing element and the first index which is greater than the target, respectively.\n\nThe algorithm works effectively as the majority element occurs more than half of the times, so the probability of picking it randomly in the 20 iterations is very high.\n    "}
{"id": 1282, "slug": "group-the-people-given-the-group-size-they-belong-to", "title": "Group the People Given the Group Size They Belong To", "difficulty": "Medium", "content": "There are `n` people that are split into some unknown number of groups. Each person is labeled with a **unique ID** from `0` to `n - 1`.\n\nYou are given an integer array `groupSizes`, where `groupSizes[i]` is the size of the group that person `i` is in. For example, if `groupSizes[1] = 3`, then person `1` must be in a group of size `3`.\n\nReturn _a list of groups such that each person `i` is in a group of size `groupSizes[i]`_.\n\nEach person should appear in **exactly one group**, and every person must be in a group. If there are multiple answers, **return any of them**. It is **guaranteed** that there will be **at least one** valid solution for the given input.\n\n**Example 1:**\n\n**Input:** groupSizes = \\[3,3,3,3,3,1,3\\]\n**Output:** \\[\\[5\\],\\[0,1,2\\],\\[3,4,6\\]\\]\n**Explanation:** \nThe first group is \\[5\\]. The size is 1, and groupSizes\\[5\\] = 1.\nThe second group is \\[0,1,2\\]. The size is 3, and groupSizes\\[0\\] = groupSizes\\[1\\] = groupSizes\\[2\\] = 3.\nThe third group is \\[3,4,6\\]. The size is 3, and groupSizes\\[3\\] = groupSizes\\[4\\] = groupSizes\\[6\\] = 3.\nOther possible solutions are \\[\\[2,1,6\\],\\[5\\],\\[0,4,3\\]\\] and \\[\\[5\\],\\[0,6,2\\],\\[4,3,1\\]\\].\n\n**Example 2:**\n\n**Input:** groupSizes = \\[2,1,3,3,3,2\\]\n**Output:** \\[\\[1\\],\\[0,5\\],\\[2,3,4\\]\\]\n\n**Constraints:**\n\n*   `groupSizes.length == n`\n*   `1 <= n <= 500`\n*   `1 <= groupSizes[i] <= n`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<List<Integer>> groupThePeople(int[] groupSizes) {\n    Map<Integer, List<Integer>> groups = new HashMap<>();\n    List<List<Integer>> result = new ArrayList<>();\n\n    for (int i = 0; i < groupSizes.length; i++) {\n        groups.computeIfAbsent(groupSizes[i], k -> new ArrayList<>()).add(i);\n\n        if (groups.get(groupSizes[i]).size() == groupSizes[i]) {\n            result.add(groups.get(groupSizes[i]));\n            groups.put(groupSizes[i], new ArrayList<>());\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a hash map (unordered_map in C++, HashMap in Java, defaultdict in Python, plain object in JavaScript) to store the groups for each group size. For each person, their group size is added as a key if it doesn't exist, and then the person's index is added to the group.\n\nWhen a group reaches the size defined by the key, it appends this group to the result list and clears the group from the hash map.\n\nFinally, it returns the result list containing the groups with each person in their corresponding group size.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nstd::vector<std::vector<int>> groupThePeople(std::vector<int>& groupSizes) {\n    std::unordered_map<int, std::vector<int>> groups;\n    std::vector<std::vector<int>> result;\n    \n    for (int i = 0; i < groupSizes.size(); i++) {\n        groups[groupSizes[i]].push_back(i);\n        if (groups[groupSizes[i]].size() == groupSizes[i]) {\n            result.push_back(groups[groupSizes[i]]);\n            groups[groupSizes[i]].clear();\n        }\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm uses a hash map (unordered_map in C++, HashMap in Java, defaultdict in Python, plain object in JavaScript) to store the groups for each group size. For each person, their group size is added as a key if it doesn't exist, and then the person's index is added to the group.\n\nWhen a group reaches the size defined by the key, it appends this group to the result list and clears the group from the hash map.\n\nFinally, it returns the result list containing the groups with each person in their corresponding group size.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\n\ndef groupThePeople(groupSizes):\n    groups = defaultdict(list)\n    result = []\n\n    for i, size in enumerate(groupSizes):\n        groups[size].append(i)\n        if len(groups[size]) == size:\n            result.append(groups[size])\n            groups[size] = []\n\n    return result\n```\n    \n    The algorithm uses a hash map (unordered_map in C++, HashMap in Java, defaultdict in Python, plain object in JavaScript) to store the groups for each group size. For each person, their group size is added as a key if it doesn't exist, and then the person's index is added to the group.\n\nWhen a group reaches the size defined by the key, it appends this group to the result list and clears the group from the hash map.\n\nFinally, it returns the result list containing the groups with each person in their corresponding group size.\n    ", "javascript": "\n    ```javascript\nfunction groupThePeople(groupSizes) {\n    const groups = {};\n    const result = [];\n\n    for (let i = 0; i < groupSizes.length; i++) {\n        const size = groupSizes[i];\n        if (!groups[size]) {\n            groups[size] = [];\n        }\n        groups[size].push(i);\n\n        if (groups[size].length === size) {\n            result.push(groups[size]);\n            groups[size] = [];\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a hash map (unordered_map in C++, HashMap in Java, defaultdict in Python, plain object in JavaScript) to store the groups for each group size. For each person, their group size is added as a key if it doesn't exist, and then the person's index is added to the group.\n\nWhen a group reaches the size defined by the key, it appends this group to the result list and clears the group from the hash map.\n\nFinally, it returns the result list containing the groups with each person in their corresponding group size.\n    "}
{"id": 1296, "slug": "divide-array-in-sets-of-k-consecutive-numbers", "title": "Divide Array in Sets of K Consecutive Numbers", "difficulty": "Medium", "content": "Given an array of integers `nums` and a positive integer `k`, check whether it is possible to divide this array into sets of `k` consecutive numbers.\n\nReturn `true` _if it is possible_. Otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,3,4,4,5,6\\], k = 4\n**Output:** true\n**Explanation:** Array can be divided into \\[1,2,3,4\\] and \\[3,4,5,6\\].\n\n**Example 2:**\n\n**Input:** nums = \\[3,2,1,2,3,4,3,4,5,9,10,11\\], k = 3\n**Output:** true\n**Explanation:** Array can be divided into \\[1,2,3\\] , \\[2,3,4\\] , \\[3,4,5\\] and \\[9,10,11\\].\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4\\], k = 3\n**Output:** false\n**Explanation:** Each array should be divided in subarrays of size 3.\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\n\n**Note:** This question is the same as 846: [https://leetcode.com/problems/hand-of-straights/](https://leetcode.com/problems/hand-of-straights/)", "java": "\n    ```java\nclass TreeAncestor {\n    int[][] dp;\n\n    public TreeAncestor(int n, int[] parent) {\n        dp = new int[n][20];\n        for (int i = 0; i < n; i++) dp[i][0] = parent[i];\n        for (int k = 1; k < 20; k++)\n            for (int i = 0; i < n; i++)\n                dp[i][k] = dp[i][k - 1] == -1 ? -1 : dp[dp[i][k - 1]][k - 1];\n    }\n\n    public int getKthAncestor(int node, int k) {\n        for (int i = 0; i < 20; i++) {\n            if ((k & (1 << i)) != 0) {\n                node = dp[node][i];\n                if (node == -1) return -1;\n            }\n        }\n        return node;\n    }\n}\n```\n    \n    We preprocess the parent array into a 2D dynamic programming table 'dp' with 20 levels (using binary lifting), where `dp[i][j]` represents the 2^j-th parent of the node i. To find the kth ancestor of a given node, we use a loop to check each bit of the binary representation of k. If the ith bit is set, we update the node to be the 2^i-th ancestor of the current node. We repeat this process for all bits in the binary representation of k. If at any point node becomes -1, we return -1 since the kth ancestor does not exist. Otherwise, the final value of node at the end of the process is the required kth ancestor.\n    ", "c++": "\n    ```cpp\nclass TreeAncestor {\npublic:\n    vector<vector<int>> dp;\n\n    TreeAncestor(int n, vector<int>& parent) {\n        dp.resize(n, vector<int>(20));\n        for (int i = 0; i < n; i++) dp[i][0] = parent[i];\n        for (int k = 1; k < 20; k++)\n            for (int i = 0; i < n; i++)\n                dp[i][k] = dp[i][k - 1] == -1 ? -1 : dp[dp[i][k - 1]][k - 1];\n    }\n\n    int getKthAncestor(int node, int k) {\n        for (int i = 0; i < 20; i++) {\n            if (k & (1 << i)) {\n                node = dp[node][i];\n                if (node == -1) return -1;\n            }\n        }\n        return node;\n    }\n};\n```\n    \n    We preprocess the parent array into a 2D dynamic programming table 'dp' with 20 levels (using binary lifting), where `dp[i][j]` represents the 2^j-th parent of the node i. To find the kth ancestor of a given node, we use a loop to check each bit of the binary representation of k. If the ith bit is set, we update the node to be the 2^i-th ancestor of the current node. We repeat this process for all bits in the binary representation of k. If at any point node becomes -1, we return -1 since the kth ancestor does not exist. Otherwise, the final value of node at the end of the process is the required kth ancestor.\n    ", "python": "\n    ```python\nclass TreeAncestor:\n\n    def __init__(self, n: int, parent: List[int]):\n        self.dp = [[0] * 20 for _ in range(n)]\n        for i in range(n):\n            self.dp[i][0] = parent[i]\n        for k in range(1, 20):\n            for i in range(n):\n                if self.dp[i][k - 1] != -1:\n                    self.dp[i][k] = self.dp[self.dp[i][k - 1]][k - 1]\n                else:\n                    self.dp[i][k] = -1\n\n    def getKthAncestor(self, node: int, k: int) -> int:\n        for i in range(20):\n            if k & (1 << i):\n                node = self.dp[node][i]\n                if node == -1:\n                    return -1\n        return node\n```\n    \n    We preprocess the parent array into a 2D dynamic programming table 'dp' with 20 levels (using binary lifting), where `dp[i][j]` represents the 2^j-th parent of the node i. To find the kth ancestor of a given node, we use a loop to check each bit of the binary representation of k. If the ith bit is set, we update the node to be the 2^i-th ancestor of the current node. We repeat this process for all bits in the binary representation of k. If at any point node becomes -1, we return -1 since the kth ancestor does not exist. Otherwise, the final value of node at the end of the process is the required kth ancestor.\n    ", "javascript": "\n    ```javascript\nclass TreeAncestor {\n    constructor(n, parent) {\n        this.dp = new Array(n).fill(0).map(() => new Array(20).fill(0));\n        for (let i = 0; i < n; i++) this.dp[i][0] = parent[i];\n        for (let k = 1; k < 20; k++)\n            for (let i = 0; i < n; i++)\n                this.dp[i][k] = this.dp[i][k - 1] === -1 ? -1 : this.dp[this.dp[i][k - 1]][k - 1];\n    }\n\n    getKthAncestor(node, k) {\n        for (let i = 0; i < 20; i++) {\n            if (k & (1 << i)) {\n                node = this.dp[node][i];\n                if (node === -1) return -1;\n            }\n        }\n        return node;\n    }\n}\n```\n    \n    We preprocess the parent array into a 2D dynamic programming table 'dp' with 20 levels (using binary lifting), where `dp[i][j]` represents the 2^j-th parent of the node i. To find the kth ancestor of a given node, we use a loop to check each bit of the binary representation of k. If the ith bit is set, we update the node to be the 2^i-th ancestor of the current node. We repeat this process for all bits in the binary representation of k. If at any point node becomes -1, we return -1 since the kth ancestor does not exist. Otherwise, the final value of node at the end of the process is the required kth ancestor.\n    "}
{"id": 1323, "slug": "maximum-69-number", "title": "Maximum 69 Number", "difficulty": "Easy", "content": "You are given a positive integer `num` consisting only of digits `6` and `9`.\n\nReturn _the maximum number you can get by changing **at most** one digit (_`6` _becomes_ `9`_, and_ `9` _becomes_ `6`_)_.\n\n**Example 1:**\n\n**Input:** num = 9669\n**Output:** 9969\n**Explanation:** \nChanging the first digit results in 6669.\nChanging the second digit results in 9969.\nChanging the third digit results in 9699.\nChanging the fourth digit results in 9666.\nThe maximum number is 9969.\n\n**Example 2:**\n\n**Input:** num = 9996\n**Output:** 9999\n**Explanation:** Changing the last digit 6 to 9 results in the maximum number.\n\n**Example 3:**\n\n**Input:** num = 9999\n**Output:** 9999\n**Explanation:** It is better not to apply any change.\n\n**Constraints:**\n\n*   `1 <= num <= 104`\n*   `num` consists of only `6` and `9` digits.", "java": "\n    ```java\npublic int maximum69Number (int num) {\n    String numStr = Integer.toString(num);\n    char[] numArr = numStr.toCharArray();\n    for (int i = 0; i < numArr.length; i++) {\n        if (numArr[i] == '6') {\n            numArr[i] = '9';\n            break;\n        }\n    }\n    return Integer.parseInt(new String(numArr));\n}\n```\n    \n    The algorithm to solve this problem is simple:\n\n1. Convert the integer `num` to a string, so that we can easily manipulate individual digits.\n2. Iterate through the string, looking for the first occurrence of the digit '6'.\n3. When the digit '6' is found, change it to '9' and exit the loop.\n4. Convert the modified string back to an integer and return it.\n\nThis algorithm guarantees that only one digit will be modified at most, and the result will be the maximum value possible under the given constraints.\n    ", "c++": "\n    ```cpp\nint maximum69Number (int num) {\n    string numStr = to_string(num);\n    for (char &c : numStr) {\n        if (c == '6') {\n            c = '9';\n            break;\n        }\n    }\n    return stoi(numStr);\n}\n```\n    \n    The algorithm to solve this problem is simple:\n\n1. Convert the integer `num` to a string, so that we can easily manipulate individual digits.\n2. Iterate through the string, looking for the first occurrence of the digit '6'.\n3. When the digit '6' is found, change it to '9' and exit the loop.\n4. Convert the modified string back to an integer and return it.\n\nThis algorithm guarantees that only one digit will be modified at most, and the result will be the maximum value possible under the given constraints.\n    ", "python": "\n    ```python\ndef maximum69Number(num: int) -> int:\n    num_str = list(str(num))\n    for i in range(len(num_str)):\n        if num_str[i] == '6':\n            num_str[i] = '9'\n            break\n    return int(''.join(num_str))\n```\n    \n    The algorithm to solve this problem is simple:\n\n1. Convert the integer `num` to a string, so that we can easily manipulate individual digits.\n2. Iterate through the string, looking for the first occurrence of the digit '6'.\n3. When the digit '6' is found, change it to '9' and exit the loop.\n4. Convert the modified string back to an integer and return it.\n\nThis algorithm guarantees that only one digit will be modified at most, and the result will be the maximum value possible under the given constraints.\n    ", "javascript": "\n    ```javascript\nfunction maximum69Number(num) {\n    let numStr = num.toString();\n    let numArr = Array.from(numStr);\n    for (let i = 0; i < numArr.length; i++) {\n        if (numArr[i] == '6') {\n            numArr[i] = '9';\n            break;\n        }\n    }\n    return parseInt(numArr.join(''));\n}\n```\n    \n    The algorithm to solve this problem is simple:\n\n1. Convert the integer `num` to a string, so that we can easily manipulate individual digits.\n2. Iterate through the string, looking for the first occurrence of the digit '6'.\n3. When the digit '6' is found, change it to '9' and exit the loop.\n4. Convert the modified string back to an integer and return it.\n\nThis algorithm guarantees that only one digit will be modified at most, and the result will be the maximum value possible under the given constraints.\n    "}
{"id": 1326, "slug": "minimum-number-of-taps-to-open-to-water-a-garden", "title": "Minimum Number of Taps to Open to Water a Garden", "difficulty": "Hard", "content": "There is a one-dimensional garden on the x-axis. The garden starts at the point `0` and ends at the point `n`. (i.e The length of the garden is `n`).\n\nThere are `n + 1` taps located at points `[0, 1, ..., n]` in the garden.\n\nGiven an integer `n` and an integer array `ranges` of length `n + 1` where `ranges[i]` (0-indexed) means the `i-th` tap can water the area `[i - ranges[i], i + ranges[i]]` if it was open.\n\nReturn _the minimum number of taps_ that should be open to water the whole garden, If the garden cannot be watered return **\\-1**.\n\n**Example 1:**\n\n**Input:** n = 5, ranges = \\[3,4,1,1,0,0\\]\n**Output:** 1\n**Explanation:** The tap at point 0 can cover the interval \\[-3,3\\]\nThe tap at point 1 can cover the interval \\[-3,5\\]\nThe tap at point 2 can cover the interval \\[1,3\\]\nThe tap at point 3 can cover the interval \\[2,4\\]\nThe tap at point 4 can cover the interval \\[4,4\\]\nThe tap at point 5 can cover the interval \\[5,5\\]\nOpening Only the second tap will water the whole garden \\[0,5\\]\n\n**Example 2:**\n\n**Input:** n = 3, ranges = \\[0,0,0,0\\]\n**Output:** -1\n**Explanation:** Even if you activate all the four taps you cannot water the whole garden.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\n*   `ranges.length == n + 1`\n*   `0 <= ranges[i] <= 100`", "java": "\n    ```java\npublic int sumOfFlooredPairs(int[] nums) {\n    int mod = 1000000007;\n    int maxVal = Integer.MIN_VALUE;\n    for (int num : nums) {\n        maxVal = Math.max(maxVal, num);\n    }\n    int[] count = new int[maxVal + 1];\n    long[] prefSum = new long[maxVal + 1];\n\n    for (int num : nums) {\n        count[num]++;\n    }\n\n    for (int i = 1; i <= maxVal; i++) {\n        prefSum[i] = (prefSum[i - 1] + count[i]) % mod;\n    }\n\n    long res = 0;\n    for (int x = 1; x <= maxVal; x++) {\n        for (int k = 1, nx = x; nx <= maxVal; k++, nx += x) {\n            res = (res + ((prefSum[nx] - prefSum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod;\n        }\n    }\n    return (int) res;\n}\n```\n    \n    The algorithm first calculates the maximum value present in the array named maxVal. Then it initializes two other arrays: count and prefSum of size (maxVal + 1). The count array stores the frequency count of numbers in the input array, and prefSum stores the prefix sum of count array modulo mod (10^9 + 7).\n\nThe main logic is implemented using nested loops. The outer loop iterates through each unique number (x) in the input array, and the inner loop generates multiples of that number (nx) within the range of the maximum value. For each nx, calculate the result as the product of count[x], k, and the sum of the prefSum values within the range (nx - x) and nx modulo mod. The final result is obtained by summing these products modulo mod for every possible pair of numbers in the input array.\n\nThe time complexity of the algorithm is O(maxVal^2) where maxVal is the maximum value in the input array nums. The space complexity is O(maxVal) due to the count and prefSum arrays.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nint sumOfFlooredPairs(std::vector<int>& nums) {\n    int mod = 1e9 + 7;\n    int maxVal = *max_element(nums.begin(), nums.end());\n    std::vector<int> count(maxVal + 1, 0);\n    std::vector<long long> prefSum(maxVal + 1, 0);\n\n    for (int num : nums) {\n        count[num]++;\n    }\n\n    for (int i = 1; i <= maxVal; i++) {\n        prefSum[i] = (prefSum[i - 1] + count[i]) % mod;\n    }\n\n    long long res = 0;\n    for (int x = 1; x <= maxVal; x++) {\n        for (int k = 1, nx = x; nx <= maxVal; k++, nx += x) {\n            res = (res + ((prefSum[nx] - prefSum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm first calculates the maximum value present in the array named maxVal. Then it initializes two other arrays: count and prefSum of size (maxVal + 1). The count array stores the frequency count of numbers in the input array, and prefSum stores the prefix sum of count array modulo mod (10^9 + 7).\n\nThe main logic is implemented using nested loops. The outer loop iterates through each unique number (x) in the input array, and the inner loop generates multiples of that number (nx) within the range of the maximum value. For each nx, calculate the result as the product of count[x], k, and the sum of the prefSum values within the range (nx - x) and nx modulo mod. The final result is obtained by summing these products modulo mod for every possible pair of numbers in the input array.\n\nThe time complexity of the algorithm is O(maxVal^2) where maxVal is the maximum value in the input array nums. The space complexity is O(maxVal) due to the count and prefSum arrays.\n    ", "python": "\n    ```python\ndef sum_of_floored_pairs(nums):\n    mod = 10**9 + 7\n    max_val = max(nums)\n    count = [0] * (max_val + 1)\n    pref_sum = [0] * (max_val + 1)\n\n    for num in nums:\n        count[num] += 1\n\n    for i in range(1, max_val + 1):\n        pref_sum[i] = (pref_sum[i - 1] + count[i]) % mod\n\n    res = 0\n    for x in range(1, max_val + 1):\n        nx = x\n        k = 1\n        while nx <= max_val:\n            res = (res + ((pref_sum[nx] - pref_sum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod\n            k += 1\n            nx += x\n    return res\n```\n    \n    The algorithm first calculates the maximum value present in the array named maxVal. Then it initializes two other arrays: count and prefSum of size (maxVal + 1). The count array stores the frequency count of numbers in the input array, and prefSum stores the prefix sum of count array modulo mod (10^9 + 7).\n\nThe main logic is implemented using nested loops. The outer loop iterates through each unique number (x) in the input array, and the inner loop generates multiples of that number (nx) within the range of the maximum value. For each nx, calculate the result as the product of count[x], k, and the sum of the prefSum values within the range (nx - x) and nx modulo mod. The final result is obtained by summing these products modulo mod for every possible pair of numbers in the input array.\n\nThe time complexity of the algorithm is O(maxVal^2) where maxVal is the maximum value in the input array nums. The space complexity is O(maxVal) due to the count and prefSum arrays.\n    ", "javascript": "\n    ```javascript\nfunction sumOfFlooredPairs(nums) {\n    const mod = 1e9 + 7;\n    const maxVal = Math.max(...nums);\n    const count = Array(maxVal + 1).fill(0);\n    const prefSum = Array(maxVal + 1).fill(0);\n\n    for (let num of nums) {\n        count[num]++;\n    }\n\n    for (let i = 1; i <= maxVal; i++) {\n        prefSum[i] = (prefSum[i - 1] + count[i]) % mod;\n    }\n\n    let res = 0;\n    for (let x = 1; x <= maxVal; x++) {\n        for (let k = 1, nx = x; nx <= maxVal; k++, nx += x) {\n            res = (res + ((prefSum[nx] - prefSum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm first calculates the maximum value present in the array named maxVal. Then it initializes two other arrays: count and prefSum of size (maxVal + 1). The count array stores the frequency count of numbers in the input array, and prefSum stores the prefix sum of count array modulo mod (10^9 + 7).\n\nThe main logic is implemented using nested loops. The outer loop iterates through each unique number (x) in the input array, and the inner loop generates multiples of that number (nx) within the range of the maximum value. For each nx, calculate the result as the product of count[x], k, and the sum of the prefSum values within the range (nx - x) and nx modulo mod. The final result is obtained by summing these products modulo mod for every possible pair of numbers in the input array.\n\nThe time complexity of the algorithm is O(maxVal^2) where maxVal is the maximum value in the input array nums. The space complexity is O(maxVal) due to the count and prefSum arrays.\n    "}
{"id": 1328, "slug": "break-a-palindrome", "title": "Break a Palindrome", "difficulty": "Medium", "content": "Given a palindromic string of lowercase English letters `palindrome`, replace **exactly one** character with any lowercase English letter so that the resulting string is **not** a palindrome and that it is the **lexicographically smallest** one possible.\n\nReturn _the resulting string. If there is no way to replace a character to make it not a palindrome, return an **empty string**._\n\nA string `a` is lexicographically smaller than a string `b` (of the same length) if in the first position where `a` and `b` differ, `a` has a character strictly smaller than the corresponding character in `b`. For example, `\"abcc \"` is lexicographically smaller than `\"abcd \"` because the first position they differ is at the fourth character, and `'c'` is smaller than `'d'`.\n\n**Example 1:**\n\n**Input:** palindrome =  \"abccba \"\n**Output:**  \"aaccba \"\n**Explanation:** There are many ways to make  \"abccba \" not a palindrome, such as  \"zbccba \",  \"aaccba \", and  \"abacba \".\nOf all the ways,  \"aaccba \" is the lexicographically smallest.\n\n**Example 2:**\n\n**Input:** palindrome =  \"a \"\n**Output:**  \" \"\n**Explanation:** There is no way to replace a single character to make  \"a \" not a palindrome, so return an empty string.\n\n**Constraints:**\n\n*   `1 <= palindrome.length <= 1000`\n*   `palindrome` consists of only lowercase English letters.", "java": "\n    ```java\npublic String breakPalindrome(String palindrome) {\n    int length = palindrome.length();\n    if (length == 1) return \"\";\n    \n    char[] chars = palindrome.toCharArray();\n    for (int i = 0; i < length / 2; i++) {\n        if (chars[i] != 'a') {\n            chars[i] = 'a';\n            return String.valueOf(chars);\n        }\n    }\n    \n    chars[length - 1] = 'b';\n    return String.valueOf(chars);\n}\n```\n    \n    To find the lexicographically smallest non-palindromic string, we first check if the length of the input string is 1. If it is, we return an empty string since we can't change a single character to make it a non-palindrome. Otherwise, we iterate through the first half of the string and look for any character not equal to `'a'`. If we find one, we change it to `'a'` and return the new string.\n\nIf we reach the end of the loop without finding a non-`'a'` character, it means that the string is composed of only `'a'` characters. In this case, we can change the last character to `'b'` to create a non-palindrome, and return the result. This ensures the lexicographically smallest string since it only changes one character and does so as early in the string as possible.\n    ", "c++": "\n    ```cpp\n#include <string>\n\nstd::string breakPalindrome(std::string palindrome) {\n    int length = palindrome.length();\n    if (length == 1) return \"\";\n    \n    for (int i = 0; i < length / 2; i++) {\n        if (palindrome[i] != 'a') {\n            palindrome[i] = 'a';\n            return palindrome;\n        }\n    }\n    \n    palindrome[length - 1] = 'b';\n    return palindrome;\n}\n```\n    \n    To find the lexicographically smallest non-palindromic string, we first check if the length of the input string is 1. If it is, we return an empty string since we can't change a single character to make it a non-palindrome. Otherwise, we iterate through the first half of the string and look for any character not equal to `'a'`. If we find one, we change it to `'a'` and return the new string.\n\nIf we reach the end of the loop without finding a non-`'a'` character, it means that the string is composed of only `'a'` characters. In this case, we can change the last character to `'b'` to create a non-palindrome, and return the result. This ensures the lexicographically smallest string since it only changes one character and does so as early in the string as possible.\n    ", "python": "\n    ```python\ndef breakPalindrome(palindrome: str) -> str:\n    length = len(palindrome)\n    if length == 1:\n        return \"\"\n    \n    chars = list(palindrome)\n    for i in range(length // 2):\n        if chars[i] != 'a':\n            chars[i] = 'a'\n            return \"\".join(chars)\n    \n    chars[length - 1] = 'b'\n    return \"\".join(chars)\n```\n    \n    To find the lexicographically smallest non-palindromic string, we first check if the length of the input string is 1. If it is, we return an empty string since we can't change a single character to make it a non-palindrome. Otherwise, we iterate through the first half of the string and look for any character not equal to `'a'`. If we find one, we change it to `'a'` and return the new string.\n\nIf we reach the end of the loop without finding a non-`'a'` character, it means that the string is composed of only `'a'` characters. In this case, we can change the last character to `'b'` to create a non-palindrome, and return the result. This ensures the lexicographically smallest string since it only changes one character and does so as early in the string as possible.\n    ", "javascript": "\n    ```javascript\nfunction breakPalindrome(palindrome) {\n    const length = palindrome.length;\n    if (length === 1) return \"\";\n    \n    let chars = palindrome.split(\"\");\n    for (let i = 0; i < Math.floor(length / 2); i++) {\n        if (chars[i] !== 'a') {\n            chars[i] = 'a';\n            return chars.join(\"\");\n        }\n    }\n    \n    chars[length - 1] = 'b';\n    return chars.join(\"\");\n}\n```\n    \n    To find the lexicographically smallest non-palindromic string, we first check if the length of the input string is 1. If it is, we return an empty string since we can't change a single character to make it a non-palindrome. Otherwise, we iterate through the first half of the string and look for any character not equal to `'a'`. If we find one, we change it to `'a'` and return the new string.\n\nIf we reach the end of the loop without finding a non-`'a'` character, it means that the string is composed of only `'a'` characters. In this case, we can change the last character to `'b'` to create a non-palindrome, and return the result. This ensures the lexicographically smallest string since it only changes one character and does so as early in the string as possible.\n    "}
{"id": 1330, "slug": "reverse-subarray-to-maximize-array-value", "title": "Reverse Subarray To Maximize Array Value", "difficulty": "Hard", "content": "You are given an integer array `nums`. The _value_ of this array is defined as the sum of `|nums[i] - nums[i + 1]|` for all `0 <= i < nums.length - 1`.\n\nYou are allowed to select any subarray of the given array and reverse it. You can perform this operation **only once**.\n\nFind maximum possible value of the final array.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,1,5,4\\]\n**Output:** 10\n**Explanation:** By reversing the subarray \\[3,1,5\\] the array becomes \\[2,5,1,3,4\\] whose value is 10.\n\n**Example 2:**\n\n**Input:** nums = \\[2,4,9,24,2,1,10\\]\n**Output:** 68\n\n**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-105 <= nums[i] <= 105`", "java": "\n    ```java\npublic int longestSubsequence(int[] arr, int difference) {\n    HashMap<Integer, Integer> dp = new HashMap<>();\n    int maxLength = 0;\n    for (int num : arr) {\n        dp.put(num, dp.getOrDefault(num - difference, 0) + 1);\n        maxLength = Math.max(maxLength, dp.get(num));\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm creates a hashmap to store the maximum length of the arithmetic subsequence with difference \"difference\" ending at each element of the array. We iterate through each element in the array, calculate the length of the arithmetic subsequence ending at the current number, and update the hashmap accordingly. During the loop, we also keep track of the maximum length of the arithmetic subsequence seen so far. At the end of the loop, we return the maxLength.\n\nThe time complexity of this algorithm is O(n), where n is the length of the array \"arr\".\n    ", "c++": "\n    ```cpp\nint longestSubsequence(vector<int>& arr, int difference) {\n    unordered_map<int, int> dp;\n    int maxLength = 0;\n    for (int num : arr) {\n        dp[num] = dp[num - difference] + 1;\n        maxLength = max(maxLength, dp[num]);\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm creates a hashmap to store the maximum length of the arithmetic subsequence with difference \"difference\" ending at each element of the array. We iterate through each element in the array, calculate the length of the arithmetic subsequence ending at the current number, and update the hashmap accordingly. During the loop, we also keep track of the maximum length of the arithmetic subsequence seen so far. At the end of the loop, we return the maxLength.\n\nThe time complexity of this algorithm is O(n), where n is the length of the array \"arr\".\n    ", "python": "\n    ```python\ndef longestSubsequence(arr, difference):\n    dp = {}\n    maxLength = 0\n    for num in arr:\n        dp[num] = dp.get(num - difference, 0) + 1\n        maxLength = max(maxLength, dp[num])\n    return maxLength\n```\n\n    \n    The algorithm creates a hashmap to store the maximum length of the arithmetic subsequence with difference \"difference\" ending at each element of the array. We iterate through each element in the array, calculate the length of the arithmetic subsequence ending at the current number, and update the hashmap accordingly. During the loop, we also keep track of the maximum length of the arithmetic subsequence seen so far. At the end of the loop, we return the maxLength.\n\nThe time complexity of this algorithm is O(n), where n is the length of the array \"arr\".\n    ", "javascript": "\n    ```javascript\nfunction longestSubsequence(arr, difference) {\n    const dp = new Map();\n    let maxLength = 0;\n    for (let num of arr) {\n        dp.set(num, (dp.get(num - difference) || 0) + 1);\n        maxLength = Math.max(maxLength, dp.get(num));\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm creates a hashmap to store the maximum length of the arithmetic subsequence with difference \"difference\" ending at each element of the array. We iterate through each element in the array, calculate the length of the arithmetic subsequence ending at the current number, and update the hashmap accordingly. During the loop, we also keep track of the maximum length of the arithmetic subsequence seen so far. At the end of the loop, we return the maxLength.\n\nThe time complexity of this algorithm is O(n), where n is the length of the array \"arr\".\n    "}
{"id": 1338, "slug": "reduce-array-size-to-the-half", "title": "Reduce Array Size to The Half", "difficulty": "Medium", "content": "You are given an integer array `arr`. You can choose a set of integers and remove all the occurrences of these integers in the array.\n\nReturn _the minimum size of the set so that **at least** half of the integers of the array are removed_.\n\n**Example 1:**\n\n**Input:** arr = \\[3,3,3,3,5,5,5,2,2,7\\]\n**Output:** 2\n**Explanation:** Choosing {3,7} will make the new array \\[5,5,5,2,2\\] which has size 5 (i.e equal to half of the size of the old array).\nPossible sets of size 2 are {3,5},{3,2},{5,2}.\nChoosing set {2,7} is not possible as it will make the new array \\[3,3,3,3,5,5,5\\] which has a size greater than half of the size of the old array.\n\n**Example 2:**\n\n**Input:** arr = \\[7,7,7,7,7,7\\]\n**Output:** 1\n**Explanation:** The only possible set you can choose is {7}. This will make the new array empty.\n\n**Constraints:**\n\n*   `2 <= arr.length <= 105`\n*   `arr.length` is even.\n*   `1 <= arr[i] <= 105`", "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\npublic int minSetSize(int[] arr) {\n    Map<Integer, Integer> freq_map = new HashMap<>();\n    PriorityQueue<Integer> max_heap = new PriorityQueue<>((a, b) -> b - a);\n    for (int x : arr)\n        freq_map.put(x, freq_map.getOrDefault(x, 0) + 1);\n    for (int cnt : freq_map.values())\n        max_heap.offer(cnt);\n    int half = arr.length / 2;\n    int cnt = 0;\n    int size = 0;\n    while (size < half) {\n        size += max_heap.poll();\n        cnt++;\n    }\n    return cnt;\n}\n```\n    \n    To solve this problem, we need to count the occurrences of each integer in the array. We can then calculate the minimum set size by greedily selecting the most frequent integers until at least half of the elements are removed.\n\n1. Construct a frequency map for each integer, i.e., count how many times each integer appears in the array.\n2. Create a max heap (priority queue) from the frequency map values.\n3. Initialize two counters: one for the total removed elements and one for the set size.\n4. While the total removed elements are less than half of the array's length, pop elements from the max heap and add their frequency to the total removed elements. Increment the set size each time.\n5. Return the minimum set size.\n\nThis algorithm has a time complexity of O(n + k * log(k)) and a space complexity of O(k), where n is the length of the given array and k is the number of distinct integers in the array.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n#include <queue>\nusing namespace std;\n\nint minSetSize(vector<int>& arr) {\n    unordered_map<int, int> freq_map;\n    priority_queue<int> max_heap;\n    for (int x : arr)\n        freq_map[x]++;\n    for (auto &[_, cnt] : freq_map)\n        max_heap.push(cnt);\n    int half = arr.size() / 2;\n    int cnt = 0;\n    int size = 0;\n    while (size < half) {\n        size += max_heap.top();\n        max_heap.pop();\n        cnt++;\n    }\n    return cnt;\n}\n```\n    \n    To solve this problem, we need to count the occurrences of each integer in the array. We can then calculate the minimum set size by greedily selecting the most frequent integers until at least half of the elements are removed.\n\n1. Construct a frequency map for each integer, i.e., count how many times each integer appears in the array.\n2. Create a max heap (priority queue) from the frequency map values.\n3. Initialize two counters: one for the total removed elements and one for the set size.\n4. While the total removed elements are less than half of the array's length, pop elements from the max heap and add their frequency to the total removed elements. Increment the set size each time.\n5. Return the minimum set size.\n\nThis algorithm has a time complexity of O(n + k * log(k)) and a space complexity of O(k), where n is the length of the given array and k is the number of distinct integers in the array.\n    ", "python": "\n    ```python\nfrom collections import Counter\nimport heapq\n\ndef minSetSize(arr):\n    freq_map = Counter(arr)\n    max_heap = [-cnt for cnt in freq_map.values()]\n    heapq.heapify(max_heap)\n    half = len(arr) // 2\n    cnt = 0\n    size = 0\n    while size < half:\n        size -= heapq.heappop(max_heap)\n        cnt += 1\n    return cnt\n```\n    \n    To solve this problem, we need to count the occurrences of each integer in the array. We can then calculate the minimum set size by greedily selecting the most frequent integers until at least half of the elements are removed.\n\n1. Construct a frequency map for each integer, i.e., count how many times each integer appears in the array.\n2. Create a max heap (priority queue) from the frequency map values.\n3. Initialize two counters: one for the total removed elements and one for the set size.\n4. While the total removed elements are less than half of the array's length, pop elements from the max heap and add their frequency to the total removed elements. Increment the set size each time.\n5. Return the minimum set size.\n\nThis algorithm has a time complexity of O(n + k * log(k)) and a space complexity of O(k), where n is the length of the given array and k is the number of distinct integers in the array.\n    ", "javascript": "\n    ```javascript\nfunction minSetSize(arr) {\n    let freq_map = new Map();\n    for (let x of arr)\n        freq_map.set(x, (freq_map.get(x) || 0) + 1);\n    let max_heap = Array.from(freq_map.values());\n    max_heap.sort((a, b) => b - a);\n    let half = arr.length / 2;\n    let cnt = 0;\n    let size = 0;\n    for (let i = 0; size < half; i++) {\n        size += max_heap[i];\n        cnt++;\n    }\n    return cnt;\n}\n```\n    \n    To solve this problem, we need to count the occurrences of each integer in the array. We can then calculate the minimum set size by greedily selecting the most frequent integers until at least half of the elements are removed.\n\n1. Construct a frequency map for each integer, i.e., count how many times each integer appears in the array.\n2. Create a max heap (priority queue) from the frequency map values.\n3. Initialize two counters: one for the total removed elements and one for the set size.\n4. While the total removed elements are less than half of the array's length, pop elements from the max heap and add their frequency to the total removed elements. Increment the set size each time.\n5. Return the minimum set size.\n\nThis algorithm has a time complexity of O(n + k * log(k)) and a space complexity of O(k), where n is the length of the given array and k is the number of distinct integers in the array.\n    "}
{"id": 1353, "slug": "maximum-number-of-events-that-can-be-attended", "title": "Maximum Number of Events That Can Be Attended", "difficulty": "Medium", "content": "You are given an array of `events` where `events[i] = [startDayi, endDayi]`. Every event `i` starts at `startDayi` and ends at `endDayi`.\n\nYou can attend an event `i` at any day `d` where `startTimei <= d <= endTimei`. You can only attend one event at any time `d`.\n\nReturn _the maximum number of events you can attend_.\n\n**Example 1:**\n\n**Input:** events = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 3\n**Explanation:** You can attend all the three events.\nOne way to attend them all is as shown.\nAttend the first event on day 1.\nAttend the second event on day 2.\nAttend the third event on day 3.\n\n**Example 2:**\n\n**Input:** events= \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[1,2\\]\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= events.length <= 105`\n*   `events[i].length == 2`\n*   `1 <= startDayi <= endDayi <= 105`", "java": "\n    ```java\nimport java.util.*;\n\npublic int maxEvents(int[][] events) {\n    Arrays.sort(events, (a, b) -> a[0] - b[0]);\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    int eventCount = 0, day = 0;\n\n    for (int[] event : events) {\n        while (!minHeap.isEmpty() && minHeap.peek() < event[0]) {\n            minHeap.poll();\n        }\n        minHeap.add(event[1]);\n        eventCount++;\n        day++;\n    }\n\n    return eventCount;\n}\n```\n\n    \n    First, we sort the `events` array by its start day in ascending order, using a custom compare function.\nThen, we create a min-heap to store the end day of each event.\n\nWe initialize `eventCount` and `day` to 0. Then, we iterate through the events.\n\nFor each event, we check if the min-heap contains any previously attended events whose end day is less than the start day of the current event. If there are any, we remove them from the min-heap (as they have no impact on the overall count anymore).\n\nAfter that, we push the end day of the current event into the min-heap and increment both the `eventCount` and `day`.\n\nAt the end, we return the `eventCount`, which represents the maximum number of events we could attend.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nbool compareEvents(const vector<int> &event1, const vector<int> &event2) {\n    return event1[0] < event2[0];\n}\n\nint maxEvents(vector<vector<int>> &events) {\n    sort(events.begin(), events.end(), compareEvents);\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n    int eventCount = 0, day = 0;\n\n    for (auto &event : events) {\n        while (!minHeap.empty() && minHeap.top() < event[0]) {\n            minHeap.pop();\n        }\n        minHeap.push(event[1]);\n        eventCount++;\n        day++;\n    }\n\n    return eventCount;\n}\n```\n\n    \n    First, we sort the `events` array by its start day in ascending order, using a custom compare function.\nThen, we create a min-heap to store the end day of each event.\n\nWe initialize `eventCount` and `day` to 0. Then, we iterate through the events.\n\nFor each event, we check if the min-heap contains any previously attended events whose end day is less than the start day of the current event. If there are any, we remove them from the min-heap (as they have no impact on the overall count anymore).\n\nAfter that, we push the end day of the current event into the min-heap and increment both the `eventCount` and `day`.\n\nAt the end, we return the `eventCount`, which represents the maximum number of events we could attend.\n    ", "python": "\n    ```python\nimport heapq\n\ndef maxEvents(events: List[List[int]]) -> int:\n    events.sort(key=lambda x: x[0])\n    min_heap = []\n    event_count, day = 0, 0\n\n    for event in events:\n        while min_heap and min_heap[0] < event[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, event[1])\n        event_count += 1\n        day += 1\n\n    return event_count\n```\n\n    \n    First, we sort the `events` array by its start day in ascending order, using a custom compare function.\nThen, we create a min-heap to store the end day of each event.\n\nWe initialize `eventCount` and `day` to 0. Then, we iterate through the events.\n\nFor each event, we check if the min-heap contains any previously attended events whose end day is less than the start day of the current event. If there are any, we remove them from the min-heap (as they have no impact on the overall count anymore).\n\nAfter that, we push the end day of the current event into the min-heap and increment both the `eventCount` and `day`.\n\nAt the end, we return the `eventCount`, which represents the maximum number of events we could attend.\n    ", "javascript": "\n    ```javascript\nfunction maxEvents(events) {\n    events.sort((a, b) => a[0] - b[0]);\n    const minHeap = [];\n    let eventCount = 0, day = 0;\n\n    for (let event of events) {\n        while (minHeap.length && minHeap[0] < event[0]) {\n            minHeap.shift();\n        }\n        minHeap.push(event[1]);\n        minHeap.sort((a, b) => a - b);\n        eventCount++;\n        day++;\n    }\n\n    return eventCount;\n}\n```\n\n    \n    First, we sort the `events` array by its start day in ascending order, using a custom compare function.\nThen, we create a min-heap to store the end day of each event.\n\nWe initialize `eventCount` and `day` to 0. Then, we iterate through the events.\n\nFor each event, we check if the min-heap contains any previously attended events whose end day is less than the start day of the current event. If there are any, we remove them from the min-heap (as they have no impact on the overall count anymore).\n\nAfter that, we push the end day of the current event into the min-heap and increment both the `eventCount` and `day`.\n\nAt the end, we return the `eventCount`, which represents the maximum number of events we could attend.\n    "}
{"id": 1363, "slug": "largest-multiple-of-three", "title": "Largest Multiple of Three", "difficulty": "Hard", "content": "Given an array of digits `digits`, return _the largest multiple of **three** that can be formed by concatenating some of the given digits in **any order**_. If there is no answer return an empty string.\n\nSince the answer may not fit in an integer data type, return the answer as a string. Note that the returning answer must not contain unnecessary leading zeros.\n\n**Example 1:**\n\n**Input:** digits = \\[8,1,9\\]\n**Output:**  \"981 \"\n\n**Example 2:**\n\n**Input:** digits = \\[8,6,7,1,0\\]\n**Output:**  \"8760 \"\n\n**Example 3:**\n\n**Input:** digits = \\[1\\]\n**Output:**  \" \"\n\n**Constraints:**\n\n*   `1 <= digits.length <= 104`\n*   `0 <= digits[i] <= 9`", "java": "\n    ```java\nimport java.util.*;\n\npublic String largestMultipleOfThree(int[] digits) {\n    Arrays.sort(digits);\n    int sum = 0;\n    for (int digit : digits) {\n        sum += digit;\n    }\n\n    if (sum % 3 == 0) {\n        if (digits[0] == 0) return \"0\";\n        StringBuilder result = new StringBuilder();\n        for (int i = digits.length - 1; i >= 0; --i) {\n            result.append(digits[i]);\n        }\n        return result.toString();\n    }\n\n    List<Integer>[] mod = new List[3];\n    for (int i = 0; i < 3; ++i) {\n        mod[i] = new ArrayList<Integer>();\n    }\n    for (int digit : digits) {\n        mod[digit % 3].add(digit);\n    }\n\n    if (sum % 3 == 1) {\n        if (!mod[1].isEmpty()) {\n            mod[1].remove(mod[1].size() - 1);\n        } else {\n            mod[2].remove(mod[2].size() - 1);\n            mod[2].remove(mod[2].size() - 1);\n        }\n    } else {\n        if (!mod[2].isEmpty()) {\n            mod[2].remove(mod[2].size() - 1);\n        } else {\n            mod[1].remove(mod[1].size() - 1);\n            mod[1].remove(mod[1].size() - 1);\n        }\n    }\n\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < 3; ++i) {\n        for (int digit : mod[i]) {\n            result.append(digit);\n        }\n    }\n\n    result.reverse();\n    if (result.length() == 0 || result.charAt(0) == '0') {\n        return \"0\";\n    }\n\n    return result.toString();\n}\n```\n\n    \n    1. Sort the input array in descending order.\n2. Calculate the sum of all digits.\n3. If the sum is divisible by 3, return the joined digits as a string (or \"0\" if the last digit is 0).\n4. Create a mod array where mod[i] contains digits with the remainder i when divided by 3.\n5. If the remainder of the sum is 1:\n    - Remove the smallest digit from mod[1], if not empty.\n    - Otherwise, remove the two smallest digits from mod[2].\n6. If the remainder of the sum is 2:\n    - Remove the smallest digit from mod[2], if not empty.\n    - Otherwise, remove the two smallest digits from mod[1].\n7. Flatten the mod array and join its digits into a string. Sort the string in descending order.\n8. Return the sorted string (or \"0\" if empty or starting with \"0\").\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string largestMultipleOfThree(std::vector<int>& digits) {\n    std::sort(digits.rbegin(), digits.rend());\n    int sum = 0;\n    for (int digit : digits) {\n        sum += digit;\n    }\n\n    if (sum % 3 == 0) {\n        if (digits.back() == 0) return \"0\";\n        std::string result(digits.begin(), digits.end());\n        return result;\n    }\n\n    std::vector<int> mod[3];\n    for (int digit : digits) {\n        mod[digit % 3].push_back(digit);\n    }\n\n    if (sum % 3 == 1) {\n        if (!mod[1].empty()) {\n            mod[1].pop_back();\n        } else {\n            mod[2].pop_back();\n            mod[2].pop_back();\n        }\n    } else {\n        if (!mod[2].empty()) {\n            mod[2].pop_back();\n        } else {\n            mod[1].pop_back();\n            mod[1].pop_back();\n        }\n    }\n\n    std::string result;\n    for (int i = 0; i < 3; ++i) {\n        for (int digit : mod[i]) {\n            result += std::to_string(digit);\n        }\n    }\n\n    std::sort(result.rbegin(), result.rend());\n    if (result.empty() || result[0] == '0') {\n        return \"0\";\n    }\n    \n    return result;\n}\n```\n\n    \n    1. Sort the input array in descending order.\n2. Calculate the sum of all digits.\n3. If the sum is divisible by 3, return the joined digits as a string (or \"0\" if the last digit is 0).\n4. Create a mod array where mod[i] contains digits with the remainder i when divided by 3.\n5. If the remainder of the sum is 1:\n    - Remove the smallest digit from mod[1], if not empty.\n    - Otherwise, remove the two smallest digits from mod[2].\n6. If the remainder of the sum is 2:\n    - Remove the smallest digit from mod[2], if not empty.\n    - Otherwise, remove the two smallest digits from mod[1].\n7. Flatten the mod array and join its digits into a string. Sort the string in descending order.\n8. Return the sorted string (or \"0\" if empty or starting with \"0\").\n    ", "python": "\n    ```python\nfrom collections import defaultdict\n\ndef largest_multiple_of_three(digits):\n    digits.sort(reverse=True)\n    sum_digits = sum(digits)\n\n    if sum_digits % 3 == 0:\n        return '0' if digits[-1] == 0 else ''.join(map(str, digits))\n\n    mod = defaultdict(list)\n    for digit in digits:\n        mod[digit % 3].append(digit)\n\n    if sum_digits % 3 == 1:\n        if mod[1]:\n            mod[1].pop()\n        else:\n            mod[2].pop(), mod[2].pop()\n    else:\n        if mod[2]:\n            mod[2].pop()\n        else:\n            mod[1].pop(), mod[1].pop()\n\n    result = \"\".join(str(digit) for value in mod.values() for digit in value)\n    result = \"\".join(sorted(result, reverse=True))\n\n    return '0' if not result or result[0] == '0' else result\n```\n\n    \n    1. Sort the input array in descending order.\n2. Calculate the sum of all digits.\n3. If the sum is divisible by 3, return the joined digits as a string (or \"0\" if the last digit is 0).\n4. Create a mod array where mod[i] contains digits with the remainder i when divided by 3.\n5. If the remainder of the sum is 1:\n    - Remove the smallest digit from mod[1], if not empty.\n    - Otherwise, remove the two smallest digits from mod[2].\n6. If the remainder of the sum is 2:\n    - Remove the smallest digit from mod[2], if not empty.\n    - Otherwise, remove the two smallest digits from mod[1].\n7. Flatten the mod array and join its digits into a string. Sort the string in descending order.\n8. Return the sorted string (or \"0\" if empty or starting with \"0\").\n    ", "javascript": "\n    ```javascript\nfunction largestMultipleOfThree(digits) {\n    digits.sort((a, b) => b - a);\n    const sum = digits.reduce((a, b) => a + b, 0);\n\n    if (sum % 3 === 0) {\n        if (digits[digits.length - 1] === 0) return \"0\";\n        return digits.join(\"\");\n    }\n\n    let mod = new Array(3).fill(null).map(() => []);\n    for (let digit of digits) {\n        mod[digit % 3].push(digit);\n    }\n\n    if (sum % 3 === 1) {\n        if (mod[1].length > 0) {\n            mod[1].pop();\n        } else {\n            mod[2].pop(), mod[2].pop();\n        }\n    } else {\n        if (mod[2].length > 0) {\n            mod[2].pop();\n        } else {\n            mod[1].pop(), mod[1].pop();\n        }\n    }\n\n    let result = mod.flat().join(\"\");\n    result = Array.from(result).sort((a, b) => b - a).join(\"\");\n\n    if (!result || result[0] === \"0\") {\n        return \"0\";\n    }\n\n    return result;\n}\n```\n\n    \n    1. Sort the input array in descending order.\n2. Calculate the sum of all digits.\n3. If the sum is divisible by 3, return the joined digits as a string (or \"0\" if the last digit is 0).\n4. Create a mod array where mod[i] contains digits with the remainder i when divided by 3.\n5. If the remainder of the sum is 1:\n    - Remove the smallest digit from mod[1], if not empty.\n    - Otherwise, remove the two smallest digits from mod[2].\n6. If the remainder of the sum is 2:\n    - Remove the smallest digit from mod[2], if not empty.\n    - Otherwise, remove the two smallest digits from mod[1].\n7. Flatten the mod array and join its digits into a string. Sort the string in descending order.\n8. Return the sorted string (or \"0\" if empty or starting with \"0\").\n    "}
{"id": 1382, "slug": "balance-a-binary-search-tree", "title": "Balance a Binary Search Tree", "difficulty": "Medium", "content": "Given the `root` of a binary search tree, return _a **balanced** binary search tree with the same node values_. If there is more than one answer, return **any of them**.\n\nA binary search tree is **balanced** if the depth of the two subtrees of every node never differs by more than `1`.\n\n**Example 1:**\n\n**Input:** root = \\[1,null,2,null,3,null,4,null,null\\]\n**Output:** \\[2,1,3,null,null,null,4\\]\n**Explanation:** This is not the only correct answer, \\[3,1,4,null,2\\] is also correct.\n\n**Example 2:**\n\n**Input:** root = \\[2,1,3\\]\n**Output:** \\[2,1,3\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `1 <= Node.val <= 105`", "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public TreeNode balanceBST(TreeNode root) {\n        List<TreeNode> sortedNodes = new ArrayList<>();\n        inorderTraversal(root, sortedNodes);\n        return sortedArrayToBST(sortedNodes, 0, sortedNodes.size() - 1);\n    }\n    \n    private void inorderTraversal(TreeNode node, List<TreeNode> sortedNodes) {\n        if (node == null) return;\n        inorderTraversal(node.left, sortedNodes);\n        sortedNodes.add(node);\n        inorderTraversal(node.right, sortedNodes);\n    }\n    \n    private TreeNode sortedArrayToBST(List<TreeNode> sortedNodes, int start, int end) {\n        if (start > end) return null;\n        int mid = start + (end - start) / 2;\n        TreeNode newNode = sortedNodes.get(mid);\n        newNode.left = sortedArrayToBST(sortedNodes, start, mid - 1);\n        newNode.right = sortedArrayToBST(sortedNodes, mid + 1, end);\n        return newNode;\n    }\n}\n```\n\n    \n    The algorithm first traverses the input binary search tree using Inorder Traversal (Left-Root-Right) to obtain the ordered tree nodes in a sorted array. After that, it converts the sorted array recursively into a balanced binary search tree by picking the middle element as the root node and performing the same operation on the left and right subarrays. The middle element is chosen so the subtree depths remain no more than one level apart, fulfilling the balanced binary search tree constraint.\n    ", "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* balanceBST(TreeNode* root) {\n        vector<TreeNode*> sortedNodes;\n        inorderTraversal(root, sortedNodes);\n        return sortedArrayToBST(sortedNodes, 0, sortedNodes.size() - 1);\n    }\n\n    void inorderTraversal(TreeNode* node, vector<TreeNode*>& sortedNodes) {\n        if (node == nullptr) return;\n        inorderTraversal(node->left, sortedNodes);\n        sortedNodes.push_back(node);\n        inorderTraversal(node->right, sortedNodes);\n    }\n\n    TreeNode* sortedArrayToBST(vector<TreeNode*>& sortedNodes, int start, int end) {\n        if (start > end) return nullptr;\n        int mid = start + (end - start) / 2;\n        TreeNode* newNode = sortedNodes[mid];\n        newNode->left = sortedArrayToBST(sortedNodes, start, mid - 1);\n        newNode->right = sortedArrayToBST(sortedNodes, mid + 1, end);\n        return newNode;\n    }\n};\n```\n\n    \n    The algorithm first traverses the input binary search tree using Inorder Traversal (Left-Root-Right) to obtain the ordered tree nodes in a sorted array. After that, it converts the sorted array recursively into a balanced binary search tree by picking the middle element as the root node and performing the same operation on the left and right subarrays. The middle element is chosen so the subtree depths remain no more than one level apart, fulfilling the balanced binary search tree constraint.\n    ", "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def balanceBST(self, root: TreeNode) -> TreeNode:\n        sortedNodes = []\n        self.inorderTraversal(root, sortedNodes)\n        return self.sortedArrayToBST(sortedNodes, 0, len(sortedNodes) - 1)\n\n    def inorderTraversal(self, node: TreeNode, sortedNodes: list):\n        if node is None: return\n        self.inorderTraversal(node.left, sortedNodes)\n        sortedNodes.append(node)\n        self.inorderTraversal(node.right, sortedNodes)\n\n    def sortedArrayToBST(self, sortedNodes: list, start: int, end: int) -> TreeNode:\n        if start > end: return None\n        mid = start + (end - start) // 2\n        newNode = sortedNodes[mid]\n        newNode.left = self.sortedArrayToBST(sortedNodes, start, mid - 1)\n        newNode.right = self.sortedArrayToBST(sortedNodes, mid + 1, end)\n        return newNode\n```\n\n    \n    The algorithm first traverses the input binary search tree using Inorder Traversal (Left-Root-Right) to obtain the ordered tree nodes in a sorted array. After that, it converts the sorted array recursively into a balanced binary search tree by picking the middle element as the root node and performing the same operation on the left and right subarrays. The middle element is chosen so the subtree depths remain no more than one level apart, fulfilling the balanced binary search tree constraint.\n    ", "javascript": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction inorderTraversal(node, sortedNodes) {\n    if (node === null) return;\n    inorderTraversal(node.left, sortedNodes);\n    sortedNodes.push(node);\n    inorderTraversal(node.right, sortedNodes);\n}\n\nfunction sortedArrayToBST(sortedNodes, start, end) {\n    if (start > end) return null;\n    let mid = start + Math.floor((end - start) / 2);\n    let newNode = sortedNodes[mid];\n    newNode.left = sortedArrayToBST(sortedNodes, start, mid - 1);\n    newNode.right = sortedArrayToBST(sortedNodes, mid + 1, end);\n    return newNode;\n}\n\nfunction balanceBST(root) {\n    let sortedNodes = [];\n    inorderTraversal(root, sortedNodes);\n    return sortedArrayToBST(sortedNodes, 0, sortedNodes.length - 1);\n}\n```\n\n    \n    The algorithm first traverses the input binary search tree using Inorder Traversal (Left-Root-Right) to obtain the ordered tree nodes in a sorted array. After that, it converts the sorted array recursively into a balanced binary search tree by picking the middle element as the root node and performing the same operation on the left and right subarrays. The middle element is chosen so the subtree depths remain no more than one level apart, fulfilling the balanced binary search tree constraint.\n    "}
{"id": 1383, "slug": "maximum-performance-of-a-team", "title": "Maximum Performance of a Team", "difficulty": "Hard", "content": "You are given two integers `n` and `k` and two integer arrays `speed` and `efficiency` both of length `n`. There are `n` engineers numbered from `1` to `n`. `speed[i]` and `efficiency[i]` represent the speed and efficiency of the `ith` engineer respectively.\n\nChoose **at most** `k` different engineers out of the `n` engineers to form a team with the maximum **performance**.\n\nThe performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers.\n\nReturn _the maximum performance of this team_. Since the answer can be a huge number, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 2\n**Output:** 60\n**Explanation:** \nWe have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) \\* min(4, 7) = 60.\n\n**Example 2:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 3\n**Output:** 68\n**Explanation:**\nThis is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) \\* min(5, 4, 7) = 68.\n\n**Example 3:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 4\n**Output:** 72\n\n**Constraints:**\n\n*   `1 <= k <= n <= 105`\n*   `speed.length == n`\n*   `efficiency.length == n`\n*   `1 <= speed[i] <= 105`\n*   `1 <= efficiency[i] <= 108`", "java": "\n    ```java\nimport java.util.*;\n\npublic int maxPerformance(int n, int k, int[] speed, int[] efficiency) {\n    int[][] engineers = new int[n][2];\n    for (int i = 0; i < n; i++) {\n        engineers[i] = new int[] {efficiency[i], speed[i]};\n    }\n\n    Arrays.sort(engineers, (a, b) -> b[0] - a[0]);\n\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>(k, Comparator.reverseOrder());\n    long speedSum = 0;\n    long maxPerformance = 0;\n\n    for (int[] engineer : engineers) {\n        speedSum += engineer[1];\n        minHeap.offer(engineer[1]);\n\n        if (minHeap.size() > k) {\n            speedSum -= minHeap.poll();\n        }\n\n        maxPerformance = Math.max(maxPerformance, speedSum * engineer[0]);\n    }\n\n    return (int) (maxPerformance % (1e9 + 7));\n}\n```\n    \n    1. Store each engineer as pair of efficiency and speed in a list/array and sort that list/array in decreasing order based on efficiency.\n2. Initialize an empty min-heap, speed_sum and max_performance.\n3. Iterate over the sorted engineers list/array:\n   a. Add the current engineer's speed to the speed_sum.\n   b. Add the current engineer's speed to the min-heap.\n   c. If the min-heap's size is greater than given k, remove the minimum speed from the min-heap and subtract it from the speed_sum.\n   d. Update max_performance by comparing the current max_performance with the product of speed_sum and the current engineer's efficiency.\n4. Return max_performance % (10^9 + 7).\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nint maxPerformance(int n, int k, std::vector<int>& speed, std::vector<int>& efficiency) {\n    std::vector<std::pair<int, int>> engineers(n);\n    for (int i = 0; i < n; ++i) {\n        engineers[i] = {efficiency[i], speed[i]};\n    }\n    \n    std::sort(engineers.rbegin(), engineers.rend());\n    \n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;\n    \n    long long speed_sum = 0;\n    long long max_performance = 0;\n    \n    for (auto& engineer : engineers) {\n        speed_sum += engineer.second;\n        min_heap.push(engineer.second);\n        \n        if (min_heap.size() > k) {\n            speed_sum -= min_heap.top();\n            min_heap.pop();\n        }\n        \n        max_performance = std::max(max_performance, speed_sum * engineer.first);\n    }\n    \n    return max_performance % 1000000007;\n}\n```\n    \n    1. Store each engineer as pair of efficiency and speed in a list/array and sort that list/array in decreasing order based on efficiency.\n2. Initialize an empty min-heap, speed_sum and max_performance.\n3. Iterate over the sorted engineers list/array:\n   a. Add the current engineer's speed to the speed_sum.\n   b. Add the current engineer's speed to the min-heap.\n   c. If the min-heap's size is greater than given k, remove the minimum speed from the min-heap and subtract it from the speed_sum.\n   d. Update max_performance by comparing the current max_performance with the product of speed_sum and the current engineer's efficiency.\n4. Return max_performance % (10^9 + 7).\n    ", "python": "\n    ```python\nimport heapq\nfrom typing import List\n\ndef max_performance(n: int, k: int, speed: List[int], efficiency: List[int]) -> int:\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    min_heap = []\n    speed_sum = 0\n    max_performance = 0\n\n    for e, s in engineers:\n        speed_sum += s\n        heapq.heappush(min_heap, s)\n\n        if len(min_heap) > k:\n            speed_sum -= heapq.heappop(min_heap)\n\n        max_performance = max(max_performance, speed_sum * e)\n\n    return max_performance % (10**9 + 7)\n```\n    \n    1. Store each engineer as pair of efficiency and speed in a list/array and sort that list/array in decreasing order based on efficiency.\n2. Initialize an empty min-heap, speed_sum and max_performance.\n3. Iterate over the sorted engineers list/array:\n   a. Add the current engineer's speed to the speed_sum.\n   b. Add the current engineer's speed to the min-heap.\n   c. If the min-heap's size is greater than given k, remove the minimum speed from the min-heap and subtract it from the speed_sum.\n   d. Update max_performance by comparing the current max_performance with the product of speed_sum and the current engineer's efficiency.\n4. Return max_performance % (10^9 + 7).\n    ", "javascript": "\n    ```javascript\nfunction maxPerformance(n, k, speed, efficiency) {\n    const engineers = efficiency.map((e, i) => [e, speed[i]]).sort((a, b) => b[0] - a[0]);\n    const minHeap = new MinHeap();\n\n    let speedSum = 0;\n    let maxPerformance = 0;\n\n    for (const [e, s] of engineers) {\n        speedSum += s;\n        minHeap.insert(s);\n\n        if (minHeap.size() > k) {\n            speedSum -= minHeap.extractMin();\n        }\n\n        maxPerformance = Math.max(maxPerformance, speedSum * e);\n    }\n\n    return maxPerformance % (10**9 + 7);\n}\n\nclass MinHeap {\n    constructor() {\n        this.heap = [];\n    }\n    insert(value) {\n        this.heap.push(value);\n        this.bubbleUp(this.heap.length - 1);\n    }\n    extractMin() {\n        const min = this.heap[0];\n        this.heap[0] = this.heap.pop();\n        this.bubbleDown(0);\n        return min;\n    }\n    size() {\n        return this.heap.length;\n    }\n    bubbleUp(index) {\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n            if (this.heap[index] >= this.heap[parentIndex]) {\n                break;\n            }\n            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n            index = parentIndex;\n        }\n    }\n    bubbleDown(index) {\n        while (true) {\n            let minIndex = index;\n            const leftChildIndex = 2 * index + 1;\n            const rightChildIndex = 2 * index + 2;\n            if (leftChildIndex < this.heap.length && this.heap[leftChildIndex] < this.heap[minIndex]) {\n                minIndex = leftChildIndex;\n            }\n            if (rightChildIndex < this.heap.length && this.heap[rightChildIndex] < this.heap[minIndex]) {\n                minIndex = rightChildIndex;\n            }\n            if (minIndex === index) {\n                break;\n            }\n            [this.heap[index], this.heap[minIndex]] = [this.heap[minIndex], this.heap[index]];\n            index = minIndex;\n        }\n    }\n}\n```\n    \n    1. Store each engineer as pair of efficiency and speed in a list/array and sort that list/array in decreasing order based on efficiency.\n2. Initialize an empty min-heap, speed_sum and max_performance.\n3. Iterate over the sorted engineers list/array:\n   a. Add the current engineer's speed to the speed_sum.\n   b. Add the current engineer's speed to the min-heap.\n   c. If the min-heap's size is greater than given k, remove the minimum speed from the min-heap and subtract it from the speed_sum.\n   d. Update max_performance by comparing the current max_performance with the product of speed_sum and the current engineer's efficiency.\n4. Return max_performance % (10^9 + 7).\n    "}
{"id": 1386, "slug": "cinema-seat-allocation", "title": "Cinema Seat Allocation", "difficulty": "Medium", "content": "A cinema has `n` rows of seats, numbered from 1 to `n` and there are ten seats in each row, labelled from 1 to 10 as shown in the figure above.\n\nGiven the array `reservedSeats` containing the numbers of seats already reserved, for example, `reservedSeats[i] = [3,8]` means the seat located in row **3** and labelled with **8** is already reserved.\n\n_Return the maximum number of four-person groups you can assign on the cinema seats._ A four-person group occupies four adjacent seats **in one single row**. Seats across an aisle (such as \\[3,3\\] and \\[3,4\\]) are not considered to be adjacent, but there is an exceptional case on which an aisle split a four-person group, in that case, the aisle split a four-person group in the middle, which means to have two people on each side.\n\n**Example 1:**\n\n**Input:** n = 3, reservedSeats = \\[\\[1,2\\],\\[1,3\\],\\[1,8\\],\\[2,6\\],\\[3,1\\],\\[3,10\\]\\]\n**Output:** 4\n**Explanation:** The figure above shows the optimal allocation for four groups, where seats mark with blue are already reserved and contiguous seats mark with orange are for one group.\n\n**Example 2:**\n\n**Input:** n = 2, reservedSeats = \\[\\[2,1\\],\\[1,8\\],\\[2,6\\]\\]\n**Output:** 2\n\n**Example 3:**\n\n**Input:** n = 4, reservedSeats = \\[\\[4,3\\],\\[1,4\\],\\[4,6\\],\\[1,7\\]\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= n <= 10^9`\n*   `1 <= reservedSeats.length <= min(10*n, 10^4)`\n*   `reservedSeats[i].length == 2`\n*   `1 <= reservedSeats[i][0] <= n`\n*   `1 <= reservedSeats[i][1] <= 10`\n*   All `reservedSeats[i]` are distinct.", "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic List<List<Integer>> shiftGrid(int[][] grid, int k) {\n    int m = grid.length, n = grid[0].length;\n    k %= (m * n);\n    List<List<Integer>> res = new ArrayList<>();\n    for (int i = 0; i < m; ++i) {\n        List<Integer> row = new ArrayList<>();\n        for (int j = 0; j < n; ++j) {\n            int idx = (i * n + j + k) % (m * n);\n            row.add(grid[idx / n][idx % n]);\n        }\n        res.add(row);\n    }\n    return res;\n}\n```\n\n    \n    The algorithm works as follows:\n1. Get the dimensions of the grid, `m` and `n`, and calculate the total number of elements.\n2. Take the modulo of `k` with the total number of elements, so that `k` doesn't exceed the grid size.\n3. Initialize a result grid `res` with the same dimensions, filled with 0s.\n4. Iterate through the original grid using two nested loops, one for rows and one for columns.\n5. For each element in the original grid, calculate its new position in the result grid, using the formula `(i * n + j + k) % (m * n)` for the flattened indices.\n6. Assign the grid element to its new position in the result grid.\n7. Return the result grid after iterating through all elements.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\n    int m = grid.size(), n = grid[0].size();\n    k %= (m * n);\n    vector<vector<int>> res(m, vector<int>(n));\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int idx = (i * n + j + k) % (m * n);\n            res[idx / n][idx % n] = grid[i][j];\n        }\n    }\n    return res;\n}\n```\n\n    \n    The algorithm works as follows:\n1. Get the dimensions of the grid, `m` and `n`, and calculate the total number of elements.\n2. Take the modulo of `k` with the total number of elements, so that `k` doesn't exceed the grid size.\n3. Initialize a result grid `res` with the same dimensions, filled with 0s.\n4. Iterate through the original grid using two nested loops, one for rows and one for columns.\n5. For each element in the original grid, calculate its new position in the result grid, using the formula `(i * n + j + k) % (m * n)` for the flattened indices.\n6. Assign the grid element to its new position in the result grid.\n7. Return the result grid after iterating through all elements.\n    ", "python": "\n    ```python\ndef shiftGrid(grid, k):\n    m, n = len(grid), len(grid[0])\n    k %= (m * n)\n    res = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            idx = (i * n + j + k) % (m * n)\n            res[idx // n][idx % n] = grid[i][j]\n    return res\n```\n\n    \n    The algorithm works as follows:\n1. Get the dimensions of the grid, `m` and `n`, and calculate the total number of elements.\n2. Take the modulo of `k` with the total number of elements, so that `k` doesn't exceed the grid size.\n3. Initialize a result grid `res` with the same dimensions, filled with 0s.\n4. Iterate through the original grid using two nested loops, one for rows and one for columns.\n5. For each element in the original grid, calculate its new position in the result grid, using the formula `(i * n + j + k) % (m * n)` for the flattened indices.\n6. Assign the grid element to its new position in the result grid.\n7. Return the result grid after iterating through all elements.\n    ", "javascript": "\n    ```javascript\nfunction shiftGrid(grid, k) {\n    const m = grid.length, n = grid[0].length;\n    k %= (m * n);\n    const res = Array.from({length: m}, () => Array(n).fill(0));\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            let idx = (i * n + j + k) % (m * n);\n            res[Math.floor(idx / n)][idx % n] = grid[i][j];\n        }\n    }\n    return res;\n}\n```\n\n    \n    The algorithm works as follows:\n1. Get the dimensions of the grid, `m` and `n`, and calculate the total number of elements.\n2. Take the modulo of `k` with the total number of elements, so that `k` doesn't exceed the grid size.\n3. Initialize a result grid `res` with the same dimensions, filled with 0s.\n4. Iterate through the original grid using two nested loops, one for rows and one for columns.\n5. For each element in the original grid, calculate its new position in the result grid, using the formula `(i * n + j + k) % (m * n)` for the flattened indices.\n6. Assign the grid element to its new position in the result grid.\n7. Return the result grid after iterating through all elements.\n    "}
{"id": 1388, "slug": "pizza-with-3n-slices", "title": "Pizza With 3n Slices", "difficulty": "Hard", "content": "There is a pizza with `3n` slices of varying size, you and your friends will take slices of pizza as follows:\n\n*   You will pick **any** pizza slice.\n*   Your friend Alice will pick the next slice in the anti-clockwise direction of your pick.\n*   Your friend Bob will pick the next slice in the clockwise direction of your pick.\n*   Repeat until there are no more slices of pizzas.\n\nGiven an integer array `slices` that represent the sizes of the pizza slices in a clockwise direction, return _the maximum possible sum of slice sizes that you can pick_.\n\n**Example 1:**\n\n**Input:** slices = \\[1,2,3,4,5,6\\]\n**Output:** 10\n**Explanation:** Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.\n\n**Example 2:**\n\n**Input:** slices = \\[8,9,8,6,1,1\\]\n**Output:** 16\n**Explanation:** Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.\n\n**Constraints:**\n\n*   `3 * n == slices.length`\n*   `1 <= slices.length <= 500`\n*   `1 <= slices[i] <= 1000`", "java": "\n    ```java\npublic int maxSumDivThree(int[] nums) {\n    int[] dp = new int[3];\n    for (int num : nums) {\n        int[] temp = Arrays.copyOf(dp, 3);\n        for (int s : temp) {\n            dp[(s + num) % 3] = Math.max(dp[(s + num) % 3], s + num);\n        }\n    }\n    return dp[0];\n}\n```\n    \n    1. Initialize a dynamic programming array `dp` having 3 elements with all 0's. This will store the maximum sum for % 3 == 0, % 3 == 1, and % 3 == 2.\n2. Iterate through the input array `nums`.\n3. For each number, create a temporary copy of the current `dp` state, as we want to make changes to the original `dp` array based on the original state.\n4. For each number, iterate through the temporary copy of `dp` (temp). Calculate `(s + num) % 3` for the current number and the sum, and update the respective position in `dp` array with the maximum sum.\n5. The answer will be stored at `dp[0]`, which is the maximum sum that is divisible by three.\n    ", "c++": "\n    ```cpp\nint maxSumDivThree(vector<int>& nums) {\n    vector<int> dp(3, 0);\n    for (int num : nums) {\n        vector<int> temp(dp);\n        for (int s : temp) {\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num);\n        }\n    }\n    return dp[0];\n}\n```\n    \n    1. Initialize a dynamic programming array `dp` having 3 elements with all 0's. This will store the maximum sum for % 3 == 0, % 3 == 1, and % 3 == 2.\n2. Iterate through the input array `nums`.\n3. For each number, create a temporary copy of the current `dp` state, as we want to make changes to the original `dp` array based on the original state.\n4. For each number, iterate through the temporary copy of `dp` (temp). Calculate `(s + num) % 3` for the current number and the sum, and update the respective position in `dp` array with the maximum sum.\n5. The answer will be stored at `dp[0]`, which is the maximum sum that is divisible by three.\n    ", "python": "\n    ```python\ndef maxSumDivThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        temp = dp[:]\n        for s in temp:\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num)\n    return dp[0]\n```\n    \n    1. Initialize a dynamic programming array `dp` having 3 elements with all 0's. This will store the maximum sum for % 3 == 0, % 3 == 1, and % 3 == 2.\n2. Iterate through the input array `nums`.\n3. For each number, create a temporary copy of the current `dp` state, as we want to make changes to the original `dp` array based on the original state.\n4. For each number, iterate through the temporary copy of `dp` (temp). Calculate `(s + num) % 3` for the current number and the sum, and update the respective position in `dp` array with the maximum sum.\n5. The answer will be stored at `dp[0]`, which is the maximum sum that is divisible by three.\n    ", "javascript": "\n    ```javascript\nfunction maxSumDivThree(nums) {\n    let dp = [0, 0, 0];\n    for (let num of nums) {\n        let temp = [...dp];\n        for (let s of temp) {\n            dp[(s + num) % 3] = Math.max(dp[(s + num) % 3], s + num);\n        }\n    }\n    return dp[0];\n}\n```\n    \n    1. Initialize a dynamic programming array `dp` having 3 elements with all 0's. This will store the maximum sum for % 3 == 0, % 3 == 1, and % 3 == 2.\n2. Iterate through the input array `nums`.\n3. For each number, create a temporary copy of the current `dp` state, as we want to make changes to the original `dp` array based on the original state.\n4. For each number, iterate through the temporary copy of `dp` (temp). Calculate `(s + num) % 3` for the current number and the sum, and update the respective position in `dp` array with the maximum sum.\n5. The answer will be stored at `dp[0]`, which is the maximum sum that is divisible by three.\n    "}
{"id": 1400, "slug": "construct-k-palindrome-strings", "title": "Construct K Palindrome Strings", "difficulty": "Medium", "content": "Given a string `s` and an integer `k`, return `true` _if you can use all the characters in_ `s` _to construct_ `k` _palindrome strings or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** s =  \"annabelle \", k = 2\n**Output:** true\n**Explanation:** You can construct two palindromes using all characters in s.\nSome possible constructions  \"anna \" +  \"elble \",  \"anbna \" +  \"elle \",  \"anellena \" +  \"b \"\n\n**Example 2:**\n\n**Input:** s =  \"leetcode \", k = 3\n**Output:** false\n**Explanation:** It is impossible to construct 3 palindromes using all the characters of s.\n\n**Example 3:**\n\n**Input:** s =  \"true \", k = 4\n**Output:** true\n**Explanation:** The only possible solution is to put each character in a separate string.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters.\n*   `1 <= k <= 105`", "java": "\n    ```java\nimport java.util.*;\n\npublic String tictactoe(int[][] moves) {\n    int[][] grid = new int[3][3];\n    int player = 1;\n    for (int[] move : moves) {\n        grid[move[0]][move[1]] = player;\n        if ((grid[0][move[1]] == player && grid[1][move[1]] == player && grid[2][move[1]] == player) ||\n            (grid[move[0]][0] == player && grid[move[0]][1] == player && grid[move[0]][2] == player) ||\n            (move[0] == move[1] && grid[0][0] == player && grid[1][1] == player && grid[2][2] == player) ||\n            (move[0] + move[1] == 2 && grid[0][2] == player && grid[1][1] == player && grid[2][0] == player)) {\n            return player == 1 ? \"A\" : \"B\";\n        }\n        player = 3 - player;\n    }\n    return moves.length == 9 ? \"Draw\" : \"Pending\";\n}\n```\n\n    \n    1. Initialize an empty `grid` and set the first player to be `1` (representing A) to track players.\n2. Iterate through each move in `moves`.\n3. In each iteration, apply the corresponding player's move on the grid.\n4. Check if the current move created 3 in a row, 3 in a column, or 3 on either diagonal. If so, the current player wins and return \"A\" or \"B\" corresponding to the player.\n5. If no winner is found after processing all moves, return \"Draw\" if there are 9 moves, else return \"Pending\".\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::string tictactoe(std::vector<std::vector<int>>& moves) {\n    int grid[3][3] = {0};\n    int player = 1;\n    for (const auto& move : moves) {\n        grid[move[0]][move[1]] = player;\n        if ((grid[0][move[1]] == player && grid[1][move[1]] == player && grid[2][move[1]] == player) ||\n            (grid[move[0]][0] == player && grid[move[0]][1] == player && grid[move[0]][2] == player) ||\n            (move[0] == move[1] && grid[0][0] == player && grid[1][1] == player && grid[2][2] == player) ||\n            (move[0] + move[1] == 2 && grid[0][2] == player && grid[1][1] == player && grid[2][0] == player)) {\n            return player == 1 ? \"A\" : \"B\";\n        }\n        player = 3 - player;\n    }\n    return moves.size() == 9 ? \"Draw\" : \"Pending\";\n}\n```\n\n    \n    1. Initialize an empty `grid` and set the first player to be `1` (representing A) to track players.\n2. Iterate through each move in `moves`.\n3. In each iteration, apply the corresponding player's move on the grid.\n4. Check if the current move created 3 in a row, 3 in a column, or 3 on either diagonal. If so, the current player wins and return \"A\" or \"B\" corresponding to the player.\n5. If no winner is found after processing all moves, return \"Draw\" if there are 9 moves, else return \"Pending\".\n    ", "python": "\n    ```python\ndef tictactoe(moves):\n    grid = [[0] * 3 for _ in range(3)]\n    player = 1\n    for move in moves:\n        r, c = move\n        grid[r][c] = player\n        if (all(grid[i][c] == player for i in range(3)) or\n            all(grid[r][i] == player for i in range(3)) or\n            (r == c and all(grid[i][i] == player for i in range(3))) or\n            (r + c == 2 and all(grid[i][2 - i] == player for i in range(3)))):\n            return 'A' if player == 1 else 'B'\n        player = 3 - player\n    \n    return 'Draw' if len(moves) == 9 else 'Pending'\n```\n\n    \n    1. Initialize an empty `grid` and set the first player to be `1` (representing A) to track players.\n2. Iterate through each move in `moves`.\n3. In each iteration, apply the corresponding player's move on the grid.\n4. Check if the current move created 3 in a row, 3 in a column, or 3 on either diagonal. If so, the current player wins and return \"A\" or \"B\" corresponding to the player.\n5. If no winner is found after processing all moves, return \"Draw\" if there are 9 moves, else return \"Pending\".\n    ", "javascript": "\n    ```javascript\nfunction tictactoe(moves) {\n    const grid = Array.from({ length: 3 }, () => new Array(3).fill(0));\n    let player = 1;\n    for (const move of moves) {\n        const [row, col] = move;\n        grid[row][col] = player;\n        if ((Array(3).fill().every((_, i) => grid[i][col] === player)) ||\n            (Array(3).fill().every((_, i) => grid[row][i] === player)) ||\n            (row === col && Array(3).fill().every((_, i) => grid[i][i] === player)) ||\n            (row + col === 2 && Array(3).fill().every((_, i) => grid[i][2 - i] === player))) {\n            return player === 1 ? \"A\" : \"B\";\n        }\n        player = 3 - player;\n    }\n    return moves.length === 9 ? \"Draw\" : \"Pending\";\n}\n```\n\n    \n    1. Initialize an empty `grid` and set the first player to be `1` (representing A) to track players.\n2. Iterate through each move in `moves`.\n3. In each iteration, apply the corresponding player's move on the grid.\n4. Check if the current move created 3 in a row, 3 in a column, or 3 on either diagonal. If so, the current player wins and return \"A\" or \"B\" corresponding to the player.\n5. If no winner is found after processing all moves, return \"Draw\" if there are 9 moves, else return \"Pending\".\n    "}
{"id": 1402, "slug": "reducing-dishes", "title": "Reducing Dishes", "difficulty": "Hard", "content": "A chef has collected data on the `satisfaction` level of his `n` dishes. Chef can cook any dish in 1 unit of time.\n\n**Like-time coefficient** of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. `time[i] * satisfaction[i]`.\n\nReturn _the maximum sum of **like-time coefficient** that the chef can obtain after dishes preparation_.\n\nDishes can be prepared in **any** order and the chef can discard some dishes to get this maximum value.\n\n**Example 1:**\n\n**Input:** satisfaction = \\[-1,-8,0,5,-9\\]\n**Output:** 14\n**Explanation:** After Removing the second and last dish, the maximum total **like-time coefficient** will be equal to (-1\\*1 + 0\\*2 + 5\\*3 = 14).\nEach dish is prepared in one unit of time.\n\n**Example 2:**\n\n**Input:** satisfaction = \\[4,3,2\\]\n**Output:** 20\n**Explanation:** Dishes can be prepared in any order, (2\\*1 + 3\\*2 + 4\\*3 = 20)\n\n**Example 3:**\n\n**Input:** satisfaction = \\[-1,-4,-5\\]\n**Output:** 0\n**Explanation:** People do not like the dishes. No dish is prepared.\n\n**Constraints:**\n\n*   `n == satisfaction.length`\n*   `1 <= n <= 500`\n*   `-1000 <= satisfaction[i] <= 1000`", "java": "\n    ```java\npublic int countSquares(int[][] matrix) {\n    int m = matrix.length, n = matrix[0].length, ans = 0;\n    int[][] dp = new int[m][n];\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i == 0 || j == 0) dp[i][j] = matrix[i][j];\n            else if(matrix[i][j] == 1) dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\n            ans += dp[i][j];\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a dynamic programming approach. For each cell of the input matrix, we create a `dp` matrix that will store the size of the square that ends at the current cell `[i, j]`. If the current cell contains 1, we need to check the values of the neighbors, i.e., cells `[i-1, j-1]`, `[i-1, j]`, and `[i, j-1]`. To form a square of size `k`, all three neighboring cells must have squares of size `k-1`. Thus, we set the current cell in `dp` to the minimum of the neighboring cells plus one (`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`).\n\nFor each cell, we then add its value in the `dp` matrix to the result (`ans += dp[i][j]`). Finally, we return the total number of squares found.\n    ", "c++": "\n    ```cpp\nint countSquares(vector<vector<int>>& matrix) {\n    int m = matrix.size(), n = matrix[0].size(), ans = 0;\n    vector<vector<int>> dp(m, vector<int>(n, 0));\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i == 0 || j == 0) dp[i][j] = matrix[i][j];\n            else if(matrix[i][j]) dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;\n            ans += dp[i][j];\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a dynamic programming approach. For each cell of the input matrix, we create a `dp` matrix that will store the size of the square that ends at the current cell `[i, j]`. If the current cell contains 1, we need to check the values of the neighbors, i.e., cells `[i-1, j-1]`, `[i-1, j]`, and `[i, j-1]`. To form a square of size `k`, all three neighboring cells must have squares of size `k-1`. Thus, we set the current cell in `dp` to the minimum of the neighboring cells plus one (`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`).\n\nFor each cell, we then add its value in the `dp` matrix to the result (`ans += dp[i][j]`). Finally, we return the total number of squares found.\n    ", "python": "\n    ```python\ndef countSquares(matrix: List[List[int]]) -> int:\n    m, n, ans = len(matrix), len(matrix[0]), 0\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = matrix[i][j]\n            elif matrix[i][j]:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n            ans += dp[i][j]\n    return ans\n```\n    \n    The algorithm uses a dynamic programming approach. For each cell of the input matrix, we create a `dp` matrix that will store the size of the square that ends at the current cell `[i, j]`. If the current cell contains 1, we need to check the values of the neighbors, i.e., cells `[i-1, j-1]`, `[i-1, j]`, and `[i, j-1]`. To form a square of size `k`, all three neighboring cells must have squares of size `k-1`. Thus, we set the current cell in `dp` to the minimum of the neighboring cells plus one (`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`).\n\nFor each cell, we then add its value in the `dp` matrix to the result (`ans += dp[i][j]`). Finally, we return the total number of squares found.\n    ", "javascript": "\n    ```javascript\nfunction countSquares(matrix) {\n    const m = matrix.length, n = matrix[0].length;\n    let ans = 0, dp = Array.from({length: m}, () => Array(n));\n    for(let i = 0; i < m; i++) {\n        for(let j = 0; j < n; j++) {\n            if(i === 0 || j === 0) dp[i][j] = matrix[i][j];\n            else if(matrix[i][j]) dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;\n            ans += dp[i][j];\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a dynamic programming approach. For each cell of the input matrix, we create a `dp` matrix that will store the size of the square that ends at the current cell `[i, j]`. If the current cell contains 1, we need to check the values of the neighbors, i.e., cells `[i-1, j-1]`, `[i-1, j]`, and `[i, j-1]`. To form a square of size `k`, all three neighboring cells must have squares of size `k-1`. Thus, we set the current cell in `dp` to the minimum of the neighboring cells plus one (`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`).\n\nFor each cell, we then add its value in the `dp` matrix to the result (`ans += dp[i][j]`). Finally, we return the total number of squares found.\n    "}
{"id": 1403, "slug": "minimum-subsequence-in-non-increasing-order", "title": "Minimum Subsequence in Non-Increasing Order", "difficulty": "Easy", "content": "Given the array `nums`, obtain a subsequence of the array whose sum of elements is **strictly greater** than the sum of the non included elements in such subsequence.\n\nIf there are multiple solutions, return the subsequence with **minimum size** and if there still exist multiple solutions, return the subsequence with the **maximum total sum** of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.\n\nNote that the solution with the given constraints is guaranteed to be **unique**. Also return the answer sorted in **non-increasing** order.\n\n**Example 1:**\n\n**Input:** nums = \\[4,3,10,9,8\\]\n**Output:** \\[10,9\\] \n**Explanation:** The subsequences \\[10,9\\] and \\[10,8\\] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence \\[10,9\\] has the maximum total sum of its elements. \n\n**Example 2:**\n\n**Input:** nums = \\[4,4,7,6,7\\]\n**Output:** \\[7,7,6\\] \n**Explanation:** The subsequence \\[7,7\\] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence \\[7,6,7\\] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-decreasing order.  \n\n**Constraints:**\n\n*   `1 <= nums.length <= 500`\n*   `1 <= nums[i] <= 100`", "java": "\n    ```java\npublic int minChangesToDivideString(String s, int k) {\n    int n = s.length();\n    if (n % k != 0) return -1;\n    int chunkCount = n / k;\n    int res = 0;\n    for (int i = 0; i < k; ++i) {\n        int[] counts = new int[26];\n        for (int j = i; j < n; j += k) {\n            ++counts[s.charAt(j) - 'a'];\n        }\n        int maxCount = Arrays.stream(counts).max().getAsInt();\n        res += chunkCount - maxCount;\n    }\n    return res;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Check if the length of the string s is divisible by k. If not, return -1 as it's impossible to divide the string.\n2. Calculate the number of chunks the string will be divided into. This value will be (length of string / k).\n3. Initialize a variable `res` to 0. This will store the total count of characters needed to be changed.\n4. Loop through 0 to k as `i`:\n   a. Create a count array `counts` with 26 elements for each character in the lowercase English alphabet.\n   b. Loop through the characters of the string starting from `i` and incrementing by `k`.\n   c. Increment the count associated with each lowercase character in the `counts` array.\n   d. Find the maximum count in the `counts` array.\n   e. Add the difference of chunkCount and maxCount to the `res` variable.\n5. Return the `res` variable, which contains the minimal number of characters that need to be changed.\n    ", "c++": "\n    ```cpp\nint min_changes_to_divide_string(const std::string& s, int k) {\n    int n = s.length();\n    if (n % k != 0) return -1;\n    int chunk_count = n / k;\n    int res = 0;\n    for (int i = 0; i < k; ++i) {\n        int counts[26] = {0};\n        for (int j = i; j < n; j += k) {\n            ++counts[s[j] - 'a'];\n        }\n        int max_count = *std::max_element(counts, counts + 26);\n        res += chunk_count - max_count;\n    }\n    return res;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Check if the length of the string s is divisible by k. If not, return -1 as it's impossible to divide the string.\n2. Calculate the number of chunks the string will be divided into. This value will be (length of string / k).\n3. Initialize a variable `res` to 0. This will store the total count of characters needed to be changed.\n4. Loop through 0 to k as `i`:\n   a. Create a count array `counts` with 26 elements for each character in the lowercase English alphabet.\n   b. Loop through the characters of the string starting from `i` and incrementing by `k`.\n   c. Increment the count associated with each lowercase character in the `counts` array.\n   d. Find the maximum count in the `counts` array.\n   e. Add the difference of chunkCount and maxCount to the `res` variable.\n5. Return the `res` variable, which contains the minimal number of characters that need to be changed.\n    ", "python": "\n    ```python\ndef min_changes_to_divide_string(s, k):\n    n = len(s)\n    if n % k != 0:\n        return -1\n    chunk_count = n // k\n    res = 0\n    for i in range(k):\n        counts = [0] * 26\n        for j in range(i, n, k):\n            counts[ord(s[j]) - ord('a')] += 1\n        max_count = max(counts)\n        res += chunk_count - max_count\n    return res\n```\n    \n    The algorithm works as follows:\n\n1. Check if the length of the string s is divisible by k. If not, return -1 as it's impossible to divide the string.\n2. Calculate the number of chunks the string will be divided into. This value will be (length of string / k).\n3. Initialize a variable `res` to 0. This will store the total count of characters needed to be changed.\n4. Loop through 0 to k as `i`:\n   a. Create a count array `counts` with 26 elements for each character in the lowercase English alphabet.\n   b. Loop through the characters of the string starting from `i` and incrementing by `k`.\n   c. Increment the count associated with each lowercase character in the `counts` array.\n   d. Find the maximum count in the `counts` array.\n   e. Add the difference of chunkCount and maxCount to the `res` variable.\n5. Return the `res` variable, which contains the minimal number of characters that need to be changed.\n    ", "javascript": "\n    ```javascript\nfunction minChangesToDivideString(s, k) {\n    let n = s.length;\n    if (n % k !== 0) {\n        return -1;\n    }\n    let chunkCount = n / k;\n    let res = 0;\n    for (let i = 0; i < k; ++i) {\n        let counts = new Array(26).fill(0);\n        for (let j = i; j < n; j += k) {\n            ++counts[s.charCodeAt(j) - 'a'.charCodeAt(0)];\n        }\n        let maxCount = Math.max(...counts);\n        res += chunkCount - maxCount;\n    }\n    return res;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Check if the length of the string s is divisible by k. If not, return -1 as it's impossible to divide the string.\n2. Calculate the number of chunks the string will be divided into. This value will be (length of string / k).\n3. Initialize a variable `res` to 0. This will store the total count of characters needed to be changed.\n4. Loop through 0 to k as `i`:\n   a. Create a count array `counts` with 26 elements for each character in the lowercase English alphabet.\n   b. Loop through the characters of the string starting from `i` and incrementing by `k`.\n   c. Increment the count associated with each lowercase character in the `counts` array.\n   d. Find the maximum count in the `counts` array.\n   e. Add the difference of chunkCount and maxCount to the `res` variable.\n5. Return the `res` variable, which contains the minimal number of characters that need to be changed.\n    "}
{"id": 1405, "slug": "longest-happy-string", "title": "Longest Happy String", "difficulty": "Medium", "content": "A string `s` is called **happy** if it satisfies the following conditions:\n\n*   `s` only contains the letters `'a'`, `'b'`, and `'c'`.\n*   `s` does not contain any of `\"aaa \"`, `\"bbb \"`, or `\"ccc \"` as a substring.\n*   `s` contains **at most** `a` occurrences of the letter `'a'`.\n*   `s` contains **at most** `b` occurrences of the letter `'b'`.\n*   `s` contains **at most** `c` occurrences of the letter `'c'`.\n\nGiven three integers `a`, `b`, and `c`, return _the **longest possible happy** string_. If there are multiple longest happy strings, return _any of them_. If there is no such string, return _the empty string_ `\" \"`.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n**Example 1:**\n\n**Input:** a = 1, b = 1, c = 7\n**Output:**  \"ccaccbcc \"\n**Explanation:**  \"ccbccacc \" would also be a correct answer.\n\n**Example 2:**\n\n**Input:** a = 7, b = 1, c = 0\n**Output:**  \"aabaa \"\n**Explanation:** It is the only correct answer in this case.\n\n**Constraints:**\n\n*   `0 <= a, b, c <= 100`\n*   `a + b + c > 0`", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public String longestDiverseString(int a, int b, int c) {\n        StringBuilder result = new StringBuilder();\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a1, a2) -> a2[0] - a1[0]);\n        if (a != 0) pq.offer(new int[]{a, 'a'});\n        if (b != 0) pq.offer(new int[]{b, 'b'});\n        if (c != 0) pq.offer(new int[]{c, 'c'});\n        \n        while (!pq.isEmpty()) {\n            int[] first = pq.poll();\n            if (result.length() != 0 && result.charAt(result.length()-1) == first[1]) {\n                if (pq.isEmpty()) break;\n                int[] second = pq.poll();\n                result.append((char)second[1]);\n                second[0]--;\n                if (second[0] != 0) pq.offer(second);\n                pq.offer(first);\n            } else {\n                result.append((char)first[1]);\n                first[0]--;\n                if (first[0] != 0) pq.offer(first);\n            }\n        }\n        return result.toString();\n    }\n}\n```\n    \n    Create a priority queue that stores the frequency and the character, in descending order of frequency. Iterate through the queue, adding characters to the result string. If the current character is the same as the last character in the result, and there is another character available in the queue, add the next available character to the result instead. Then, decrement the frequency count and push the used characters back into the priority queue if they still have positive frequency. If there are no suitable characters left in the priority queue, stop processing and return the result string. The final result will be a happy string that meets the given requirements.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nstring longestDiverseString(int a, int b, int c) {\n    string result = \"\";\n    using T = pair<int, char>;\n    priority_queue<T> pq;\n    if (a) pq.push({a, 'a'});\n    if (b) pq.push({b, 'b'});\n    if (c) pq.push({c, 'c'});\n    \n    while (!pq.empty()) {\n        T first = pq.top(); pq.pop();\n        if (!result.empty() && result.back() == first.second) {\n            if (pq.empty()) break;\n            T second = pq.top(); pq.pop();\n            result += second.second;\n            second.first--;\n            if (second.first) pq.push(second);\n            pq.push(first);\n        } else {\n            result += first.second;\n            first.first--;\n            if (first.first) pq.push(first);\n        }\n    }\n    return result;\n}\n```\n    \n    Create a priority queue that stores the frequency and the character, in descending order of frequency. Iterate through the queue, adding characters to the result string. If the current character is the same as the last character in the result, and there is another character available in the queue, add the next available character to the result instead. Then, decrement the frequency count and push the used characters back into the priority queue if they still have positive frequency. If there are no suitable characters left in the priority queue, stop processing and return the result string. The final result will be a happy string that meets the given requirements.\n    ", "python": "\n    ```python\nimport heapq\n\ndef longest_diverse_string(a: int, b: int, c: int) -> str:\n    result = \"\"\n    pq = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(pq)\n    \n    while pq:\n        first = heapq.heappop(pq)\n        if not result or result[-1] != first[1]:\n            result += first[1]\n            first = (first[0] + 1, first[1])\n            if first[0] < 0:\n                heapq.heappush(pq, first)\n        elif pq:\n            second = heapq.heappop(pq)\n            result += second[1]\n            second = (second[0] + 1, second[1])\n            if second[0] < 0:\n                heapq.heappush(pq, second)\n            if first[0] < 0:\n                heapq.heappush(pq, first)\n        else:\n            break\n            \n    return result\n```\n    \n    Create a priority queue that stores the frequency and the character, in descending order of frequency. Iterate through the queue, adding characters to the result string. If the current character is the same as the last character in the result, and there is another character available in the queue, add the next available character to the result instead. Then, decrement the frequency count and push the used characters back into the priority queue if they still have positive frequency. If there are no suitable characters left in the priority queue, stop processing and return the result string. The final result will be a happy string that meets the given requirements.\n    ", "javascript": "\n    ```javascript\nvar longestDiverseString = function(a, b, c) {\n    let result = \"\";\n    let pq = new PriorityQueue(([cnt1, _], [cnt2, __]) => cnt1 > cnt2);\n    if (a !== 0) pq.enqueue([a, 'a']);\n    if (b !== 0) pq.enqueue([b, 'b']);\n    if (c !== 0) pq.enqueue([c, 'c']);\n    \n    while (!pq.isEmpty()) {\n        let [firstCnt, firstChar] = pq.dequeue();\n        if (result.length === 0 || result[result.length - 1] !== firstChar) {\n            result += firstChar;\n            firstCnt--;\n            if (firstCnt !== 0) pq.enqueue([firstCnt, firstChar]);\n        } else if (!pq.isEmpty()) {\n            let [secondCnt, secondChar] = pq.dequeue();\n            result += secondChar;\n            secondCnt--;\n            if (secondCnt !== 0) pq.enqueue([secondCnt, secondChar]);\n            pq.enqueue([firstCnt, firstChar]);\n        } else {\n            break;\n        }\n    }\n    return result;\n};\n```\n    \n    Create a priority queue that stores the frequency and the character, in descending order of frequency. Iterate through the queue, adding characters to the result string. If the current character is the same as the last character in the result, and there is another character available in the queue, add the next available character to the result instead. Then, decrement the frequency count and push the used characters back into the priority queue if they still have positive frequency. If there are no suitable characters left in the priority queue, stop processing and return the result string. The final result will be a happy string that meets the given requirements.\n    "}
{"id": 1414, "slug": "find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k", "title": "Find the Minimum Number of Fibonacci Numbers Whose Sum Is K", "difficulty": "Medium", "content": "Given an integer `k`, _return the minimum number of Fibonacci numbers whose sum is equal to_ `k`. The same Fibonacci number can be used multiple times.\n\nThe Fibonacci numbers are defined as:\n\n*   `F1 = 1`\n*   `F2 = 1`\n*   `Fn = Fn-1 + Fn-2` for `n > 2.`\n\nIt is guaranteed that for the given constraints we can always find such Fibonacci numbers that sum up to `k`.\n\n**Example 1:**\n\n**Input:** k = 7\n**Output:** 2 \n**Explanation:** The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ... \nFor k = 7 we can use 2 + 5 = 7.\n\n**Example 2:**\n\n**Input:** k = 10\n**Output:** 2 \n**Explanation:** For k = 10 we can use 2 + 8 = 10.\n\n**Example 3:**\n\n**Input:** k = 19\n**Output:** 3 \n**Explanation:** For k = 19 we can use 1 + 5 + 13 = 19.\n\n**Constraints:**\n\n*   `1 <= k <= 109`", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int shortestPath(int[][] grid, int k) {\n        int m = grid.length;\n        int n = grid[0].length;\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0, 0, k});\n        boolean[][][] visited = new boolean[m][n][k + 1];\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n            int step = current[2];\n            int remainingK = current[3];\n\n            if (x == m - 1 && y == n - 1) return step;\n            if (visited[x][y][remainingK]) continue;\n            visited[x][y][remainingK] = true;\n\n            int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n            for (int[] dir : directions) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    if (grid[nx][ny] == 1 && remainingK > 0) {\n                        queue.offer(new int[]{nx, ny, step + 1, remainingK - 1});\n                    } else if (grid[nx][ny] == 0) {\n                        queue.offer(new int[]{nx, ny, step + 1, remainingK});\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n}\n```\n    \n    We use Breadth-First Search (BFS) algorithm to explore the grid. We maintain a queue to store the current status of the cell (x, y, step) as well as the remaining obstacles that we can eliminate (remaining_k). We initialize the queue with (0, 0, 0, k).\n\nWe then iterate through the queue until it's empty, in each iteration we pop the front element and check if we reach the bottom-right corner (m-1, n-1). If yes, we return the number of steps. If not, we mark the cell as visited and try to explore the neighbors in all four directions (up, down, left, right). If the neighbor cell has an obstacle and we have remaining_k > 0, we can eliminate the obstacle and add the neighbor cell into the queue with its new status. If the neighbor cell has no obstacle, we can simply add it to the queue.\n\nAfter the iteration through the queue, if we haven't found a valid path to (m-1, n-1), we return -1.\n\nThe time complexity of this algorithm is O(m * n * k) because we potentially need to traverse all m * n cells, multiplied by k because we are keeping track of k states at each cell.\n    ", "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\n\nint shortestPath(std::vector<std::vector<int>>& grid, int k) {\n    int m = grid.size();\n    int n = grid[0].size();\n    std::queue<std::tuple<int, int, int, int>> q;\n    q.push({0, 0, 0, k});\n    std::vector<std::vector<std::vector<int>>> visited(m, std::vector<std::vector<int>>(n, std::vector<int>(k + 1, false)));\n\n    while (!q.empty()) {\n        auto [x, y, step, remain_k] = q.front();\n        q.pop();\n\n        if (x == m - 1 && y == n - 1) return step;\n        if (visited[x][y][remain_k]) continue;\n        visited[x][y][remain_k] = true;\n\n        std::vector<std::vector<int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        for (const auto &dir : directions) {\n            int nx = x + dir[0];\n            int ny = y + dir[1];\n\n            if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                if (grid[nx][ny] == 1 && remain_k > 0) {\n                    q.push({nx, ny, step + 1, remain_k - 1});\n                } else if (grid[nx][ny] == 0) {\n                    q.push({nx, ny, step + 1, remain_k});\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n```\n    \n    We use Breadth-First Search (BFS) algorithm to explore the grid. We maintain a queue to store the current status of the cell (x, y, step) as well as the remaining obstacles that we can eliminate (remaining_k). We initialize the queue with (0, 0, 0, k).\n\nWe then iterate through the queue until it's empty, in each iteration we pop the front element and check if we reach the bottom-right corner (m-1, n-1). If yes, we return the number of steps. If not, we mark the cell as visited and try to explore the neighbors in all four directions (up, down, left, right). If the neighbor cell has an obstacle and we have remaining_k > 0, we can eliminate the obstacle and add the neighbor cell into the queue with its new status. If the neighbor cell has no obstacle, we can simply add it to the queue.\n\nAfter the iteration through the queue, if we haven't found a valid path to (m-1, n-1), we return -1.\n\nThe time complexity of this algorithm is O(m * n * k) because we potentially need to traverse all m * n cells, multiplied by k because we are keeping track of k states at each cell.\n    ", "python": "\n    ```python\nfrom collections import deque\n\ndef shortestPath(grid, k):\n    m, n = len(grid), len(grid[0])\n    queue = deque([(0, 0, 0, k)])\n    visited = [[[False] * (k + 1) for _ in range(n)] for _ in range(m)]\n\n    while queue:\n        x, y, step, remaining_k = queue.popleft()\n\n        if x == m - 1 and y == n - 1:\n            return step\n        if visited[x][y][remaining_k]:\n            continue\n        visited[x][y][remaining_k] = True\n\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n\n            if 0 <= nx < m and 0 <= ny < n:\n                if grid[nx][ny] == 1 and remaining_k > 0:\n                    queue.append((nx, ny, step + 1, remaining_k - 1))\n                elif grid[nx][ny] == 0:\n                    queue.append((nx, ny, step + 1, remaining_k))\n\n    return -1\n```\n    \n    We use Breadth-First Search (BFS) algorithm to explore the grid. We maintain a queue to store the current status of the cell (x, y, step) as well as the remaining obstacles that we can eliminate (remaining_k). We initialize the queue with (0, 0, 0, k).\n\nWe then iterate through the queue until it's empty, in each iteration we pop the front element and check if we reach the bottom-right corner (m-1, n-1). If yes, we return the number of steps. If not, we mark the cell as visited and try to explore the neighbors in all four directions (up, down, left, right). If the neighbor cell has an obstacle and we have remaining_k > 0, we can eliminate the obstacle and add the neighbor cell into the queue with its new status. If the neighbor cell has no obstacle, we can simply add it to the queue.\n\nAfter the iteration through the queue, if we haven't found a valid path to (m-1, n-1), we return -1.\n\nThe time complexity of this algorithm is O(m * n * k) because we potentially need to traverse all m * n cells, multiplied by k because we are keeping track of k states at each cell.\n    ", "javascript": "\n    ```javascript\nfunction shortestPath(grid, k) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const queue = [[0, 0, 0, k]];\n    const visited = new Array(m).fill(null).map(() => new Array(n).fill(null).map(() => new Array(k + 1).fill(false)));\n\n    while (queue.length) {\n        const [x, y, step, remainingK] = queue.shift();\n\n        if (x === m - 1 && y === n - 1) return step;\n        if (visited[x][y][remainingK]) continue;\n        visited[x][y][remainingK] = true;\n\n        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\n        for (const [dx, dy] of directions) {\n            const nx = x + dx;\n            const ny = y + dy;\n\n            if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                if (grid[nx][ny] === 1 && remainingK > 0) {\n                    queue.push([nx, ny, step + 1, remainingK - 1]);\n                } else if (grid[nx][ny] === 0) {\n                    queue.push([nx, ny, step + 1, remainingK]);\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n```\n    \n    We use Breadth-First Search (BFS) algorithm to explore the grid. We maintain a queue to store the current status of the cell (x, y, step) as well as the remaining obstacles that we can eliminate (remaining_k). We initialize the queue with (0, 0, 0, k).\n\nWe then iterate through the queue until it's empty, in each iteration we pop the front element and check if we reach the bottom-right corner (m-1, n-1). If yes, we return the number of steps. If not, we mark the cell as visited and try to explore the neighbors in all four directions (up, down, left, right). If the neighbor cell has an obstacle and we have remaining_k > 0, we can eliminate the obstacle and add the neighbor cell into the queue with its new status. If the neighbor cell has no obstacle, we can simply add it to the queue.\n\nAfter the iteration through the queue, if we haven't found a valid path to (m-1, n-1), we return -1.\n\nThe time complexity of this algorithm is O(m * n * k) because we potentially need to traverse all m * n cells, multiplied by k because we are keeping track of k states at each cell.\n    "}
{"id": 1432, "slug": "max-difference-you-can-get-from-changing-an-integer", "title": "Max Difference You Can Get From Changing an Integer", "difficulty": "Medium", "content": "You are given an integer `num`. You will apply the following steps exactly **two** times:\n\n*   Pick a digit `x (0 <= x <= 9)`.\n*   Pick another digit `y (0 <= y <= 9)`. The digit `y` can be equal to `x`.\n*   Replace all the occurrences of `x` in the decimal representation of `num` by `y`.\n*   The new integer **cannot** have any leading zeros, also the new integer **cannot** be 0.\n\nLet `a` and `b` be the results of applying the operations to `num` the first and second times, respectively.\n\nReturn _the max difference_ between `a` and `b`.\n\n**Example 1:**\n\n**Input:** num = 555\n**Output:** 888\n**Explanation:** The first time pick x = 5 and y = 9 and store the new integer in a.\nThe second time pick x = 5 and y = 1 and store the new integer in b.\nWe have now a = 999 and b = 111 and max difference = 888\n\n**Example 2:**\n\n**Input:** num = 9\n**Output:** 8\n**Explanation:** The first time pick x = 9 and y = 9 and store the new integer in a.\nThe second time pick x = 9 and y = 1 and store the new integer in b.\nWe have now a = 9 and b = 1 and max difference = 8\n\n**Constraints:**\n\n*   `1 <= num <= 10`8", "java": "\n    ```java\npublic int maxDiff(int num) {\n    int a = -1, b = -1;\n    String s = Integer.toString(num);\n    for (char c : s.toCharArray()) {\n        if (a == -1 && c != '9') {\n            a = c - '0';\n        }\n        if (b == -1 && c > '1') {\n            b = c - '0';\n        }\n        if (a != -1 && b != -1) {\n            break;\n        }\n    }\n    int result = 0;\n    for (char c : s.toCharArray()) {\n        if (c - '0' == a) {\n            result = result * 10 + 9;\n        } else if (c - '0' == b) {\n            result = result * 10 + ((c == s.charAt(0)) ? 1 : 0);\n        } else {\n            result = result * 10 + c - '0';\n        }\n    }\n    return result - num;\n}\n```\n\n    \n    The algorithm first initializes two variables `a` and `b` with -1. Then, it iterates through the digits of the given integer `num` in the form of a string. It sets the values of `a` and `b` as follows:\n- `a` is the first digit that is not 9. Changing this digit to 9 will result in the maximum possible integer.\n- `b` is the first digit that is greater than 1. Changing this digit to 1 when it's the first digit, and to 0 otherwise, will result in the minimum possible integer.\n\nAfter finding `a` and `b`, the algorithm iterates through the digits of `num` again and creates a new integer by replacing the digits of `num` with the corresponding processed digits. Finally, it returns the difference between the processed integer and the original one, which corresponds to the max difference between `a` and `b`.\n    ", "c++": "\n    ```cpp\nint maxDiff(int num) {\n    int a = -1, b = -1;\n    string s = to_string(num);\n    for (char c : s) {\n        if (a == -1 && c != '9') {\n            a = c - '0';\n        }\n        if (b == -1 && c > '1') {\n            b = c - '0';\n        }\n        if (a != -1 && b != -1) {\n            break;\n        }\n    }\n    for (char& c : s) {\n        if (c - '0' == a) {\n            c = '9';\n        } else if (c - '0' == b) {\n            c = (s.front() == c) ? '1' : '0';\n        }\n    }\n    return stoi(s) - num;\n}\n```\n\n    \n    The algorithm first initializes two variables `a` and `b` with -1. Then, it iterates through the digits of the given integer `num` in the form of a string. It sets the values of `a` and `b` as follows:\n- `a` is the first digit that is not 9. Changing this digit to 9 will result in the maximum possible integer.\n- `b` is the first digit that is greater than 1. Changing this digit to 1 when it's the first digit, and to 0 otherwise, will result in the minimum possible integer.\n\nAfter finding `a` and `b`, the algorithm iterates through the digits of `num` again and creates a new integer by replacing the digits of `num` with the corresponding processed digits. Finally, it returns the difference between the processed integer and the original one, which corresponds to the max difference between `a` and `b`.\n    ", "python": "\n    ```python\ndef max_diff(num):\n    a, b = -1, -1\n    num_str = str(num)\n    for c in num_str:\n        if a == -1 and c != '9':\n            a = int(c)\n        if b == -1 and c > '1':\n            b = int(c)\n        if a != -1 and b != -1:\n            break\n            \n    result = 0\n    for c in num_str:\n        if int(c) == a:\n            result = result * 10 + 9\n        elif int(c) == b:\n            result = result * 10 + (1 if c == num_str[0] else 0)\n        else:\n            result = result * 10 + int(c)\n    return result - num\n```\n\n    \n    The algorithm first initializes two variables `a` and `b` with -1. Then, it iterates through the digits of the given integer `num` in the form of a string. It sets the values of `a` and `b` as follows:\n- `a` is the first digit that is not 9. Changing this digit to 9 will result in the maximum possible integer.\n- `b` is the first digit that is greater than 1. Changing this digit to 1 when it's the first digit, and to 0 otherwise, will result in the minimum possible integer.\n\nAfter finding `a` and `b`, the algorithm iterates through the digits of `num` again and creates a new integer by replacing the digits of `num` with the corresponding processed digits. Finally, it returns the difference between the processed integer and the original one, which corresponds to the max difference between `a` and `b`.\n    ", "javascript": "\n    ```javascript\nfunction maxDiff(num) {\n    let a = -1, b = -1;\n    const numStr = num.toString();\n    for (const c of numStr) {\n        if (a === -1 && c !== '9') {\n            a = parseInt(c);\n        }\n        if (b === -1 && c > '1') {\n            b = parseInt(c);\n        }\n        if (a !== -1 && b !== -1) {\n            break;\n        }\n    }\n    let result = 0;\n    for (const c of numStr) {\n        if (parseInt(c) === a) {\n            result = result * 10 + 9;\n        } else if (parseInt(c) === b) {\n            result = result * 10 + ((c === numStr[0]) ? 1 : 0);\n        } else {\n            result = result * 10 + parseInt(c);\n        }\n    }\n    return result - num;\n}\n```\n\n    \n    The algorithm first initializes two variables `a` and `b` with -1. Then, it iterates through the digits of the given integer `num` in the form of a string. It sets the values of `a` and `b` as follows:\n- `a` is the first digit that is not 9. Changing this digit to 9 will result in the maximum possible integer.\n- `b` is the first digit that is greater than 1. Changing this digit to 1 when it's the first digit, and to 0 otherwise, will result in the minimum possible integer.\n\nAfter finding `a` and `b`, the algorithm iterates through the digits of `num` again and creates a new integer by replacing the digits of `num` with the corresponding processed digits. Finally, it returns the difference between the processed integer and the original one, which corresponds to the max difference between `a` and `b`.\n    "}
{"id": 1433, "slug": "check-if-a-string-can-break-another-string", "title": "Check If a String Can Break Another String", "difficulty": "Medium", "content": "Given two strings: `s1` and `s2` with the same size, check if some permutation of string `s1` can break some permutation of string `s2` or vice-versa. In other words `s2` can break `s1` or vice-versa.\n\nA string `x` can break string `y` (both of size `n`) if `x[i] >= y[i]` (in alphabetical order) for all `i` between `0` and `n-1`.\n\n**Example 1:**\n\n**Input:** s1 =  \"abc \", s2 =  \"xya \"\n**Output:** true\n**Explanation:**  \"ayx \" is a permutation of s2= \"xya \" which can break to string  \"abc \" which is a permutation of s1= \"abc \".\n\n**Example 2:**\n\n**Input:** s1 =  \"abe \", s2 =  \"acd \"\n**Output:** false \n**Explanation:** All permutations for s1= \"abe \" are:  \"abe \",  \"aeb \",  \"bae \",  \"bea \",  \"eab \" and  \"eba \" and all permutation for s2= \"acd \" are:  \"acd \",  \"adc \",  \"cad \",  \"cda \",  \"dac \" and  \"dca \". However, there is not any permutation from s1 which can break some permutation from s2 and vice-versa.\n\n**Example 3:**\n\n**Input:** s1 =  \"leetcodee \", s2 =  \"interview \"\n**Output:** true\n\n**Constraints:**\n\n*   `s1.length == n`\n*   `s2.length == n`\n*   `1 <= n <= 10^5`\n*   All strings consist of lowercase English letters.", "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Encrypter {\n    private Map<Character, String> encryptMap;\n    private Map<String, Character> decryptMap;\n    private Set<String> dictionary;\n\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\n        encryptMap = new HashMap<>();\n        decryptMap = new HashMap<>();\n        this.dictionary = new HashSet<>();\n        for (int i = 0; i < keys.length; i++) {\n            encryptMap.put(keys[i], values[i]);\n            decryptMap.put(values[i], keys[i]);\n        }\n        for (String word : dictionary) {\n            this.dictionary.add(word);\n        }\n    }\n\n    public String encrypt(String original) {\n        StringBuilder res = new StringBuilder();\n        for (char c : original.toCharArray()) {\n            if (!encryptMap.containsKey(c)) {\n                return \"\";\n            }\n            res.append(encryptMap.get(c));\n        }\n        return res.toString();\n    }\n\n    public String decrypt(String encrypted) {\n        StringBuilder res = new StringBuilder();\n        for (int i = 0; i < encrypted.length(); i += 2) {\n            String temp = encrypted.substring(i, i + 2);\n            if (!decryptMap.containsKey(temp)) {\n                return \"\";\n            }\n            res.append(decryptMap.get(temp));\n        }\n        String decrypted = res.toString();\n        if (!dictionary.contains(decrypted)) {\n            return \"\";\n        }\n        return decrypted;\n    }\n}\n```\n    \n    The Encrypter class/constructor initializes three data structures:\n1. `encrypt_map` to map the unique characters to their encrypted strings.\n2. `decrypt_map` to map the encrypted strings back to their original characters.\n3. `dictionary` to store the list of permitted original strings for decryption.\n\nThe `encrypt` function does the following:\n- Iterates through the characters in the original string.\n- Checks if the character is present in the `encrypt_map`. If not, it returns an empty string.\n- Appends the encrypted value from the `encrypt_map` to the result.\n- Returns the joined result as a string.\n\nThe `decrypt` function does the following:\n- Iterates through the encrypted string in steps of 2 since all encrypted strings have a length of 2.\n- Checks if the substring is present in the `decrypt_map`. If not, it returns an empty string.\n- Appends the decrypted character from the `decrypt_map` to the result.\n- Checks if the decrypted string is present in the `dictionary`. If not, it returns an empty string.\n- Returns the decrypted string.\n\nThe overall algorithm for both encryption and decryption is O(n), where n is the length of the input string. The class provides a simple encryption and decryption process. The main limitation is that it can only handle unique characters, as stated in the problem description.\n    ", "c++": "\n    ```cpp\n#include <unordered_map>\n#include <string>\n#include <vector>\n\nclass Encrypter {\npublic:\n    Encrypter(std::vector<char> keys, std::vector<std::string> values, std::vector<std::string> dictionary) {\n        for (int i = 0; i < keys.size(); i++) {\n            encrypt_map[keys[i]] = values[i];\n            decrypt_map[values[i]] = keys[i];\n        }\n        for (const auto &word : dictionary) {\n            this->dictionary.insert(word);\n        }\n    }\n\n    std::string encrypt(const std::string &original) {\n        std::string res = \"\";\n        for (char c : original) {\n            if (encrypt_map.find(c) == encrypt_map.end()) {\n                return \"\";\n            }\n            res += encrypt_map[c];\n        }\n        return res;\n    }\n\n    std::string decrypt(const std::string &encrypted) {\n        std::string res = \"\";\n        for (int i = 0; i < encrypted.size(); i += 2) {\n            std::string temp = encrypted.substr(i, 2);\n            if (decrypt_map.find(temp) == decrypt_map.end()) {\n                return \"\";\n            }\n            res += decrypt_map[temp];\n        }\n        if (dictionary.find(res) == dictionary.end()) {\n            return \"\";\n        }\n        return res;\n    }\n\nprivate:\n    std::unordered_map<char, std::string> encrypt_map;\n    std::unordered_map<std::string, char> decrypt_map;\n    std::unordered_set<std::string> dictionary;\n};\n```\n    \n    The Encrypter class/constructor initializes three data structures:\n1. `encrypt_map` to map the unique characters to their encrypted strings.\n2. `decrypt_map` to map the encrypted strings back to their original characters.\n3. `dictionary` to store the list of permitted original strings for decryption.\n\nThe `encrypt` function does the following:\n- Iterates through the characters in the original string.\n- Checks if the character is present in the `encrypt_map`. If not, it returns an empty string.\n- Appends the encrypted value from the `encrypt_map` to the result.\n- Returns the joined result as a string.\n\nThe `decrypt` function does the following:\n- Iterates through the encrypted string in steps of 2 since all encrypted strings have a length of 2.\n- Checks if the substring is present in the `decrypt_map`. If not, it returns an empty string.\n- Appends the decrypted character from the `decrypt_map` to the result.\n- Checks if the decrypted string is present in the `dictionary`. If not, it returns an empty string.\n- Returns the decrypted string.\n\nThe overall algorithm for both encryption and decryption is O(n), where n is the length of the input string. The class provides a simple encryption and decryption process. The main limitation is that it can only handle unique characters, as stated in the problem description.\n    ", "python": "\n    ```python\nclass Encrypter:\n    def __init__(self, keys, values, dictionary):\n        self.encrypt_map = dict(zip(keys, values))\n        self.decrypt_map = dict(zip(values, keys))\n        self.dictionary = set(dictionary)\n    \n    def encrypt(self, original):\n        result = []\n        for c in original:\n            if c not in self.encrypt_map:\n                return \"\"\n            result.append(self.encrypt_map[c])\n        return \"\".join(result)\n\n    def decrypt(self, encrypted):\n        result = []\n        for i in range(0, len(encrypted), 2):\n            temp = encrypted[i:i+2]\n            if temp not in self.decrypt_map:\n                return \"\"\n            result.append(self.decrypt_map[temp])\n        \n        decrypted = \"\".join(result)\n        if decrypted not in self.dictionary:\n            return \"\"\n        return decrypted\n```\n    \n    The Encrypter class/constructor initializes three data structures:\n1. `encrypt_map` to map the unique characters to their encrypted strings.\n2. `decrypt_map` to map the encrypted strings back to their original characters.\n3. `dictionary` to store the list of permitted original strings for decryption.\n\nThe `encrypt` function does the following:\n- Iterates through the characters in the original string.\n- Checks if the character is present in the `encrypt_map`. If not, it returns an empty string.\n- Appends the encrypted value from the `encrypt_map` to the result.\n- Returns the joined result as a string.\n\nThe `decrypt` function does the following:\n- Iterates through the encrypted string in steps of 2 since all encrypted strings have a length of 2.\n- Checks if the substring is present in the `decrypt_map`. If not, it returns an empty string.\n- Appends the decrypted character from the `decrypt_map` to the result.\n- Checks if the decrypted string is present in the `dictionary`. If not, it returns an empty string.\n- Returns the decrypted string.\n\nThe overall algorithm for both encryption and decryption is O(n), where n is the length of the input string. The class provides a simple encryption and decryption process. The main limitation is that it can only handle unique characters, as stated in the problem description.\n    ", "javascript": "\n    ```javascript\nclass Encrypter {\n    constructor(keys, values, dictionary) {\n        this.encryptMap = new Map();\n        this.decryptMap = new Map();\n        this.dictionary = new Set(dictionary);\n        for (let i = 0; i < keys.length; i++) {\n            this.encryptMap.set(keys[i], values[i]);\n            this.decryptMap.set(values[i], keys[i]);\n        }\n    }\n\n    encrypt(original) {\n        let res = [];\n        for (const c of original) {\n            if (!this.encryptMap.has(c)) {\n                return \"\";\n            }\n            res.push(this.encryptMap.get(c));\n        }\n        return res.join('');\n    }\n\n    decrypt(encrypted) {\n        let res = [];\n        for (let i = 0; i < encrypted.length; i += 2) {\n            const temp = encrypted.slice(i, i + 2);\n            if (!this.decryptMap.has(temp)) {\n                return \"\";\n            }\n            res.push(this.decryptMap.get(temp));\n        }\n        const decrypted = res.join('');\n        if (!this.dictionary.has(decrypted)) {\n            return \"\";\n        }\n        return decrypted;\n    }\n}\n```\n    \n    The Encrypter class/constructor initializes three data structures:\n1. `encrypt_map` to map the unique characters to their encrypted strings.\n2. `decrypt_map` to map the encrypted strings back to their original characters.\n3. `dictionary` to store the list of permitted original strings for decryption.\n\nThe `encrypt` function does the following:\n- Iterates through the characters in the original string.\n- Checks if the character is present in the `encrypt_map`. If not, it returns an empty string.\n- Appends the encrypted value from the `encrypt_map` to the result.\n- Returns the joined result as a string.\n\nThe `decrypt` function does the following:\n- Iterates through the encrypted string in steps of 2 since all encrypted strings have a length of 2.\n- Checks if the substring is present in the `decrypt_map`. If not, it returns an empty string.\n- Appends the decrypted character from the `decrypt_map` to the result.\n- Checks if the decrypted string is present in the `dictionary`. If not, it returns an empty string.\n- Returns the decrypted string.\n\nThe overall algorithm for both encryption and decryption is O(n), where n is the length of the input string. The class provides a simple encryption and decryption process. The main limitation is that it can only handle unique characters, as stated in the problem description.\n    "}
{"id": 1465, "slug": "maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts", "title": "Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts", "difficulty": "Medium", "content": "You are given a rectangular cake of size `h x w` and two arrays of integers `horizontalCuts` and `verticalCuts` where:\n\n*   `horizontalCuts[i]` is the distance from the top of the rectangular cake to the `ith` horizontal cut and similarly, and\n*   `verticalCuts[j]` is the distance from the left of the rectangular cake to the `jth` vertical cut.\n\nReturn _the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays_ `horizontalCuts` _and_ `verticalCuts`. Since the answer can be a large number, return this **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** h = 5, w = 4, horizontalCuts = \\[1,2,4\\], verticalCuts = \\[1,3\\]\n**Output:** 4 \n**Explanation:** The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area.\n\n**Example 2:**\n\n**Input:** h = 5, w = 4, horizontalCuts = \\[3,1\\], verticalCuts = \\[1\\]\n**Output:** 6\n**Explanation:** The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area.\n\n**Example 3:**\n\n**Input:** h = 5, w = 4, horizontalCuts = \\[3\\], verticalCuts = \\[3\\]\n**Output:** 9\n\n**Constraints:**\n\n*   `2 <= h, w <= 109`\n*   `1 <= horizontalCuts.length <= min(h - 1, 105)`\n*   `1 <= verticalCuts.length <= min(w - 1, 105)`\n*   `1 <= horizontalCuts[i] < h`\n*   `1 <= verticalCuts[i] < w`\n*   All the elements in `horizontalCuts` are distinct.\n*   All the elements in `verticalCuts` are distinct.", "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class Solution {\n    private static final int MOD = 1000000007;\n\n    public int maxProduct(TreeNode root) {\n        long total = dfs(root), result = 0;\n        return (int) (dfs2(root, total / 2, result, total) % MOD);\n    }\n\n    private int dfs(TreeNode root) {\n        return root == null ? 0 : root.val + dfs(root.left) + dfs(root.right);\n    }\n\n    private long dfs2(TreeNode root, double half, long result, long total) {\n        if (root == null) return 0;\n        int curSum = root.val + dfs2(root.left, half, result, total) + dfs2(root.right, half, result, total);\n        result = Math.max(result, (total - curSum) * curSum);\n        return curSum;\n    }\n}\n```\n    \n    We first find the total sum of the tree by doing a simple DFS traversal. Then, we do another DFS traversal to find the optimal edge to remove to maximize the product of the sums of the two subtrees. In this second DFS traversal, we calculate the sum of the current subtree rooted at the current node, and check if the product of the current subtree sum and the remaining sum (total - current subtree sum) is larger than the current result. If so, we update the result. Finally, we return the result modulo 1e9+7 as required.\n    ", "c++": "\n    ```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int maxProduct(TreeNode* root) {\n        long total = dfs(root), result = 0;\n        dfs2(root, total/2, result, total);\n        return result % 1000000007;\n    }\n\n    int dfs(TreeNode* root) {\n        if (!root) return 0;\n        return root->val + dfs(root->left) + dfs(root->right);\n    }\n\n    int dfs2(TreeNode* root, double half, long& result, long total) {\n        if (!root) return 0;\n        int curSum = root->val + dfs2(root->left, half, result, total) + dfs2(root->right, half, result, total);\n        result = max(result, (total - curSum) * curSum);\n        return curSum;\n    }\n};\n```\n    \n    We first find the total sum of the tree by doing a simple DFS traversal. Then, we do another DFS traversal to find the optimal edge to remove to maximize the product of the sums of the two subtrees. In this second DFS traversal, we calculate the sum of the current subtree rooted at the current node, and check if the product of the current subtree sum and the remaining sum (total - current subtree sum) is larger than the current result. If so, we update the result. Finally, we return the result modulo 1e9+7 as required.\n    ", "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxProduct(self, root: TreeNode) -> int:\n        def dfs(node):\n            if not node:\n                return 0\n            return node.val + dfs(node.left) + dfs(node.right)\n\n        def dfs2(node, half):\n            nonlocal result\n\n            if not node:\n                return 0\n            cur_sum = node.val + dfs2(node.left, half) + dfs2(node.right, half)\n            result = max(result, (total - cur_sum) * cur_sum)\n            return cur_sum\n\n        total = dfs(root)\n        result = 0\n        dfs2(root, total / 2)\n        return result % (10**9 + 7)\n```\n    \n    We first find the total sum of the tree by doing a simple DFS traversal. Then, we do another DFS traversal to find the optimal edge to remove to maximize the product of the sums of the two subtrees. In this second DFS traversal, we calculate the sum of the current subtree rooted at the current node, and check if the product of the current subtree sum and the remaining sum (total - current subtree sum) is larger than the current result. If so, we update the result. Finally, we return the result modulo 1e9+7 as required.\n    ", "javascript": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left, right) {\n        this.val = (val === undefined ? 0 : val)\n        this.left = (left === undefined ? null : left)\n        this.right = (right === undefined ? null : right)\n    }\n}\n\nvar maxProduct = function(root) {\n    const mod = BigInt(10 ** 9 + 7);\n    let total, result = 0n;\n\n    function dfs(node) {\n        if (!node) return 0;\n        return node.val + dfs(node.left) + dfs(node.right);\n    }\n\n    function dfs2(node) {\n        if (!node) return 0;\n        let curSum = node.val + dfs2(node.left) + dfs2(node.right);\n        result = BigInt(Math.max(Number(result), Number((total - curSum) * curSum)));\n        return curSum;\n    }\n\n    total = BigInt(dfs(root));\n    dfs2(root);\n    return Number(result % mod);\n};\n```\n    \n    We first find the total sum of the tree by doing a simple DFS traversal. Then, we do another DFS traversal to find the optimal edge to remove to maximize the product of the sums of the two subtrees. In this second DFS traversal, we calculate the sum of the current subtree rooted at the current node, and check if the product of the current subtree sum and the remaining sum (total - current subtree sum) is larger than the current result. If so, we update the result. Finally, we return the result modulo 1e9+7 as required.\n    "}
{"id": 1481, "slug": "least-number-of-unique-integers-after-k-removals", "title": "Least Number of Unique Integers after K Removals", "difficulty": "Medium", "content": "Given an array of integers `arr` and an integer `k`. Find the _least number of unique integers_ after removing **exactly** `k` elements**.**\n\n**Example 1:**\n\n**Input:** arr = \\[5,5,4\\], k = 1\n**Output:** 1\n**Explanation**: Remove the single 4, only 5 is left.\n\n**Example 2:**\n\n**Input:** arr = \\[4,3,1,1,3,3,2\\], k = 3\n**Output:** 2\n**Explanation**: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 10^5`\n*   `1 <= arr[i] <= 10^9`\n*   `0 <= k <= arr.length`", "java": "\n    ```java\nimport java.util.*;\nclass Solution {\n    public int findLeastNumOfUniqueInts(int[] arr, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int n : arr) {\n           count.put(n, count.getOrDefault(n, 0) + 1);\n        }\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (int freq : count.values()) {\n            pq.add(freq);\n        }\n        while (k > 0) {\n            k -= pq.poll();\n        }\n        return k == 0 ? pq.size() : pq.size() + 1;\n    }\n}\n```\n    \n    The algorithm first counts the frequency of each unique integer in the array using a hashmap/dictionary. Then the frequencies are put into a min-heap/priority queue. The algorithm then removes k elements, taking into consideration the least frequent integers first (popping from the min-heap). After k elements are removed, the size of the priority queue is the number of remaining unique integers. If k is exactly 0, return the size of the priority queue, otherwise, return the size + 1 (as the last integer's frequency was not completely removed from the queue).\n    ", "c++": "\n    ```cpp\n#include <unordered_map>\n#include <queue>\nint findLeastNumOfUniqueInts(vector<int>& arr, int k) {\n    unordered_map<int, int> count;\n    for (int n : arr) {\n        count[n]++;\n    }\n    priority_queue<int, vector<int>, greater<int>> pq;\n    for (auto &p : count) {\n        pq.push(p.second);\n    }\n    while (k > 0) {\n        k -= pq.top();\n        pq.pop();\n    }\n    return k == 0 ? pq.size() : pq.size() + 1;\n}\n```\n    \n    The algorithm first counts the frequency of each unique integer in the array using a hashmap/dictionary. Then the frequencies are put into a min-heap/priority queue. The algorithm then removes k elements, taking into consideration the least frequent integers first (popping from the min-heap). After k elements are removed, the size of the priority queue is the number of remaining unique integers. If k is exactly 0, return the size of the priority queue, otherwise, return the size + 1 (as the last integer's frequency was not completely removed from the queue).\n    ", "python": "\n    ```python\nfrom collections import Counter\nimport heapq\n\ndef findLeastNumOfUniqueInts(arr, k):\n    count = Counter(arr)\n    pq = list(count.values())\n    heapq.heapify(pq)\n    while k > 0:\n        k -= heapq.heappop(pq)\n    return len(pq) if k == 0 else len(pq) + 1\n```\n    \n    The algorithm first counts the frequency of each unique integer in the array using a hashmap/dictionary. Then the frequencies are put into a min-heap/priority queue. The algorithm then removes k elements, taking into consideration the least frequent integers first (popping from the min-heap). After k elements are removed, the size of the priority queue is the number of remaining unique integers. If k is exactly 0, return the size of the priority queue, otherwise, return the size + 1 (as the last integer's frequency was not completely removed from the queue).\n    ", "javascript": "\n    ```javascript\nfunction findLeastNumOfUniqueInts(arr, k) {\n    let count = {};\n    for (let n of arr) {\n        count[n] = (count[n] || 0) + 1;\n    }\n    let pq = Object.values(count).sort((a, b) => a - b);\n    while (k > 0) {\n        k -= pq.shift();\n    }\n    return k === 0 ? pq.length : pq.length + 1;\n}\n```\n    \n    The algorithm first counts the frequency of each unique integer in the array using a hashmap/dictionary. Then the frequencies are put into a min-heap/priority queue. The algorithm then removes k elements, taking into consideration the least frequent integers first (popping from the min-heap). After k elements are removed, the size of the priority queue is the number of remaining unique integers. If k is exactly 0, return the size of the priority queue, otherwise, return the size + 1 (as the last integer's frequency was not completely removed from the queue).\n    "}
{"id": 1488, "slug": "avoid-flood-in-the-city", "title": "Avoid Flood in The City", "difficulty": "Medium", "content": "Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the `nth` lake, the `nth` lake becomes full of water. If it rains over a lake that is **full of water**, there will be a **flood**. Your goal is to avoid floods in any lake.\n\nGiven an integer array `rains` where:\n\n*   `rains[i] > 0` means there will be rains over the `rains[i]` lake.\n*   `rains[i] == 0` means there are no rains this day and you can choose **one lake** this day and **dry it**.\n\nReturn _an array `ans`_ where:\n\n*   `ans.length == rains.length`\n*   `ans[i] == -1` if `rains[i] > 0`.\n*   `ans[i]` is the lake you choose to dry in the `ith` day if `rains[i] == 0`.\n\nIf there are multiple valid answers return **any** of them. If it is impossible to avoid flood return **an empty array**.\n\nNotice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes.\n\n**Example 1:**\n\n**Input:** rains = \\[1,2,3,4\\]\n**Output:** \\[-1,-1,-1,-1\\]\n**Explanation:** After the first day full lakes are \\[1\\]\nAfter the second day full lakes are \\[1,2\\]\nAfter the third day full lakes are \\[1,2,3\\]\nAfter the fourth day full lakes are \\[1,2,3,4\\]\nThere's no day to dry any lake and there is no flood in any lake.\n\n**Example 2:**\n\n**Input:** rains = \\[1,2,0,0,2,1\\]\n**Output:** \\[-1,-1,2,1,-1,-1\\]\n**Explanation:** After the first day full lakes are \\[1\\]\nAfter the second day full lakes are \\[1,2\\]\nAfter the third day, we dry lake 2. Full lakes are \\[1\\]\nAfter the fourth day, we dry lake 1. There is no full lakes.\nAfter the fifth day, full lakes are \\[2\\].\nAfter the sixth day, full lakes are \\[1,2\\].\nIt is easy that this scenario is flood-free. \\[-1,-1,1,2,-1,-1\\] is another acceptable scenario.\n\n**Example 3:**\n\n**Input:** rains = \\[1,2,0,1,2\\]\n**Output:** \\[\\]\n**Explanation:** After the second day, full lakes are  \\[1,2\\]. We have to dry one lake in the third day.\nAfter that, it will rain over lakes \\[1,2\\]. It's easy to prove that no matter which lake you choose to dry in the 3rd day, the other one will flood.\n\n**Constraints:**\n\n*   `1 <= rains.length <= 105`\n*   `0 <= rains[i] <= 109`", "java": "\n    ```java\nint getPower(int x) {\n    int steps = 0;\n    while (x != 1) {\n        if (x % 2 == 0) x /= 2;\n        else x = 3 * x + 1;\n        steps++;\n    }\n    return steps;\n}\n\nint sortByPower(int lo, int hi, int k) {\n    List<int[]> nums = new ArrayList<>();\n    for (int i = lo; i <= hi; i++) {\n        nums.add(new int[]{getPower(i), i});\n    }\n    nums.sort(Comparator.comparingInt((int[] a) -> a[0]).thenComparingInt(a -> a[1]));\n    return nums.get(k - 1)[1];\n}\n```\n    \n    The algorithm starts with defining a helper function `getPower(x)` that takes an integer `x` and calculates its power value by following the given steps (divide by 2 if even, multiply by 3 and add 1 if odd) until `x` becomes 1. The function returns the number of steps required to reach 1.\n\nThen, we define the main function `sort_by_power(lo, hi, k)` that generates a list of pairs (in Python, tuples) consisting of the power value and the integer itself for all integers in the range [lo, hi]. It then sorts this list in ascending order based on the power values (and the integers themselves as a tiebreaker).\n\nFinally, the kth integer in the sorted list is returned as the result. This is achieved by indexing the sorted list with `k - 1` due to zero-based indexing.\n    ", "c++": "\n    ```cpp\nint getPower(int x) {\n    int steps = 0;\n    while (x != 1) {\n        if (x % 2 == 0) x /= 2;\n        else x = 3 * x + 1;\n        steps++;\n    }\n    return steps;\n}\n\nint sort_by_power(int lo, int hi, int k) {\n    vector<pair<int, int>> nums;\n    for (int i = lo; i <= hi; i++) {\n        nums.push_back({getPower(i), i});\n    }\n    sort(nums.begin(), nums.end());\n    return nums[k - 1].second;\n}\n```\n    \n    The algorithm starts with defining a helper function `getPower(x)` that takes an integer `x` and calculates its power value by following the given steps (divide by 2 if even, multiply by 3 and add 1 if odd) until `x` becomes 1. The function returns the number of steps required to reach 1.\n\nThen, we define the main function `sort_by_power(lo, hi, k)` that generates a list of pairs (in Python, tuples) consisting of the power value and the integer itself for all integers in the range [lo, hi]. It then sorts this list in ascending order based on the power values (and the integers themselves as a tiebreaker).\n\nFinally, the kth integer in the sorted list is returned as the result. This is achieved by indexing the sorted list with `k - 1` due to zero-based indexing.\n    ", "python": "\n    ```python\ndef get_power(x):\n    steps = 0\n    while x != 1:\n        if x % 2 == 0:\n            x //= 2\n        else:\n            x = 3 * x + 1\n        steps += 1\n    return steps\n\ndef sort_by_power(lo, hi, k):\n    nums = [(get_power(i), i) for i in range(lo, hi + 1)]\n    nums.sort()\n    return nums[k - 1][1]\n```\n    \n    The algorithm starts with defining a helper function `getPower(x)` that takes an integer `x` and calculates its power value by following the given steps (divide by 2 if even, multiply by 3 and add 1 if odd) until `x` becomes 1. The function returns the number of steps required to reach 1.\n\nThen, we define the main function `sort_by_power(lo, hi, k)` that generates a list of pairs (in Python, tuples) consisting of the power value and the integer itself for all integers in the range [lo, hi]. It then sorts this list in ascending order based on the power values (and the integers themselves as a tiebreaker).\n\nFinally, the kth integer in the sorted list is returned as the result. This is achieved by indexing the sorted list with `k - 1` due to zero-based indexing.\n    ", "javascript": "\n    ```javascript\nfunction getPower(x) {\n    let steps = 0;\n    while (x !== 1) {\n        if (x % 2 === 0) x /= 2;\n        else x = 3 * x + 1;\n        steps++;\n    }\n    return steps;\n}\n\nfunction sortByPower(lo, hi, k) {\n    let nums = [];\n    for (let i = lo; i <= hi; i++) {\n        nums.push([getPower(i), i]);\n    }\n    nums.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n    return nums[k - 1][1];\n}\n```\n    \n    The algorithm starts with defining a helper function `getPower(x)` that takes an integer `x` and calculates its power value by following the given steps (divide by 2 if even, multiply by 3 and add 1 if odd) until `x` becomes 1. The function returns the number of steps required to reach 1.\n\nThen, we define the main function `sort_by_power(lo, hi, k)` that generates a list of pairs (in Python, tuples) consisting of the power value and the integer itself for all integers in the range [lo, hi]. It then sorts this list in ascending order based on the power values (and the integers themselves as a tiebreaker).\n\nFinally, the kth integer in the sorted list is returned as the result. This is achieved by indexing the sorted list with `k - 1` due to zero-based indexing.\n    "}
{"id": 1505, "slug": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits", "title": "Minimum Possible Integer After at Most K Adjacent Swaps On Digits", "difficulty": "Hard", "content": "You are given a string `num` representing **the digits** of a very large integer and an integer `k`. You are allowed to swap any two adjacent digits of the integer **at most** `k` times.\n\nReturn _the minimum integer you can obtain also as a string_.\n\n**Example 1:**\n\n**Input:** num =  \"4321 \", k = 4\n**Output:**  \"1342 \"\n**Explanation:** The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.\n\n**Example 2:**\n\n**Input:** num =  \"100 \", k = 1\n**Output:**  \"010 \"\n**Explanation:** It's ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros.\n\n**Example 3:**\n\n**Input:** num =  \"36789 \", k = 1000\n**Output:**  \"36789 \"\n**Explanation:** We can keep the number without any swaps.\n\n**Constraints:**\n\n*   `1 <= num.length <= 3 * 104`\n*   `num` consists of only **digits** and does not contain **leading zeros**.\n*   `1 <= k <= 109`", "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic int[] createTargetArray(int[] nums, int[] index) {\n    ArrayList<Integer> target = new ArrayList<>();\n    for (int i = 0; i < nums.length; ++i) {\n        target.add(index[i], nums[i]);\n    }\n    int[] result = new int[target.size()];\n    for (int i = 0; i < target.size(); ++i) {\n        result[i] = target.get(i);\n    }\n    return result;\n}\n```\n    \n    The algorithm first initializes an empty target array (or ArrayList in Java). Then, it iterates through the nums and index arrays. At each iteration, it inserts the current number from the nums array at the position specified by the current value in the index array. This is done using the insert function in C++ and Python, the splice function in JavaScript, and the add function in Java. At the end, the target array is returned.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> createTargetArray(std::vector<int>& nums, std::vector<int>& index) {\n    std::vector<int> target;\n    for (int i = 0; i < nums.size(); ++i) {\n        target.insert(target.begin() + index[i], nums[i]);\n    }\n    return target;\n}\n```\n    \n    The algorithm first initializes an empty target array (or ArrayList in Java). Then, it iterates through the nums and index arrays. At each iteration, it inserts the current number from the nums array at the position specified by the current value in the index array. This is done using the insert function in C++ and Python, the splice function in JavaScript, and the add function in Java. At the end, the target array is returned.\n    ", "python": "\n    ```python\ndef createTargetArray(nums, index):\n    target = []\n    for i in range(len(nums)):\n        target.insert(index[i], nums[i])\n    return target\n```\n    \n    The algorithm first initializes an empty target array (or ArrayList in Java). Then, it iterates through the nums and index arrays. At each iteration, it inserts the current number from the nums array at the position specified by the current value in the index array. This is done using the insert function in C++ and Python, the splice function in JavaScript, and the add function in Java. At the end, the target array is returned.\n    ", "javascript": "\n    ```javascript\nfunction createTargetArray(nums, index) {\n    let target = [];\n    for (let i = 0; i < nums.length; ++i) {\n        target.splice(index[i], 0, nums[i]);\n    }\n    return target;\n}\n```\n    \n    The algorithm first initializes an empty target array (or ArrayList in Java). Then, it iterates through the nums and index arrays. At each iteration, it inserts the current number from the nums array at the position specified by the current value in the index array. This is done using the insert function in C++ and Python, the splice function in JavaScript, and the add function in Java. At the end, the target array is returned.\n    "}
{"id": 1509, "slug": "minimum-difference-between-largest-and-smallest-value-in-three-moves", "title": "Minimum Difference Between Largest and Smallest Value in Three Moves", "difficulty": "Medium", "content": "You are given an integer array `nums`.\n\nIn one move, you can choose one element of `nums` and change it to **any value**.\n\nReturn _the minimum difference between the largest and smallest value of `nums` **after performing at most three moves**_.\n\n**Example 1:**\n\n**Input:** nums = \\[5,3,2,4\\]\n**Output:** 0\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 2 to 3. nums becomes \\[5,3,3,4\\].\nIn the second move, change 4 to 3. nums becomes \\[5,3,3,3\\].\nIn the third move, change 5 to 3. nums becomes \\[3,3,3,3\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0.\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,0,10,14\\]\n**Output:** 1\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 5 to 0. nums becomes \\[1,0,0,10,14\\].\nIn the second move, change 10 to 0. nums becomes \\[1,0,0,0,14\\].\nIn the third move, change 14 to 1. nums becomes \\[1,0,0,0,1\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 0.\nIt can be shown that there is no way to make the difference 0 in 3 moves.\n\n**Example 3:**\n\n**Input:** nums = \\[3,100,20\\]\n**Output:** 0\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 100 to 7. nums becomes \\[4,7,20\\].\nIn the second move, change 20 to 7. nums becomes \\[4,7,7\\].\nIn the third move, change 4 to 3. nums becomes \\[7,7,7\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`", "java": "\n    ```java\npublic int minDifference(int[] nums) {\n    int n = nums.length;\n    if (n <= 4) return 0;\n    Arrays.sort(nums);\n    int res = Integer.MAX_VALUE;\n    for (int i = 0; i <= 3; ++i)\n        res = Math.min(res, nums[n - 4 + i] - nums[i]);\n    return res;\n}\n```\n    \n    1. First, check if the length of the input array is less than or equal to 4. If it is, return 0 since there's no need to perform any operation on this input.\n2. Sort the input array in ascending order.\n3. Initialize the result (minimum difference) as the maximum value possible.\n4. Loop through the array from the 0-th element to the 3-rd element (inclusive). For each iteration, find the difference between the (n - 4 + i)-th element and the i-th element in the sorted array, where n is the length of the input array. Update the result as the minimum of the current and previous minimum differences.\n5. After the loop, return the resulting minimum difference.\n    ", "c++": "\n    ```cpp\nint minDifference(vector<int>& nums) {\n    int n = nums.size();\n    if (n <= 4) return 0;\n    sort(nums.begin(), nums.end());\n    int res = INT_MAX;\n    for (int i = 0; i <= 3; ++i)\n        res = min(res, nums[n - 4 + i] - nums[i]);\n    return res;\n}\n```\n    \n    1. First, check if the length of the input array is less than or equal to 4. If it is, return 0 since there's no need to perform any operation on this input.\n2. Sort the input array in ascending order.\n3. Initialize the result (minimum difference) as the maximum value possible.\n4. Loop through the array from the 0-th element to the 3-rd element (inclusive). For each iteration, find the difference between the (n - 4 + i)-th element and the i-th element in the sorted array, where n is the length of the input array. Update the result as the minimum of the current and previous minimum differences.\n5. After the loop, return the resulting minimum difference.\n    ", "python": "\n    ```python\ndef minDifference(nums):\n    n = len(nums)\n    if n <= 4: return 0\n    nums.sort()\n    res = float('inf')\n    for i in range(4):\n        res = min(res, nums[n - 4 + i] - nums[i])\n    return res\n```\n    \n    1. First, check if the length of the input array is less than or equal to 4. If it is, return 0 since there's no need to perform any operation on this input.\n2. Sort the input array in ascending order.\n3. Initialize the result (minimum difference) as the maximum value possible.\n4. Loop through the array from the 0-th element to the 3-rd element (inclusive). For each iteration, find the difference between the (n - 4 + i)-th element and the i-th element in the sorted array, where n is the length of the input array. Update the result as the minimum of the current and previous minimum differences.\n5. After the loop, return the resulting minimum difference.\n    ", "javascript": "\n    ```javascript\nfunction minDifference(nums) {\n    let n = nums.length;\n    if (n <= 4) return 0;\n    nums.sort((a, b) => a - b);\n    let res = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i <= 3; ++i)\n        res = Math.min(res, nums[n - 4 + i] - nums[i]);\n    return res;\n}\n```\n    \n    1. First, check if the length of the input array is less than or equal to 4. If it is, return 0 since there's no need to perform any operation on this input.\n2. Sort the input array in ascending order.\n3. Initialize the result (minimum difference) as the maximum value possible.\n4. Loop through the array from the 0-th element to the 3-rd element (inclusive). For each iteration, find the difference between the (n - 4 + i)-th element and the i-th element in the sorted array, where n is the length of the input array. Update the result as the minimum of the current and previous minimum differences.\n5. After the loop, return the resulting minimum difference.\n    "}
{"id": 1520, "slug": "maximum-number-of-non-overlapping-substrings", "title": "Maximum Number of Non-Overlapping Substrings", "difficulty": "Hard", "content": "Given a string `s` of lowercase letters, you need to find the maximum number of **non-empty** substrings of `s` that meet the following conditions:\n\n1.  The substrings do not overlap, that is for any two substrings `s[i..j]` and `s[x..y]`, either `j < x` or `i > y` is true.\n2.  A substring that contains a certain character `c` must also contain all occurrences of `c`.\n\nFind _the maximum number of substrings that meet the above conditions_. If there are multiple solutions with the same number of substrings, _return the one with minimum total length._ It can be shown that there exists a unique solution of minimum total length.\n\nNotice that you can return the substrings in **any** order.\n\n**Example 1:**\n\n**Input:** s =  \"adefaddaccc \"\n**Output:** \\[ \"e \", \"f \", \"ccc \"\\]\n**Explanation:** The following are all the possible substrings that meet the conditions:\n\\[\n   \"adefaddaccc \"\n   \"adefadda \",\n   \"ef \",\n   \"e \",\n   \"f \",\n   \"ccc \",\n\\]\nIf we choose the first string, we cannot choose anything else and we'd get only 1. If we choose  \"adefadda \", we are left with  \"ccc \" which is the only one that doesn't overlap, thus obtaining 2 substrings. Notice also, that it's not optimal to choose  \"ef \" since it can be split into two. Therefore, the optimal way is to choose \\[ \"e \", \"f \", \"ccc \"\\] which gives us 3 substrings. No other solution of the same number of substrings exist.\n\n**Example 2:**\n\n**Input:** s =  \"abbaccd \"\n**Output:** \\[ \"d \", \"bb \", \"cc \"\\]\n**Explanation:** Notice that while the set of substrings \\[ \"d \", \"abba \", \"cc \"\\] also has length 3, it's considered incorrect since it has larger total length.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` contains only lowercase English letters.", "java": "\n    ```java\npublic int numSteps(String s) {\n    int steps = 0, carry = 0;\n    for (int i = s.length() - 1; i > 0; --i) {\n        int current = s.charAt(i) - '0' + carry;\n        if (current == 1) {\n            steps += 2;\n            carry = 1;\n        } else {\n            steps += carry;\n            carry = current;\n        }\n    }\n\n    return steps + carry;\n}\n```\n    \n    1. Initialize the count of steps and carry to 0.\n2. Iterate through the elements of the binary string from the least significant digit to the most significant digit.\n3. In each iteration, add the carry and the current digit.\n4. If the result is 1, increment the steps by 2 and update the carry to 1.\n5. If the result is not 1, increment the steps by the previous carry and update the carry with the result.\n6. Return the total number of steps taken plus the final carry.\n    ", "c++": "\n    ```cpp\nint num_steps(const std::string& s) {\n    int steps = 0, carry = 0;\n    for (int i = s.size() - 1; i > 0; --i) {\n        if (s[i] - '0' + carry == 1) {\n            steps += 2;\n            carry = 1;\n        } else {\n            steps += carry;\n            carry = s[i] - '0';\n        }\n    }\n\n    return steps + carry;\n}\n```\n    \n    1. Initialize the count of steps and carry to 0.\n2. Iterate through the elements of the binary string from the least significant digit to the most significant digit.\n3. In each iteration, add the carry and the current digit.\n4. If the result is 1, increment the steps by 2 and update the carry to 1.\n5. If the result is not 1, increment the steps by the previous carry and update the carry with the result.\n6. Return the total number of steps taken plus the final carry.\n    ", "python": "\n    ```python\ndef num_steps(s: str) -> int:\n    steps = 0\n    carry = 0\n\n    for i in range(len(s) - 1, 0, -1):\n        current = int(s[i]) + carry\n        if current == 1:\n            steps += 2\n            carry = 1\n        else:\n            steps += carry\n            carry = current\n\n    return steps + carry\n```\n    \n    1. Initialize the count of steps and carry to 0.\n2. Iterate through the elements of the binary string from the least significant digit to the most significant digit.\n3. In each iteration, add the carry and the current digit.\n4. If the result is 1, increment the steps by 2 and update the carry to 1.\n5. If the result is not 1, increment the steps by the previous carry and update the carry with the result.\n6. Return the total number of steps taken plus the final carry.\n    ", "javascript": "\n    ```javascript\nfunction numSteps(s) {\n    let steps = 0, carry = 0;\n    for (let i = s.length - 1; i > 0; --i) {\n        let current = parseInt(s[i]) + carry;\n        if (current == 1) {\n            steps += 2;\n            carry = 1;\n        } else {\n            steps += carry;\n            carry = current;\n        }\n    }\n\n    return steps + carry;\n}\n```\n    \n    1. Initialize the count of steps and carry to 0.\n2. Iterate through the elements of the binary string from the least significant digit to the most significant digit.\n3. In each iteration, add the carry and the current digit.\n4. If the result is 1, increment the steps by 2 and update the carry to 1.\n5. If the result is not 1, increment the steps by the previous carry and update the carry with the result.\n6. Return the total number of steps taken plus the final carry.\n    "}
{"id": 1526, "slug": "minimum-number-of-increments-on-subarrays-to-form-a-target-array", "title": "Minimum Number of Increments on Subarrays to Form a Target Array", "difficulty": "Hard", "content": "You are given an integer array `target`. You have an integer array `initial` of the same size as `target` with all elements initially zeros.\n\nIn one operation you can choose **any** subarray from `initial` and increment each value by one.\n\nReturn _the minimum number of operations to form a_ `target` _array from_ `initial`.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n**Example 1:**\n\n**Input:** target = \\[1,2,3,2,1\\]\n**Output:** 3\n**Explanation:** We need at least 3 operations to form the target array from the initial array.\n\\[**0,0,0,0,0**\\] increment 1 from index 0 to 4 (inclusive).\n\\[1,**1,1,1**,1\\] increment 1 from index 1 to 3 (inclusive).\n\\[1,2,**2**,2,1\\] increment 1 at index 2.\n\\[1,2,3,2,1\\] target array is formed.\n\n**Example 2:**\n\n**Input:** target = \\[3,1,1,2\\]\n**Output:** 4\n**Explanation:** \\[**0,0,0,0**\\] -> \\[1,1,1,**1**\\] -> \\[**1**,1,1,2\\] -> \\[**2**,1,1,2\\] -> \\[3,1,1,2\\]\n\n**Example 3:**\n\n**Input:** target = \\[3,1,5,4,2\\]\n**Output:** 7\n**Explanation:** \\[**0,0,0,0,0**\\] -> \\[**1**,1,1,1,1\\] -> \\[**2**,1,1,1,1\\] -> \\[3,1,**1,1,1**\\] -> \\[3,1,**2,2**,2\\] -> \\[3,1,**3,3**,2\\] -> \\[3,1,**4**,4,2\\] -> \\[3,1,5,4,2\\].\n\n**Constraints:**\n\n*   `1 <= target.length <= 105`\n*   `1 <= target[i] <= 105`", "java": "\n    ```java\nimport java.util.HashMap;\n\npublic String entityParser(String text) {\n    HashMap<String, Character> entities = new HashMap<String, Character>();\n    entities.put(\"&quot;\", '\\\"');\n    entities.put(\"&apos;\", '\\'');\n    entities.put(\"&amp;\", '&');\n    entities.put(\"&gt;\", '>');\n    entities.put(\"&lt;\", '<');\n    entities.put(\"&frasl;\", '/');\n    \n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < text.length(); ++i) {\n        if (text.charAt(i) == '&') {\n            StringBuilder temp = new StringBuilder();\n            for (int j = i; j < text.length() && j < i + 7; ++j) {\n                temp.append(text.charAt(j));\n                Character c = entities.get(temp.toString());\n                if (c != null) {\n                    result.append(c);\n                    i = j;\n                    break;\n                }\n            }\n            if (temp.charAt(temp.length() - 1) != ';') result.append(text.charAt(i));\n        } else {\n            result.append(text.charAt(i));\n        }\n    }\n    return result.toString();\n}\n```\n\n    \n    1. Initialize a dictionary or hashmap named `entities` with keys as the HTML entity representation and values as the corresponding plaintext characters.\n2. Initialize an empty string or character list named `result` to store the parsed text.\n3. Loop through each character of the input `text`.\n4. If the character is '&', try to match it as an entity in the dictionary.\n5. If a match is found within the next 7 characters, append the decoded entity character to the `result` and update the loop counter `i` to skip the matched entity.\n6. If no match is found, append the character to `result` as is.\n7. After the loop, return the `result` as the parsed text.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nstring entityParser(string text) {\n    unordered_map<string, char> entities{\n        {\"&quot;\", '\\\"'},\n        {\"&apos;\", '\\''},\n        {\"&amp;\", '&'},\n        {\"&gt;\", '>'},\n        {\"&lt;\", '<'},\n        {\"&frasl;\", '/'}\n    };\n    string result;\n    for (int i = 0; i < text.size(); ++i) {\n        if (text[i] == '&') {\n            string temp;\n            for (int j = i; j < text.size() && j < i + 7; ++j) {\n                temp.push_back(text[j]);\n                if (entities.find(temp) != entities.end()) {\n                    result.push_back(entities[temp]);\n                    i = j;\n                    break;\n                }\n            }\n            if (temp.back() != ';') result.push_back(text[i]);\n        } else {\n            result.push_back(text[i]);\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize a dictionary or hashmap named `entities` with keys as the HTML entity representation and values as the corresponding plaintext characters.\n2. Initialize an empty string or character list named `result` to store the parsed text.\n3. Loop through each character of the input `text`.\n4. If the character is '&', try to match it as an entity in the dictionary.\n5. If a match is found within the next 7 characters, append the decoded entity character to the `result` and update the loop counter `i` to skip the matched entity.\n6. If no match is found, append the character to `result` as is.\n7. After the loop, return the `result` as the parsed text.\n    ", "python": "\n    ```python\ndef entityParser(text: str) -> str:\n    entities = {\n        \"&quot;\": '\\\"',\n        \"&apos;\": '\\'',\n        \"&amp;\": '&',\n        \"&gt;\": '>',\n        \"&lt;\": '<',\n        \"&frasl;\": '/'\n    }\n\n    result, i = [], 0\n    while i < len(text):\n        if text[i] == '&':\n            temp = ''\n            for j in range(i, min(i+7, len(text))):\n                temp += text[j]\n                if temp in entities:\n                    result.append(entities[temp])\n                    i = j\n                    break\n            else:\n                result.append(text[i])\n        else:\n            result.append(text[i])\n        i += 1\n    return ''.join(result)\n```\n\n    \n    1. Initialize a dictionary or hashmap named `entities` with keys as the HTML entity representation and values as the corresponding plaintext characters.\n2. Initialize an empty string or character list named `result` to store the parsed text.\n3. Loop through each character of the input `text`.\n4. If the character is '&', try to match it as an entity in the dictionary.\n5. If a match is found within the next 7 characters, append the decoded entity character to the `result` and update the loop counter `i` to skip the matched entity.\n6. If no match is found, append the character to `result` as is.\n7. After the loop, return the `result` as the parsed text.\n    ", "javascript": "\n    ```javascript\nfunction entityParser(text) {\n    const entities = {\n        \"&quot;\": '\\\"',\n        \"&apos;\": '\\'',\n        \"&amp;\": '&',\n        \"&gt;\": '>',\n        \"&lt;\": '<',\n        \"&frasl;\": '/'\n    };\n\n    let result = '';\n    for (let i = 0; i < text.length; ++i) {\n        if (text[i] === '&') {\n            let temp = '';\n            for (let j = i; j < text.length && j < i + 7; ++j) {\n                temp += text[j];\n                if (temp in entities) {\n                    result += entities[temp];\n                    i = j;\n                    break;\n                }\n            }\n            if (temp[temp.length - 1] !== ';') result += text[i];\n        } else {\n            result += text[i];\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize a dictionary or hashmap named `entities` with keys as the HTML entity representation and values as the corresponding plaintext characters.\n2. Initialize an empty string or character list named `result` to store the parsed text.\n3. Loop through each character of the input `text`.\n4. If the character is '&', try to match it as an entity in the dictionary.\n5. If a match is found within the next 7 characters, append the decoded entity character to the `result` and update the loop counter `i` to skip the matched entity.\n6. If no match is found, append the character to `result` as is.\n7. After the loop, return the `result` as the parsed text.\n    "}
{"id": 1529, "slug": "minimum-suffix-flips", "title": "Minimum Suffix Flips", "difficulty": "Medium", "content": "You are given a **0-indexed** binary string `target` of length `n`. You have another binary string `s` of length `n` that is initially set to all zeros. You want to make `s` equal to `target`.\n\nIn one operation, you can pick an index `i` where `0 <= i < n` and flip all bits in the **inclusive** range `[i, n - 1]`. Flip means changing `'0'` to `'1'` and `'1'` to `'0'`.\n\nReturn _the minimum number of operations needed to make_ `s` _equal to_ `target`.\n\n**Example 1:**\n\n**Input:** target =  \"10111 \"\n**Output:** 3\n**Explanation:** Initially, s =  \"00000 \".\nChoose index i = 2:  \"00000 \" ->  \"00111 \"\nChoose index i = 0:  \"00111 \" ->  \"11000 \"\nChoose index i = 1:  \"11000 \" ->  \"10111 \"\nWe need at least 3 flip operations to form target.\n\n**Example 2:**\n\n**Input:** target =  \"101 \"\n**Output:** 3\n**Explanation:** Initially, s =  \"000 \".\nChoose index i = 0:  \"000 \" ->  \"111 \"\nChoose index i = 1:  \"111 \" ->  \"100 \"\nChoose index i = 2:  \"100 \" ->  \"101 \"\nWe need at least 3 flip operations to form target.\n\n**Example 3:**\n\n**Input:** target =  \"00000 \"\n**Output:** 0\n**Explanation:** We do not need any operations since the initial s already equals target.\n\n**Constraints:**\n\n*   `n == target.length`\n*   `1 <= n <= 105`\n*   `target[i]` is either `'0'` or `'1'`.", "java": "\n    ```java\npublic int maxDifference(int num) {\n    int a = num + 9 - (num % 10);\n    int b = num - (num / 1000 % 10) * 111;\n\n    return a - b;\n}\n```\n    \n    The problem states that there are two operations applied to the given integer `num`. Let's find out the logic for determining the maximum difference between two numbers when these operations are applied to the given `num` twice:\n\n1. In the first operation, try to increase the smallest digit of `num` to `9`. This will result in a new number `a`. Calculate `a` by adding `9` and subtracting the lowest digit (obtained using `num % 10`).\n2. In the second operation, try to decrease the largest digit of `num` to `0`. This will result in a new number `b`. Calculate `b` by subtracting the highest digit multiplied by 111 (as it is a 4 digit number, so for each digit place the value is 1000s, 100s, 10s, and 1 respectively).\n\nFinally, find the maximum difference between `a` and `b` by subtracting `b` from `a`.\n    ", "c++": "\n    ```cpp\nint maxDifference(int num) {\n    int a = num + 9 - (num % 10);\n    int b = num - (num / 1000 % 10) * 111;\n\n    return a - b;\n}\n```\n    \n    The problem states that there are two operations applied to the given integer `num`. Let's find out the logic for determining the maximum difference between two numbers when these operations are applied to the given `num` twice:\n\n1. In the first operation, try to increase the smallest digit of `num` to `9`. This will result in a new number `a`. Calculate `a` by adding `9` and subtracting the lowest digit (obtained using `num % 10`).\n2. In the second operation, try to decrease the largest digit of `num` to `0`. This will result in a new number `b`. Calculate `b` by subtracting the highest digit multiplied by 111 (as it is a 4 digit number, so for each digit place the value is 1000s, 100s, 10s, and 1 respectively).\n\nFinally, find the maximum difference between `a` and `b` by subtracting `b` from `a`.\n    ", "python": "\n    ```python\ndef max_difference(num):\n    a = num + 9 - (num % 10)\n    b = num - (num // 1000 % 10) * 111\n\n    return a - b\n```\n    \n    The problem states that there are two operations applied to the given integer `num`. Let's find out the logic for determining the maximum difference between two numbers when these operations are applied to the given `num` twice:\n\n1. In the first operation, try to increase the smallest digit of `num` to `9`. This will result in a new number `a`. Calculate `a` by adding `9` and subtracting the lowest digit (obtained using `num % 10`).\n2. In the second operation, try to decrease the largest digit of `num` to `0`. This will result in a new number `b`. Calculate `b` by subtracting the highest digit multiplied by 111 (as it is a 4 digit number, so for each digit place the value is 1000s, 100s, 10s, and 1 respectively).\n\nFinally, find the maximum difference between `a` and `b` by subtracting `b` from `a`.\n    ", "javascript": "\n    ```javascript\nfunction maxDifference(num) {\n    const a = num + 9 - (num % 10);\n    const b = num - (Math.floor(num / 1000) % 10) * 111;\n\n    return a - b;\n}\n```\n    \n    The problem states that there are two operations applied to the given integer `num`. Let's find out the logic for determining the maximum difference between two numbers when these operations are applied to the given `num` twice:\n\n1. In the first operation, try to increase the smallest digit of `num` to `9`. This will result in a new number `a`. Calculate `a` by adding `9` and subtracting the lowest digit (obtained using `num % 10`).\n2. In the second operation, try to decrease the largest digit of `num` to `0`. This will result in a new number `b`. Calculate `b` by subtracting the highest digit multiplied by 111 (as it is a 4 digit number, so for each digit place the value is 1000s, 100s, 10s, and 1 respectively).\n\nFinally, find the maximum difference between `a` and `b` by subtracting `b` from `a`.\n    "}
{"id": 1536, "slug": "minimum-swaps-to-arrange-a-binary-grid", "title": "Minimum Swaps to Arrange a Binary Grid", "difficulty": "Medium", "content": "Given an `n x n` binary `grid`, in one step you can choose two **adjacent rows** of the grid and swap them.\n\nA grid is said to be **valid** if all the cells above the main diagonal are **zeros**.\n\nReturn _the minimum number of steps_ needed to make the grid valid, or **\\-1** if the grid cannot be valid.\n\nThe main diagonal of a grid is the diagonal that starts at cell `(1, 1)` and ends at cell `(n, n)`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,1\\],\\[1,1,0\\],\\[1,0,0\\]\\]\n**Output:** 3\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[0,1,1,0\\],\\[0,1,1,0\\],\\[0,1,1,0\\]\\]\n**Output:** -1\n**Explanation:** All rows are similar, swaps have no effect on the grid.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,0,0\\],\\[1,1,0\\],\\[1,1,1\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == grid.length` `== grid[i].length`\n*   `1 <= n <= 200`\n*   `grid[i][j]` is either `0` or `1`", "java": "\n    ```java\npublic int minSwaps(int[][] grid) {\n    int n = grid.length;\n    int steps = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int row = -1;\n        for (int j = i; j < n; ++j) {\n            if (grid[j][i] == 0) {\n                row = j;\n                break;\n            }\n        }\n        if (row == -1) {\n            return -1;\n        }\n\n        while (row > i) {\n            int[] temp = grid[row];\n            grid[row] = grid[row - 1];\n            grid[row - 1] = temp;\n            steps++;\n            row--;\n        }\n    }\n    return steps;\n}\n```\n\n    \n    The algorithm first initializes steps to 0. Then, for each column i from 0 to n-1, it tries to find a row in which the cell in the current column is 0. If a row is found, it swaps this row with the previous row to move the 0 value up until the required position is reached. While doing the swaps, it increments the steps counter. If the row is not found for any column, the algorithm returns -1 as the grid cannot be valid.\n    ", "c++": "\n    ```cpp\nint minSwaps(vector<vector<int>>& grid) {\n    int n = grid.size();\n    int steps = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int row = -1;\n        for (int j = i; j < n; ++j) {\n            if (grid[j][i] == 0) {\n                row = j;\n                break;\n            }\n        }\n        if (row == -1) {\n            return -1;\n        }\n\n        while (row > i) {\n            swap(grid[row], grid[row - 1]);\n            steps++;\n            row--;\n        }\n    }\n    return steps;\n}\n```\n\n    \n    The algorithm first initializes steps to 0. Then, for each column i from 0 to n-1, it tries to find a row in which the cell in the current column is 0. If a row is found, it swaps this row with the previous row to move the 0 value up until the required position is reached. While doing the swaps, it increments the steps counter. If the row is not found for any column, the algorithm returns -1 as the grid cannot be valid.\n    ", "python": "\n    ```python\ndef minSwaps(grid):\n    n = len(grid)\n    steps = 0\n\n    for i in range(n):\n        row = -1\n        for j in range(i, n):\n            if grid[j][i] == 0:\n                row = j\n                break\n        if row == -1:\n            return -1\n\n        while row > i:\n            grid[row], grid[row - 1] = grid[row - 1], grid[row]\n            steps += 1\n            row -= 1\n\n    return steps\n```\n\n    \n    The algorithm first initializes steps to 0. Then, for each column i from 0 to n-1, it tries to find a row in which the cell in the current column is 0. If a row is found, it swaps this row with the previous row to move the 0 value up until the required position is reached. While doing the swaps, it increments the steps counter. If the row is not found for any column, the algorithm returns -1 as the grid cannot be valid.\n    ", "javascript": "\n    ```javascript\nfunction minSwaps(grid) {\n    const n = grid.length;\n    let steps = 0;\n\n    for (let i = 0; i < n; ++i) {\n        let row = -1;\n        for (let j = i; j < n; ++j) {\n            if (grid[j][i] === 0) {\n                row = j;\n                break;\n            }\n        }\n        if (row === -1) {\n            return -1;\n        }\n\n        while (row > i) {\n            [grid[row], grid[row - 1]] = [grid[row - 1], grid[row]];\n            steps++;\n            row--;\n        }\n    }\n    return steps;\n}\n```\n\n    \n    The algorithm first initializes steps to 0. Then, for each column i from 0 to n-1, it tries to find a row in which the cell in the current column is 0. If a row is found, it swaps this row with the previous row to move the 0 value up until the required position is reached. While doing the swaps, it increments the steps counter. If the row is not found for any column, the algorithm returns -1 as the grid cannot be valid.\n    "}
{"id": 1537, "slug": "get-the-maximum-score", "title": "Get the Maximum Score", "difficulty": "Hard", "content": "You are given two **sorted** arrays of distinct integers `nums1` and `nums2.`\n\nA **valid path** is defined as follows:\n\n*   Choose array `nums1` or `nums2` to traverse (from index-0).\n*   Traverse the current array from left to right.\n*   If you are reading any value that is present in `nums1` and `nums2` you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).\n\nThe **score** is defined as the sum of uniques values in a valid path.\n\nReturn _the maximum score you can obtain of all possible **valid paths**_. Since the answer may be too large, return it modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[2,4,5,8,10\\], nums2 = \\[4,6,8,9\\]\n**Output:** 30\n**Explanation:** Valid paths:\n\\[2,4,5,8,10\\], \\[2,4,5,8,9\\], \\[2,4,6,8,9\\], \\[2,4,6,8,10\\],  (starting from nums1)\n\\[4,6,8,9\\], \\[4,5,8,10\\], \\[4,5,8,9\\], \\[4,6,8,10\\]    (starting from nums2)\nThe maximum is obtained with the path in green **\\[2,4,6,8,10\\]**.\n\n**Example 2:**\n\n**Input:** nums1 = \\[1,3,5,7,9\\], nums2 = \\[3,5,100\\]\n**Output:** 109\n**Explanation:** Maximum sum is obtained with the path **\\[1,3,5,100\\]**.\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,2,3,4,5\\], nums2 = \\[6,7,8,9,10\\]\n**Output:** 40\n**Explanation:** There are no common elements between nums1 and nums2.\nMaximum sum is obtained with the path \\[6,7,8,9,10\\].\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 105`\n*   `1 <= nums1[i], nums2[i] <= 107`\n*   `nums1` and `nums2` are strictly increasing.", "java": "\n    ```java\npublic int maxScore(String s) {\n    int left_zeros = 0, right_ones = 0, max_score = 0;\n    for(char c : s.toCharArray()) if(c == '1') right_ones++;      \n        \n    for(int i = 0; i < s.length() - 1; i++) {\n        if(s.charAt(i) == '0') left_zeros++;\n        else right_ones--;\n        max_score = Math.max(max_score, left_zeros + right_ones);\n    }\n    return max_score;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize three variables: `left_zeros` to count zeros in the left substring, `right_ones` to count ones in the right substring, and `max_score` to store the maximum score after checking all possible splits.\n2. Count the total number of ones in the whole string and store it in `right_ones`.\n3. Iterate through the string (excluding the last character since both substrings should be non-empty) and for each character i, do the following:\n   a. If the character is '0', increment `left_zeros`. Else, decrement `right_ones` as the character '1' is moving from the right substring to the left substring.\n   b. Calculate the score by adding `left_zeros` and `right_ones`, and update `max_score` if it is less than the current score.\n4. Return the `max_score` after the iteration is complete.\n    ", "c++": "\n    ```cpp\nint maxScore(string s) {\n    int left_zeros = 0, right_ones = 0, max_score = 0;\n    for(char c : s) if(c == '1') right_ones++;\n        \n    for(int i = 0; i < s.size() - 1; i++) {\n        if(s[i] == '0') left_zeros++;\n        else right_ones--;\n        max_score = max(max_score, left_zeros + right_ones);\n    }\n    return max_score;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize three variables: `left_zeros` to count zeros in the left substring, `right_ones` to count ones in the right substring, and `max_score` to store the maximum score after checking all possible splits.\n2. Count the total number of ones in the whole string and store it in `right_ones`.\n3. Iterate through the string (excluding the last character since both substrings should be non-empty) and for each character i, do the following:\n   a. If the character is '0', increment `left_zeros`. Else, decrement `right_ones` as the character '1' is moving from the right substring to the left substring.\n   b. Calculate the score by adding `left_zeros` and `right_ones`, and update `max_score` if it is less than the current score.\n4. Return the `max_score` after the iteration is complete.\n    ", "python": "\n    ```python\ndef maxScore(s):\n    left_zeros, right_ones, max_score = 0, s.count('1'), 0\n    for i in range(len(s) - 1):\n        if s[i] == '0': left_zeros += 1\n        else: right_ones -= 1\n        max_score = max(max_score, left_zeros + right_ones)\n    return max_score\n```\n    \n    The algorithm works as follows:\n1. Initialize three variables: `left_zeros` to count zeros in the left substring, `right_ones` to count ones in the right substring, and `max_score` to store the maximum score after checking all possible splits.\n2. Count the total number of ones in the whole string and store it in `right_ones`.\n3. Iterate through the string (excluding the last character since both substrings should be non-empty) and for each character i, do the following:\n   a. If the character is '0', increment `left_zeros`. Else, decrement `right_ones` as the character '1' is moving from the right substring to the left substring.\n   b. Calculate the score by adding `left_zeros` and `right_ones`, and update `max_score` if it is less than the current score.\n4. Return the `max_score` after the iteration is complete.\n    ", "javascript": "\n    ```javascript\nfunction maxScore(s) {\n    let left_zeros = 0, right_ones = 0, max_score = 0;\n    for(let c of s) if(c === '1') right_ones++;\n        \n    for(let i = 0; i < s.length - 1; i++) {\n        if(s[i] === '0') left_zeros++;\n        else right_ones--;\n        max_score = Math.max(max_score, left_zeros + right_ones);\n    }\n    return max_score;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize three variables: `left_zeros` to count zeros in the left substring, `right_ones` to count ones in the right substring, and `max_score` to store the maximum score after checking all possible splits.\n2. Count the total number of ones in the whole string and store it in `right_ones`.\n3. Iterate through the string (excluding the last character since both substrings should be non-empty) and for each character i, do the following:\n   a. If the character is '0', increment `left_zeros`. Else, decrement `right_ones` as the character '1' is moving from the right substring to the left substring.\n   b. Calculate the score by adding `left_zeros` and `right_ones`, and update `max_score` if it is less than the current score.\n4. Return the `max_score` after the iteration is complete.\n    "}
{"id": 1541, "slug": "minimum-insertions-to-balance-a-parentheses-string", "title": "Minimum Insertions to Balance a Parentheses String", "difficulty": "Medium", "content": "Given a parentheses string `s` containing only the characters `'('` and `')'`. A parentheses string is **balanced** if:\n\n*   Any left parenthesis `'('` must have a corresponding two consecutive right parenthesis `'))'`.\n*   Left parenthesis `'('` must go before the corresponding two consecutive right parenthesis `'))'`.\n\nIn other words, we treat `'('` as an opening parenthesis and `'))'` as a closing parenthesis.\n\n*   For example, `\"()) \"`, `\"())(()))) \"` and `\"(())()))) \"` are balanced, `\")() \"`, `\"())) \"` and `\"(())) \"` are not balanced.\n\nYou can insert the characters `'('` and `')'` at any position of the string to balance it if needed.\n\nReturn _the minimum number of insertions_ needed to make `s` balanced.\n\n**Example 1:**\n\n**Input:** s =  \"(())) \"\n**Output:** 1\n**Explanation:** The second '(' has two matching '))', but the first '(' has only ')' matching. We need to add one more ')' at the end of the string to be  \"(()))) \" which is balanced.\n\n**Example 2:**\n\n**Input:** s =  \"()) \"\n**Output:** 0\n**Explanation:** The string is already balanced.\n\n**Example 3:**\n\n**Input:** s =  \"))())( \"\n**Output:** 3\n**Explanation:** Add '(' to match the first '))', Add '))' to match the last '('.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of `'('` and `')'` only.", "java": "\n    ```java\npublic int minInsertions(String s) {\n    int left = 0, res = 0;\n    int n = s.length();\n    for (int i = 0; i < n; i++) {\n        if (s.charAt(i) == '(') {\n            left++;\n        } else {\n            if (left == 0) res++;\n            else left--;\n            if (i == n - 1 || s.charAt(i + 1) != ')') {\n                res++;\n                i++;\n            }\n        }\n    }\n    return res + left * 2;\n}\n```\n    \n    The algorithm iterates through the string and maintains a counter `left` for open parentheses that have not been closed yet. Whenever a close parenthesis is encountered, it checks if there is an open parenthesis which has not been closed yet.\n\n1. If yes, decrement the `left` counter.\n2. If no, then increment the `res` counter, because we need to insert an open parenthesis.\n\nFor the given rules, every close parenthesis should be followed by another close parenthesis to make it balanced. Therefore, if the current character is a close parenthesis and the next character is not a close parenthesis, increment the `res` counter, because we need to insert a close parenthesis.\n\nFinally, each open parenthesis needs two close parentheses. After the loop, if there are any open parentheses left (which have not been closed yet), add their required number of close parentheses, i.e., `left * 2`, to the `res` counter.\n\nReturn the result as the minimum number of insertions required to make the string balanced.\n    ", "c++": "\n    ```cpp\nint minInsertions(string s) {\n    int left = 0, res = 0;\n    int n = s.length();\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '(') {\n            left++;\n        } else {\n            if (left == 0) res++;\n            else left--;\n            if (i == n - 1 || s[i + 1] != ')') {\n                res++;\n                i++;\n            }\n        }\n    }\n    return res + left * 2;\n}\n```\n    \n    The algorithm iterates through the string and maintains a counter `left` for open parentheses that have not been closed yet. Whenever a close parenthesis is encountered, it checks if there is an open parenthesis which has not been closed yet.\n\n1. If yes, decrement the `left` counter.\n2. If no, then increment the `res` counter, because we need to insert an open parenthesis.\n\nFor the given rules, every close parenthesis should be followed by another close parenthesis to make it balanced. Therefore, if the current character is a close parenthesis and the next character is not a close parenthesis, increment the `res` counter, because we need to insert a close parenthesis.\n\nFinally, each open parenthesis needs two close parentheses. After the loop, if there are any open parentheses left (which have not been closed yet), add their required number of close parentheses, i.e., `left * 2`, to the `res` counter.\n\nReturn the result as the minimum number of insertions required to make the string balanced.\n    ", "python": "\n    ```python\ndef minInsertions(s: str) -> int:\n    left = 0\n    res = 0\n    n = len(s)\n    i = 0\n    while i < n:\n        if s[i] == '(':\n            left += 1\n        else:\n            if left == 0: \n                res += 1\n            else: \n                left -= 1\n            if i == n - 1 or s[i + 1] != ')':\n                res += 1\n                i += 1\n        i += 1\n    return res + left * 2\n```\n    \n    The algorithm iterates through the string and maintains a counter `left` for open parentheses that have not been closed yet. Whenever a close parenthesis is encountered, it checks if there is an open parenthesis which has not been closed yet.\n\n1. If yes, decrement the `left` counter.\n2. If no, then increment the `res` counter, because we need to insert an open parenthesis.\n\nFor the given rules, every close parenthesis should be followed by another close parenthesis to make it balanced. Therefore, if the current character is a close parenthesis and the next character is not a close parenthesis, increment the `res` counter, because we need to insert a close parenthesis.\n\nFinally, each open parenthesis needs two close parentheses. After the loop, if there are any open parentheses left (which have not been closed yet), add their required number of close parentheses, i.e., `left * 2`, to the `res` counter.\n\nReturn the result as the minimum number of insertions required to make the string balanced.\n    ", "javascript": "\n    ```javascript\nfunction minInsertions(s) {\n    let left = 0, res = 0;\n    const n = s.length;\n    for (let i = 0; i < n; i++) {\n        if (s[i] === '(') {\n            left++;\n        } else {\n            if (left === 0) res++;\n            else left--;\n            if (i === n - 1 || s[i + 1] !== ')') {\n                res++;\n                i++;\n            }\n        }\n    }\n    return res + left * 2;\n}\n```\n    \n    The algorithm iterates through the string and maintains a counter `left` for open parentheses that have not been closed yet. Whenever a close parenthesis is encountered, it checks if there is an open parenthesis which has not been closed yet.\n\n1. If yes, decrement the `left` counter.\n2. If no, then increment the `res` counter, because we need to insert an open parenthesis.\n\nFor the given rules, every close parenthesis should be followed by another close parenthesis to make it balanced. Therefore, if the current character is a close parenthesis and the next character is not a close parenthesis, increment the `res` counter, because we need to insert a close parenthesis.\n\nFinally, each open parenthesis needs two close parentheses. After the loop, if there are any open parentheses left (which have not been closed yet), add their required number of close parentheses, i.e., `left * 2`, to the `res` counter.\n\nReturn the result as the minimum number of insertions required to make the string balanced.\n    "}
{"id": 1546, "slug": "maximum-number-of-non-overlapping-subarrays-with-sum-equals-target", "title": "Maximum Number of Non-Overlapping Subarrays With Sum Equals Target", "difficulty": "Medium", "content": "Given an array `nums` and an integer `target`, return _the maximum number of **non-empty** **non-overlapping** subarrays such that the sum of values in each subarray is equal to_ `target`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,1,1,1\\], target = 2\n**Output:** 2\n**Explanation:** There are 2 non-overlapping subarrays \\[**1,1**,1,**1,1**\\] with sum equals to target(2).\n\n**Example 2:**\n\n**Input:** nums = \\[-1,3,5,1,4,2,-9\\], target = 6\n**Output:** 2\n**Explanation:** There are 3 subarrays with sum equal to 6.\n(\\[5,1\\], \\[4,2\\], \\[3,5,1,4,2,-9\\]) but only the first 2 are non-overlapping.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`\n*   `0 <= target <= 106`", "java": "\n    ```java\npublic int maxNonOverlapping(int[] nums, int target) {\n    Map<Integer, Integer> prefixSum = new HashMap<>();\n    int sum = 0, count = 0;\n    prefixSum.put(0, 0);\n    for (int num : nums) {\n        sum += num;\n        if (prefixSum.containsKey(sum - target)) {\n            count = Math.max(count, 1 + prefixSum.get(sum - target));\n        }\n        prefixSum.put(sum, count);\n    }\n    return count;\n}\n```\n    \n    We use the prefix sum to cumulatively store the sum of the array until the current position. On each iteration, we calculate the sum of elements and then check if the (current sum - target) exists in the prefix sum hashmap. If it exists, it means we have a subarray that sums to the target, so we update our count. We also make sure to only consider non-overlapping subarrays by storing the current max count in the hashmap.\n    ", "c++": "\n    ```cpp\nint maxNonOverlapping(vector<int>& nums, int target) {\n    unordered_map<int, int> prefix_sum;\n    int sum = 0, count = 0;\n    prefix_sum[0] = 0;\n    for (const int& num : nums) {\n        sum += num;\n        if (prefix_sum.find(sum - target) != prefix_sum.end()) {\n            count = max(count, 1 + prefix_sum[sum - target]);\n        }\n        prefix_sum[sum] = count;\n    }\n    return count;\n}\n```\n    \n    We use the prefix sum to cumulatively store the sum of the array until the current position. On each iteration, we calculate the sum of elements and then check if the (current sum - target) exists in the prefix sum hashmap. If it exists, it means we have a subarray that sums to the target, so we update our count. We also make sure to only consider non-overlapping subarrays by storing the current max count in the hashmap.\n    ", "python": "\n    ```python\ndef maxNonOverlapping(nums, target):\n    prefix_sum = {0: 0}\n    sum, count = 0, 0\n    for num in nums:\n        sum += num\n        if sum - target in prefix_sum:\n            count = max(count, 1 + prefix_sum[sum - target])\n        prefix_sum[sum] = count\n    return count\n```\n    \n    We use the prefix sum to cumulatively store the sum of the array until the current position. On each iteration, we calculate the sum of elements and then check if the (current sum - target) exists in the prefix sum hashmap. If it exists, it means we have a subarray that sums to the target, so we update our count. We also make sure to only consider non-overlapping subarrays by storing the current max count in the hashmap.\n    ", "javascript": "\n    ```javascript\nfunction maxNonOverlapping(nums, target) {\n    const prefixSum = new Map();\n    let sum = 0, count = 0;\n    prefixSum.set(0, 0);\n    for (const num of nums) {\n        sum += num;\n        if (prefixSum.has(sum - target)) {\n            count = Math.max(count, 1 + prefixSum.get(sum - target));\n        }\n        prefixSum.set(sum, count);\n    }\n    return count;\n}\n```\n    \n    We use the prefix sum to cumulatively store the sum of the array until the current position. On each iteration, we calculate the sum of elements and then check if the (current sum - target) exists in the prefix sum hashmap. If it exists, it means we have a subarray that sums to the target, so we update our count. We also make sure to only consider non-overlapping subarrays by storing the current max count in the hashmap.\n    "}
{"id": 1558, "slug": "minimum-numbers-of-function-calls-to-make-target-array", "title": "Minimum Numbers of Function Calls to Make Target Array", "difficulty": "Medium", "content": "You are given an integer array `nums`. You have an integer array `arr` of the same length with all values set to `0` initially. You also have the following `modify` function:\n\nYou want to use the modify function to covert `arr` to `nums` using the minimum number of calls.\n\nReturn _the minimum number of function calls to make_ `nums` _from_ `arr`.\n\nThe test cases are generated so that the answer fits in a **32-bit** signed integer.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5\\]\n**Output:** 5\n**Explanation:** Increment by 1 (second element): \\[0, 0\\] to get \\[0, 1\\] (1 operation).\nDouble all the elements: \\[0, 1\\] -> \\[0, 2\\] -> \\[0, 4\\] (2 operations).\nIncrement by 1 (both elements)  \\[0, 4\\] -> \\[1, 4\\] -> **\\[1, 5\\]** (2 operations).\nTotal of operations: 1 + 2 + 2 = 5.\n\n**Example 2:**\n\n**Input:** nums = \\[2,2\\]\n**Output:** 3\n**Explanation:** Increment by 1 (both elements) \\[0, 0\\] -> \\[0, 1\\] -> \\[1, 1\\] (2 operations).\nDouble all the elements: \\[1, 1\\] -> **\\[2, 2\\]** (1 operation).\nTotal of operations: 2 + 1 = 3.\n\n**Example 3:**\n\n**Input:** nums = \\[4,2,5\\]\n**Output:** 6\n**Explanation:** (initial)\\[0,0,0\\] -> \\[1,0,0\\] -> \\[1,0,1\\] -> \\[2,0,2\\] -> \\[2,1,2\\] -> \\[4,2,4\\] -> **\\[4,2,5\\]**(nums).\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 109`", "java": "\n    ```java\nimport java.util.*;\n\npublic class Solution {\n    public void DFS(int src, Map<Integer, List<Integer>> graph, boolean[] visited, boolean[] transitiveClosure, int dest) {\n        if (src == dest) {\n            transitiveClosure[dest] = true;\n            return;\n        }\n        if (visited[src]) return;\n        visited[src] = true;\n        for (int neighbor : graph.get(src)) {\n            DFS(neighbor, graph, visited, transitiveClosure, dest);\n            if (transitiveClosure[dest]) return;\n        }\n    }\n\n    public boolean[] checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n\n        for (int[] pre : prerequisites) {\n            graph.computeIfAbsent(pre[0], k -> new ArrayList<>()).add(pre[1]);\n        }\n\n        boolean[] result = new boolean[queries.length];\n\n        for (int i = 0; i < queries.length; ++i) {\n            boolean[] visited = new boolean[numCourses];\n            boolean[] transitiveClosure = new boolean[numCourses];\n            DFS(queries[i][0], graph, visited, transitiveClosure, queries[i][1]);\n            result[i] = transitiveClosure[queries[i][1]];\n        }\n\n        return result;\n    }\n}\n```\n\n    \n    The algorithm starts by creating a graph representation from the given prerequisites, with the courses represented as nodes and directed edges from the prerequisites to the dependent courses. Then, for each query, we perform a Depth-First Search (DFS) from the source course to check if we can reach the destination course. During the DFS traversal, we maintain a visited array and a transitive closure array to prevent cycles and to mark prerequisite courses. If we reach the destination course during DFS, we set the corresponding position in the transitive closure array to true, indicating that the prerequisite is satisfied. Finally, results are collected in an array and returned.\n    ", "c++": "\n    ```cpp\n#include<vector>\n#include<unordered_map>\n\nusing namespace std;\n\nvoid DFS(int src, unordered_map<int, vector<int>> &graph, vector<bool> &visited, vector<bool> &transitiveClosure, int dest) {\n    if (src == dest) {\n        transitiveClosure[dest] = true;\n        return;\n    }\n    if (visited[src]) return;\n    visited[src] = true;\n    for (int neighbor : graph[src]) {\n        DFS(neighbor, graph, visited, transitiveClosure, dest);\n        if (transitiveClosure[dest]) return;\n    }\n}\n\nvector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {\n    unordered_map<int, vector<int>> graph;\n\n    for (auto &pre : prerequisites) {\n        graph[pre[0]].push_back(pre[1]);\n    }\n\n    vector<bool> result(queries.size());\n\n    for (int i = 0; i < queries.size(); ++i) {\n        vector<bool> visited(numCourses, false);\n        vector<bool> transitiveClosure(numCourses, false);\n        DFS(queries[i][0], graph, visited, transitiveClosure, queries[i][1]);\n        result[i] = transitiveClosure[queries[i][1]];\n    }\n\n    return result;\n}\n```\n    \n    The algorithm starts by creating a graph representation from the given prerequisites, with the courses represented as nodes and directed edges from the prerequisites to the dependent courses. Then, for each query, we perform a Depth-First Search (DFS) from the source course to check if we can reach the destination course. During the DFS traversal, we maintain a visited array and a transitive closure array to prevent cycles and to mark prerequisite courses. If we reach the destination course during DFS, we set the corresponding position in the transitive closure array to true, indicating that the prerequisite is satisfied. Finally, results are collected in an array and returned.\n    ", "python": "\n    ```python\nfrom collections import defaultdict\n\ndef DFS(src, graph, visited, transitive_closure, dest):\n    if src == dest:\n        transitive_closure[dest] = True\n        return\n    if visited[src]:\n        return\n    visited[src] = True\n    for neighbor in graph[src]:\n        DFS(neighbor, graph, visited, transitive_closure, dest)\n        if transitive_closure[dest]:\n            return\n\ndef checkIfPrerequisite(numCourses, prerequisites, queries):\n    graph = defaultdict(list)\n\n    for pre in prerequisites:\n        graph[pre[0]].append(pre[1])\n\n    result = []\n\n    for i in range(len(queries)):\n        visited = [False] * numCourses\n        transitive_closure = [False] * numCourses\n        DFS(queries[i][0], graph, visited, transitive_closure, queries[i][1])\n        result.append(transitive_closure[queries[i][1]])\n\n    return result\n```\n    \n    The algorithm starts by creating a graph representation from the given prerequisites, with the courses represented as nodes and directed edges from the prerequisites to the dependent courses. Then, for each query, we perform a Depth-First Search (DFS) from the source course to check if we can reach the destination course. During the DFS traversal, we maintain a visited array and a transitive closure array to prevent cycles and to mark prerequisite courses. If we reach the destination course during DFS, we set the corresponding position in the transitive closure array to true, indicating that the prerequisite is satisfied. Finally, results are collected in an array and returned.\n    ", "javascript": "\n    ```javascript\nfunction DFS(src, graph, visited, transitiveClosure, dest) {\n    if (src === dest) {\n        transitiveClosure[dest] = true;\n        return;\n    }\n    if (visited[src]) return;\n    visited[src] = true;\n    for (let neighbor of graph[src]) {\n        DFS(neighbor, graph, visited, transitiveClosure, dest);\n        if (transitiveClosure[dest]) return;\n    }\n}\n\nfunction checkIfPrerequisite(numCourses, prerequisites, queries) {\n    const graph = new Map();\n\n    for (let pre of prerequisites) {\n        if (!graph.has(pre[0])) {\n            graph.set(pre[0], []);\n        }\n        graph.get(pre[0]).push(pre[1]);\n    }\n\n    const result = [];\n\n    for (let i = 0; i < queries.length; ++i) {\n        const visited = new Array(numCourses).fill(false);\n        const transitiveClosure = new Array(numCourses).fill(false);\n        DFS(queries[i][0], graph, visited, transitiveClosure, queries[i][1]);\n        result.push(transitiveClosure[queries[i][1]]);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm starts by creating a graph representation from the given prerequisites, with the courses represented as nodes and directed edges from the prerequisites to the dependent courses. Then, for each query, we perform a Depth-First Search (DFS) from the source course to check if we can reach the destination course. During the DFS traversal, we maintain a visited array and a transitive closure array to prevent cycles and to mark prerequisite courses. If we reach the destination course during DFS, we set the corresponding position in the transitive closure array to true, indicating that the prerequisite is satisfied. Finally, results are collected in an array and returned.\n    "}
{"id": 1561, "slug": "maximum-number-of-coins-you-can-get", "title": "Maximum Number of Coins You Can Get", "difficulty": "Medium", "content": "There are `3n` piles of coins of varying size, you and your friends will take piles of coins as follows:\n\n*   In each step, you will choose **any** `3` piles of coins (not necessarily consecutive).\n*   Of your choice, Alice will pick the pile with the maximum number of coins.\n*   You will pick the next pile with the maximum number of coins.\n*   Your friend Bob will pick the last pile.\n*   Repeat until there are no more piles of coins.\n\nGiven an array of integers `piles` where `piles[i]` is the number of coins in the `ith` pile.\n\nReturn the maximum number of coins that you can have.\n\n**Example 1:**\n\n**Input:** piles = \\[2,4,1,2,7,8\\]\n**Output:** 9\n**Explanation:** Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with **7** coins and Bob the last one.\nChoose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with **2** coins and Bob the last one.\nThe maximum number of coins which you can have are: 7 + 2 = 9.\nOn the other hand if we choose this arrangement (1, **2**, 8), (2, **4**, 7) you only get 2 + 4 = 6 coins which is not optimal.\n\n**Example 2:**\n\n**Input:** piles = \\[2,4,5\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** piles = \\[9,8,7,6,5,1,2,3,4\\]\n**Output:** 18\n\n**Constraints:**\n\n*   `3 <= piles.length <= 105`\n*   `piles.length % 3 == 0`\n*   `1 <= piles[i] <= 104`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic class Main {\n    public static String arrangeWords(String text) {\n        String[] words = text.toLowerCase().split(\" \");\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\n        words[0] = Character.toUpperCase(words[0].charAt(0)) + words[0].substring(1);\n        return String.join(\" \", words);\n    }\n}\n```\n    \n    1. First, convert the first character of `text` to lowercase.\n2. Split the `text` into an array or vector of words based on the space character.\n3. Sort the words by their length using the `sort` or `stable_sort` function. The stable sort preservers the relative order of the elements with same length.\n4. Change the first character of the first word to uppercase.\n5. Join the words with a space separator and return the resulting string.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n\nstd::string arrangeWords(std::string text) {\n    text[0] = tolower(text[0]);\n    std::istringstream iss(text);\n    std::vector<std::pair<std::string, int>> words;\n    std::string word;\n    int i = 0;\n    while (iss >> word) {\n        words.emplace_back(word, i++);\n    }\n    std::stable_sort(words.begin(), words.end(), [](const auto &a, const auto &b) {\n        return a.first.length() < b.first.length();\n    });\n    std::ostringstream oss;\n    for (const auto &w : words) {\n        if (&w != &words[0]) oss << ' ';\n        oss << w.first;\n    }\n    auto result = oss.str();\n    result[0] = toupper(result[0]);\n    return result;\n}\n```\n    \n    1. First, convert the first character of `text` to lowercase.\n2. Split the `text` into an array or vector of words based on the space character.\n3. Sort the words by their length using the `sort` or `stable_sort` function. The stable sort preservers the relative order of the elements with same length.\n4. Change the first character of the first word to uppercase.\n5. Join the words with a space separator and return the resulting string.\n    ", "python": "\n    ```python\ndef arrangeWords(text: str) -> str:\n    words = text.split()\n    words[0] = words[0].lower()\n    words.sort(key=len)\n    words[0] = words[0].capitalize()\n    return ' '.join(words)\n```\n    \n    1. First, convert the first character of `text` to lowercase.\n2. Split the `text` into an array or vector of words based on the space character.\n3. Sort the words by their length using the `sort` or `stable_sort` function. The stable sort preservers the relative order of the elements with same length.\n4. Change the first character of the first word to uppercase.\n5. Join the words with a space separator and return the resulting string.\n    ", "javascript": "\n    ```javascript\nfunction arrangeWords(text) {\n    const words = text.toLowerCase().split(' ').sort((a, b) => a.length - b.length);\n    words[0] = words[0].charAt(0).toUpperCase() + words[0].slice(1);\n    return words.join(' ');\n}\n```\n    \n    1. First, convert the first character of `text` to lowercase.\n2. Split the `text` into an array or vector of words based on the space character.\n3. Sort the words by their length using the `sort` or `stable_sort` function. The stable sort preservers the relative order of the elements with same length.\n4. Change the first character of the first word to uppercase.\n5. Join the words with a space separator and return the resulting string.\n    "}
{"id": 1564, "slug": "put-boxes-into-the-warehouse-i", "title": "Put Boxes Into the Warehouse I", "difficulty": "Medium", "content": "You are given two arrays of positive integers, `boxes` and `warehouse`, representing the heights of some boxes of unit width and the heights of `n` rooms in a warehouse respectively. The warehouse's rooms are labelled from `0` to `n - 1` from left to right where `warehouse[i]` (0-indexed) is the height of the `ith` room.\n\nBoxes are put into the warehouse by the following rules:\n\n*   Boxes cannot be stacked.\n*   You can rearrange the insertion order of the boxes.\n*   Boxes can only be pushed into the warehouse from left to right only.\n*   If the height of some room in the warehouse is less than the height of a box, then that box and all other boxes behind it will be stopped before that room.\n\nReturn _the maximum number of boxes you can put into the warehouse._\n\n**Example 1:**\n\n**Input:** boxes = \\[4,3,4,1\\], warehouse = \\[5,3,3,4,1\\]\n**Output:** 3\n**Explanation:** \n \nWe can first put the box of height 1 in room 4. Then we can put the box of height 3 in either of the 3 rooms 1, 2, or 3. Lastly, we can put one box of height 4 in room 0.\nThere is no way we can fit all 4 boxes in the warehouse.\n\n**Example 2:**\n\n**Input:** boxes = \\[1,2,2,3,4\\], warehouse = \\[3,4,1,2\\]\n**Output:** 3\n**Explanation:** \n \nNotice that it's not possible to put the box of height 4 into the warehouse since it cannot pass the first room of height 3.\nAlso, for the last two rooms, 2 and 3, only boxes of height 1 can fit.\nWe can fit 3 boxes maximum as shown above. The yellow box can also be put in room 2 instead.\nSwapping the orange and green boxes is also valid, or swapping one of them with the red box.\n\n**Example 3:**\n\n**Input:** boxes = \\[1,2,3\\], warehouse = \\[1,2,3,4\\]\n**Output:** 1\n**Explanation:** Since the first room in the warehouse is of height 1, we can only put boxes of height 1.\n\n**Constraints:**\n\n*   `n == warehouse.length`\n*   `1 <= boxes.length, warehouse.length <= 105`\n*   `1 <= boxes[i], warehouse[i] <= 109`", "java": "\n    ```java\npublic int maxBoxesInWarehouse(int[] boxes, int[] warehouse) {\n    int n = warehouse.length;\n    for (int i = 1; i < n; i++)\n        warehouse[i] = Math.min(warehouse[i], warehouse[i - 1]);\n    Arrays.sort(boxes);\n    int boxIndex = boxes.length - 1;\n    int boxesCount = 0;\n    for (int i = 0; i < n && boxIndex >= 0; i++) {\n        if (boxes[boxIndex] <= warehouse[i]) {\n            boxesCount++;\n            boxIndex--;\n        }\n    }\n    return boxesCount;\n}\n```\n\n    \n    The main idea of the algorithm is to first preprocess the warehouse array such that for each room, it stores the minimum height up to that room. This is done to find the maximum height a box can have to be placed in a room considering previous rooms' heights. Then, reverse sort the boxes array to have the largest box first. Finally, iterate through the preprocessed warehouse array and compare the height of the current largest box with the height of the current room. If the box can fit, increment the count of boxes and move to the next box in the sorted array.\n    ", "c++": "\n    ```cpp\nint maxBoxesInWarehouse(vector<int>& boxes, vector<int>& warehouse) {\n    int n = warehouse.size();\n    for (int i = 1; i < n; i++)\n        warehouse[i] = min(warehouse[i], warehouse[i - 1]);\n    sort(boxes.rbegin(), boxes.rend());\n    int boxIndex = 0;\n    int boxesCount = 0;\n    for (int i = 0; i < n && boxIndex < boxes.size(); i++) {\n        if (boxes[boxIndex] <= warehouse[i]) {\n            boxesCount++;\n            boxIndex++;\n        }\n    }\n    return boxesCount;\n}\n```\n\n    \n    The main idea of the algorithm is to first preprocess the warehouse array such that for each room, it stores the minimum height up to that room. This is done to find the maximum height a box can have to be placed in a room considering previous rooms' heights. Then, reverse sort the boxes array to have the largest box first. Finally, iterate through the preprocessed warehouse array and compare the height of the current largest box with the height of the current room. If the box can fit, increment the count of boxes and move to the next box in the sorted array.\n    ", "python": "\n    ```python\ndef maxBoxesInWarehouse(boxes, warehouse):\n    n = len(warehouse)\n    for i in range(1, n):\n        warehouse[i] = min(warehouse[i], warehouse[i - 1])\n    boxes.sort(reverse=True)\n    boxIndex = 0\n    boxesCount = 0\n    for i in range(n):\n        if boxIndex < len(boxes) and boxes[boxIndex] <= warehouse[i]:\n            boxesCount += 1\n            boxIndex += 1\n    return boxesCount\n```\n\n    \n    The main idea of the algorithm is to first preprocess the warehouse array such that for each room, it stores the minimum height up to that room. This is done to find the maximum height a box can have to be placed in a room considering previous rooms' heights. Then, reverse sort the boxes array to have the largest box first. Finally, iterate through the preprocessed warehouse array and compare the height of the current largest box with the height of the current room. If the box can fit, increment the count of boxes and move to the next box in the sorted array.\n    ", "javascript": "\n    ```javascript\nfunction maxBoxesInWarehouse(boxes, warehouse) {\n    let n = warehouse.length;\n    for (let i = 1; i < n; i++)\n        warehouse[i] = Math.min(warehouse[i], warehouse[i - 1]);\n    boxes.sort((a, b) => b - a);\n    let boxIndex = 0;\n    let boxesCount = 0;\n    for (let i = 0; i < n && boxIndex < boxes.length; i++) {\n        if (boxes[boxIndex] <= warehouse[i]) {\n            boxesCount++;\n            boxIndex++;\n        }\n    }\n    return boxesCount;\n}\n```\n\n    \n    The main idea of the algorithm is to first preprocess the warehouse array such that for each room, it stores the minimum height up to that room. This is done to find the maximum height a box can have to be placed in a room considering previous rooms' heights. Then, reverse sort the boxes array to have the largest box first. Finally, iterate through the preprocessed warehouse array and compare the height of the current largest box with the height of the current room. If the box can fit, increment the count of boxes and move to the next box in the sorted array.\n    "}
{"id": 1567, "slug": "maximum-length-of-subarray-with-positive-product", "title": "Maximum Length of Subarray With Positive Product", "difficulty": "Medium", "content": "Given an array of integers `nums`, find the maximum length of a subarray where the product of all its elements is positive.\n\nA subarray of an array is a consecutive sequence of zero or more values taken out of that array.\n\nReturn _the maximum length of a subarray with positive product_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,-2,-3,4\\]\n**Output:** 4\n**Explanation:** The array nums already has a positive product of 24.\n\n**Example 2:**\n\n**Input:** nums = \\[0,1,-2,-3,-4\\]\n**Output:** 3\n**Explanation:** The longest subarray with positive product is \\[1,-2,-3\\] which has a product of 6.\nNotice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.\n\n**Example 3:**\n\n**Input:** nums = \\[-1,-2,-3,0,1\\]\n**Output:** 2\n**Explanation:** The longest subarray with positive product is \\[-1,-2\\] or \\[-2,-3\\].\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`", "java": "\n    ```java\npublic int maxVowels(String s, int k) {\n    int max_count = 0, count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        count += isVowel(s.charAt(i)) ? 1 : 0;\n        if (i >= k)\n            count -= isVowel(s.charAt(i - k)) ? 1 : 0;\n        max_count = Math.max(max_count, count);\n    }\n    return max_count;\n}\n\nprivate boolean isVowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n```\n\n    \n    1. Initialize `max_count` and `count` variables to store the maximum count of consecutive vowels and the current count of vowels within the window of size `k`.\n2. Iterate through each character in the input string `s`.\n3. For each character, check if the character is a vowel. If it's a vowel, increment the `count` variable.\n4. If the current index `i` is greater than or equal to `k`, then check if the character (`s[i - k]`) that is outside of the current `k`-sized window is a vowel. If it's a vowel, decrement the `count` variable.\n5. At each iteration, update the `max_count` variable to store the maximum value of `count`.\n6. Return the value of `max_count` after the loop.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <algorithm>\n\nint maxVowels(std::string s, int k) {\n    int max_count = 0, count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        count += (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u');\n        if (i >= k)\n            count -= (s[i - k] == 'a' || s[i - k] == 'e' || s[i - k] == 'i' || s[i - k] == 'o' || s[i - k] == 'u');\n        max_count = std::max(max_count, count);\n    }\n    return max_count;\n}\n```\n\n    \n    1. Initialize `max_count` and `count` variables to store the maximum count of consecutive vowels and the current count of vowels within the window of size `k`.\n2. Iterate through each character in the input string `s`.\n3. For each character, check if the character is a vowel. If it's a vowel, increment the `count` variable.\n4. If the current index `i` is greater than or equal to `k`, then check if the character (`s[i - k]`) that is outside of the current `k`-sized window is a vowel. If it's a vowel, decrement the `count` variable.\n5. At each iteration, update the `max_count` variable to store the maximum value of `count`.\n6. Return the value of `max_count` after the loop.\n    ", "python": "\n    ```python\ndef max_vowels(s, k):\n    max_count = count = 0\n    for i, c in enumerate(s):\n        count += int(c in 'aeiou')\n        if i >= k:\n            count -= int(s[i - k] in 'aeiou')\n        max_count = max(max_count, count)\n    return max_count\n```\n\n    \n    1. Initialize `max_count` and `count` variables to store the maximum count of consecutive vowels and the current count of vowels within the window of size `k`.\n2. Iterate through each character in the input string `s`.\n3. For each character, check if the character is a vowel. If it's a vowel, increment the `count` variable.\n4. If the current index `i` is greater than or equal to `k`, then check if the character (`s[i - k]`) that is outside of the current `k`-sized window is a vowel. If it's a vowel, decrement the `count` variable.\n5. At each iteration, update the `max_count` variable to store the maximum value of `count`.\n6. Return the value of `max_count` after the loop.\n    ", "javascript": "\n    ```javascript\nfunction maxVowels(s, k) {\n    let max_count = 0, count = 0;\n    for (let i = 0; i < s.length; i++) {\n        count += isVowel(s[i]) ? 1 : 0;\n        if (i >= k)\n            count -= isVowel(s[i - k]) ? 1 : 0;\n        max_count = Math.max(max_count, count);\n    }\n    return max_count;\n}\n\nfunction isVowel(c) {\n    return c === 'a' || c === 'e' || c === 'i' || c === 'o' || c === 'u';\n}\n```\n\n    \n    1. Initialize `max_count` and `count` variables to store the maximum count of consecutive vowels and the current count of vowels within the window of size `k`.\n2. Iterate through each character in the input string `s`.\n3. For each character, check if the character is a vowel. If it's a vowel, increment the `count` variable.\n4. If the current index `i` is greater than or equal to `k`, then check if the character (`s[i - k]`) that is outside of the current `k`-sized window is a vowel. If it's a vowel, decrement the `count` variable.\n5. At each iteration, update the `max_count` variable to store the maximum value of `count`.\n6. Return the value of `max_count` after the loop.\n    "}
{"id": 1578, "slug": "minimum-time-to-make-rope-colorful", "title": "Minimum Time to Make Rope Colorful", "difficulty": "Medium", "content": "Alice has `n` balloons arranged on a rope. You are given a **0-indexed** string `colors` where `colors[i]` is the color of the `ith` balloon.\n\nAlice wants the rope to be **colorful**. She does not want **two consecutive balloons** to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it **colorful**. You are given a **0-indexed** integer array `neededTime` where `neededTime[i]` is the time (in seconds) that Bob needs to remove the `ith` balloon from the rope.\n\nReturn _the **minimum time** Bob needs to make the rope **colorful**_.\n\n**Example 1:**\n\n**Input:** colors =  \"abaac \", neededTime = \\[1,2,3,4,5\\]\n**Output:** 3\n**Explanation:** In the above image, 'a' is blue, 'b' is red, and 'c' is green.\nBob can remove the blue balloon at index 2. This takes 3 seconds.\nThere are no longer two consecutive balloons of the same color. Total time = 3.\n\n**Example 2:**\n\n**Input:** colors =  \"abc \", neededTime = \\[1,2,3\\]\n**Output:** 0\n**Explanation:** The rope is already colorful. Bob does not need to remove any balloons from the rope.\n\n**Example 3:**\n\n**Input:** colors =  \"aabaa \", neededTime = \\[1,2,3,4,1\\]\n**Output:** 2\n**Explanation:** Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.\nThere are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.\n\n**Constraints:**\n\n*   `n == colors.length == neededTime.length`\n*   `1 <= n <= 105`\n*   `1 <= neededTime[i] <= 104`\n*   `colors` contains only lowercase English letters.", "java": "\n    ```java\npublic int minTime(String colors, int[] neededTime) {\n    int res = 0, prev = -1;\n    for (int i = 0; i < colors.length() - 1; i++) {\n        if (colors.charAt(i) == colors.charAt(i + 1)) {\n            if (prev == -1 || neededTime[i] < neededTime[prev]) prev = i;\n            if (neededTime[i + 1] < neededTime[prev]) prev = i + 1;\n            res += neededTime[prev];\n            neededTime[prev] = 1000000;\n            prev = -1;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm needs to find the minimum time to remove consecutive balloons with the same color. It iterates through the colors array, and for each pair of consecutive colors that are the same, it checks which of the two balloons takes the least time to remove, and removes it. Then, it updates the `neededTime` array by setting the removed balloon's needed time to a large number (1000000) and sums up the needed time for each removed balloon in the `res` variable. Finally, it returns the total time spent (the value of `res`).\n    ", "c++": "\n    ```cpp\nint minTime(string colors, vector<int>& neededTime) {\n    int res = 0, prev = -1;\n    for (int i = 0; i < colors.length() - 1; i++) {\n        if (colors[i] == colors[i + 1]) {\n            if (prev == -1 || neededTime[i] < neededTime[prev]) prev = i;\n            if (neededTime[i + 1] < neededTime[prev]) prev = i + 1;\n            res += neededTime[prev];\n            neededTime[prev] = 1000000;\n            prev = -1;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm needs to find the minimum time to remove consecutive balloons with the same color. It iterates through the colors array, and for each pair of consecutive colors that are the same, it checks which of the two balloons takes the least time to remove, and removes it. Then, it updates the `neededTime` array by setting the removed balloon's needed time to a large number (1000000) and sums up the needed time for each removed balloon in the `res` variable. Finally, it returns the total time spent (the value of `res`).\n    ", "python": "\n    ```python\ndef minTime(colors: str, neededTime: List[int]) -> int:\n    res, prev = 0, -1\n    for i in range(len(colors) - 1):\n        if colors[i] == colors[i + 1]:\n            if prev == -1 or neededTime[i] < neededTime[prev]:\n                prev = i\n            if neededTime[i + 1] < neededTime[prev]:\n                prev = i + 1\n            res += neededTime[prev]\n            neededTime[prev] = 1000000\n            prev = -1\n    return res\n```\n    \n    The algorithm needs to find the minimum time to remove consecutive balloons with the same color. It iterates through the colors array, and for each pair of consecutive colors that are the same, it checks which of the two balloons takes the least time to remove, and removes it. Then, it updates the `neededTime` array by setting the removed balloon's needed time to a large number (1000000) and sums up the needed time for each removed balloon in the `res` variable. Finally, it returns the total time spent (the value of `res`).\n    ", "javascript": "\n    ```javascript\nfunction minTime(colors, neededTime) {\n    let res = 0, prev = -1;\n    for (let i = 0; i < colors.length - 1; i++) {\n        if (colors[i] === colors[i + 1]) {\n            if (prev === -1 || neededTime[i] < neededTime[prev]) prev = i;\n            if (neededTime[i + 1] < neededTime[prev]) prev = i + 1;\n            res += neededTime[prev];\n            neededTime[prev] = 1000000;\n            prev = -1;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm needs to find the minimum time to remove consecutive balloons with the same color. It iterates through the colors array, and for each pair of consecutive colors that are the same, it checks which of the two balloons takes the least time to remove, and removes it. Then, it updates the `neededTime` array by setting the removed balloon's needed time to a large number (1000000) and sums up the needed time for each removed balloon in the `res` variable. Finally, it returns the total time spent (the value of `res`).\n    "}
{"id": 1580, "slug": "put-boxes-into-the-warehouse-ii", "title": "Put Boxes Into the Warehouse II", "difficulty": "Medium", "content": "You are given two arrays of positive integers, `boxes` and `warehouse`, representing the heights of some boxes of unit width and the heights of `n` rooms in a warehouse respectively. The warehouse's rooms are labeled from `0` to `n - 1` from left to right where `warehouse[i]` (0-indexed) is the height of the `ith` room.\n\nBoxes are put into the warehouse by the following rules:\n\n*   Boxes cannot be stacked.\n*   You can rearrange the insertion order of the boxes.\n*   Boxes can be pushed into the warehouse from **either side** (left or right)\n*   If the height of some room in the warehouse is less than the height of a box, then that box and all other boxes behind it will be stopped before that room.\n\nReturn _the maximum number of boxes you can put into the warehouse._\n\n**Example 1:**\n\n**Input:** boxes = \\[1,2,2,3,4\\], warehouse = \\[3,4,1,2\\]\n**Output:** 4\n**Explanation:**\n \nWe can store the boxes in the following order:\n1- Put the yellow box in room 2 from either the left or right side.\n2- Put the orange box in room 3 from the right side.\n3- Put the green box in room 1 from the left side.\n4- Put the red box in room 0 from the left side.\nNotice that there are other valid ways to put 4 boxes such as swapping the red and green boxes or the red and orange boxes.\n\n**Example 2:**\n\n**Input:** boxes = \\[3,5,5,2\\], warehouse = \\[2,1,3,4,5\\]\n**Output:** 3\n**Explanation:**\n \nIt is not possible to put the two boxes of height 5 in the warehouse since there's only 1 room of height >= 5.\nOther valid solutions are to put the green box in room 2 or to put the orange box first in room 2 before putting the green and red boxes.\n\n**Constraints:**\n\n*   `n == warehouse.length`\n*   `1 <= boxes.length, warehouse.length <= 105`\n*   `1 <= boxes[i], warehouse[i] <= 109`", "java": "\n    ```java\npublic int[] shuffle(int[] nums, int n) {\n    int[] shuffled = new int[nums.length];\n    for(int i = 0; i < n; i++) {\n        shuffled[2*i] = nums[i];\n        shuffled[2*i+1] = nums[i+n];\n    }\n    return shuffled;\n}\n```\n\n    \n    The algorithm for solving this problem is quite simple:\n1. Initialize an empty array called \"shuffled\" to store the shuffled elements.\n2. Iterate through the first n elements of the input array (nums).\n3. For each element at index i, add nums[i] and nums[i+n] to the \"shuffled\" array in that order.\n4. Return the \"shuffled\" array.\n    ", "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nvector<int> shuffle(vector<int>& nums, int n) {\n    vector<int> shuffled;\n    for(int i = 0; i < n; ++i) {\n        shuffled.push_back(nums[i]);\n        shuffled.push_back(nums[i+n]);\n    }\n    return shuffled;\n}\n```\n\n    \n    The algorithm for solving this problem is quite simple:\n1. Initialize an empty array called \"shuffled\" to store the shuffled elements.\n2. Iterate through the first n elements of the input array (nums).\n3. For each element at index i, add nums[i] and nums[i+n] to the \"shuffled\" array in that order.\n4. Return the \"shuffled\" array.\n    ", "python": "\n    ```python\ndef shuffle(nums, n):\n    shuffled = []\n    for i in range(n):\n        shuffled.append(nums[i])\n        shuffled.append(nums[i+n])\n    return shuffled\n```\n    \n    The algorithm for solving this problem is quite simple:\n1. Initialize an empty array called \"shuffled\" to store the shuffled elements.\n2. Iterate through the first n elements of the input array (nums).\n3. For each element at index i, add nums[i] and nums[i+n] to the \"shuffled\" array in that order.\n4. Return the \"shuffled\" array.\n    ", "javascript": "\n    ```javascript\nfunction shuffle(nums, n) {\n    const shuffled = [];\n    for(let i = 0; i < n; i++) {\n        shuffled.push(nums[i]);\n        shuffled.push(nums[i+n]);\n    }\n    return shuffled;\n}\n```\n    \n    The algorithm for solving this problem is quite simple:\n1. Initialize an empty array called \"shuffled\" to store the shuffled elements.\n2. Iterate through the first n elements of the input array (nums).\n3. For each element at index i, add nums[i] and nums[i+n] to the \"shuffled\" array in that order.\n4. Return the \"shuffled\" array.\n    "}
{"id": 1585, "slug": "check-if-string-is-transformable-with-substring-sort-operations", "title": "Check If String Is Transformable With Substring Sort Operations", "difficulty": "Hard", "content": "Given two strings `s` and `t`, transform string `s` into string `t` using the following operation any number of times:\n\n*   Choose a **non-empty** substring in `s` and sort it in place so the characters are in **ascending order**.\n    *   For example, applying the operation on the underlined substring in `\"14234 \"` results in `\"12344 \"`.\n\nReturn `true` if _it is possible to transform `s` into `t`_. Otherwise, return `false`.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n**Example 1:**\n\n**Input:** s =  \"84532 \", t =  \"34852 \"\n**Output:** true\n**Explanation:** You can transform s into t using the following sort operations:\n \"84532 \" (from index 2 to 3) ->  \"84352 \"\n \"84352 \" (from index 0 to 2) ->  \"34852 \"\n\n**Example 2:**\n\n**Input:** s =  \"34521 \", t =  \"23415 \"\n**Output:** true\n**Explanation:** You can transform s into t using the following sort operations:\n \"34521 \" ->  \"23451 \"\n \"23451 \" ->  \"23415 \"\n\n**Example 3:**\n\n**Input:** s =  \"12345 \", t =  \"12435 \"\n**Output:** false\n\n**Constraints:**\n\n*   `s.length == t.length`\n*   `1 <= s.length <= 105`\n*   `s` and `t` consist of only digits.", "java": "\n    ```java\npublic int kthFactor(int n, int k) {\n    for (int i = 1; i <= n; ++i) {\n        if (n % i == 0) {\n            --k;\n            if (k == 0) return i;\n        }\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm starts with the smallest possible factor `i=1` and iterates through all numbers up to `n`. For each iteration, the algorithm checks if `n % i` is equal to 0, which means the current `i` is a factor of `n`. If so, it decrements the value of `k`. When `k` becomes zero, return the current `i`, as it is the kth factor. If the loop ends without finding the kth factor, return -1, since there are no k factors for given `n`.\n    ", "c++": "\n    ```cpp\nint kthFactor(int n, int k) {\n    for (int i = 1; i <= n; ++i) {\n        if (n % i == 0) {\n            --k;\n            if (k == 0) return i;\n        }\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm starts with the smallest possible factor `i=1` and iterates through all numbers up to `n`. For each iteration, the algorithm checks if `n % i` is equal to 0, which means the current `i` is a factor of `n`. If so, it decrements the value of `k`. When `k` becomes zero, return the current `i`, as it is the kth factor. If the loop ends without finding the kth factor, return -1, since there are no k factors for given `n`.\n    ", "python": "\n    ```python\ndef kth_factor(n: int, k: int) -> int:\n    for i in range(1, n+1):\n        if n % i == 0:\n            k -= 1\n            if k == 0:\n                return i\n    return -1\n```\n\n    \n    The algorithm starts with the smallest possible factor `i=1` and iterates through all numbers up to `n`. For each iteration, the algorithm checks if `n % i` is equal to 0, which means the current `i` is a factor of `n`. If so, it decrements the value of `k`. When `k` becomes zero, return the current `i`, as it is the kth factor. If the loop ends without finding the kth factor, return -1, since there are no k factors for given `n`.\n    ", "javascript": "\n    ```javascript\nfunction kthFactor(n, k) {\n    for (let i = 1; i <= n; ++i) {\n        if (n % i === 0) {\n            --k;\n            if (k === 0) return i;\n        }\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm starts with the smallest possible factor `i=1` and iterates through all numbers up to `n`. For each iteration, the algorithm checks if `n % i` is equal to 0, which means the current `i` is a factor of `n`. If so, it decrements the value of `k`. When `k` becomes zero, return the current `i`, as it is the kth factor. If the loop ends without finding the kth factor, return -1, since there are no k factors for given `n`.\n    "}
{"id": 1589, "slug": "maximum-sum-obtained-of-any-permutation", "title": "Maximum Sum Obtained of Any Permutation", "difficulty": "Medium", "content": "We have an array of integers, `nums`, and an array of `requests` where `requests[i] = [starti, endi]`. The `ith` request asks for the sum of `nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]`. Both `starti` and `endi` are _0-indexed_.\n\nReturn _the maximum total sum of all requests **among all permutations** of_ `nums`.\n\nSince the answer may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5\\], requests = \\[\\[1,3\\],\\[0,1\\]\\]\n**Output:** 19\n**Explanation:** One permutation of nums is \\[2,1,3,4,5\\] with the following result: \nrequests\\[0\\] -> nums\\[1\\] + nums\\[2\\] + nums\\[3\\] = 1 + 3 + 4 = 8\nrequests\\[1\\] -> nums\\[0\\] + nums\\[1\\] = 2 + 1 = 3\nTotal sum: 8 + 3 = 11.\nA permutation with a higher total sum is \\[3,5,4,2,1\\] with the following result:\nrequests\\[0\\] -> nums\\[1\\] + nums\\[2\\] + nums\\[3\\] = 5 + 4 + 2 = 11\nrequests\\[1\\] -> nums\\[0\\] + nums\\[1\\] = 3 + 5  = 8\nTotal sum: 11 + 8 = 19, which is the best that you can do.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5,6\\], requests = \\[\\[0,1\\]\\]\n**Output:** 11\n**Explanation:** A permutation with the max total sum is \\[6,5,4,3,2,1\\] with request sums \\[11\\].\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5,10\\], requests = \\[\\[0,2\\],\\[1,3\\],\\[1,1\\]\\]\n**Output:** 47\n**Explanation:** A permutation with the max total sum is \\[4,10,5,3,2,1\\] with request sums \\[19,18,10\\].\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `0 <= nums[i] <= 105`\n*   `1 <= requests.length <= 105`\n*   `requests[i].length == 2`\n*   `0 <= starti <= endi < n`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxSumRangeQuery(int[] nums, int[][] requests) {\n    int n = nums.length;\n    int[] count = new int[n];\n    for (int[] request : requests) {\n        count[request[0]]++;\n        if (request[1] + 1 < n)\n            count[request[1] + 1]--;\n    }\n    for (int i = 1; i < n; i++) {\n        count[i] += count[i - 1];\n    }\n    Arrays.sort(nums);\n    Arrays.sort(count);\n    \n    long ans = 0;\n    for (int i = 0; i < n; i++) {\n        ans = (ans + (long)nums[i] * count[i]) % 1000000007;\n    }\n    return (int) ans;\n}\n```\n    \n    1. Create an empty frequency count array, `count`, of the same size as `nums`.\n2. Loop through the `requests` array to update our `count` array: increment the count value on the `start` index and decrement it on the `end + 1` index, if it is less than `n`.\n3. Starting from the second index of the `count` array, update each `count` element with the sum of the current element and the previous element, i.e., compute the prefix sum.\n4. Sort both the `nums` and `count` arrays in non-decreasing order.\n5. Calculate the summation of the product of pairwise elements of two sorted arrays, modulo 1e9+7, and store it in a variable called `ans`.\n6. Return the `ans` value.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\n    int n = nums.size();\n    vector<int> count(n, 0);\n    for (auto& request : requests) {\n        count[request[0]]++;\n        if (request[1] + 1 < n) \n            count[request[1] + 1]--;\n    }\n    for (int i = 1; i < n; i++) {\n        count[i] += count[i - 1];\n    }\n    sort(nums.begin(), nums.end());\n    sort(count.begin(), count.end());\n    \n    long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        ans = (ans + (long long)nums[i] * count[i]) % MOD;\n    }\n    return ans;\n}\n```\n    \n    1. Create an empty frequency count array, `count`, of the same size as `nums`.\n2. Loop through the `requests` array to update our `count` array: increment the count value on the `start` index and decrement it on the `end + 1` index, if it is less than `n`.\n3. Starting from the second index of the `count` array, update each `count` element with the sum of the current element and the previous element, i.e., compute the prefix sum.\n4. Sort both the `nums` and `count` arrays in non-decreasing order.\n5. Calculate the summation of the product of pairwise elements of two sorted arrays, modulo 1e9+7, and store it in a variable called `ans`.\n6. Return the `ans` value.\n    ", "python": "\n    ```python\ndef maxSumRangeQuery(nums, requests):\n    n = len(nums)\n    count = [0] * n\n    for request in requests:\n        count[request[0]] += 1\n        if request[1] + 1 < n:\n            count[request[1] + 1] -= 1\n    for i in range(1, n):\n        count[i] += count[i - 1]\n\n    nums.sort()\n    count.sort()\n\n    ans = 0\n    for i in range(n):\n        ans = (ans + nums[i] * count[i]) % 1000000007\n    return ans\n```\n    \n    1. Create an empty frequency count array, `count`, of the same size as `nums`.\n2. Loop through the `requests` array to update our `count` array: increment the count value on the `start` index and decrement it on the `end + 1` index, if it is less than `n`.\n3. Starting from the second index of the `count` array, update each `count` element with the sum of the current element and the previous element, i.e., compute the prefix sum.\n4. Sort both the `nums` and `count` arrays in non-decreasing order.\n5. Calculate the summation of the product of pairwise elements of two sorted arrays, modulo 1e9+7, and store it in a variable called `ans`.\n6. Return the `ans` value.\n    ", "javascript": "\n    ```javascript\nfunction maxSumRangeQuery(nums, requests) {\n    const n = nums.length;\n    const count = new Array(n).fill(0);\n    const MOD = 1000000007;\n\n    for (const request of requests) {\n        count[request[0]]++;\n        if (request[1] + 1 < n) {\n            count[request[1] + 1]--;\n        }\n    }\n    for (let i = 1; i < n; i++) {\n        count[i] += count[i - 1];\n    }\n\n    nums.sort((a, b) => a - b);\n    count.sort((a, b) => a - b);\n\n    let ans = 0;\n    for (let i = 0; i < n; i++) {\n        ans = (ans + nums[i] * count[i]) % MOD;\n    }\n\n    return ans;\n}\n```\n    \n    1. Create an empty frequency count array, `count`, of the same size as `nums`.\n2. Loop through the `requests` array to update our `count` array: increment the count value on the `start` index and decrement it on the `end + 1` index, if it is less than `n`.\n3. Starting from the second index of the `count` array, update each `count` element with the sum of the current element and the previous element, i.e., compute the prefix sum.\n4. Sort both the `nums` and `count` arrays in non-decreasing order.\n5. Calculate the summation of the product of pairwise elements of two sorted arrays, modulo 1e9+7, and store it in a variable called `ans`.\n6. Return the `ans` value.\n    "}
{"id": 1605, "slug": "find-valid-matrix-given-row-and-column-sums", "title": "Find Valid Matrix Given Row and Column Sums", "difficulty": "Medium", "content": "You are given two arrays `rowSum` and `colSum` of non-negative integers where `rowSum[i]` is the sum of the elements in the `ith` row and `colSum[j]` is the sum of the elements of the `jth` column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.\n\nFind any matrix of **non-negative** integers of size `rowSum.length x colSum.length` that satisfies the `rowSum` and `colSum` requirements.\n\nReturn _a 2D array representing **any** matrix that fulfills the requirements_. It's guaranteed that **at least one** matrix that fulfills the requirements exists.\n\n**Example 1:**\n\n**Input:** rowSum = \\[3,8\\], colSum = \\[4,7\\]\n**Output:** \\[\\[3,0\\],\n         \\[1,7\\]\\]\n**Explanation:** \n0th row: 3 + 0 = 3 == rowSum\\[0\\]\n1st row: 1 + 7 = 8 == rowSum\\[1\\]\n0th column: 3 + 1 = 4 == colSum\\[0\\]\n1st column: 0 + 7 = 7 == colSum\\[1\\]\nThe row and column sums match, and all matrix elements are non-negative.\nAnother possible matrix is: \\[\\[1,2\\],\n                             \\[3,5\\]\\]\n\n**Example 2:**\n\n**Input:** rowSum = \\[5,7,10\\], colSum = \\[8,6,8\\]\n**Output:** \\[\\[0,5,0\\],\n         \\[6,1,0\\],\n         \\[2,0,8\\]\\]\n\n**Constraints:**\n\n*   `1 <= rowSum.length, colSum.length <= 500`\n*   `0 <= rowSum[i], colSum[i] <= 108`\n*   `sum(rowSum) == sum(colSum)`", "java": "\n    ```java\npublic int minDays(int[] bloomDay, int m, int k) {\n    int left = Arrays.stream(bloomDay).min().getAsInt();\n    int right = Arrays.stream(bloomDay).max().getAsInt();\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        int bouquets = 0, flowers = 0;\n        for (int day : bloomDay) {\n            if (day > mid) {\n                flowers = 0;\n            } else {\n                flowers++;\n                if (flowers == k) {\n                    bouquets++;\n                    flowers = 0;\n                }\n            }\n        }\n        if (bouquets >= m) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return m == 0 ? -1 : left;\n}\n```\n    \n    We will use binary search to approach this problem. We first find the minimum and maximum bloom days, which will be the left and right boundaries of the search range. In each iteration, we calculate the middle value, and calculate the number of bouquets we can make with the bloom days less than or equal to the middle value. If the number of bouquets is greater than or equal to m, we update the right boundary to mid. Otherwise, we update the left boundary to mid + 1. The search ends when the left boundary is equal to the right boundary. The final return value will be -1 if m is 0, otherwise, it will be left boundary value.\n    ", "c++": "\n    ```cpp\nint minDays(vector<int>& bloomDay, int m, int k) {\n    int left = *min_element(bloomDay.begin(), bloomDay.end());\n    int right = *max_element(bloomDay.begin(), bloomDay.end());\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        int bouquets = 0, flowers = 0;\n        for (int day : bloomDay) {\n            if (day > mid) {\n                flowers = 0;\n            } else {\n                flowers++;\n                if (flowers == k) {\n                    bouquets++;\n                    flowers = 0;\n                }\n            }\n        }\n        if (bouquets >= m) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return m == 0 ? -1 : left;\n}\n```\n    \n    We will use binary search to approach this problem. We first find the minimum and maximum bloom days, which will be the left and right boundaries of the search range. In each iteration, we calculate the middle value, and calculate the number of bouquets we can make with the bloom days less than or equal to the middle value. If the number of bouquets is greater than or equal to m, we update the right boundary to mid. Otherwise, we update the left boundary to mid + 1. The search ends when the left boundary is equal to the right boundary. The final return value will be -1 if m is 0, otherwise, it will be left boundary value.\n    ", "python": "\n    ```python\ndef minDays(bloomDay, m, k):\n    left, right = min(bloomDay), max(bloomDay)\n\n    while left < right:\n        mid = left + (right - left) // 2\n        bouquets = flowers = 0\n        for day in bloomDay:\n            if day > mid:\n                flowers = 0\n            else:\n                flowers += 1\n                if flowers == k:\n                    bouquets += 1\n                    flowers = 0\n\n        if bouquets >= m:\n            right = mid\n        else:\n            left = mid + 1\n\n    return -1 if m == 0 else left\n```\n    \n    We will use binary search to approach this problem. We first find the minimum and maximum bloom days, which will be the left and right boundaries of the search range. In each iteration, we calculate the middle value, and calculate the number of bouquets we can make with the bloom days less than or equal to the middle value. If the number of bouquets is greater than or equal to m, we update the right boundary to mid. Otherwise, we update the left boundary to mid + 1. The search ends when the left boundary is equal to the right boundary. The final return value will be -1 if m is 0, otherwise, it will be left boundary value.\n    ", "javascript": "\n    ```javascript\nfunction minDays(bloomDay, m, k) {\n    let left = Math.min(...bloomDay), right = Math.max(...bloomDay);\n\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        let bouquets = 0, flowers = 0;\n        for (let day of bloomDay) {\n            if (day > mid) {\n                flowers = 0;\n            } else {\n                flowers++;\n                if (flowers === k) {\n                    bouquets++;\n                    flowers = 0;\n                }\n            }\n        }\n        if (bouquets >= m) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return m === 0 ? -1 : left;\n}\n```\n    \n    We will use binary search to approach this problem. We first find the minimum and maximum bloom days, which will be the left and right boundaries of the search range. In each iteration, we calculate the middle value, and calculate the number of bouquets we can make with the bloom days less than or equal to the middle value. If the number of bouquets is greater than or equal to m, we update the right boundary to mid. Otherwise, we update the left boundary to mid + 1. The search ends when the left boundary is equal to the right boundary. The final return value will be -1 if m is 0, otherwise, it will be left boundary value.\n    "}
{"id": 1606, "slug": "find-servers-that-handled-most-number-of-requests", "title": "Find Servers That Handled Most Number of Requests", "difficulty": "Hard", "content": "You have `k` servers numbered from `0` to `k-1` that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but **cannot handle more than one request at a time**. The requests are assigned to servers according to a specific algorithm:\n\n*   The `ith` (0-indexed) request arrives.\n*   If all servers are busy, the request is dropped (not handled at all).\n*   If the `(i % k)th` server is available, assign the request to that server.\n*   Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the `ith` server is busy, try to assign the request to the `(i+1)th` server, then the `(i+2)th` server, and so on.\n\nYou are given a **strictly increasing** array `arrival` of positive integers, where `arrival[i]` represents the arrival time of the `ith` request, and another array `load`, where `load[i]` represents the load of the `ith` request (the time it takes to complete). Your goal is to find the **busiest server(s)**. A server is considered **busiest** if it handled the most number of requests successfully among all the servers.\n\nReturn _a list containing the IDs (0-indexed) of the **busiest server(s)**_. You may return the IDs in any order.\n\n**Example 1:**\n\n**Input:** k = 3, arrival = \\[1,2,3,4,5\\], load = \\[5,2,3,3,3\\] \n**Output:** \\[1\\] \n**Explanation:** \nAll of the servers start out available.\nThe first 3 requests are handled by the first 3 servers in order.\nRequest 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.\nRequest 4 comes in. It cannot be handled since all servers are busy, so it is dropped.\nServers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.\n\n**Example 2:**\n\n**Input:** k = 3, arrival = \\[1,2,3,4\\], load = \\[1,2,1,2\\]\n**Output:** \\[0\\]\n**Explanation:** \nThe first 3 requests are handled by first 3 servers.\nRequest 3 comes in. It is handled by server 0 since the server is available.\nServer 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.\n\n**Example 3:**\n\n**Input:** k = 3, arrival = \\[1,2,3\\], load = \\[10,12,11\\]\n**Output:** \\[0,1,2\\]\n**Explanation:** Each server handles a single request, so they are all considered the busiest.\n\n**Constraints:**\n\n*   `1 <= k <= 105`\n*   `1 <= arrival.length, load.length <= 105`\n*   `arrival.length == load.length`\n*   `1 <= arrival[i], load[i] <= 109`\n*   `arrival` is **strictly increasing**.", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\n    int[] server_status = new int[k];\n    int[] server_request_count = new int[k];\n\n    for (int i = 0; i < arrival.length; i++) {\n        int index = i % k;\n        for (int j = 0; j < k; j++) {\n            if (server_status[index] <= arrival[i]) {\n                server_status[index] = arrival[i] + load[i];\n                server_request_count[index]++;\n                break;\n            }\n            index = (index + 1) % k;\n        }\n    }\n\n    int max_requests = 0;\n    for (int count : server_request_count) {\n        max_requests = Math.max(max_requests, count);\n    }\n    List<Integer> busiest_servers = new ArrayList<>();\n    for (int i = 0; i < k; i++) {\n        if (server_request_count[i] == max_requests) {\n            busiest_servers.add(i);\n        }\n    }\n    return busiest_servers;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Initialize two arrays: `server_status` and `server_request_count` with lengths `k`. The `server_status` array will store the end time for the committed requests, initially set to -1 (available). The `server_request_count` array will store the number of requests processed by each server, initially set to 0.\n\n2. For each request `i`, calculate the index `index = i % k` and check all servers `k` times (in circular manner) to find an available server.\n\n3. If a server with an end time less than or equal to the current arrival time is found, update the server's end time with the request's end time (`arrival[i] + load[i]`) and increment the server's request count.\n\n4. Once all requests have been processed, find the busiest server(s) by finding the maximum value in the `server_request_count` array and creating a list of indices (server IDs) that match the maximum value.\n\n5. Return the list of busiest server IDs.\n\n*Note: The algorithm's time complexity is O(n * k) where n is the number of requests and k is the number of servers.*\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\n    vector<int> server_status(k, -1); // -1 means available\n    vector<int> server_request_count(k, 0);\n\n    for (int i = 0; i < arrival.size(); i++) {\n        int index = i % k;\n        for (int j = 0; j < k; j++) {\n            if (server_status[index] <= arrival[i]) {\n                server_status[index] = arrival[i] + load[i];\n                server_request_count[index]++;\n                break;\n            }\n            index = (index + 1) % k;\n        }\n    }\n\n    int max_requests = *max_element(server_request_count.begin(), server_request_count.end());\n    vector<int> busiest_servers;\n    for (int i = 0; i < k; i++) {\n        if (server_request_count[i] == max_requests) {\n            busiest_servers.push_back(i);\n        }\n    }\n    return busiest_servers;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Initialize two arrays: `server_status` and `server_request_count` with lengths `k`. The `server_status` array will store the end time for the committed requests, initially set to -1 (available). The `server_request_count` array will store the number of requests processed by each server, initially set to 0.\n\n2. For each request `i`, calculate the index `index = i % k` and check all servers `k` times (in circular manner) to find an available server.\n\n3. If a server with an end time less than or equal to the current arrival time is found, update the server's end time with the request's end time (`arrival[i] + load[i]`) and increment the server's request count.\n\n4. Once all requests have been processed, find the busiest server(s) by finding the maximum value in the `server_request_count` array and creating a list of indices (server IDs) that match the maximum value.\n\n5. Return the list of busiest server IDs.\n\n*Note: The algorithm's time complexity is O(n * k) where n is the number of requests and k is the number of servers.*\n    ", "python": "\n    ```python\ndef busiestServers(k, arrival, load):\n    server_status = [-1] * k\n    server_request_count = [0] * k\n\n    for i in range(len(arrival)):\n        index = i % k\n        for _ in range(k):\n            if server_status[index] <= arrival[i]:\n                server_status[index] = arrival[i] + load[i]\n                server_request_count[index] += 1\n                break\n            index = (index + 1) % k\n\n    max_requests = max(server_request_count)\n    return [i for i in range(k) if server_request_count[i] == max_requests]\n```\n    \n    The algorithm works as follows:\n\n1. Initialize two arrays: `server_status` and `server_request_count` with lengths `k`. The `server_status` array will store the end time for the committed requests, initially set to -1 (available). The `server_request_count` array will store the number of requests processed by each server, initially set to 0.\n\n2. For each request `i`, calculate the index `index = i % k` and check all servers `k` times (in circular manner) to find an available server.\n\n3. If a server with an end time less than or equal to the current arrival time is found, update the server's end time with the request's end time (`arrival[i] + load[i]`) and increment the server's request count.\n\n4. Once all requests have been processed, find the busiest server(s) by finding the maximum value in the `server_request_count` array and creating a list of indices (server IDs) that match the maximum value.\n\n5. Return the list of busiest server IDs.\n\n*Note: The algorithm's time complexity is O(n * k) where n is the number of requests and k is the number of servers.*\n    ", "javascript": "\n    ```javascript\nfunction busiestServers(k, arrival, load) {\n    let server_status = new Array(k).fill(-1);\n    let server_request_count = new Array(k).fill(0);\n\n    for (let i = 0; i < arrival.length; i++) {\n        let index = i % k;\n        for (let j = 0; j < k; j++) {\n            if (server_status[index] <= arrival[i]) {\n                server_status[index] = arrival[i] + load[i];\n                server_request_count[index]++;\n                break;\n            }\n            index = (index + 1) % k;\n        }\n    }\n\n    let max_requests = Math.max(...server_request_count);\n    let busiest_servers = [];\n    for (let i = 0; i < k; i++) {\n        if (server_request_count[i] === max_requests) {\n            busiest_servers.push(i);\n        }\n    }\n    return busiest_servers;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Initialize two arrays: `server_status` and `server_request_count` with lengths `k`. The `server_status` array will store the end time for the committed requests, initially set to -1 (available). The `server_request_count` array will store the number of requests processed by each server, initially set to 0.\n\n2. For each request `i`, calculate the index `index = i % k` and check all servers `k` times (in circular manner) to find an available server.\n\n3. If a server with an end time less than or equal to the current arrival time is found, update the server's end time with the request's end time (`arrival[i] + load[i]`) and increment the server's request count.\n\n4. Once all requests have been processed, find the busiest server(s) by finding the maximum value in the `server_request_count` array and creating a list of indices (server IDs) that match the maximum value.\n\n5. Return the list of busiest server IDs.\n\n*Note: The algorithm's time complexity is O(n * k) where n is the number of requests and k is the number of servers.*\n    "}
{"id": 1642, "slug": "furthest-building-you-can-reach", "title": "Furthest Building You Can Reach", "difficulty": "Medium", "content": "You are given an integer array `heights` representing the heights of buildings, some `bricks`, and some `ladders`.\n\nYou start your journey from building `0` and move to the next building by possibly using bricks or ladders.\n\nWhile moving from building `i` to building `i+1` (**0-indexed**),\n\n*   If the current building's height is **greater than or equal** to the next building's height, you do **not** need a ladder or bricks.\n*   If the current building's height is **less than** the next building's height, you can either use **one ladder** or `(h[i+1] - h[i])` **bricks**.\n\n_Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally._\n\n**Example 1:**\n\n**Input:** heights = \\[4,2,7,6,9,14,12\\], bricks = 5, ladders = 1\n**Output:** 4\n**Explanation:** Starting at building 0, you can follow these steps:\n- Go to building 1 without using ladders nor bricks since 4 >= 2.\n- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.\n- Go to building 3 without using ladders nor bricks since 7 >= 6.\n- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.\nIt is impossible to go beyond building 4 because you do not have any more bricks or ladders.\n\n**Example 2:**\n\n**Input:** heights = \\[4,12,2,7,3,18,20,3,19\\], bricks = 10, ladders = 2\n**Output:** 7\n\n**Example 3:**\n\n**Input:** heights = \\[14,3,19,3\\], bricks = 17, ladders = 0\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= heights.length <= 105`\n*   `1 <= heights[i] <= 106`\n*   `0 <= bricks <= 109`\n*   `0 <= ladders <= heights.length`", "java": "\n    ```java\npublic int maxWaterBottles(int numBottles, int numExchange) {\n    int total = numBottles;\n    while (numBottles >= numExchange) {\n        int newBottles = numBottles / numExchange;\n        total += newBottles;\n        numBottles = newBottles + numBottles % numExchange;\n    }\n    return total;\n}\n```\n    \n    The algorithm initializes the total number of bottles to `numBottles` (the initial number of filled bottles), then enters into a loop that continues until the number of bottles is less than the `numExchange` value. Inside the loop, we find how many new full bottles we can get by exchanging the empty bottles (`newBottles = numBottles / numExchange`), add the obtained `newBottles` to the total, and update the `numBottles` to reflect the number of new filled bottles plus the remaining empty bottles that we couldn't exchange. We repeat this process until we no longer have enough bottles to exchange. We return the `total` number of water bottles that were drank.\n    ", "c++": "\n    ```cpp\nint maxWaterBottles(int numBottles, int numExchange) {\n    int total = numBottles;\n    while (numBottles >= numExchange) {\n        int newBottles = numBottles / numExchange;\n        total += newBottles;\n        numBottles = newBottles + numBottles % numExchange;\n    }\n    return total;\n}\n```\n    \n    The algorithm initializes the total number of bottles to `numBottles` (the initial number of filled bottles), then enters into a loop that continues until the number of bottles is less than the `numExchange` value. Inside the loop, we find how many new full bottles we can get by exchanging the empty bottles (`newBottles = numBottles / numExchange`), add the obtained `newBottles` to the total, and update the `numBottles` to reflect the number of new filled bottles plus the remaining empty bottles that we couldn't exchange. We repeat this process until we no longer have enough bottles to exchange. We return the `total` number of water bottles that were drank.\n    ", "python": "\n    ```python\ndef maxWaterBottles(numBottles: int, numExchange: int) -> int:\n    total = numBottles\n    while numBottles >= numExchange:\n        newBottles = numBottles // numExchange\n        total += newBottles\n        numBottles = newBottles + numBottles % numExchange\n    return total\n```\n    \n    The algorithm initializes the total number of bottles to `numBottles` (the initial number of filled bottles), then enters into a loop that continues until the number of bottles is less than the `numExchange` value. Inside the loop, we find how many new full bottles we can get by exchanging the empty bottles (`newBottles = numBottles / numExchange`), add the obtained `newBottles` to the total, and update the `numBottles` to reflect the number of new filled bottles plus the remaining empty bottles that we couldn't exchange. We repeat this process until we no longer have enough bottles to exchange. We return the `total` number of water bottles that were drank.\n    ", "javascript": "\n    ```javascript\nfunction maxWaterBottles(numBottles, numExchange) {\n    let total = numBottles;\n    while (numBottles >= numExchange) {\n        const newBottles = Math.floor(numBottles / numExchange);\n        total += newBottles;\n        numBottles = newBottles + numBottles % numExchange;\n    }\n    return total;\n}\n```\n\n    \n    The algorithm initializes the total number of bottles to `numBottles` (the initial number of filled bottles), then enters into a loop that continues until the number of bottles is less than the `numExchange` value. Inside the loop, we find how many new full bottles we can get by exchanging the empty bottles (`newBottles = numBottles / numExchange`), add the obtained `newBottles` to the total, and update the `numBottles` to reflect the number of new filled bottles plus the remaining empty bottles that we couldn't exchange. We repeat this process until we no longer have enough bottles to exchange. We return the `total` number of water bottles that were drank.\n    "}
{"id": 1647, "slug": "minimum-deletions-to-make-character-frequencies-unique", "title": "Minimum Deletions to Make Character Frequencies Unique", "difficulty": "Medium", "content": "A string `s` is called **good** if there are no two different characters in `s` that have the same **frequency**.\n\nGiven a string `s`, return _the **minimum** number of characters you need to delete to make_ `s` _**good**._\n\nThe **frequency** of a character in a string is the number of times it appears in the string. For example, in the string `\"aab \"`, the **frequency** of `'a'` is `2`, while the **frequency** of `'b'` is `1`.\n\n**Example 1:**\n\n**Input:** s =  \"aab \"\n**Output:** 0\n**Explanation:** `s` is already good.\n\n**Example 2:**\n\n**Input:** s =  \"aaabbbcc \"\n**Output:** 2\n**Explanation:** You can delete two 'b's resulting in the good string  \"aaabcc \".\nAnother way it to delete one 'b' and one 'c' resulting in the good string  \"aaabbc \".\n\n**Example 3:**\n\n**Input:** s =  \"ceabaacb \"\n**Output:** 2\n**Explanation:** You can delete both 'c's resulting in the good string  \"eabaab \".\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` contains only lowercase English letters.", "java": "\n    ```java\npublic boolean canConvert(String s, String t, int k) {\n    int diff = 0;\n    for (int i = 0; i < s.length(); i++) {\n        int curr_diff = (t.charAt(i) - s.charAt(i) + 26) % 26;\n        if (curr_diff > 0) {\n            diff += curr_diff;\n            k -= curr_diff;\n        }\n    }\n    return k >= 0 && k >= diff - s.length() && k % 26 == 0;\n}\n```\n    \n    For each character in string `s`, we calculate the difference with the corresponding character in string `t`. We then add that difference to the total `diff` and subtract it from `k`. If the current difference is greater than 0, it means that character has been shifted.\n\nAfter every character has been checked, we need to check the following conditions: \n1. `k` should be greater than or equals to 0, which means we didn't exceed the total number of moves allowed.\n2. `k` should be greater than or equals to `diff` - `s.length()` to ensure that all possible shifts have been performed.\n3. `k % 26` should be equal to 0, as any multiple of 26 would bring the character back to the original position, making the shifts redundant.\n\nIf all the conditions are satisfied, it's possible to convert `s` into `t` in no more than `k` moves, otherwise it's not possible.\n    ", "c++": "\n    ```cpp\n#include <cmath>\n\nbool canConvert(std::string s, std::string t, int k) {\n    int diff = 0;\n    for (int i = 0; i < s.length(); i++) {\n        int curr_diff = (t[i] - s[i] + 26) % 26;\n        if (curr_diff > 0) {\n            diff += curr_diff;\n            k -= curr_diff;\n        }\n    }\n    return k >= 0 && k >= diff - s.length() && k % 26 == 0;\n}\n```\n    \n    For each character in string `s`, we calculate the difference with the corresponding character in string `t`. We then add that difference to the total `diff` and subtract it from `k`. If the current difference is greater than 0, it means that character has been shifted.\n\nAfter every character has been checked, we need to check the following conditions: \n1. `k` should be greater than or equals to 0, which means we didn't exceed the total number of moves allowed.\n2. `k` should be greater than or equals to `diff` - `s.length()` to ensure that all possible shifts have been performed.\n3. `k % 26` should be equal to 0, as any multiple of 26 would bring the character back to the original position, making the shifts redundant.\n\nIf all the conditions are satisfied, it's possible to convert `s` into `t` in no more than `k` moves, otherwise it's not possible.\n    ", "python": "\n    ```python\ndef can_convert(s, t, k):\n    diff = 0\n    for i in range(len(s)):\n        curr_diff = (ord(t[i]) - ord(s[i]) + 26) % 26\n        if curr_diff > 0:\n            diff += curr_diff\n            k -= curr_diff\n    return k >= 0 and k >= diff - len(s) and k % 26 == 0\n```\n    \n    For each character in string `s`, we calculate the difference with the corresponding character in string `t`. We then add that difference to the total `diff` and subtract it from `k`. If the current difference is greater than 0, it means that character has been shifted.\n\nAfter every character has been checked, we need to check the following conditions: \n1. `k` should be greater than or equals to 0, which means we didn't exceed the total number of moves allowed.\n2. `k` should be greater than or equals to `diff` - `s.length()` to ensure that all possible shifts have been performed.\n3. `k % 26` should be equal to 0, as any multiple of 26 would bring the character back to the original position, making the shifts redundant.\n\nIf all the conditions are satisfied, it's possible to convert `s` into `t` in no more than `k` moves, otherwise it's not possible.\n    ", "javascript": "\n    ```javascript\nfunction canConvert(s, t, k) {\n    let diff = 0;\n    for (let i = 0; i < s.length; i++) {\n        let curr_diff = (t.charCodeAt(i) - s.charCodeAt(i) + 26) % 26;\n        if (curr_diff > 0) {\n            diff += curr_diff;\n            k -= curr_diff;\n        }\n    }\n    return k >= 0 && k >= diff - s.length && k % 26 === 0;\n}\n```\n    \n    For each character in string `s`, we calculate the difference with the corresponding character in string `t`. We then add that difference to the total `diff` and subtract it from `k`. If the current difference is greater than 0, it means that character has been shifted.\n\nAfter every character has been checked, we need to check the following conditions: \n1. `k` should be greater than or equals to 0, which means we didn't exceed the total number of moves allowed.\n2. `k` should be greater than or equals to `diff` - `s.length()` to ensure that all possible shifts have been performed.\n3. `k % 26` should be equal to 0, as any multiple of 26 would bring the character back to the original position, making the shifts redundant.\n\nIf all the conditions are satisfied, it's possible to convert `s` into `t` in no more than `k` moves, otherwise it's not possible.\n    "}
{"id": 1648, "slug": "sell-diminishing-valued-colored-balls", "title": "Sell Diminishing-Valued Colored Balls", "difficulty": "Medium", "content": "You have an `inventory` of different colored balls, and there is a customer that wants `orders` balls of **any** color.\n\nThe customer weirdly values the colored balls. Each colored ball's value is the number of balls **of that color** you currently have in your `inventory`. For example, if you own `6` yellow balls, the customer would pay `6` for the first yellow ball. After the transaction, there are only `5` yellow balls left, so the next yellow ball is then valued at `5` (i.e., the value of the balls decreases as you sell more to the customer).\n\nYou are given an integer array, `inventory`, where `inventory[i]` represents the number of balls of the `ith` color that you initially own. You are also given an integer `orders`, which represents the total number of balls that the customer wants. You can sell the balls **in any order**.\n\nReturn _the **maximum** total value that you can attain after selling_ `orders` _colored balls_. As the answer may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** inventory = \\[2,5\\], orders = 4\n**Output:** 14\n**Explanation:** Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).\nThe maximum total value is 2 + 5 + 4 + 3 = 14.\n\n**Example 2:**\n\n**Input:** inventory = \\[3,5\\], orders = 6\n**Output:** 19\n**Explanation:** Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).\nThe maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.\n\n**Constraints:**\n\n*   `1 <= inventory.length <= 105`\n*   `1 <= inventory[i] <= 109`\n*   `1 <= orders <= min(sum(inventory[i]), 109)`", "java": "\n    ```java\npublic int minInsertions(String s) {\n    int ans = 0, depth = 0;\n    for (int i = 0; i < s.length(); ++i) {\n        if (s.charAt(i) == '(') {\n            depth += 2;\n        } else {\n            if (s.charAt(i - 1) == '(') {\n                --depth;\n            } else {\n                depth -= 2;\n            }\n            if (depth < 0) {\n                ans -= depth;\n                depth = 0;\n            }\n        }\n    }\n    return ans + depth;\n}\n```\n    \n    For this problem, the algorithm iterates through the string, keeping track of the required depth, which is initialized to 0. We use depth as an indicator of how balanced the parentheses are at each step.\n\nWhen encountering an opening parenthesis '(', the depth is increased by 2. This is because, in order to balance a single '(', we need 2 closing parentheses '))'.\n\nWhen encountering a closing parenthesis ')', if the previous character is an opening parenthesis '(', decrease depth by 1, because this represents a partially balanced pair. However, if the previous character is another closing parenthesis ')', we decrease depth by 2, as we have a closed pair '))'.\n\nIf at any point the depth becomes negative, we adjust the answer and depth back to 0. At the end, we return the resultant answer updated with the remaining depth.\n\nOverall, the algorithm has a time complexity of O(n), where n is the length of the input string.\n    ", "c++": "\n    ```cpp\nint minInsertions(string s) {\n    int ans = 0, depth = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == '(') {\n            depth += 2;\n        } else {\n            if (s[i-1] == '(') {\n                --depth;\n            } else {\n                depth -= 2;\n            }\n            if (depth < 0) {\n                ans -= depth;\n                depth = 0;\n            }\n        }\n    }\n    return ans + depth;\n}\n```\n    \n    For this problem, the algorithm iterates through the string, keeping track of the required depth, which is initialized to 0. We use depth as an indicator of how balanced the parentheses are at each step.\n\nWhen encountering an opening parenthesis '(', the depth is increased by 2. This is because, in order to balance a single '(', we need 2 closing parentheses '))'.\n\nWhen encountering a closing parenthesis ')', if the previous character is an opening parenthesis '(', decrease depth by 1, because this represents a partially balanced pair. However, if the previous character is another closing parenthesis ')', we decrease depth by 2, as we have a closed pair '))'.\n\nIf at any point the depth becomes negative, we adjust the answer and depth back to 0. At the end, we return the resultant answer updated with the remaining depth.\n\nOverall, the algorithm has a time complexity of O(n), where n is the length of the input string.\n    ", "python": "\n    ```python\ndef minInsertions(s: str) -> int:\n    ans, depth = 0, 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            depth += 2\n        else:\n            if s[i - 1] == '(':\n                depth -= 1\n            else:\n                depth -= 2\n            if depth < 0:\n                ans -= depth\n                depth = 0\n    return ans + depth\n```\n    \n    For this problem, the algorithm iterates through the string, keeping track of the required depth, which is initialized to 0. We use depth as an indicator of how balanced the parentheses are at each step.\n\nWhen encountering an opening parenthesis '(', the depth is increased by 2. This is because, in order to balance a single '(', we need 2 closing parentheses '))'.\n\nWhen encountering a closing parenthesis ')', if the previous character is an opening parenthesis '(', decrease depth by 1, because this represents a partially balanced pair. However, if the previous character is another closing parenthesis ')', we decrease depth by 2, as we have a closed pair '))'.\n\nIf at any point the depth becomes negative, we adjust the answer and depth back to 0. At the end, we return the resultant answer updated with the remaining depth.\n\nOverall, the algorithm has a time complexity of O(n), where n is the length of the input string.\n    ", "javascript": "\n    ```javascript\nfunction minInsertions(s) {\n    let ans = 0, depth = 0;\n    for (let i = 0; i < s.length; ++i) {\n        if (s[i] === '(') {\n            depth += 2;\n        } else {\n            if (s[i - 1] === '(') {\n                --depth;\n            } else {\n                depth -= 2;\n            }\n            if (depth < 0) {\n                ans -= depth;\n                depth = 0;\n            }\n        }\n    }\n    return ans + depth;\n}\n```\n    \n    For this problem, the algorithm iterates through the string, keeping track of the required depth, which is initialized to 0. We use depth as an indicator of how balanced the parentheses are at each step.\n\nWhen encountering an opening parenthesis '(', the depth is increased by 2. This is because, in order to balance a single '(', we need 2 closing parentheses '))'.\n\nWhen encountering a closing parenthesis ')', if the previous character is an opening parenthesis '(', decrease depth by 1, because this represents a partially balanced pair. However, if the previous character is another closing parenthesis ')', we decrease depth by 2, as we have a closed pair '))'.\n\nIf at any point the depth becomes negative, we adjust the answer and depth back to 0. At the end, we return the resultant answer updated with the remaining depth.\n\nOverall, the algorithm has a time complexity of O(n), where n is the length of the input string.\n    "}
{"id": 1663, "slug": "smallest-string-with-a-given-numeric-value", "title": "Smallest String With A Given Numeric Value", "difficulty": "Medium", "content": "The **numeric value** of a **lowercase character** is defined as its position `(1-indexed)` in the alphabet, so the numeric value of `a` is `1`, the numeric value of `b` is `2`, the numeric value of `c` is `3`, and so on.\n\nThe **numeric value** of a **string** consisting of lowercase characters is defined as the sum of its characters' numeric values. For example, the numeric value of the string `\"abe \"` is equal to `1 + 2 + 5 = 8`.\n\nYou are given two integers `n` and `k`. Return _the **lexicographically smallest string** with **length** equal to `n` and **numeric value** equal to `k`._\n\nNote that a string `x` is lexicographically smaller than string `y` if `x` comes before `y` in dictionary order, that is, either `x` is a prefix of `y`, or if `i` is the first position such that `x[i] != y[i]`, then `x[i]` comes before `y[i]` in alphabetic order.\n\n**Example 1:**\n\n**Input:** n = 3, k = 27\n**Output:**  \"aay \"\n**Explanation:** The numeric value of the string is 1 + 1 + 25 = 27, and it is the smallest string with such a value and length equal to 3.\n\n**Example 2:**\n\n**Input:** n = 5, k = 73\n**Output:**  \"aaszz \"\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `n <= k <= 26 * n`", "java": "\n    ```java\npublic boolean containsCycle(char[][] grid) {\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (dfs(grid, i, j, i, j, 0)) return true;\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] grid, int x, int y, int startX, int startY, int depth) {\n    if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != grid[startX][startY])\n        return false;\n    \n    grid[x][y] = '*';\n    \n    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for (int[] direction : directions) {\n        int newX = x + direction[0];\n        int newY = y + direction[1];\n\n        if (newX == startX && newY == startY && depth >= 4) return true;\n        \n        if (dfs(grid, newX, newY, startX, startY, depth + 1)) return true;\n    }\n    \n    grid[x][y] = grid[startX][startY];\n    \n    return false;\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) approach to find cycles in the given 2D grid. For each cell in the grid, we perform a DFS search on its adjacent cells with the same value, making sure not to revisit the cell we just came from. Since we are looking for cycles of length 4 or more, we keep track of the depth of the search. If we find a cycle of 4 or more cells, we return true. If no cycle is found, return false.\n\nThe main function `containsCycle` loops through every cell of the grid, and for each cell, it calls the DFS function. If the DFS function returns true at any point, we immediately return true from the main function, meaning a cycle has been found. Otherwise, we return false, indicating that there's no cycle in the given grid.\n    ", "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool dfs(vector<vector<char>>& grid, int x, int y, int startX, int startY, int depth) {\n    if (x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] != grid[startX][startY])\n        return false;\n\n    grid[x][y] = '*';\n\n    static vector<vector<int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for (auto& direction : directions) {\n        int newX = x + direction[0];\n        int newY = y + direction[1];\n\n        if (newX == startX && newY == startY && depth >= 4) return true;\n\n        if (dfs(grid, newX, newY, startX, startY, depth + 1)) return true;\n    }\n\n    grid[x][y] = grid[startX][startY];\n\n    return false;\n}\n\nbool containsCycle(vector<vector<char>>& grid) {\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (dfs(grid, i, j, i, j, 0)) return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) approach to find cycles in the given 2D grid. For each cell in the grid, we perform a DFS search on its adjacent cells with the same value, making sure not to revisit the cell we just came from. Since we are looking for cycles of length 4 or more, we keep track of the depth of the search. If we find a cycle of 4 or more cells, we return true. If no cycle is found, return false.\n\nThe main function `containsCycle` loops through every cell of the grid, and for each cell, it calls the DFS function. If the DFS function returns true at any point, we immediately return true from the main function, meaning a cycle has been found. Otherwise, we return false, indicating that there's no cycle in the given grid.\n    ", "python": "\n    ```python\ndef contains_cycle(grid):\n    def dfs(x, y, start_x, start_y, depth):\n        if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != grid[start_x][start_y]:\n            return False\n        \n        grid[x][y] = '*'\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            new_x, new_y = x + dx, y + dy\n\n            if new_x == start_x and new_y == start_y and depth >= 4:\n                return True\n\n            if dfs(new_x, new_y, start_x, start_y, depth + 1):\n                return True\n        \n        grid[x][y] = grid[start_x][start_y]\n\n        return False\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, i, j, 0):\n                return True\n\n    return False\n```\n    \n    The algorithm uses a depth-first search (DFS) approach to find cycles in the given 2D grid. For each cell in the grid, we perform a DFS search on its adjacent cells with the same value, making sure not to revisit the cell we just came from. Since we are looking for cycles of length 4 or more, we keep track of the depth of the search. If we find a cycle of 4 or more cells, we return true. If no cycle is found, return false.\n\nThe main function `containsCycle` loops through every cell of the grid, and for each cell, it calls the DFS function. If the DFS function returns true at any point, we immediately return true from the main function, meaning a cycle has been found. Otherwise, we return false, indicating that there's no cycle in the given grid.\n    ", "javascript": "\n    ```javascript\nfunction containsCycle(grid) {\n    function dfs(x, y, startX, startY, depth) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] !== grid[startX][startY])\n            return false;\n\n        grid[x][y] = '*';\n\n        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n        for (const [dx, dy] of directions) {\n            const newX = x + dx;\n            const newY = y + dy;\n\n            if (newX === startX && newY === startY && depth >= 4) return true;\n\n            if (dfs(newX, newY, startX, startY, depth + 1)) return true;\n        }\n      \n        grid[x][y] = grid[startX][startY];\n\n        return false;\n    }\n\n    for (let i = 0; i < grid.length; ++i) {\n        for (let j = 0; j < grid[0].length; ++j) {\n            if (dfs(i, j, i, j, 0)) return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) approach to find cycles in the given 2D grid. For each cell in the grid, we perform a DFS search on its adjacent cells with the same value, making sure not to revisit the cell we just came from. Since we are looking for cycles of length 4 or more, we keep track of the depth of the search. If we find a cycle of 4 or more cells, we return true. If no cycle is found, return false.\n\nThe main function `containsCycle` loops through every cell of the grid, and for each cell, it calls the DFS function. If the DFS function returns true at any point, we immediately return true from the main function, meaning a cycle has been found. Otherwise, we return false, indicating that there's no cycle in the given grid.\n    "}
{"id": 1665, "slug": "minimum-initial-energy-to-finish-tasks", "title": "Minimum Initial Energy to Finish Tasks", "difficulty": "Hard", "content": "You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`:\n\n*   `actuali` is the actual amount of energy you **spend to finish** the `ith` task.\n*   `minimumi` is the minimum amount of energy you **require to begin** the `ith` task.\n\nFor example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it.\n\nYou can finish the tasks in **any order** you like.\n\nReturn _the **minimum** initial amount of energy you will need_ _to finish all the tasks_.\n\n**Example 1:**\n\n**Input:** tasks = \\[\\[1,2\\],\\[2,4\\],\\[4,8\\]\\]\n**Output:** 8\n**Explanation:**\nStarting with 8 energy, we finish the tasks in the following order:\n    - 3rd task. Now energy = 8 - 4 = 4.\n    - 2nd task. Now energy = 4 - 2 = 2.\n    - 1st task. Now energy = 2 - 1 = 1.\nNotice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.\n\n**Example 2:**\n\n**Input:** tasks = \\[\\[1,3\\],\\[2,4\\],\\[10,11\\],\\[10,12\\],\\[8,9\\]\\]\n**Output:** 32\n**Explanation:**\nStarting with 32 energy, we finish the tasks in the following order:\n    - 1st task. Now energy = 32 - 1 = 31.\n    - 2nd task. Now energy = 31 - 2 = 29.\n    - 3rd task. Now energy = 29 - 10 = 19.\n    - 4th task. Now energy = 19 - 10 = 9.\n    - 5th task. Now energy = 9 - 8 = 1.\n\n**Example 3:**\n\n**Input:** tasks = \\[\\[1,7\\],\\[2,8\\],\\[3,9\\],\\[4,10\\],\\[5,11\\],\\[6,12\\]\\]\n**Output:** 27\n**Explanation:**\nStarting with 27 energy, we finish the tasks in the following order:\n    - 5th task. Now energy = 27 - 5 = 22.\n    - 2nd task. Now energy = 22 - 2 = 20.\n    - 3rd task. Now energy = 20 - 3 = 17.\n    - 1st task. Now energy = 17 - 1 = 16.\n    - 4th task. Now energy = 16 - 4 = 12.\n    - 6th task. Now energy = 12 - 6 = 6.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= actual\u200bi <= minimumi <= 104`", "java": "\n    ```java\npublic int minimumEffort(int[][] tasks) {\n    Arrays.sort(tasks, (a, b) -> (b[1] - b[0]) - (a[1] - a[0]));\n    int ans = 0, sum = 0;\n    for (int[] task : tasks) {\n        ans = Math.max(ans, sum + task[1]);\n        sum += task[0];\n    }\n    return ans;\n}\n```\n    \n    The main idea of this algorithm is to sort the tasks in descending order based on the difference between their `minimum` and `actual` energy requirements. By sorting in this order, we can ensure that we first finish the tasks which require more minimum energy, and the remaining tasks require less minimum energy to start. \n\nAfter sorting the tasks in the desired order, we iterate through the tasks to find the minimum initial energy required. \n\n1. Set the initial values of `ans` and `sum_energy` to 0.\n2. For each task in the sorted tasks list, calculate the maximum value between the current `ans` and the sum of `sum_energy` and the `minimum` energy required for the current task. Update the `ans` variable with this maximum value.\n3. Add the `actual` energy spent on the current task to the `sum_energy`.\n4. After iterating through all the tasks, the `ans` variable will store the minimum initial amount of energy required to finish all the tasks.\n    ", "c++": "\n    ```cpp\nint minimumEffort(vector<vector<int>>& tasks) {\n    sort(tasks.begin(), tasks.end(), [](vector<int>& a, vector<int>& b) {\n        return a[1] - a[0] > b[1] - b[0];\n    });\n    int ans = 0, sum = 0;\n    for (auto& task : tasks) {\n        ans = max(ans, sum + task[1]);\n        sum += task[0];\n    }\n    return ans;\n}\n```\n    \n    The main idea of this algorithm is to sort the tasks in descending order based on the difference between their `minimum` and `actual` energy requirements. By sorting in this order, we can ensure that we first finish the tasks which require more minimum energy, and the remaining tasks require less minimum energy to start. \n\nAfter sorting the tasks in the desired order, we iterate through the tasks to find the minimum initial energy required. \n\n1. Set the initial values of `ans` and `sum_energy` to 0.\n2. For each task in the sorted tasks list, calculate the maximum value between the current `ans` and the sum of `sum_energy` and the `minimum` energy required for the current task. Update the `ans` variable with this maximum value.\n3. Add the `actual` energy spent on the current task to the `sum_energy`.\n4. After iterating through all the tasks, the `ans` variable will store the minimum initial amount of energy required to finish all the tasks.\n    ", "python": "\n    ```python\ndef minimumEffort(tasks):\n    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)\n    ans, sum_energy = 0, 0\n    for task in tasks:\n        ans = max(ans, sum_energy + task[1])\n        sum_energy += task[0]\n    return ans\n```\n    \n    The main idea of this algorithm is to sort the tasks in descending order based on the difference between their `minimum` and `actual` energy requirements. By sorting in this order, we can ensure that we first finish the tasks which require more minimum energy, and the remaining tasks require less minimum energy to start. \n\nAfter sorting the tasks in the desired order, we iterate through the tasks to find the minimum initial energy required. \n\n1. Set the initial values of `ans` and `sum_energy` to 0.\n2. For each task in the sorted tasks list, calculate the maximum value between the current `ans` and the sum of `sum_energy` and the `minimum` energy required for the current task. Update the `ans` variable with this maximum value.\n3. Add the `actual` energy spent on the current task to the `sum_energy`.\n4. After iterating through all the tasks, the `ans` variable will store the minimum initial amount of energy required to finish all the tasks.\n    ", "javascript": "\n    ```javascript\nfunction minimumEffort(tasks) {\n    tasks.sort((a, b) => (b[1] - b[0]) - (a[1] - a[0]));\n    let ans = 0, sum = 0;\n    for (const task of tasks) {\n        ans = Math.max(ans, sum + task[1]);\n        sum += task[0];\n    }\n    return ans;\n}\n```\n    \n    The main idea of this algorithm is to sort the tasks in descending order based on the difference between their `minimum` and `actual` energy requirements. By sorting in this order, we can ensure that we first finish the tasks which require more minimum energy, and the remaining tasks require less minimum energy to start. \n\nAfter sorting the tasks in the desired order, we iterate through the tasks to find the minimum initial energy required. \n\n1. Set the initial values of `ans` and `sum_energy` to 0.\n2. For each task in the sorted tasks list, calculate the maximum value between the current `ans` and the sum of `sum_energy` and the `minimum` energy required for the current task. Update the `ans` variable with this maximum value.\n3. Add the `actual` energy spent on the current task to the `sum_energy`.\n4. After iterating through all the tasks, the `ans` variable will store the minimum initial amount of energy required to finish all the tasks.\n    "}
{"id": 1671, "slug": "minimum-number-of-removals-to-make-mountain-array", "title": "Minimum Number of Removals to Make Mountain Array", "difficulty": "Hard", "content": "You may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `nums`\u200b\u200b\u200b, return _the **minimum** number of elements to remove to make_ `nums_\u200b\u200b\u200b_` _a **mountain array**._\n\n**Example 1:**\n\n**Input:** nums = \\[1,3,1\\]\n**Output:** 0\n**Explanation:** The array itself is a mountain array so we do not need to remove any elements.\n\n**Example 2:**\n\n**Input:** nums = \\[2,1,1,5,6,2,3,1\\]\n**Output:** 3\n**Explanation:** One solution is to remove the elements at indices 0, 1, and 5, making the array nums = \\[1,5,6,3,1\\].\n\n**Constraints:**\n\n*   `3 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 109`\n*   It is guaranteed that you can make a mountain array out of `nums`.", "java": "\n    ```java\npublic int minimumMountainRemovals(int[] nums) {\n    int n = nums.length;\n    int[] left = new int[n], right = new int[n];\n    for (int i = 1; i < n; ++i) {\n        left[i] = left[i - 1] + (nums[i] > nums[i - 1] ? 1 : 0);\n        right[n - i - 1] = right[n - i] + (nums[n - i - 1] > nums[n - i] ? 1 : 0);\n    }\n    int ans = n - 3;\n    for (int i = 1; i < n - 1; ++i) {\n        ans = Math.min(ans, n - 1 - left[i] - right[i]);\n    }\n    return ans;\n}\n```\n    \n    The algorithm calculates the minimum number of elements to remove to make the input array a mountain array. First, it initializes two arrays `left` and `right`, with the same length as the input array. These arrays will store the increasing and decreasing sequence, respectively, ending at position `i`.\n\nFor each index in the range of the input array, the algorithm increases the length of `left` and `right` sequences if the current element is greater than the previous one or if the current element in the reversed array is greater the next one, respectively. Then, the minimum number of elements to remove is calculated by comparing the sum of both sequences for each index, and keeping the minimum value. Subtracting this value from the total length minus one is the final answer.\n    ", "c++": "\n    ```cpp\nint minimumMountainRemovals(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> left(n), right(n);\n    for (int i = 1; i < n; ++i) {\n        left[i] = left[i - 1] + (nums[i] > nums[i - 1]);\n        right[n - i - 1] = right[n - i] + (nums[n - i - 1] > nums[n - i]);\n    }\n    int ans = n - 3;\n    for (int i = 1; i < n - 1; ++i) {\n        ans = min(ans, n - 1 - left[i] - right[i]);\n    }\n    return ans;\n}\n```\n    \n    The algorithm calculates the minimum number of elements to remove to make the input array a mountain array. First, it initializes two arrays `left` and `right`, with the same length as the input array. These arrays will store the increasing and decreasing sequence, respectively, ending at position `i`.\n\nFor each index in the range of the input array, the algorithm increases the length of `left` and `right` sequences if the current element is greater than the previous one or if the current element in the reversed array is greater the next one, respectively. Then, the minimum number of elements to remove is calculated by comparing the sum of both sequences for each index, and keeping the minimum value. Subtracting this value from the total length minus one is the final answer.\n    ", "python": "\n    ```python\ndef minimumMountainRemovals(nums):\n    n = len(nums)\n    left, right = [0] * n, [0] * n\n    for i in range(1, n):\n        left[i] = left[i - 1] + int(nums[i] > nums[i - 1])\n        right[n - i - 1] = right[n - i] + int(nums[n - i - 1] > nums[n - i])\n    ans = n - 3\n    for i in range(1, n - 1):\n        ans = min(ans, n - 1 - left[i] - right[i])\n    return ans\n```\n    \n    The algorithm calculates the minimum number of elements to remove to make the input array a mountain array. First, it initializes two arrays `left` and `right`, with the same length as the input array. These arrays will store the increasing and decreasing sequence, respectively, ending at position `i`.\n\nFor each index in the range of the input array, the algorithm increases the length of `left` and `right` sequences if the current element is greater than the previous one or if the current element in the reversed array is greater the next one, respectively. Then, the minimum number of elements to remove is calculated by comparing the sum of both sequences for each index, and keeping the minimum value. Subtracting this value from the total length minus one is the final answer.\n    ", "javascript": "\n    ```javascript\nfunction minimumMountainRemovals(nums) {\n    const n = nums.length;\n    const left = new Array(n).fill(0);\n    const right = new Array(n).fill(0);\n    for (let i = 1; i < n; ++i) {\n        left[i] = left[i - 1] + (nums[i] > nums[i - 1] ? 1 : 0);\n        right[n - i - 1] = right[n - i] + (nums[n - i - 1] > nums[n - i] ? 1 : 0);\n    }\n    let ans = n - 3;\n    for (let i = 1; i < n - 1; ++i) {\n        ans = Math.min(ans, n - 1 - left[i] - right[i]);\n    }\n    return ans;\n}\n```\n    \n    The algorithm calculates the minimum number of elements to remove to make the input array a mountain array. First, it initializes two arrays `left` and `right`, with the same length as the input array. These arrays will store the increasing and decreasing sequence, respectively, ending at position `i`.\n\nFor each index in the range of the input array, the algorithm increases the length of `left` and `right` sequences if the current element is greater than the previous one or if the current element in the reversed array is greater the next one, respectively. Then, the minimum number of elements to remove is calculated by comparing the sum of both sequences for each index, and keeping the minimum value. Subtracting this value from the total length minus one is the final answer.\n    "}
{"id": 1673, "slug": "find-the-most-competitive-subsequence", "title": "Find the Most Competitive Subsequence", "difficulty": "Medium", "content": "Given an integer array `nums` and a positive integer `k`, return _the most **competitive** subsequence of_ `nums` _of size_ `k`.\n\nAn array's subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.\n\nWe define that a subsequence `a` is more **competitive** than a subsequence `b` (of the same length) if in the first position where `a` and `b` differ, subsequence `a` has a number **less** than the corresponding number in `b`. For example, `[1,3,4]` is more competitive than `[1,3,5]` because the first position they differ is at the final number, and `4` is less than `5`.\n\n**Example 1:**\n\n**Input:** nums = \\[3,5,2,6\\], k = 2\n**Output:** \\[2,6\\]\n**Explanation:** Among the set of every possible subsequence: {\\[3,5\\], \\[3,2\\], \\[3,6\\], \\[5,2\\], \\[5,6\\], \\[2,6\\]}, \\[2,6\\] is the most competitive.\n\n**Example 2:**\n\n**Input:** nums = \\[2,4,3,3,5,4,9,6\\], k = 4\n**Output:** \\[2,3,3,4\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 109`\n*   `1 <= k <= nums.length`", "java": "\n    ```java\nimport java.util.Stack;\n\npublic int[] mostCompetitive(int[] nums, int k) {\n    Stack<Integer> stack = new Stack<>();\n    int n = nums.length;\n    for (int i = 0; i < n; i++) {\n        while (!stack.empty() && stack.peek() > nums[i] && stack.size() + n - i > k) {\n            stack.pop();\n        }\n        if (stack.size() < k) {\n            stack.push(nums[i]);\n        }\n    }\n    int[] result = new int[k];\n    for (int i = k - 1; i >= 0; i--) {\n        result[i] = stack.pop();\n    }\n    return result;\n}\n```\n\n    \n    The algorithm works by keeping a monotonically increasing stack. We iterate through the `nums` array and try to make our stack size equal to `k`. At each step, we check if it is possible to remove the current top element of the stack and still have `k` elements after processing all of the array elements. If it is possible and the current top element of the stack is greater than the current element in `nums`, we remove it. This ensures that the stack remains monotonically increasing and holds the most competitive subsequence of size `k`.\n\nAfter processing all the elements in `nums`, the stack will have the most competitive subsequence of size `k`. We convert the stack into a result array/vector/list and return it.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\n\nstd::vector<int> mostCompetitive(std::vector<int>& nums, int k) {\n    std::stack<int> stk;\n    int n = nums.size();\n    for (int i = 0; i < n; i++) {\n        while (!stk.empty() && stk.top() > nums[i] && stk.size() + n - i > k) {\n            stk.pop();\n        }\n        if (stk.size() < k) {\n            stk.push(nums[i]);\n        }\n    }\n    std::vector<int> result(k);\n    for (int i = k - 1; i >= 0; i--) {\n        result[i] = stk.top();\n        stk.pop();\n    }\n    return result;\n}\n```\n\n    \n    The algorithm works by keeping a monotonically increasing stack. We iterate through the `nums` array and try to make our stack size equal to `k`. At each step, we check if it is possible to remove the current top element of the stack and still have `k` elements after processing all of the array elements. If it is possible and the current top element of the stack is greater than the current element in `nums`, we remove it. This ensures that the stack remains monotonically increasing and holds the most competitive subsequence of size `k`.\n\nAfter processing all the elements in `nums`, the stack will have the most competitive subsequence of size `k`. We convert the stack into a result array/vector/list and return it.\n    ", "python": "\n    ```python\nfrom collections import deque\n\ndef mostCompetitive(nums, k):\n    stack = deque()\n    n = len(nums)\n    for i in range(n):\n        while stack and stack[-1] > nums[i] and len(stack) + n - i > k:\n            stack.pop()\n        if len(stack) < k:\n            stack.append(nums[i])\n    return list(stack)\n```\n\n    \n    The algorithm works by keeping a monotonically increasing stack. We iterate through the `nums` array and try to make our stack size equal to `k`. At each step, we check if it is possible to remove the current top element of the stack and still have `k` elements after processing all of the array elements. If it is possible and the current top element of the stack is greater than the current element in `nums`, we remove it. This ensures that the stack remains monotonically increasing and holds the most competitive subsequence of size `k`.\n\nAfter processing all the elements in `nums`, the stack will have the most competitive subsequence of size `k`. We convert the stack into a result array/vector/list and return it.\n    ", "javascript": "\n    ```javascript\nfunction mostCompetitive(nums, k) {\n    let stack = [];\n    let n = nums.length;\n    for (let i = 0; i < n; i++) {\n        while (stack.length > 0 && stack[stack.length - 1] > nums[i] && stack.length + n - i > k) {\n            stack.pop();\n        }\n        if (stack.length < k) {\n            stack.push(nums[i]);\n        }\n    }\n    return stack;\n}\n```\n\n    \n    The algorithm works by keeping a monotonically increasing stack. We iterate through the `nums` array and try to make our stack size equal to `k`. At each step, we check if it is possible to remove the current top element of the stack and still have `k` elements after processing all of the array elements. If it is possible and the current top element of the stack is greater than the current element in `nums`, we remove it. This ensures that the stack remains monotonically increasing and holds the most competitive subsequence of size `k`.\n\nAfter processing all the elements in `nums`, the stack will have the most competitive subsequence of size `k`. We convert the stack into a result array/vector/list and return it.\n    "}
{"id": 1675, "slug": "minimize-deviation-in-array", "title": "Minimize Deviation in Array", "difficulty": "Hard", "content": "You are given an array `nums` of `n` positive integers.\n\nYou can perform two types of operations on any element of the array any number of times:\n\n*   If the element is **even**, **divide** it by `2`.\n    *   For example, if the array is `[1,2,3,4]`, then you can do this operation on the last element, and the array will be `[1,2,3,2].`\n*   If the element is **odd**, **multiply** it by `2`.\n    *   For example, if the array is `[1,2,3,4]`, then you can do this operation on the first element, and the array will be `[2,2,3,4].`\n\nThe **deviation** of the array is the **maximum difference** between any two elements in the array.\n\nReturn _the **minimum deviation** the array can have after performing some number of operations._\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 1\n**Explanation:** You can transform the array to \\[1,2,3,2\\], then to \\[2,2,3,2\\], then the deviation will be 3 - 2 = 1.\n\n**Example 2:**\n\n**Input:** nums = \\[4,1,5,20,3\\]\n**Output:** 3\n**Explanation:** You can transform the array after two operations to \\[4,2,5,5,3\\], then the deviation will be 5 - 2 = 3.\n\n**Example 3:**\n\n**Input:** nums = \\[2,10,8\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `2 <= n <= 5 * 104`\n*   `1 <= nums[i] <= 109`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxDistance(int[] position, int m) {\n    Arrays.sort(position);\n\n    int left = 1;\n    int right = position[position.length - 1] - position[0];\n    int ans = 0;\n\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (canPlaceBalls(mid, position, m)) {\n            ans = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return ans;\n}\n\nprivate boolean canPlaceBalls(int force, int[] position, int m) {\n    int last_position = position[0];\n    int placed_balls = 1;\n\n    for (int i = 1; i < position.length; i++) {\n        if (position[i] - last_position >= force) {\n            placed_balls++;\n            last_position = position[i];\n\n            if (placed_balls == m) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```\n    \n    The algorithm consists of a binary search to find the minimum distance between `m` balls in the baskets. It has a helper function, `canPlaceBalls`, that checks if it is possible to place `m` balls in the baskets with the given minimum distance. The main function, `maxDistance`, sorts the position array first and then does the binary search. During the binary search, it repeatedly calls the `canPlaceBalls` function with different distances to find the maximum distance, where `m` balls can still be placed in the baskets.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nbool canPlaceBalls(int force, const std::vector<int>& position, int m) {\n    int last_position = position[0];\n    int placed_balls = 1;\n\n    for (int i = 1; i < position.size(); i++) {\n        if (position[i] - last_position >= force) {\n            placed_balls++;\n            last_position = position[i];\n\n            if (placed_balls == m) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint maxDistance(std::vector<int>& position, int m) {\n    std::sort(position.begin(), position.end());\n\n    int left = 1;\n    int right = position.back() - position[0];\n    int ans = 0;\n\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (canPlaceBalls(mid, position, m)) {\n            ans = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm consists of a binary search to find the minimum distance between `m` balls in the baskets. It has a helper function, `canPlaceBalls`, that checks if it is possible to place `m` balls in the baskets with the given minimum distance. The main function, `maxDistance`, sorts the position array first and then does the binary search. During the binary search, it repeatedly calls the `canPlaceBalls` function with different distances to find the maximum distance, where `m` balls can still be placed in the baskets.\n    ", "python": "\n    ```python\nfrom typing import List\n\ndef can_place_balls(force: int, position: List[int], m: int) -> bool:\n    last_position = position[0]\n    placed_balls = 1\n\n    for i in range(1, len(position)):\n        if position[i] - last_position >= force:\n            placed_balls += 1\n            last_position = position[i]\n\n            if placed_balls == m:\n                return True\n\n    return False\n\ndef max_distance(position: List[int], m: int) -> int:\n    position.sort()\n\n    left = 1\n    right = position[-1] - position[0]\n    ans = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_place_balls(mid, position, m):\n            ans = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return ans\n```\n    \n    The algorithm consists of a binary search to find the minimum distance between `m` balls in the baskets. It has a helper function, `canPlaceBalls`, that checks if it is possible to place `m` balls in the baskets with the given minimum distance. The main function, `maxDistance`, sorts the position array first and then does the binary search. During the binary search, it repeatedly calls the `canPlaceBalls` function with different distances to find the maximum distance, where `m` balls can still be placed in the baskets.\n    ", "javascript": "\n    ```javascript\nfunction canPlaceBalls(force, position, m) {\n    let last_position = position[0];\n    let placed_balls = 1;\n\n    for (let i = 1; i < position.length; i++) {\n        if (position[i] - last_position >= force) {\n            placed_balls++;\n            last_position = position[i];\n\n            if (placed_balls === m) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction maxDistance(position, m) {\n    position.sort((a, b) => a - b);\n\n    let left = 1;\n    let right = position[position.length - 1] - position[0];\n    let ans = 0;\n\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n        if (canPlaceBalls(mid, position, m)) {\n            ans = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm consists of a binary search to find the minimum distance between `m` balls in the baskets. It has a helper function, `canPlaceBalls`, that checks if it is possible to place `m` balls in the baskets with the given minimum distance. The main function, `maxDistance`, sorts the position array first and then does the binary search. During the binary search, it repeatedly calls the `canPlaceBalls` function with different distances to find the maximum distance, where `m` balls can still be placed in the baskets.\n    "}
{"id": 1686, "slug": "stone-game-vi", "title": "Stone Game VI", "difficulty": "Medium", "content": "Alice and Bob take turns playing a game, with Alice starting first.\n\nThere are `n` stones in a pile. On each player's turn, they can **remove** a stone from the pile and receive points based on the stone's value. Alice and Bob may **value the stones differently**.\n\nYou are given two integer arrays of length `n`, `aliceValues` and `bobValues`. Each `aliceValues[i]` and `bobValues[i]` represents how Alice and Bob, respectively, value the `ith` stone.\n\nThe winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play **optimally**. Both players know the other's values.\n\nDetermine the result of the game, and:\n\n*   If Alice wins, return `1`.\n*   If Bob wins, return `-1`.\n*   If the game results in a draw, return `0`.\n\n**Example 1:**\n\n**Input:** aliceValues = \\[1,3\\], bobValues = \\[2,1\\]\n**Output:** 1\n**Explanation:**\nIf Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\nBob can only choose stone 0, and will only receive 2 points.\nAlice wins.\n\n**Example 2:**\n\n**Input:** aliceValues = \\[1,2\\], bobValues = \\[3,1\\]\n**Output:** 0\n**Explanation:**\nIf Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\nDraw.\n\n**Example 3:**\n\n**Input:** aliceValues = \\[2,4,3\\], bobValues = \\[1,6,7\\]\n**Output:** -1\n**Explanation:**\nRegardless of how Alice plays, Bob will be able to have more points than Alice.\nFor example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\nBob wins.\n\n**Constraints:**\n\n*   `n == aliceValues.length == bobValues.length`\n*   `1 <= n <= 105`\n*   `1 <= aliceValues[i], bobValues[i] <= 100`", "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\n    int n = aliceValues.length;\n    Integer[] indices = new Integer[n];\n    for (int i = 0; i < n; i++) {\n        indices[i] = i;\n    }\n    \n    Arrays.sort(indices, (a, b) -> (bobValues[a] + aliceValues[a]) - (bobValues[b] + aliceValues[b]));\n    \n    int aliceSum = 0, bobSum = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if ((n - 1 - i) % 2 == 0)\n            aliceSum += aliceValues[indices[i]];\n        else\n            bobSum += bobValues[indices[i]];\n    }\n\n    return Integer.compare(aliceSum, bobSum);\n}\n```\n\n    \n    Instead of looking at the stones' values separately, we can look at them by their total value (`total = aliceValue + bobValue`). We sort the stones in decreasing order of their total value. Essentially, we want both Alice and Bob to take higher value stones.\n\nThen, we iterate over the sorted stones, giving each stone i to the current player (Alice gets the stones from even indices, Bob gets the stones from odd indices). After that, we compare the sum of values obtained by both players, and return the appropriate result value (win, lose, or draw) as per the problem statement.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint stoneGameVI(std::vector<int>& aliceValues, std::vector<int>& bobValues) {\n    int n = aliceValues.size();\n    std::vector<std::pair<int, int>> diff;\n    for (int i = 0; i < n; ++i) {\n        diff.push_back({aliceValues[i] + bobValues[i], i});\n    }\n    \n    std::sort(diff.rbegin(), diff.rend());\n    int aliceSum = 0, bobSum = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            aliceSum += aliceValues[diff[i].second];\n        } else {\n            bobSum += bobValues[diff[i].second];\n        }\n    }\n\n    return (aliceSum == bobSum) ? 0 : ((aliceSum > bobSum) ? 1 : -1);\n}\n```\n\n    \n    Instead of looking at the stones' values separately, we can look at them by their total value (`total = aliceValue + bobValue`). We sort the stones in decreasing order of their total value. Essentially, we want both Alice and Bob to take higher value stones.\n\nThen, we iterate over the sorted stones, giving each stone i to the current player (Alice gets the stones from even indices, Bob gets the stones from odd indices). After that, we compare the sum of values obtained by both players, and return the appropriate result value (win, lose, or draw) as per the problem statement.\n    ", "python": "\n    ```python\ndef stoneGameVI(aliceValues, bobValues):\n    n = len(aliceValues)\n    diff = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)\n\n    aliceSum, bobSum = 0, 0\n    for i in range(n):\n        if i % 2 == 0:\n            aliceSum += aliceValues[diff[i][1]]\n        else:\n            bobSum += bobValues[diff[i][1]]\n            \n    return 0 if aliceSum == bobSum else (1 if aliceSum > bobSum else -1)\n```\n\n    \n    Instead of looking at the stones' values separately, we can look at them by their total value (`total = aliceValue + bobValue`). We sort the stones in decreasing order of their total value. Essentially, we want both Alice and Bob to take higher value stones.\n\nThen, we iterate over the sorted stones, giving each stone i to the current player (Alice gets the stones from even indices, Bob gets the stones from odd indices). After that, we compare the sum of values obtained by both players, and return the appropriate result value (win, lose, or draw) as per the problem statement.\n    ", "javascript": "\n    ```javascript\nfunction stoneGameVI(aliceValues, bobValues) {\n    const n = aliceValues.length;\n    const diff = aliceValues.map((val, i) => [val + bobValues[i], i]).sort((a, b) => b[0] - a[0]);\n\n    let aliceSum = 0, bobSum = 0;\n    for (let i = 0; i < n; i++) {\n        if (i % 2 === 0)\n            aliceSum += aliceValues[diff[i][1]];\n        else\n            bobSum += bobValues[diff[i][1]];\n    }\n\n    return aliceSum === bobSum ? 0 : (aliceSum > bobSum ? 1 : -1);\n}\n```\n\n    \n    Instead of looking at the stones' values separately, we can look at them by their total value (`total = aliceValue + bobValue`). We sort the stones in decreasing order of their total value. Essentially, we want both Alice and Bob to take higher value stones.\n\nThen, we iterate over the sorted stones, giving each stone i to the current player (Alice gets the stones from even indices, Bob gets the stones from odd indices). After that, we compare the sum of values obtained by both players, and return the appropriate result value (win, lose, or draw) as per the problem statement.\n    "}
{"id": 1689, "slug": "partitioning-into-minimum-number-of-deci-binary-numbers", "title": "Partitioning Into Minimum Number Of Deci-Binary Numbers", "difficulty": "Medium", "content": "A decimal number is called **deci-binary** if each of its digits is either `0` or `1` without any leading zeros. For example, `101` and `1100` are **deci-binary**, while `112` and `3001` are not.\n\nGiven a string `n` that represents a positive decimal integer, return _the **minimum** number of positive **deci-binary** numbers needed so that they sum up to_ `n`_._\n\n**Example 1:**\n\n**Input:** n =  \"32 \"\n**Output:** 3\n**Explanation:** 10 + 11 + 11 = 32\n\n**Example 2:**\n\n**Input:** n =  \"82734 \"\n**Output:** 8\n\n**Example 3:**\n\n**Input:** n =  \"27346209830709182346 \"\n**Output:** 9\n\n**Constraints:**\n\n*   `1 <= n.length <= 105`\n*   `n` consists of only digits.\n*   `n` does not contain any leading zeros and represents a positive integer.", "java": "\n    ```java\npublic boolean containsPattern(int[] arr, int m, int k) {\n    int n = arr.length;\n    if (m * k > n) return false;\n\n    for (int i = 0; i + m * k <= n; i++) {\n        boolean patternFound = true;\n        for (int j = 0; j < m; j++) {\n            for (int l = 1; l < k; l++) {\n                if (arr[i + j] != arr[i + j + l * m]) {\n                    patternFound = false;\n                    break;\n                }\n            }\n            if (!patternFound) break;\n        }\n        if (patternFound) return true;\n    }\n    return false;\n}\n```\n    \n    1. Check if the condition `m * k > n` is true, if so return false because it is impossible to find a subarray pattern of length m repeated k times if their product is greater than the array length.\n2. Iterate through the array, checking for the presence of the pattern. Create a nested loop over the pattern length(m) and repetitions(k).\n3. If at any point a pattern doesn't match, mark patternFound as false and break the inner loop.\n4. If a valid pattern is found, return true. Otherwise, continue searching.\n5. If no valid pattern is found by the end of the iteration, return false.\n    ", "c++": "\n    ```cpp\nbool containsPattern(vector<int>& arr, int m, int k) {\n    int n = arr.size();\n    if (m * k > n) return false;\n\n    for (int i = 0; i + m * k <= n; i++) {\n        bool patternFound = true;\n        for (int j = 0; j < m; j++) {\n            for (int l = 1; l < k; l++) {\n                if (arr[i + j] != arr[i + j + l * m]) {\n                    patternFound = false;\n                    break;\n                }\n            }\n            if (!patternFound) break;\n        }\n        if (patternFound) return true;\n    }\n    return false;\n}\n```\n    \n    1. Check if the condition `m * k > n` is true, if so return false because it is impossible to find a subarray pattern of length m repeated k times if their product is greater than the array length.\n2. Iterate through the array, checking for the presence of the pattern. Create a nested loop over the pattern length(m) and repetitions(k).\n3. If at any point a pattern doesn't match, mark patternFound as false and break the inner loop.\n4. If a valid pattern is found, return true. Otherwise, continue searching.\n5. If no valid pattern is found by the end of the iteration, return false.\n    ", "python": "\n    ```python\ndef containsPattern(arr, m, k):\n    n = len(arr)\n    if m * k > n:\n        return False\n\n    for i in range(n - m * k + 1):\n        patternFound = True\n        for j in range(m):\n            for l in range(1, k):\n                if arr[i + j] != arr[i + j + l * m]:\n                    patternFound = False\n                    break\n            if not patternFound:\n                break\n        if patternFound:\n            return True\n    return False\n```\n    \n    1. Check if the condition `m * k > n` is true, if so return false because it is impossible to find a subarray pattern of length m repeated k times if their product is greater than the array length.\n2. Iterate through the array, checking for the presence of the pattern. Create a nested loop over the pattern length(m) and repetitions(k).\n3. If at any point a pattern doesn't match, mark patternFound as false and break the inner loop.\n4. If a valid pattern is found, return true. Otherwise, continue searching.\n5. If no valid pattern is found by the end of the iteration, return false.\n    ", "javascript": "\n    ```javascript\nfunction containsPattern(arr, m, k) {\n    const n = arr.length;\n    if (m * k > n) return false;\n\n    for (let i = 0; i + m * k <= n; i++) {\n        let patternFound = true;\n        for (let j = 0; j < m; j++) {\n            for (let l = 1; l < k; l++) {\n                if (arr[i + j] !== arr[i + j + l * m]) {\n                    patternFound = false;\n                    break;\n                }\n            }\n            if (!patternFound) break;\n        }\n        if (patternFound) return true;\n    }\n    return false;\n}\n```\n    \n    1. Check if the condition `m * k > n` is true, if so return false because it is impossible to find a subarray pattern of length m repeated k times if their product is greater than the array length.\n2. Iterate through the array, checking for the presence of the pattern. Create a nested loop over the pattern length(m) and repetitions(k).\n3. If at any point a pattern doesn't match, mark patternFound as false and break the inner loop.\n4. If a valid pattern is found, return true. Otherwise, continue searching.\n5. If no valid pattern is found by the end of the iteration, return false.\n    "}
{"id": 1702, "slug": "maximum-binary-string-after-change", "title": "Maximum Binary String After Change", "difficulty": "Medium", "content": "You are given a binary string `binary` consisting of only `0`'s or `1`'s. You can apply each of the following operations any number of times:\n\n*   Operation 1: If the number contains the substring `\"00 \"`, you can replace it with `\"10 \"`.\n    *   For example, `\"00010 \" -> \"10010` \"\n*   Operation 2: If the number contains the substring `\"10 \"`, you can replace it with `\"01 \"`.\n    *   For example, `\"00010 \" -> \"00001 \"`\n\n_Return the **maximum binary string** you can obtain after any number of operations. Binary string `x` is greater than binary string `y` if `x`'s decimal representation is greater than `y`'s decimal representation._\n\n**Example 1:**\n\n**Input:** binary =  \"000110 \"\n**Output:**  \"111011 \"\n**Explanation:** A valid transformation sequence can be:\n \"000110 \" ->  \"000101 \" \n \"000101 \" ->  \"100101 \" \n \"100101 \" ->  \"110101 \" \n \"110101 \" ->  \"110011 \" \n \"110011 \" ->  \"111011 \"\n\n**Example 2:**\n\n**Input:** binary =  \"01 \"\n**Output:**  \"01 \"\n**Explanation:**  \"01 \" cannot be transformed any further.\n\n**Constraints:**\n\n*   `1 <= binary.length <= 105`\n*   `binary` consist of `'0'` and `'1'`.", "java": "\n    ```java\npublic String maximumBinaryString(String binary) {\n    int zeroCount = 0;\n    int oneCount = 0;\n    \n    for (char c : binary.toCharArray()) {\n        if (c == '0') {\n            zeroCount++;\n        } else {\n            oneCount++;\n        }\n    }\n    \n    if (zeroCount <= 1) {\n        return binary;\n    }\n    \n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < oneCount; ++i) {\n        result.append('1');\n    }\n    for (int i = 0; i < zeroCount - 1; ++i) {\n        result.append('0');\n    }\n    result.append(\"1####1\");\n    return result.substring(0, binary.length());\n}\n```\n    \n    The algorithm starts by counting the number of zeros and ones in the given binary string. If there is one or no zeros, the binary string cannot be further transformed, so we return the original binary string.\n\nIf there is more than one zero, the goal is to group all the ones together and place them before any zeros. This will create the maximum binary string. To do this, we first append ones to the result string `oneCount` times. Then we append zeros `zeroCount - 1` times (since we are going to insert a one in between these zeros). Finally, we add a dummy string \"1####1\" to force the zeros to be at least as long as the original binary string, and we then truncate the result back to the original binary string length.\n\nThe time complexity of this algorithm is O(n) as we loop through the binary string once to count zeros and ones, and then another two times to construct the result string. The space complexity is also O(n) as we store the result string.\n    ", "c++": "\n    ```cpp\n#include <string>\n\nstd::string maximumBinaryString(std::string binary) {\n    int zeroCount = 0;\n    int oneCount = 0;\n    \n    for (char c : binary) {\n        if (c == '0') {\n            zeroCount++;\n        } else {\n            oneCount++;\n        }\n    }\n    \n    if (zeroCount <= 1) {\n        return binary;\n    }\n    \n    std::string result = \"\";\n    for (int i = 0; i < oneCount; ++i) {\n        result += '1';\n    }\n    for (int i = 0; i < zeroCount - 1; ++i) {\n        result += '0';\n    }\n    result += \"1####1\";\n    return result.substr(0, binary.length());\n}\n```\n    \n    The algorithm starts by counting the number of zeros and ones in the given binary string. If there is one or no zeros, the binary string cannot be further transformed, so we return the original binary string.\n\nIf there is more than one zero, the goal is to group all the ones together and place them before any zeros. This will create the maximum binary string. To do this, we first append ones to the result string `oneCount` times. Then we append zeros `zeroCount - 1` times (since we are going to insert a one in between these zeros). Finally, we add a dummy string \"1####1\" to force the zeros to be at least as long as the original binary string, and we then truncate the result back to the original binary string length.\n\nThe time complexity of this algorithm is O(n) as we loop through the binary string once to count zeros and ones, and then another two times to construct the result string. The space complexity is also O(n) as we store the result string.\n    ", "python": "\n    ```python\ndef maximum_binary_string(binary: str) -> str:\n    zero_count = binary.count('0')\n    \n    if zero_count <= 1:\n        return binary\n    \n    one_count = len(binary) - zero_count\n\n    result = \"1\" * one_count + \"0\" * (zero_count - 1) + \"1####1\"\n    return result[:len(binary)]\n```\n    \n    The algorithm starts by counting the number of zeros and ones in the given binary string. If there is one or no zeros, the binary string cannot be further transformed, so we return the original binary string.\n\nIf there is more than one zero, the goal is to group all the ones together and place them before any zeros. This will create the maximum binary string. To do this, we first append ones to the result string `oneCount` times. Then we append zeros `zeroCount - 1` times (since we are going to insert a one in between these zeros). Finally, we add a dummy string \"1####1\" to force the zeros to be at least as long as the original binary string, and we then truncate the result back to the original binary string length.\n\nThe time complexity of this algorithm is O(n) as we loop through the binary string once to count zeros and ones, and then another two times to construct the result string. The space complexity is also O(n) as we store the result string.\n    ", "javascript": "\n    ```javascript\nfunction maximumBinaryString(binary) {\n    let zeroCount = 0;\n    let oneCount = 0;\n    \n    for (const c of binary) {\n        if (c === '0') {\n            zeroCount++;\n        } else {\n            oneCount++;\n        }\n    }\n    \n    if (zeroCount <= 1) {\n        return binary;\n    }\n    \n    let result = \"\";\n    for (let i = 0; i < oneCount; ++i) {\n        result += '1';\n    }\n    for (let i = 0; i < zeroCount - 1; ++i) {\n        result += '0';\n    }\n    result += \"1####1\";\n    return result.substr(0, binary.length);\n}\n```\n    \n    The algorithm starts by counting the number of zeros and ones in the given binary string. If there is one or no zeros, the binary string cannot be further transformed, so we return the original binary string.\n\nIf there is more than one zero, the goal is to group all the ones together and place them before any zeros. This will create the maximum binary string. To do this, we first append ones to the result string `oneCount` times. Then we append zeros `zeroCount - 1` times (since we are going to insert a one in between these zeros). Finally, we add a dummy string \"1####1\" to force the zeros to be at least as long as the original binary string, and we then truncate the result back to the original binary string length.\n\nThe time complexity of this algorithm is O(n) as we loop through the binary string once to count zeros and ones, and then another two times to construct the result string. The space complexity is also O(n) as we store the result string.\n    "}
{"id": 1703, "slug": "minimum-adjacent-swaps-for-k-consecutive-ones", "title": "Minimum Adjacent Swaps for K Consecutive Ones", "difficulty": "Hard", "content": "You are given an integer array, `nums`, and an integer `k`. `nums` comprises of only `0`'s and `1`'s. In one move, you can choose two **adjacent** indices and swap their values.\n\nReturn _the **minimum** number of moves required so that_ `nums` _has_ `k` _**consecutive**_ `1`_'s_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,0,0,1,0,1\\], k = 2\n**Output:** 1\n**Explanation:** In 1 move, nums could be \\[1,0,0,0,1,1\\] and have 2 consecutive 1's.\n\n**Example 2:**\n\n**Input:** nums = \\[1,0,0,0,0,0,1,1\\], k = 3\n**Output:** 5\n**Explanation:** In 5 moves, the leftmost 1 can be shifted right until nums = \\[0,0,0,0,0,1,1,1\\].\n\n**Example 3:**\n\n**Input:** nums = \\[1,1,0,1\\], k = 2\n**Output:** 0\n**Explanation:** nums already has 2 consecutive 1's.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is `0` or `1`.\n*   `1 <= k <= sum(nums)`", "java": "\n    ```java\npublic int minMoves(int[] nums, int k) {\n    List<Integer> ones_pos = new ArrayList<>();\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] == 1) {\n            ones_pos.add(i - ones_pos.size());\n        }\n    }\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        sum += ones_pos.get(i);\n    }\n    int min_sum = sum;\n    for (int i = k; i < ones_pos.size(); i++) {\n        sum += ones_pos.get(i) - ones_pos.get(i - k);\n        min_sum = Math.min(min_sum, sum);\n    }\n    return min_sum - (k - 1) * k / 2;\n}\n```\n    \n    The algorithm finds the positions of all the 1s in the input array. Then, it calculates the differences between positions and takes out the prefix sum of differences. After that, it finds the minimum sum of the differences for the sliding window of size `k`. The final result is the minimum sum of differences minus the sum of integers from 0 to `k - 1`. All the implementations follow the above algorithm and are adjusted to work with the respective languages.\n    ", "c++": "\n    ```cpp\nint minMoves(vector<int>& nums, int k) {\n    vector<int> ones_pos;\n    int moves = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] == 1) {\n            ones_pos.push_back(i);\n        }\n    }\n    for (int i = 0; i + k <= ones_pos.size(); i++) {\n        int pos = ones_pos[i + k / 2];\n        for (int j = i; j < i + k; j++) {\n            moves += abs(ones_pos[j] - pos);\n        }\n    }\n    return moves;\n}\n```\n    \n    The algorithm finds the positions of all the 1s in the input array. Then, it calculates the differences between positions and takes out the prefix sum of differences. After that, it finds the minimum sum of the differences for the sliding window of size `k`. The final result is the minimum sum of differences minus the sum of integers from 0 to `k - 1`. All the implementations follow the above algorithm and are adjusted to work with the respective languages.\n    ", "python": "\n    ```python\ndef minMoves(nums, k):\n    ones_pos = [i for i, x in enumerate(nums) if x == 1]\n    to_move = [i_b - i_a for i_a, i_b in zip(range(k), ones_pos)]\n    min_moves = sum(to_move[k // 2:])\n    move = min_moves\n    for left, right in zip(\n        to_move[:-k],       # left \"window\" of k-sized sliding window\n        to_move[k // 2 + 1:],  # right \"window\" of k-sized sliding window\n    ):\n        move += left - right\n        min_moves = min(min_moves, move)\n    return min_moves\n```\n    \n    The algorithm finds the positions of all the 1s in the input array. Then, it calculates the differences between positions and takes out the prefix sum of differences. After that, it finds the minimum sum of the differences for the sliding window of size `k`. The final result is the minimum sum of differences minus the sum of integers from 0 to `k - 1`. All the implementations follow the above algorithm and are adjusted to work with the respective languages.\n    ", "javascript": "\n    ```javascript\nfunction minMoves(nums, k) {\n    const ones_pos = [];\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === 1) {\n            ones_pos.push(i - ones_pos.length);\n        }\n    }\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        sum += ones_pos[i];\n    }\n    let min_sum = sum;\n    for (let i = k; i < ones_pos.length; i++) {\n        sum += ones_pos[i] - ones_pos[i - k];\n        min_sum = Math.min(min_sum, sum);\n    }\n    return min_sum - (k - 1) * k / 2;\n}\n```\n\n    \n    The algorithm finds the positions of all the 1s in the input array. Then, it calculates the differences between positions and takes out the prefix sum of differences. After that, it finds the minimum sum of the differences for the sliding window of size `k`. The final result is the minimum sum of differences minus the sum of integers from 0 to `k - 1`. All the implementations follow the above algorithm and are adjusted to work with the respective languages.\n    "}
{"id": 1705, "slug": "maximum-number-of-eaten-apples", "title": "Maximum Number of Eaten Apples", "difficulty": "Medium", "content": "There is a special kind of apple tree that grows apples every day for `n` days. On the `ith` day, the tree grows `apples[i]` apples that will rot after `days[i]` days, that is on day `i + days[i]` the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by `apples[i] == 0` and `days[i] == 0`.\n\nYou decided to eat **at most** one apple a day (to keep the doctors away). Note that you can keep eating after the first `n` days.\n\nGiven two integer arrays `days` and `apples` of length `n`, return _the maximum number of apples you can eat._\n\n**Example 1:**\n\n**Input:** apples = \\[1,2,3,5,2\\], days = \\[3,2,1,4,2\\]\n**Output:** 7\n**Explanation:** You can eat 7 apples:\n- On the first day, you eat an apple that grew on the first day.\n- On the second day, you eat an apple that grew on the second day.\n- On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot.\n- On the fourth to the seventh days, you eat apples that grew on the fourth day.\n\n**Example 2:**\n\n**Input:** apples = \\[3,0,0,0,0,2\\], days = \\[3,0,0,0,0,2\\]\n**Output:** 5\n**Explanation:** You can eat 5 apples:\n- On the first to the third day you eat apples that grew on the first day.\n- Do nothing on the fouth and fifth days.\n- On the sixth and seventh days you eat apples that grew on the sixth day.\n\n**Constraints:**\n\n*   `n == apples.length == days.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= apples[i], days[i] <= 2 * 104`\n*   `days[i] = 0` if and only if `apples[i] = 0`.", "java": "\n    ```java\npublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\n    int[] pairMapping = new int[n];\n    for (int[] pair : pairs) {\n        pairMapping[pair[0]] = pair[1];\n        pairMapping[pair[1]] = pair[0];\n    }\n\n    int unhappyCount = 0;\n    for (int x = 0; x < n; x++) {\n        int y = pairMapping[x];\n        int[] prefX = preferences[x];\n        int idxY = -1;\n        for (int i = 0; i < prefX.length; i++) {\n            if (prefX[i] == y) {\n                idxY = i;\n                break;\n            }\n        }\n\n        for (int i = 0; i < idxY; i++) {\n            int u = prefX[i];\n            int v = pairMapping[u];\n            int[] prefU = preferences[u];\n            for (int j = 0; j < prefU.length; j++) {\n                if (prefU[j] == x) {\n                    unhappyCount++;\n                    break;\n                } else if (prefU[j] == v) {\n                    break;\n                }\n            }\n        }\n    }\n\n    return unhappyCount / 2;\n}\n```\n\n    \n    1. Initialize a pair_mapping array to store the pairings given in pairs.\n2. Loop through each friend (denoted by x in the for loop) from 0 to n.\n3. Check the y position in x's preference list.\n4. Loop through friends 0 to y position in x's preference list (excluding y).\n5. For each friend u, who x prefers more than y, check if u prefers x over its paired friend v.\n6. If u does prefer x over v, increment the unhappy_count and break the loop.\n7. Once all friends are checked, return half the value of the unhappy_count, as each unhappy friend is counted twice.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\n    vector<int> pair_mapping(n);\n    for (vector<int>& pair : pairs) {\n        pair_mapping[pair[0]] = pair[1];\n        pair_mapping[pair[1]] = pair[0];\n    }\n    \n    int unhappy_count = 0;\n    for (int x = 0; x < n; x++) {\n        int y = pair_mapping[x];\n        vector<int>& pref_x = preferences[x];\n        int idx_y = -1;\n        for (int i = 0; i < pref_x.size(); i++) {\n            if (pref_x[i] == y) {\n                idx_y = i;\n                break;\n            }\n        }\n        \n        for (int i = 0; i < idx_y; i++) {\n            int u = pref_x[i];\n            int v = pair_mapping[u];\n            vector<int>& pref_u = preferences[u];\n            for (int j = 0; j < pref_u.size(); j++) {\n                if (pref_u[j] == x) {\n                    unhappy_count++;\n                    break;\n                } else if (pref_u[j] == v) {\n                    break;\n                }\n            }\n        }\n    }\n    \n    return unhappy_count / 2;\n}\n```\n\n    \n    1. Initialize a pair_mapping array to store the pairings given in pairs.\n2. Loop through each friend (denoted by x in the for loop) from 0 to n.\n3. Check the y position in x's preference list.\n4. Loop through friends 0 to y position in x's preference list (excluding y).\n5. For each friend u, who x prefers more than y, check if u prefers x over its paired friend v.\n6. If u does prefer x over v, increment the unhappy_count and break the loop.\n7. Once all friends are checked, return half the value of the unhappy_count, as each unhappy friend is counted twice.\n    ", "python": "\n    ```python\ndef unhappyFriends(n, preferences, pairs):\n    pair_mapping = [0] * n\n    for pair in pairs:\n        pair_mapping[pair[0]] = pair[1]\n        pair_mapping[pair[1]] = pair[0]\n\n    unhappy_count = 0\n    for x in range(n):\n        y = pair_mapping[x]\n        pref_x = preferences[x]\n        idx_y = pref_x.index(y)\n\n        for i in range(idx_y):\n            u = pref_x[i]\n            v = pair_mapping[u]\n            pref_u = preferences[u]\n            if x in pref_u[:pref_u.index(v)]:\n                unhappy_count += 1\n                break\n\n    return unhappy_count // 2\n```\n\n    \n    1. Initialize a pair_mapping array to store the pairings given in pairs.\n2. Loop through each friend (denoted by x in the for loop) from 0 to n.\n3. Check the y position in x's preference list.\n4. Loop through friends 0 to y position in x's preference list (excluding y).\n5. For each friend u, who x prefers more than y, check if u prefers x over its paired friend v.\n6. If u does prefer x over v, increment the unhappy_count and break the loop.\n7. Once all friends are checked, return half the value of the unhappy_count, as each unhappy friend is counted twice.\n    ", "javascript": "\n    ```javascript\nfunction unhappyFriends(n, preferences, pairs) {\n    const pairMapping = new Array(n);\n    for (const pair of pairs) {\n        pairMapping[pair[0]] = pair[1];\n        pairMapping[pair[1]] = pair[0];\n    }\n\n    let unhappyCount = 0;\n    for (let x = 0; x < n; x++) {\n        const y = pairMapping[x];\n        const prefX = preferences[x];\n        const idxY = prefX.indexOf(y);\n\n        for (let i = 0; i < idxY; i++) {\n            const u = prefX[i];\n            const v = pairMapping[u];\n            const prefU = preferences[u];\n            const idxV = prefU.indexOf(v);\n            if (prefU.indexOf(x) < idxV) {\n                unhappyCount++;\n                break;\n            }\n        }\n    }\n\n    return Math.floor(unhappyCount / 2);\n}\n```\n\n    \n    1. Initialize a pair_mapping array to store the pairings given in pairs.\n2. Loop through each friend (denoted by x in the for loop) from 0 to n.\n3. Check the y position in x's preference list.\n4. Loop through friends 0 to y position in x's preference list (excluding y).\n5. For each friend u, who x prefers more than y, check if u prefers x over its paired friend v.\n6. If u does prefer x over v, increment the unhappy_count and break the loop.\n7. Once all friends are checked, return half the value of the unhappy_count, as each unhappy friend is counted twice.\n    "}
{"id": 1708, "slug": "largest-subarray-length-k", "title": "Largest Subarray Length K", "difficulty": "Easy", "content": "An array `A` is larger than some array `B` if for the first index `i` where `A[i] != B[i]`, `A[i] > B[i]`.\n\nFor example, consider `0`\\-indexing:\n\n*   `[1,3,2,4] > [1,2,2,4]`, since at index `1`, `3 > 2`.\n*   `[1,4,4,4] < [2,1,1,1]`, since at index `0`, `1 < 2`.\n\nA subarray is a contiguous subsequence of the array.\n\nGiven an integer array `nums` of **distinct** integers, return the **largest** subarray of `nums` of length `k`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,4,5,2,3\\], k = 3\n**Output:** \\[5,2,3\\]\n**Explanation:** The subarrays of size 3 are: \\[1,4,5\\], \\[4,5,2\\], and \\[5,2,3\\].\nOf these, \\[5,2,3\\] is the largest.\n\n**Example 2:**\n\n**Input:** nums = \\[1,4,5,2,3\\], k = 4\n**Output:** \\[4,5,2,3\\]\n**Explanation:** The subarrays of size 4 are: \\[1,4,5,2\\], and \\[4,5,2,3\\].\nOf these, \\[4,5,2,3\\] is the largest.\n\n**Example 3:**\n\n**Input:** nums = \\[1,4,5,2,3\\], k = 1\n**Output:** \\[5\\]\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\n*   All the integers of `nums` are **unique**.\n\n**Follow up:** What if the integers in `nums` are not distinct?", "java": "\n    ```java\npublic class ParkingSystem {\n    private int[] slots;\n\n    public ParkingSystem(int big, int medium, int small) {\n        slots = new int[]{big, medium, small};\n    }\n    \n    public boolean addCar(int carType) {\n        if (slots[carType - 1] > 0) {\n            slots[carType - 1]--;\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n```\n    \n    The ParkingSystem class is designed such that an instance of the class contains an array of integers 'slots', representing the number of big, medium, and small slots available. The constructor takes in the respective number of big, medium, and small slots as arguments and assigns the input values to the slots array.\n\nThe addCar() function is then implemented to take in an integer value carType (1, 2, or 3) representing the type of car. We then check if the number of slots for that specific type of car is more than 0. If there is available space (i.e., the respective slot count is > 0), we decrement the slot count and return true. If there is no space available (i.e., slot count is 0), we return false.\n\nThe solution is O(1) for addCar() as it directly accesses and modifies the slots array.\n    ", "c++": "\n    ```cpp\nclass ParkingSystem {\npublic:\n    ParkingSystem(int big, int medium, int small) {\n        slots = {big, medium, small};\n    }\n    \n    bool addCar(int carType) {\n        if (slots[carType - 1] > 0) {\n            slots[carType - 1]--;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\nprivate:\n    vector<int> slots;\n};\n```\n    \n    The ParkingSystem class is designed such that an instance of the class contains an array of integers 'slots', representing the number of big, medium, and small slots available. The constructor takes in the respective number of big, medium, and small slots as arguments and assigns the input values to the slots array.\n\nThe addCar() function is then implemented to take in an integer value carType (1, 2, or 3) representing the type of car. We then check if the number of slots for that specific type of car is more than 0. If there is available space (i.e., the respective slot count is > 0), we decrement the slot count and return true. If there is no space available (i.e., slot count is 0), we return false.\n\nThe solution is O(1) for addCar() as it directly accesses and modifies the slots array.\n    ", "python": "\n    ```python\nclass ParkingSystem:\n\n    def __init__(self, big: int, medium: int, small: int):\n        self.slots = [big, medium, small]\n\n    def addCar(self, carType: int) -> bool:\n        if self.slots[carType - 1] > 0:\n            self.slots[carType - 1] -= 1\n            return True\n        else:\n            return False\n```\n    \n    The ParkingSystem class is designed such that an instance of the class contains an array of integers 'slots', representing the number of big, medium, and small slots available. The constructor takes in the respective number of big, medium, and small slots as arguments and assigns the input values to the slots array.\n\nThe addCar() function is then implemented to take in an integer value carType (1, 2, or 3) representing the type of car. We then check if the number of slots for that specific type of car is more than 0. If there is available space (i.e., the respective slot count is > 0), we decrement the slot count and return true. If there is no space available (i.e., slot count is 0), we return false.\n\nThe solution is O(1) for addCar() as it directly accesses and modifies the slots array.\n    ", "javascript": "\n    ```javascript\nclass ParkingSystem {\n    constructor(big, medium, small) {\n        this.slots = [big, medium, small];\n    }\n    \n    addCar(carType) {\n        if (this.slots[carType - 1] > 0) {\n            this.slots[carType - 1]--;\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n```\n    \n    The ParkingSystem class is designed such that an instance of the class contains an array of integers 'slots', representing the number of big, medium, and small slots available. The constructor takes in the respective number of big, medium, and small slots as arguments and assigns the input values to the slots array.\n\nThe addCar() function is then implemented to take in an integer value carType (1, 2, or 3) representing the type of car. We then check if the number of slots for that specific type of car is more than 0. If there is available space (i.e., the respective slot count is > 0), we decrement the slot count and return true. If there is no space available (i.e., slot count is 0), we return false.\n\nThe solution is O(1) for addCar() as it directly accesses and modifies the slots array.\n    "}
{"id": 1710, "slug": "maximum-units-on-a-truck", "title": "Maximum Units on a Truck", "difficulty": "Easy", "content": "You are assigned to put some amount of boxes onto **one truck**. You are given a 2D array `boxTypes`, where `boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]`:\n\n*   `numberOfBoxesi` is the number of boxes of type `i`.\n*   `numberOfUnitsPerBoxi` is the number of units in each box of the type `i`.\n\nYou are also given an integer `truckSize`, which is the **maximum** number of **boxes** that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed `truckSize`.\n\nReturn _the **maximum** total number of **units** that can be put on the truck._\n\n**Example 1:**\n\n**Input:** boxTypes = \\[\\[1,3\\],\\[2,2\\],\\[3,1\\]\\], truckSize = 4\n**Output:** 8\n**Explanation:** There are:\n- 1 box of the first type that contains 3 units.\n- 2 boxes of the second type that contain 2 units each.\n- 3 boxes of the third type that contain 1 unit each.\nYou can take all the boxes of the first and second types, and one box of the third type.\nThe total number of units will be = (1 \\* 3) + (2 \\* 2) + (1 \\* 1) = 8.\n\n**Example 2:**\n\n**Input:** boxTypes = \\[\\[5,10\\],\\[2,5\\],\\[4,7\\],\\[3,9\\]\\], truckSize = 10\n**Output:** 91\n\n**Constraints:**\n\n*   `1 <= boxTypes.length <= 1000`\n*   `1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000`\n*   `1 <= truckSize <= 106`", "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\n    int[] serverRequests = new int[k];\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n    Queue<Integer> availableServers = new LinkedList<>();\n\n    for (int i = 0; i < k; i++) {\n        availableServers.offer(i);\n    }\n\n    for (int i = 0; i < arrival.length; i++) {\n        while (!pq.isEmpty() && pq.peek()[0] <= arrival[i]) {\n            availableServers.offer(pq.poll()[1]);\n        }\n\n        if (!availableServers.isEmpty()) {\n            int serverId = availableServers.poll();\n            serverRequests[serverId]++;\n            pq.offer(new int[]{arrival[i] + load[i], serverId});\n        }\n    }\n\n    int maxRequests = 0;\n    for (int requests : serverRequests) {\n        maxRequests = Math.max(maxRequests, requests);\n    }\n\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < k; i++) {\n        if (serverRequests[i] == maxRequests) {\n            result.add(i);\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Initialize an array named `serverRequests` to store the number of requests handled by each server. This array is the same length as the number of servers and filled with 0s initially. Initialize a priority queue `pq` to store the servers that are currently handling a request, in ascending order of when they will finish processing the request. Initialize a queue `availableServers` and fill it with server IDs from 0 to k-1.\n2. Iterate over the `arrival` array. For each request, dequeue any servers that have finished processing their tasks, and enqueue them into `availableServers`.\n3. If there are servers available in `availableServers`, then assign the current request to the first available server. Increment the corresponding count in `serverRequests`, and enqueue the server into `pq` with the finish time (arrival[i] + load[i]) as the priority.\n4. Iterate through `serverRequests` to find the maximum count (i.e. the highest number of requests handled).\n5. Finally, create a result list (or array) containing the IDs of servers with counts equal to the maximum count.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nstd::vector<int> busiestServers(int k, std::vector<int>& arrival, std::vector<int>& load) {\n    std::vector<int> serverRequests(k, 0);\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;\n    std::queue<int> availableServers;\n\n    for (int i = 0; i < k; ++i) {\n        availableServers.push(i);\n    }\n\n    for (int i = 0; i < arrival.size(); ++i) {\n        while (!pq.empty() && pq.top().first <= arrival[i]) {\n            availableServers.push(pq.top().second);\n            pq.pop();\n        }\n\n        if (!availableServers.empty()) {\n            int serverId = availableServers.front();\n            availableServers.pop();\n            serverRequests[serverId]++;\n            pq.push({arrival[i] + load[i], serverId});\n        }\n    }\n\n    int maxRequests = 0;\n    for (int requests : serverRequests) {\n        maxRequests = std::max(maxRequests, requests);\n    }\n\n    std::vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        if (serverRequests[i] == maxRequests) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Initialize an array named `serverRequests` to store the number of requests handled by each server. This array is the same length as the number of servers and filled with 0s initially. Initialize a priority queue `pq` to store the servers that are currently handling a request, in ascending order of when they will finish processing the request. Initialize a queue `availableServers` and fill it with server IDs from 0 to k-1.\n2. Iterate over the `arrival` array. For each request, dequeue any servers that have finished processing their tasks, and enqueue them into `availableServers`.\n3. If there are servers available in `availableServers`, then assign the current request to the first available server. Increment the corresponding count in `serverRequests`, and enqueue the server into `pq` with the finish time (arrival[i] + load[i]) as the priority.\n4. Iterate through `serverRequests` to find the maximum count (i.e. the highest number of requests handled).\n5. Finally, create a result list (or array) containing the IDs of servers with counts equal to the maximum count.\n    ", "python": "\n    ```python\nimport heapq\n\ndef busiest_servers(k, arrival, load):\n    server_requests = [0] * k\n    pq = []\n    available_servers = list(range(k))\n\n    for i in range(len(arrival)):\n        while pq and pq[0][0] <= arrival[i]:\n            _, server_id = heapq.heappop(pq)\n            available_servers.append(server_id)\n\n        if available_servers:\n            server_id = available_servers.pop(0)\n            server_requests[server_id] += 1\n            heapq.heappush(pq, (arrival[i] + load[i], server_id))\n\n    max_requests = max(server_requests)\n    return [i for i in range(k) if server_requests[i] == max_requests]\n```\n\n    \n    1. Initialize an array named `serverRequests` to store the number of requests handled by each server. This array is the same length as the number of servers and filled with 0s initially. Initialize a priority queue `pq` to store the servers that are currently handling a request, in ascending order of when they will finish processing the request. Initialize a queue `availableServers` and fill it with server IDs from 0 to k-1.\n2. Iterate over the `arrival` array. For each request, dequeue any servers that have finished processing their tasks, and enqueue them into `availableServers`.\n3. If there are servers available in `availableServers`, then assign the current request to the first available server. Increment the corresponding count in `serverRequests`, and enqueue the server into `pq` with the finish time (arrival[i] + load[i]) as the priority.\n4. Iterate through `serverRequests` to find the maximum count (i.e. the highest number of requests handled).\n5. Finally, create a result list (or array) containing the IDs of servers with counts equal to the maximum count.\n    ", "javascript": "\n    ```javascript\nfunction busiestServers(k, arrival, load) {\n    const serverRequests = new Array(k).fill(0);\n    const pq = [];\n    const availableServers = Array.from({ length: k }, (_, i) => i);\n\n    for (let i = 0; i < arrival.length; i++) {\n        while (pq.length && pq[0][0] <= arrival[i]) {\n            const [, serverId] = pq.shift();\n            availableServers.push(serverId);\n        }\n\n        if (availableServers.length) {\n            const serverId = availableServers.shift();\n            serverRequests[serverId]++;\n            pq.push([arrival[i] + load[i], serverId]);\n            pq.sort((a, b) => a[0] - b[0]);\n        }\n    }\n\n    const maxRequests = Math.max(...serverRequests);\n    return serverRequests.reduce((result, requests, i) => {\n        if (requests === maxRequests) {\n            result.push(i);\n        }\n        return result;\n    }, []);\n}\n```\n\n    \n    1. Initialize an array named `serverRequests` to store the number of requests handled by each server. This array is the same length as the number of servers and filled with 0s initially. Initialize a priority queue `pq` to store the servers that are currently handling a request, in ascending order of when they will finish processing the request. Initialize a queue `availableServers` and fill it with server IDs from 0 to k-1.\n2. Iterate over the `arrival` array. For each request, dequeue any servers that have finished processing their tasks, and enqueue them into `availableServers`.\n3. If there are servers available in `availableServers`, then assign the current request to the first available server. Increment the corresponding count in `serverRequests`, and enqueue the server into `pq` with the finish time (arrival[i] + load[i]) as the priority.\n4. Iterate through `serverRequests` to find the maximum count (i.e. the highest number of requests handled).\n5. Finally, create a result list (or array) containing the IDs of servers with counts equal to the maximum count.\n    "}
{"id": 1713, "slug": "minimum-operations-to-make-a-subsequence", "title": "Minimum Operations to Make a Subsequence", "difficulty": "Hard", "content": "You are given an array `target` that consists of **distinct** integers and another integer array `arr` that **can** have duplicates.\n\nIn one operation, you can insert any integer at any position in `arr`. For example, if `arr = [1,4,1,2]`, you can add `3` in the middle and make it `[1,4,3,1,2]`. Note that you can insert the integer at the very beginning or end of the array.\n\nReturn _the **minimum** number of operations needed to make_ `target` _a **subsequence** of_ `arr`_._\n\nA **subsequence** of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, `[2,7,4]` is a subsequence of `[4,2,3,7,2,1,4]` (the underlined elements), while `[2,4,2]` is not.\n\n**Example 1:**\n\n**Input:** target = \\[5,1,3\\], `arr` = \\[9,4,2,3,4\\]\n**Output:** 2\n**Explanation:** You can add 5 and 1 in such a way that makes `arr` = \\[5,9,4,1,2,3,4\\], then target will be a subsequence of `arr`.\n\n**Example 2:**\n\n**Input:** target = \\[6,4,8,1,3,2\\], `arr` = \\[4,7,6,2,3,8,6,1\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= target.length, arr.length <= 105`\n*   `1 <= target[i], arr[i] <= 109`\n*   `target` contains no duplicates.", "java": "\n    ```java\nimport java.util.*;\n\npublic int minOperations(int[] target, int[] arr) {\n    Map<Integer, Integer> pos = new HashMap<>();\n    for (int i = 0; i < target.length; ++i) {\n        pos.put(target[i], i);\n    }\n\n    List<Integer> dp = new ArrayList<>();\n    for (int a : arr) {\n        if (pos.containsKey(a)) {\n            int idx = Collections.binarySearch(dp, pos.get(a));\n            if (idx < 0) {\n                idx = -(idx + 1);\n            }\n            if (idx == dp.size()) {\n                dp.add(pos.get(a));\n            } else {\n                dp.set(idx, pos.get(a));\n            }\n        }\n    }\n    return target.length - dp.size();\n}\n```\n    \n    The algorithm is based on finding the longest increasing subsequence in the modified `arr` array where only the indices of target numbers are considered. First, a hashmap `pos` is created to store the position of each target number. Then, iterate through the `arr` array and check if a number exists in the target. If it does, find the index of this number in the DP (Dynamic Programming) array using binary search or lower_bound. If the index is at the end of the DP array, append the position to the DP array; otherwise, update the DP array at the found index. Finally, return the difference between the target array's length and the DP array's length as the minimum number of operations needed to make the target a subsequence of `arr`.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint minOperations(vector<int>& target, vector<int>& arr) {\n    unordered_map<int, int> pos;\n    for (int i = 0; i < target.size(); ++i) {\n        pos[target[i]] = i;\n    }\n\n    vector<int> dp;\n    for (const int& a : arr) {\n        if (pos.find(a) != pos.end()) {\n            auto idx = lower_bound(dp.begin(), dp.end(), pos[a]);\n            if (idx == dp.end()) {\n                dp.push_back(pos[a]);\n            } else {\n                *idx = pos[a];\n            }\n        }\n    }\n    return target.size() - dp.size();\n}\n```\n    \n    The algorithm is based on finding the longest increasing subsequence in the modified `arr` array where only the indices of target numbers are considered. First, a hashmap `pos` is created to store the position of each target number. Then, iterate through the `arr` array and check if a number exists in the target. If it does, find the index of this number in the DP (Dynamic Programming) array using binary search or lower_bound. If the index is at the end of the DP array, append the position to the DP array; otherwise, update the DP array at the found index. Finally, return the difference between the target array's length and the DP array's length as the minimum number of operations needed to make the target a subsequence of `arr`.\n    ", "python": "\n    ```python\nfrom bisect import bisect_left\n\ndef minOperations(target, arr):\n    pos = {x: i for i, x in enumerate(target)}\n\n    dp = []\n    for a in arr:\n        if a in pos:\n            idx = bisect_left(dp, pos[a])\n            if idx == len(dp):\n                dp.append(pos[a])\n            else:\n                dp[idx] = pos[a]\n    return len(target) - len(dp)\n```\n    \n    The algorithm is based on finding the longest increasing subsequence in the modified `arr` array where only the indices of target numbers are considered. First, a hashmap `pos` is created to store the position of each target number. Then, iterate through the `arr` array and check if a number exists in the target. If it does, find the index of this number in the DP (Dynamic Programming) array using binary search or lower_bound. If the index is at the end of the DP array, append the position to the DP array; otherwise, update the DP array at the found index. Finally, return the difference between the target array's length and the DP array's length as the minimum number of operations needed to make the target a subsequence of `arr`.\n    ", "javascript": "\n    ```javascript\nfunction minOperations(target, arr) {\n    const pos = new Map();\n    for (let i = 0; i < target.length; ++i) {\n        pos.set(target[i], i);\n    }\n\n    const dp = [];\n    for (const a of arr) {\n        if (pos.has(a)) {\n            const idx = dp.findIndex(x => x >= pos.get(a));\n            if (idx === -1) {\n                dp.push(pos.get(a));\n            } else {\n                dp[idx] = pos.get(a);\n            }\n        }\n    }\n    return target.length - dp.length;\n}\n```\n    \n    The algorithm is based on finding the longest increasing subsequence in the modified `arr` array where only the indices of target numbers are considered. First, a hashmap `pos` is created to store the position of each target number. Then, iterate through the `arr` array and check if a number exists in the target. If it does, find the index of this number in the DP (Dynamic Programming) array using binary search or lower_bound. If the index is at the end of the DP array, append the position to the DP array; otherwise, update the DP array at the found index. Finally, return the difference between the target array's length and the DP array's length as the minimum number of operations needed to make the target a subsequence of `arr`.\n    "}
{"id": 1717, "slug": "maximum-score-from-removing-substrings", "title": "Maximum Score From Removing Substrings", "difficulty": "Medium", "content": "You are given a string `s` and two integers `x` and `y`. You can perform two types of operations any number of times.\n\n*   Remove substring `\"ab \"` and gain `x` points.\n    *   For example, when removing `\"ab \"` from `\"cabxbae \"` it becomes `\"cxbae \"`.\n*   Remove substring `\"ba \"` and gain `y` points.\n    *   For example, when removing `\"ba \"` from `\"cabxbae \"` it becomes `\"cabxe \"`.\n\nReturn _the maximum points you can gain after applying the above operations on_ `s`.\n\n**Example 1:**\n\n**Input:** s =  \"cdbcbbaaabab \", x = 4, y = 5\n**Output:** 19\n**Explanation:**\n- Remove the  \"ba \" underlined in  \"cdbcbbaaabab \". Now, s =  \"cdbcbbaaab \" and 5 points are added to the score.\n- Remove the  \"ab \" underlined in  \"cdbcbbaaab \". Now, s =  \"cdbcbbaa \" and 4 points are added to the score.\n- Remove the  \"ba \" underlined in  \"cdbcbbaa \". Now, s =  \"cdbcba \" and 5 points are added to the score.\n- Remove the  \"ba \" underlined in  \"cdbcba \". Now, s =  \"cdbc \" and 5 points are added to the score.\nTotal score = 5 + 4 + 5 + 5 = 19.\n\n**Example 2:**\n\n**Input:** s =  \"aabbaaxybbaabb \", x = 5, y = 4\n**Output:** 20\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `1 <= x, y <= 104`\n*   `s` consists of lowercase English letters.", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int minCost(int[][] cost, int size1, int size2) {\n    int[] dp = new int[size2 + 1];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    dp[0] = 0;\n\n    for (int i = 0; i < size1; i++) {\n        for (int j = size2; j >= 0; j--) {\n            int minCost = Integer.MAX_VALUE;\n            for (int k = 0; k < size2; k++) {\n                if (((1 << k) & j) == 0) {\n                    minCost = Math.min(minCost, cost[i][k] + dp[j | (1 << k)]);\n                }\n            }\n            dp[j] = Math.min(dp[j], minCost);\n        }\n    }\n\n    return dp[(1 << size2) - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to solve the problem. It initializes a dp array with size `size2+1` filled with infinity to represent minimum cost, and sets the first element of dp to zero. The dp array's indices represent the connected point states of the second group.\n\nFor each point in the first group, we iterate through the dp array in reverse and then loop through each point in the second group. If a point in the second group is not connected to the current point from the first group, then we calculate the cost of connecting the two points and update the cost in the dp array by taking the minimum between the current cost and the new calculated cost.\n\nAfter iterating through all the points in both groups, the minimum cost to connect the two groups can be found at the last index of the dp array.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint min_cost(vector<vector<int>>& cost, int size1, int size2) {\n    vector<int> dp(size2 + 1, INT_MAX);\n    dp[0] = 0;\n\n    for (int i = 0; i < size1; ++i) {\n        for (int j = size2; j >= 0; --j) {\n            int min_cost = INT_MAX;\n            for (int k = 0; k < size2; ++k) {\n                if (((1 << k) & j) == 0) {\n                    min_cost = min(min_cost, cost[i][k] + dp[j | (1 << k)]);\n                }\n            }\n            dp[j] = min(dp[j], min_cost);\n        }\n    }\n\n    return dp[(1 << size2) - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to solve the problem. It initializes a dp array with size `size2+1` filled with infinity to represent minimum cost, and sets the first element of dp to zero. The dp array's indices represent the connected point states of the second group.\n\nFor each point in the first group, we iterate through the dp array in reverse and then loop through each point in the second group. If a point in the second group is not connected to the current point from the first group, then we calculate the cost of connecting the two points and update the cost in the dp array by taking the minimum between the current cost and the new calculated cost.\n\nAfter iterating through all the points in both groups, the minimum cost to connect the two groups can be found at the last index of the dp array.\n    ", "python": "\n    ```python\ndef min_cost(cost, size1, size2):\n    dp = [float('inf')] * (size2 + 1)\n    dp[0] = 0\n\n    for i in range(size1):\n        for j in range(size2, -1, -1):\n            min_cost = float('inf')\n            for k in range(size2):\n                if (1 << k) & j == 0:\n                    min_cost = min(min_cost, cost[i][k] + dp[j | (1 << k)])\n            dp[j] = min(dp[j], min_cost)\n\n    return dp[(1 << size2) - 1]\n```\n    \n    The algorithm uses dynamic programming to solve the problem. It initializes a dp array with size `size2+1` filled with infinity to represent minimum cost, and sets the first element of dp to zero. The dp array's indices represent the connected point states of the second group.\n\nFor each point in the first group, we iterate through the dp array in reverse and then loop through each point in the second group. If a point in the second group is not connected to the current point from the first group, then we calculate the cost of connecting the two points and update the cost in the dp array by taking the minimum between the current cost and the new calculated cost.\n\nAfter iterating through all the points in both groups, the minimum cost to connect the two groups can be found at the last index of the dp array.\n    ", "javascript": "\n    ```javascript\nfunction minCost(cost, size1, size2) {\n    let dp = new Array(size2 + 1).fill(Infinity);\n    dp[0] = 0;\n\n    for (let i = 0; i < size1; i++) {\n        for (let j = size2; j >= 0; j--) {\n            let minCost = Infinity;\n            for (let k = 0; k < size2; k++) {\n                if (((1 << k) & j) === 0) {\n                    minCost = Math.min(minCost, cost[i][k] + dp[j | (1 << k)]);\n                }\n            }\n            dp[j] = Math.min(dp[j], minCost);\n        }\n    }\n\n    return dp[(1 << size2) - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to solve the problem. It initializes a dp array with size `size2+1` filled with infinity to represent minimum cost, and sets the first element of dp to zero. The dp array's indices represent the connected point states of the second group.\n\nFor each point in the first group, we iterate through the dp array in reverse and then loop through each point in the second group. If a point in the second group is not connected to the current point from the first group, then we calculate the cost of connecting the two points and update the cost in the dp array by taking the minimum between the current cost and the new calculated cost.\n\nAfter iterating through all the points in both groups, the minimum cost to connect the two groups can be found at the last index of the dp array.\n    "}
{"id": 1727, "slug": "largest-submatrix-with-rearrangements", "title": "Largest Submatrix With Rearrangements", "difficulty": "Medium", "content": "You are given a binary matrix `matrix` of size `m x n`, and you are allowed to rearrange the **columns** of the `matrix` in any order.\n\nReturn _the area of the largest submatrix within_ `matrix` _where **every** element of the submatrix is_ `1` _after reordering the columns optimally._\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[0,0,1\\],\\[1,1,1\\],\\[1,0,1\\]\\]\n**Output:** 4\n**Explanation:** You can rearrange the columns as shown above.\nThe largest submatrix of 1s, in bold, has an area of 4.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[1,0,1,0,1\\]\\]\n**Output:** 3\n**Explanation:** You can rearrange the columns as shown above.\nThe largest submatrix of 1s, in bold, has an area of 3.\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[1,1,0\\],\\[1,0,1\\]\\]\n**Output:** 2\n**Explanation:** Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2.\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m * n <= 105`\n*   `matrix[i][j]` is either `0` or `1`.", "java": "\n    ```java\npublic boolean canMouseWin(char[][] grid, int catJump, int mouseJump) {\n    int rows = grid.length;\n    int cols = grid[0].length;\n    int cat_r = 0, cat_c = 0, mouse_r = 0, mouse_c = 0;\n\n    for (int r = 0; r < rows; ++r)\n        for (int c = 0; c < cols; ++c) {\n            if (grid[r][c] == 'C') {\n                cat_r = r;\n                cat_c = c;\n            } else if (grid[r][c] == 'M') {\n                mouse_r = r;\n                mouse_c = c;\n            }\n        }\n\n    int[] dirs = {-1, 0, 1, 0, -1};\n    return dfs(grid, mouse_r, mouse_c, cat_r, cat_c, 0, Math.abs(cat_r - mouse_r) + Math.abs(cat_c - mouse_c), catJump, mouseJump, dirs, new HashSet<>());\n}\n\nprivate boolean dfs(char[][] grid, int r_m, int c_m, int r_c, int c_c, int cnt, int dst_m_c, int catJump, int mouseJump, int[] dirs, Set<String> seen) {\n    if (cnt >= 100)\n        return false;\n    if (r_m < 0 || r_m >= grid.length || c_m < 0 || c_m >= grid[0].length)\n        return false;\n    if (r_c < 0 || r_c >= grid.length || c_c < 0 || c_c >= grid[0].length)\n        return true;\n    if (seen.contains(r_m + \"-\" + c_m + \"-\" + r_c + \"-\" + c_c))\n        return false;\n\n    if (grid[r_m][c_m] == 'F' || cnt != dst_m_c) {\n        return true;\n    } else if (grid[r_m][c_m] == '#' || cnt + 1 == dst_m_c) {\n        return false;\n    }\n\n    boolean res = false;\n    for(int i = 0; i < 4; i++){\n        int jump = (dst_m_c == cnt) ? catJump : mouseJump;\n        res |= !dfs(grid, r_m + jump * dirs[i], c_m + jump * dirs[i+1], r_c + dirs[i] * dirs[(i + 2) % 4], c_c + dirs[i+1] * dirs[(i + 3) % 4], cnt + 1, dst_m_c, catJump, mouseJump, dirs, seen);\n        if(jump == 1) break;\n    }\n    \n    if(!res)\n        seen.add(r_m + \"-\" + c_m + \"-\" + r_c + \"-\" + c_c);\n\n    return res;\n}\n```\n    \n    1. Find the positions of the cat and the mouse on the grid.\n2. Compute the initial distance between cat and mouse in terms of the number of steps at the beginning of the game.\n3. The DFS function will be called recursively, with updated positions for both cat and mouse. The function returns a boolean value that indicates whether the mouse can win.\n4. Base cases for DFS function: \n    1. When the game takes more than 100 steps, assume the mouse cannot win. \n    2. If the mouse is out of bounds, assume the mouse loses.\n    3. If the cat is out of bounds, assume the mouse wins.\n    4. If the mouse reaches the food or the cell the mouse is in is an odd number of steps away from the food, the mouse wins. \n    5. If the mouse is standing in a wall or the cell the mouse is in is an even number of steps away from the food, the mouse loses.\n5. When the DFS function is called, it tries all possible directions (up, down, left, and right) by adjusting the row, and column of both cat and mouse.\n6. If a new position is found such that the mouse can win, we return true. If no winning position is found, we return false.\n7. The overall function returns true if the mouse can win, and false otherwise.\n    ", "c++": "\n    ```cpp\nbool canMouseWin(vector<vector<char>>& grid, int catJump, int mouseJump) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int cat_r, cat_c, mouse_r, mouse_c, steps = 0;\n\n    for (int r = 0; r < rows; ++r)\n        for (int c = 0; c < cols; ++c) {\n            if (grid[r][c] == 'C') {\n                cat_r = r;\n                cat_c = c;\n            } else if (grid[r][c] == 'M') {\n                mouse_r = r;\n                mouse_c = c;\n            }\n        }\n\n    vector<int> dirs = {-1, 0, 1, 0, -1};\n    function<bool(int, int, int, int, int, int)> dfs = [&](int r_m, int c_m, int r_c, int c_c, int cnt, int dst_m_c) {\n        if (cnt >= 100) // The game is taking more than 100 steps\n            return false;\n        if (r_m < 0 || r_m >= rows || c_m < 0 || c_m >= cols) // Mouse out of bounds\n            return false;\n        if (r_c < 0 || r_c >= rows || c_c < 0 || c_c >= cols) // Cat out of bounds\n            return true;\n        if (grid[r_m][c_m] == 'F' || cnt != dst_m_c) { // Mouse reached food or cell is odd steps away from food\n            return true;\n        } else if (grid[r_m][c_m] == '#' || cnt + 1 == dst_m_c) { // Wall or cell is even steps away from food\n            return false;\n        }\n        \n        bool res = false;\n        for(int i = 0; i < 4; i++){\n            int jump = (dst_m_c == cnt) ? catJump : mouseJump;\n            res |= !dfs(r_m + jump * dirs[i], c_m + jump * dirs[i+1], r_c + dirs[i] * dirs[(i + 2) % 4], c_c + dirs[i+1] * dirs[(i + 3) % 4], cnt + 1, dst_m_c);\n            if(jump == 1) break;\n        }\n        return res;\n    };\n\n    return dfs(mouse_r, mouse_c, cat_r, cat_c, 0, abs(cat_r - mouse_r) + abs(cat_c - mouse_c));\n}\n```\n    \n    1. Find the positions of the cat and the mouse on the grid.\n2. Compute the initial distance between cat and mouse in terms of the number of steps at the beginning of the game.\n3. The DFS function will be called recursively, with updated positions for both cat and mouse. The function returns a boolean value that indicates whether the mouse can win.\n4. Base cases for DFS function: \n    1. When the game takes more than 100 steps, assume the mouse cannot win. \n    2. If the mouse is out of bounds, assume the mouse loses.\n    3. If the cat is out of bounds, assume the mouse wins.\n    4. If the mouse reaches the food or the cell the mouse is in is an odd number of steps away from the food, the mouse wins. \n    5. If the mouse is standing in a wall or the cell the mouse is in is an even number of steps away from the food, the mouse loses.\n5. When the DFS function is called, it tries all possible directions (up, down, left, and right) by adjusting the row, and column of both cat and mouse.\n6. If a new position is found such that the mouse can win, we return true. If no winning position is found, we return false.\n7. The overall function returns true if the mouse can win, and false otherwise.\n    ", "python": "\n    ```python\ndef canMouseWin(grid: List[List[str]], catJump: int, mouseJump: int) -> bool:\n    rows, cols = len(grid), len(grid[0])\n    cat_r = cat_c = mouse_r = mouse_c = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 'C':\n                cat_r, cat_c = r, c\n            elif grid[r][c] == 'M':\n                mouse_r, mouse_c = r, c\n\n    dirs = [-1, 0, 1, 0, -1]\n\n    def dfs(r_m, c_m, r_c, c_c, cnt, dst_m_c):\n        if cnt >= 100:\n            return False\n        if r_m < 0 or r_m >= rows or c_m < 0 or c_m >= cols:\n            return False\n        if r_c < 0 or r_c >= rows or c_c < 0 or c_c >= cols:\n            return True\n        if grid[r_m][c_m] == 'F' or cnt != dst_m_c:\n            return True\n        elif grid[r_m][c_m] == '#' or cnt + 1 == dst_m_c:\n            return False\n\n        res = False\n        for i in range(4):\n            jump = catJump if dst_m_c == cnt else mouseJump\n            res |= not dfs(r_m + jump * dirs[i], c_m + jump * dirs[i + 1], r_c + dirs[i] * dirs[(i + 2) % 4], c_c + dirs[i+1] * dirs[(i + 3) % 4], cnt + 1, dst_m_c)\n            if jump == 1:\n                break\n\n        return res\n\n    return dfs(mouse_r, mouse_c, cat_r, cat_c, 0, abs(cat_r - mouse_r) + abs(cat_c - mouse_c))\n```\n    \n    1. Find the positions of the cat and the mouse on the grid.\n2. Compute the initial distance between cat and mouse in terms of the number of steps at the beginning of the game.\n3. The DFS function will be called recursively, with updated positions for both cat and mouse. The function returns a boolean value that indicates whether the mouse can win.\n4. Base cases for DFS function: \n    1. When the game takes more than 100 steps, assume the mouse cannot win. \n    2. If the mouse is out of bounds, assume the mouse loses.\n    3. If the cat is out of bounds, assume the mouse wins.\n    4. If the mouse reaches the food or the cell the mouse is in is an odd number of steps away from the food, the mouse wins. \n    5. If the mouse is standing in a wall or the cell the mouse is in is an even number of steps away from the food, the mouse loses.\n5. When the DFS function is called, it tries all possible directions (up, down, left, and right) by adjusting the row, and column of both cat and mouse.\n6. If a new position is found such that the mouse can win, we return true. If no winning position is found, we return false.\n7. The overall function returns true if the mouse can win, and false otherwise.\n    ", "javascript": "\n    ```javascript\nfunction canMouseWin(grid, catJump, mouseJump) {\n    const rows = grid.length;\n    const cols = grid[0].length;\n    let cat_r, cat_c, mouse_r, mouse_c;\n\n    for (let r = 0; r < rows; ++r)\n        for (let c = 0; c < cols; ++c) {\n            if (grid[r][c] === 'C') {\n                cat_r = r;\n                cat_c = c;\n            } else if (grid[r][c] === 'M') {\n                mouse_r = r;\n                mouse_c = c;\n            }\n        }\n\n    const dirs = [-1, 0, 1, 0, -1];\n\n    function dfs(r_m, c_m, r_c, c_c, cnt, dst_m_c) {\n        if (cnt >= 100)\n            return false;\n        if (r_m < 0 || r_m >= rows || c_m < 0 || c_m >= cols)\n            return false;\n        if (r_c < 0 || r_c >= rows || c_c < 0 || c_c >= cols)\n            return true;\n        if (grid[r_m][c_m] === 'F' || cnt !== dst_m_c) {\n            return true;\n        } else if (grid[r_m][c_m] === '#' || cnt + 1 === dst_m_c) {\n            return false;\n        }\n\n        let res = false;\n        for(let i = 0; i < 4; i++){\n            let jump = (dst_m_c === cnt) ? catJump : mouseJump;\n            res |= !dfs(r_m + jump * dirs[i], c_m + jump * dirs[i+1], r_c + dirs[i] * dirs[(i + 2) % 4], c_c + dirs[i+1] * dirs[(i + 3) % 4], cnt + 1, dst_m_c);\n            if(jump === 1) break;\n        }\n\n        return res;\n    }\n\n    return dfs(mouse_r, mouse_c, cat_r, cat_c, 0, Math.abs(cat_r - mouse_r) + Math.abs(cat_c - mouse_c));\n}\n```\n    \n    1. Find the positions of the cat and the mouse on the grid.\n2. Compute the initial distance between cat and mouse in terms of the number of steps at the beginning of the game.\n3. The DFS function will be called recursively, with updated positions for both cat and mouse. The function returns a boolean value that indicates whether the mouse can win.\n4. Base cases for DFS function: \n    1. When the game takes more than 100 steps, assume the mouse cannot win. \n    2. If the mouse is out of bounds, assume the mouse loses.\n    3. If the cat is out of bounds, assume the mouse wins.\n    4. If the mouse reaches the food or the cell the mouse is in is an odd number of steps away from the food, the mouse wins. \n    5. If the mouse is standing in a wall or the cell the mouse is in is an even number of steps away from the food, the mouse loses.\n5. When the DFS function is called, it tries all possible directions (up, down, left, and right) by adjusting the row, and column of both cat and mouse.\n6. If a new position is found such that the mouse can win, we return true. If no winning position is found, we return false.\n7. The overall function returns true if the mouse can win, and false otherwise.\n    "}
{"id": 1733, "slug": "minimum-number-of-people-to-teach", "title": "Minimum Number of People to Teach", "difficulty": "Medium", "content": "On a social network consisting of `m` users and some friendships between users, two users can communicate with each other if they know a common language.\n\nYou are given an integer `n`, an array `languages`, and an array `friendships` where:\n\n*   There are `n` languages numbered `1` through `n`,\n*   `languages[i]` is the set of languages the `i\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b user knows, and\n*   `friendships[i] = [u\u200b\u200b\u200b\u200b\u200b\u200bi\u200b\u200b\u200b, v\u200b\u200b\u200b\u200b\u200b\u200bi]` denotes a friendship between the users `u\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200bi`\u200b\u200b\u200b\u200b\u200b and `vi`.\n\nYou can choose **one** language and teach it to some users so that all friends can communicate with each other. Return _the_ _**minimum**_ _number of users you need to teach._\n\nNote that friendships are not transitive, meaning if `x` is a friend of `y` and `y` is a friend of `z`, this doesn't guarantee that `x` is a friend of `z`.\n\n**Example 1:**\n\n**Input:** n = 2, languages = \\[\\[1\\],\\[2\\],\\[1,2\\]\\], friendships = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]\n**Output:** 1\n**Explanation:** You can either teach user 1 the second language or user 2 the first language.\n\n**Example 2:**\n\n**Input:** n = 3, languages = \\[\\[2\\],\\[1,3\\],\\[1,2\\],\\[3\\]\\], friendships = \\[\\[1,4\\],\\[1,2\\],\\[3,4\\],\\[2,3\\]\\]\n**Output:** 2\n**Explanation:** Teach the third language to users 1 and 3, yielding two users to teach.\n\n**Constraints:**\n\n*   `2 <= n <= 500`\n*   `languages.length == m`\n*   `1 <= m <= 500`\n*   `1 <= languages[i].length <= n`\n*   `1 <= languages[i][j] <= n`\n*   `1 <= u\u200b\u200b\u200b\u200b\u200b\u200bi < v\u200b\u200b\u200b\u200b\u200b\u200bi <= languages.length`\n*   `1 <= friendships.length <= 500`\n*   All tuples `(u\u200b\u200b\u200b\u200b\u200bi, v\u200b\u200b\u200b\u200b\u200b\u200bi)` are unique\n*   `languages[i]` contains only unique values", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\n    List<Double> angles = new ArrayList<>();\n    for (List<Integer> point : points) {\n        if (!point.equals(location)) {\n            angles.add(getAngle(point.get(0), point.get(1), location.get(0), location.get(1)));\n        }\n    }\n    Collections.sort(angles);\n    int n = angles.size();\n    for (int i = 0; i < n; i++) {\n        angles.add(angles.get(i) + 360);\n    }\n    int max_points = 0;\n    int j = 0;\n    for (int i = 0; i < 2 * n; i++) {\n        while (angles.get(i) - angles.get(j) > angle) {\n            j++;\n        }\n        max_points = Math.max(max_points, i - j + 1);\n    }\n    return max_points + (int) points.stream().filter(point -> point.equals(location)).count();\n}\n\nprivate double getAngle(int x, int y, int px, int py) {\n    return Math.atan2(y - py, x - px) * 180 / Math.PI;\n}\n```\n\n    \n    1. Calculate the angles of each point relative to the current position and the east direction, and add the angles to the `angles` list. Skip the points at the observer's location.\n2. Sort the `angles` list in ascending order.\n3. Copy the `angles` list while adding 360 to each angle at the end of the list.\n4. Initialize two pointers i and j, and a variable max_points to store the maximum number of points in the field of view.\n5. Iterate through the angles list using pointer i. If the difference between the i-th angle and the j-th angle is greater than the given angle, increment j. Update max_points with the maximum of max_points and i - j + 1.\n6. Finally, add the number of points at the observer's location to the max_points and return it.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ndouble getAngle(int x, int y, int px, int py) {\n    return atan2(y - py, x - px) * 180 / M_PI;\n}\n\nint visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\n    vector<double> angles;\n    for (const auto& point : points) {\n        if (point != location) {\n            angles.push_back(getAngle(point[0], point[1], location[0], location[1]));\n        }\n    } \n    sort(angles.begin(), angles.end());\n    int n = angles.size();\n    for (int i = 0; i < n; i++) {\n        angles.push_back(angles[i] + 360);\n    }\n    int max_points = 0;\n    int j = 0;\n    for (int i = 0; i < 2 * n; i++) {\n        while (angles[i] - angles[j] > angle) {\n            j++;\n        }\n        max_points = max(max_points, i - j + 1);\n    }\n    return max_points + count(points.begin(), points.end(), location);\n}\n```\n\n    \n    1. Calculate the angles of each point relative to the current position and the east direction, and add the angles to the `angles` list. Skip the points at the observer's location.\n2. Sort the `angles` list in ascending order.\n3. Copy the `angles` list while adding 360 to each angle at the end of the list.\n4. Initialize two pointers i and j, and a variable max_points to store the maximum number of points in the field of view.\n5. Iterate through the angles list using pointer i. If the difference between the i-th angle and the j-th angle is greater than the given angle, increment j. Update max_points with the maximum of max_points and i - j + 1.\n6. Finally, add the number of points at the observer's location to the max_points and return it.\n    ", "python": "\n    ```python\nfrom math import atan2, degrees\n\ndef visiblePoints(points, angle, location):\n    angles = [degrees(atan2(y - location[1], x - location[0])) for x, y in points if [x, y] != location]\n    angles.sort()\n    angles += [a + 360 for a in angles]\n    n = len(angles)\n    max_points, j = 0, 0\n    for i in range(2 * n):\n        while angles[i] - angles[j] > angle:\n            j += 1\n        max_points = max(max_points, i - j + 1)\n    return max_points + points.count(location)\n```\n\n    \n    1. Calculate the angles of each point relative to the current position and the east direction, and add the angles to the `angles` list. Skip the points at the observer's location.\n2. Sort the `angles` list in ascending order.\n3. Copy the `angles` list while adding 360 to each angle at the end of the list.\n4. Initialize two pointers i and j, and a variable max_points to store the maximum number of points in the field of view.\n5. Iterate through the angles list using pointer i. If the difference between the i-th angle and the j-th angle is greater than the given angle, increment j. Update max_points with the maximum of max_points and i - j + 1.\n6. Finally, add the number of points at the observer's location to the max_points and return it.\n    ", "javascript": "\n    ```javascript\nfunction visiblePoints(points, angle, location) {\n    const angles = points.filter(point => point[0] !== location[0] || point[1] !== location[1])\n        .map(point => Math.atan2(point[1] - location[1], point[0] - location[0]) * 180 / Math.PI)\n        .sort((a, b) => a - b);\n    angles.push(...angles.map(a => a + 360));\n    let max_points = 0;\n    let j = 0;\n    const n = angles.length;\n    for (let i = 0; i < 2 * n; i++) {\n        while (angles[i] - angles[j] > angle) {\n            j += 1;\n        }\n        max_points = Math.max(max_points, i - j + 1);\n    }\n    const locationsAtPoint = points.filter(point => point[0] === location[0] && point[1] === location[1]).length;\n    return max_points + locationsAtPoint;\n}\n```\n\n    \n    1. Calculate the angles of each point relative to the current position and the east direction, and add the angles to the `angles` list. Skip the points at the observer's location.\n2. Sort the `angles` list in ascending order.\n3. Copy the `angles` list while adding 360 to each angle at the end of the list.\n4. Initialize two pointers i and j, and a variable max_points to store the maximum number of points in the field of view.\n5. Iterate through the angles list using pointer i. If the difference between the i-th angle and the j-th angle is greater than the given angle, increment j. Update max_points with the maximum of max_points and i - j + 1.\n6. Finally, add the number of points at the observer's location to the max_points and return it.\n    "}
{"id": 1736, "slug": "latest-time-by-replacing-hidden-digits", "title": "Latest Time by Replacing Hidden Digits", "difficulty": "Easy", "content": "You are given a string `time` in the form of `hh:mm`, where some of the digits in the string are hidden (represented by `?`).\n\nThe valid times are those inclusively between `00:00` and `23:59`.\n\nReturn _the latest valid time you can get from_ `time` _by replacing the hidden_ _digits_.\n\n**Example 1:**\n\n**Input:** time =  \"2?:?0 \"\n**Output:**  \"23:50 \"\n**Explanation:** The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50.\n\n**Example 2:**\n\n**Input:** time =  \"0?:3? \"\n**Output:**  \"09:39 \"\n\n**Example 3:**\n\n**Input:** time =  \"1?:22 \"\n**Output:**  \"19:22 \"\n\n**Constraints:**\n\n*   `time` is in the format `hh:mm`.\n*   It is guaranteed that you can produce a valid time from the given string.", "java": "\n    ```java\npublic String maximumTime(String time) {\n    char[] res = time.toCharArray();\n    if (res[0] == '?') {\n        res[0] = (res[1] <= '3' || res[1] == '?') ? '2' : '1';\n    }\n    if (res[1] == '?') {\n        res[1] = (res[0] == '2') ? '3' : '9';\n    }\n    if (res[3] == '?') {\n        res[3] = '5';\n    }\n    if (res[4] == '?') {\n        res[4] = '9';\n    }\n    return new String(res);\n}\n```\n    \n    The algorithm uses the following steps:\n1. For each character in the input string, check if it's a \"?\".\n2. If the character is \"?\", assign a valid hour or minute value depending on its position in the string and other characters' values.\n- If the first \"?\" is at position 0, check if the character at position 1 is less than or equal to 3 or \"?\". If true, assign '2' else, assign '1' to position 0.\n- If the first \"?\" is at position 1, check if the character at position 0 is '2'. If true, assign '3' else, assign '9' to position 1.\n- If the first \"?\" is at position 3, assign '5' to it, any value between 00-59 is valid.\n- If the first \"?\" is at position 4, assign '9' to it, any value between 00-59 is valid.\n\nFinally, return the modified string.\n    ", "c++": "\n    ```cpp\n#include <string>\n\nstd::string maximumTime(std::string time) {\n    if (time[0] == '?') {\n        time[0] = (time[1] <= '3' || time[1] == '?') ? '2' : '1';\n    }\n    if (time[1] == '?') {\n        time[1] = (time[0] == '2') ? '3' : '9';\n    }\n    if (time[3] == '?') {\n        time[3] = '5';\n    }\n    if (time[4] == '?') {\n        time[4] = '9';\n    }\n    return time;\n}\n```\n    \n    The algorithm uses the following steps:\n1. For each character in the input string, check if it's a \"?\".\n2. If the character is \"?\", assign a valid hour or minute value depending on its position in the string and other characters' values.\n- If the first \"?\" is at position 0, check if the character at position 1 is less than or equal to 3 or \"?\". If true, assign '2' else, assign '1' to position 0.\n- If the first \"?\" is at position 1, check if the character at position 0 is '2'. If true, assign '3' else, assign '9' to position 1.\n- If the first \"?\" is at position 3, assign '5' to it, any value between 00-59 is valid.\n- If the first \"?\" is at position 4, assign '9' to it, any value between 00-59 is valid.\n\nFinally, return the modified string.\n    ", "python": "\n    ```python\ndef maximumTime(time: str) -> str:\n    time_list = list(time)\n    if time_list[0] == '?':\n        time_list[0] = '2' if time_list[1] <= '3' or time_list[1] == '?' else '1'\n    if time_list[1] == '?':\n        time_list[1] = '3' if time_list[0] == '2' else '9'\n    if time_list[3] == '?':\n        time_list[3] = '5'\n    if time_list[4] == '?':\n        time_list[4] = '9'\n    return \"\".join(time_list)\n```\n    \n    The algorithm uses the following steps:\n1. For each character in the input string, check if it's a \"?\".\n2. If the character is \"?\", assign a valid hour or minute value depending on its position in the string and other characters' values.\n- If the first \"?\" is at position 0, check if the character at position 1 is less than or equal to 3 or \"?\". If true, assign '2' else, assign '1' to position 0.\n- If the first \"?\" is at position 1, check if the character at position 0 is '2'. If true, assign '3' else, assign '9' to position 1.\n- If the first \"?\" is at position 3, assign '5' to it, any value between 00-59 is valid.\n- If the first \"?\" is at position 4, assign '9' to it, any value between 00-59 is valid.\n\nFinally, return the modified string.\n    ", "javascript": "\n    ```javascript\nfunction maximumTime(time) {\n    let res = time.split('');\n    if (res[0] === \"?\") {\n        res[0] = (res[1] <= \"3\" || res[1] === \"?\") ? \"2\" : \"1\";\n    }\n    if (res[1] === \"?\") {\n        res[1] = (res[0] === \"2\") ? \"3\" : \"9\";\n    }\n    if (res[3] === \"?\") {\n        res[3] = \"5\";\n    }\n    if (res[4] === \"?\") {\n        res[4] = \"9\";\n    }\n    return res.join('');\n}\n```\n    \n    The algorithm uses the following steps:\n1. For each character in the input string, check if it's a \"?\".\n2. If the character is \"?\", assign a valid hour or minute value depending on its position in the string and other characters' values.\n- If the first \"?\" is at position 0, check if the character at position 1 is less than or equal to 3 or \"?\". If true, assign '2' else, assign '1' to position 0.\n- If the first \"?\" is at position 1, check if the character at position 0 is '2'. If true, assign '3' else, assign '9' to position 1.\n- If the first \"?\" is at position 3, assign '5' to it, any value between 00-59 is valid.\n- If the first \"?\" is at position 4, assign '9' to it, any value between 00-59 is valid.\n\nFinally, return the modified string.\n    "}
{"id": 1739, "slug": "building-boxes", "title": "Building Boxes", "difficulty": "Hard", "content": "You have a cubic storeroom where the width, length, and height of the room are all equal to `n` units. You are asked to place `n` boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes:\n\n*   You can place the boxes anywhere on the floor.\n*   If box `x` is placed on top of the box `y`, then each side of the four vertical sides of the box `y` **must** either be adjacent to another box or to a wall.\n\nGiven an integer `n`, return _the **minimum** possible number of boxes touching the floor._\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:** The figure above is for the placement of the three boxes.\nThese boxes are placed in the corner of the room, where the corner is on the left side.\n\n**Example 2:**\n\n**Input:** n = 4\n**Output:** 3\n**Explanation:** The figure above is for the placement of the four boxes.\nThese boxes are placed in the corner of the room, where the corner is on the left side.\n\n**Example 3:**\n\n**Input:** n = 10\n**Output:** 6\n**Explanation:** The figure above is for the placement of the ten boxes.\nThese boxes are placed in the corner of the room, where the corner is on the back side.\n\n**Constraints:**\n\n*   `1 <= n <= 109`", "java": "\n    ```java\npublic class Solution {\n    public boolean checkPalindromeFormation(String a, String b) {\n        for (int i = 0, j = a.length() - 1; i < j; ++i, --j) {\n            if (a.charAt(i) != b.charAt(j))\n                return isPalindrome(a, i, j) || isPalindrome(b, i, j);\n        }\n        return true;\n    }\n\n    private boolean isPalindrome(String s, int left, int right) {\n        while (left < right) {\n            if (s.charAt(left++) != s.charAt(right--)) return false;\n        }\n        return true;\n    }\n}\n```\n    \n    The algorithm works by iterating through the two strings a and b from both ends (i starts at 0, and j starts at the end). The loop condition is `i < j`, which means it will iterate approximately half of the string length.\n\nInside the loop, we check if `a[i]` is not equal to `b[j]`. If they are not equal, we split the string a and b at the current index i and check if they form a palindrome. The function `isPalindrome` is used to check if a string is a palindrome, which takes a string and two pointers (left and right). It iterates through the string from left to right and checks if the characters are equal. If they are not, the function returns false (not a palindrome), otherwise it continues till left >= right, and returns true (palindrome).\n\nTo check if the concatenated strings (aprefix + bsuffix or bprefix + asuffix) form a palindrome, we call the `isPalindrome` function with the required parameters. If either of the concatenated strings provide a palindrome, the function returns true.\n\nAfter the loop has ended, if no palindrome combination has been found, the function returns false. Otherwise, it returns true.\n    ", "c++": "\n    ```cpp\n#include <string>\n\nbool checkPalindromeFormation(std::string a, std::string b) {\n    auto isPalindrome = [](const std::string& s, int left, int right) {\n        while (left < right) {\n            if (s[left++] != s[right--]) return false;\n        }\n        return true;\n    };\n\n    for (int i = 0, j = a.size() - 1; i < j; ++i, --j) {\n        if (a[i] != b[j]) return isPalindrome(a, i, j) || isPalindrome(b, i, j);\n    }\n    return true;\n}\n```\n    \n    The algorithm works by iterating through the two strings a and b from both ends (i starts at 0, and j starts at the end). The loop condition is `i < j`, which means it will iterate approximately half of the string length.\n\nInside the loop, we check if `a[i]` is not equal to `b[j]`. If they are not equal, we split the string a and b at the current index i and check if they form a palindrome. The function `isPalindrome` is used to check if a string is a palindrome, which takes a string and two pointers (left and right). It iterates through the string from left to right and checks if the characters are equal. If they are not, the function returns false (not a palindrome), otherwise it continues till left >= right, and returns true (palindrome).\n\nTo check if the concatenated strings (aprefix + bsuffix or bprefix + asuffix) form a palindrome, we call the `isPalindrome` function with the required parameters. If either of the concatenated strings provide a palindrome, the function returns true.\n\nAfter the loop has ended, if no palindrome combination has been found, the function returns false. Otherwise, it returns true.\n    ", "python": "\n    ```python\ndef check_palindrome_formation(a: str, b: str) -> bool:\n    def is_palindrome(s: str, left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    i, j = 0, len(a) - 1\n    while i < j:\n        if a[i] != b[j]:\n            return is_palindrome(a, i, j) or is_palindrome(b, i, j)\n        i += 1\n        j -= 1\n    return True\n```\n    \n    The algorithm works by iterating through the two strings a and b from both ends (i starts at 0, and j starts at the end). The loop condition is `i < j`, which means it will iterate approximately half of the string length.\n\nInside the loop, we check if `a[i]` is not equal to `b[j]`. If they are not equal, we split the string a and b at the current index i and check if they form a palindrome. The function `isPalindrome` is used to check if a string is a palindrome, which takes a string and two pointers (left and right). It iterates through the string from left to right and checks if the characters are equal. If they are not, the function returns false (not a palindrome), otherwise it continues till left >= right, and returns true (palindrome).\n\nTo check if the concatenated strings (aprefix + bsuffix or bprefix + asuffix) form a palindrome, we call the `isPalindrome` function with the required parameters. If either of the concatenated strings provide a palindrome, the function returns true.\n\nAfter the loop has ended, if no palindrome combination has been found, the function returns false. Otherwise, it returns true.\n    ", "javascript": "\n    ```javascript\nfunction checkPalindromeFormation(a, b) {\n    function isPalindrome(s, left, right) {\n        while (left < right) {\n            if (s.charAt(left++) !== s.charAt(right--)) return false;\n        }\n        return true;\n    }\n\n    for (let i = 0, j = a.length - 1; i < j; ++i, --j) {\n        if (a.charAt(i) !== b.charAt(j))\n            return isPalindrome(a, i, j) || isPalindrome(b, i, j);\n    }\n    return true;\n}\n```\n    \n    The algorithm works by iterating through the two strings a and b from both ends (i starts at 0, and j starts at the end). The loop condition is `i < j`, which means it will iterate approximately half of the string length.\n\nInside the loop, we check if `a[i]` is not equal to `b[j]`. If they are not equal, we split the string a and b at the current index i and check if they form a palindrome. The function `isPalindrome` is used to check if a string is a palindrome, which takes a string and two pointers (left and right). It iterates through the string from left to right and checks if the characters are equal. If they are not, the function returns false (not a palindrome), otherwise it continues till left >= right, and returns true (palindrome).\n\nTo check if the concatenated strings (aprefix + bsuffix or bprefix + asuffix) form a palindrome, we call the `isPalindrome` function with the required parameters. If either of the concatenated strings provide a palindrome, the function returns true.\n\nAfter the loop has ended, if no palindrome combination has been found, the function returns false. Otherwise, it returns true.\n    "}
{"id": 1753, "slug": "maximum-score-from-removing-stones", "title": "Maximum Score From Removing Stones", "difficulty": "Medium", "content": "You are playing a solitaire game with **three piles** of stones of sizes `a`\u200b\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b\u200b respectively. Each turn you choose two **different non-empty** piles, take one stone from each, and add `1` point to your score. The game stops when there are **fewer than two non-empty** piles (meaning there are no more available moves).\n\nGiven three integers `a`\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b, return _the_ **_maximum_** _**score** you can get._\n\n**Example 1:**\n\n**Input:** a = 2, b = 4, c = 6\n**Output:** 6\n**Explanation:** The starting state is (2, 4, 6). One optimal set of moves is:\n- Take from 1st and 3rd piles, state is now (1, 4, 5)\n- Take from 1st and 3rd piles, state is now (0, 4, 4)\n- Take from 2nd and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 6 points.\n\n**Example 2:**\n\n**Input:** a = 4, b = 4, c = 6\n**Output:** 7\n**Explanation:** The starting state is (4, 4, 6). One optimal set of moves is:\n- Take from 1st and 2nd piles, state is now (3, 3, 6)\n- Take from 1st and 3rd piles, state is now (2, 3, 5)\n- Take from 1st and 3rd piles, state is now (1, 3, 4)\n- Take from 1st and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 7 points.\n\n**Example 3:**\n\n**Input:** a = 1, b = 8, c = 8\n**Output:** 8\n**Explanation:** One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty.\nAfter that, there are fewer than two non-empty piles, so the game ends.\n\n**Constraints:**\n\n*   `1 <= a, b, c <= 105`", "java": "\n    ```java\nimport java.util.PriorityQueue;\n\nclass Solution {\n    private int[][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    \n    public int minimumEffortPath(int[][] heights) {\n        int rows = heights.length;\n        int cols = heights[0].length;\n        int[][] efforts = new int[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                efforts[i][j] = Integer.MAX_VALUE;\n            }\n        }\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        efforts[0][0] = 0;\n        pq.offer(new int[]{0, 0, 0});\n        \n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int effort = cur[0], x = cur[1], y = cur[2];\n            \n            if (x == rows - 1 && y == cols - 1) {\n                return effort;\n            }\n            \n            for (int[] dir : directions) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {\n                    int new_effort = Math.max(effort, Math.abs(heights[nx][ny] - heights[x][y]));\n                    if (new_effort < efforts[nx][ny]) {\n                        efforts[nx][ny] = new_effort;\n                        pq.offer(new int[]{new_effort, nx, ny});\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n}\n```\n\n    \n    The algorithm uses Dijkstra's shortest path algorithm to find the path with the minimum effort. Starting from position (0, 0), the algorithm maintains a priority queue of cells to visit, with their current efforts. At each step, the algorithm chooses the cell with the lowest effort, and then tries to move to its neighbors in all four possible directions. When updating the effort of its neighbor, the algorithm only takes into account the highest effort seen so far on its path, which is the maximum absolute difference in heights between two consecutive cells on its path. \n\nThe algorithm maintains a 2D effort array, where efforts[row][col] represents the minimum effort required to reach the cell (row, col). It then pushes these efforts into a priority queue that sorts the cells in non-decreasing order of their efforts.\n\nWhen the algorithm finally reaches the destination cell (rows-1, columns-1), it returns the corresponding effort.\n\nThe time complexity of the algorithm is O(rows*columns*log(rows*columns)), as it potentially visits all cells and uses a priority queue for the processing. The space complexity is O(rows*columns) due to the effort array and priority queue storage.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <utility>\n\nusing std::vector;\nusing std::pair;\nusing std::priority_queue;\n\nint minimumEffortPath(vector<vector<int>>& heights) {\n    const vector<pair<int, int>> directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    int rows = heights.size();\n    int cols = heights[0].size();\n    vector<vector<int>> efforts(rows, vector<int>(cols, INT_MAX));\n    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, std::greater<>> pq;\n    \n    efforts[0][0] = 0;\n    pq.push({0, {0, 0}});\n    \n    while (!pq.empty()) {\n        auto [effort, pos] = pq.top();\n        pq.pop();\n        int x = pos.first, y = pos.second;\n        \n        if (x == rows - 1 && y == cols - 1) {\n            return effort;\n        }\n        \n        for (const auto& dir : directions) {\n            int nx = x + dir.first;\n            int ny = y + dir.second;\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {\n                int new_effort = std::max(effort, std::abs(heights[nx][ny] - heights[x][y]));\n                if (new_effort < efforts[nx][ny]) {\n                    efforts[nx][ny] = new_effort;\n                    pq.push({new_effort, {nx, ny}});\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n```\n\n    \n    The algorithm uses Dijkstra's shortest path algorithm to find the path with the minimum effort. Starting from position (0, 0), the algorithm maintains a priority queue of cells to visit, with their current efforts. At each step, the algorithm chooses the cell with the lowest effort, and then tries to move to its neighbors in all four possible directions. When updating the effort of its neighbor, the algorithm only takes into account the highest effort seen so far on its path, which is the maximum absolute difference in heights between two consecutive cells on its path. \n\nThe algorithm maintains a 2D effort array, where efforts[row][col] represents the minimum effort required to reach the cell (row, col). It then pushes these efforts into a priority queue that sorts the cells in non-decreasing order of their efforts.\n\nWhen the algorithm finally reaches the destination cell (rows-1, columns-1), it returns the corresponding effort.\n\nThe time complexity of the algorithm is O(rows*columns*log(rows*columns)), as it potentially visits all cells and uses a priority queue for the processing. The space complexity is O(rows*columns) due to the effort array and priority queue storage.\n    ", "python": "\n    ```python\nimport heapq\nfrom typing import List\n\ndef minimumEffortPath(heights: List[List[int]]) -> int:\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    rows = len(heights)\n    cols = len(heights[0])\n    efforts = [[float('inf')] * cols for _ in range(rows)]\n\n    q = [(0, 0, 0)]\n    efforts[0][0] = 0\n    \n    while q:\n        effort, x, y = heapq.heappop(q)\n        \n        if x == rows - 1 and y == cols - 1:\n            return effort\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_effort = max(effort, abs(heights[nx][ny] - heights[x][y]))\n                if new_effort < efforts[nx][ny]:\n                    efforts[nx][ny] = new_effort\n                    heapq.heappush(q, (new_effort, nx, ny))\n    \n    return -1\n```\n\n    \n    The algorithm uses Dijkstra's shortest path algorithm to find the path with the minimum effort. Starting from position (0, 0), the algorithm maintains a priority queue of cells to visit, with their current efforts. At each step, the algorithm chooses the cell with the lowest effort, and then tries to move to its neighbors in all four possible directions. When updating the effort of its neighbor, the algorithm only takes into account the highest effort seen so far on its path, which is the maximum absolute difference in heights between two consecutive cells on its path. \n\nThe algorithm maintains a 2D effort array, where efforts[row][col] represents the minimum effort required to reach the cell (row, col). It then pushes these efforts into a priority queue that sorts the cells in non-decreasing order of their efforts.\n\nWhen the algorithm finally reaches the destination cell (rows-1, columns-1), it returns the corresponding effort.\n\nThe time complexity of the algorithm is O(rows*columns*log(rows*columns)), as it potentially visits all cells and uses a priority queue for the processing. The space complexity is O(rows*columns) due to the effort array and priority queue storage.\n    ", "javascript": "\n    ```javascript\nfunction minimumEffortPath(heights) {\n    const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n    const rows = heights.length;\n    const cols = heights[0].length;\n    const efforts = Array.from({ length: rows }, () => Array(cols).fill(Infinity));\n    const pq = new PriorityQueue((a, b) => a[0] - b[0]);\n\n    efforts[0][0] = 0;\n    pq.offer([0, 0, 0]);\n\n    while (!pq.isEmpty()) {\n        const [effort, x, y] = pq.poll();\n\n        if (x === rows - 1 && y === cols - 1) {\n            return effort;\n        }\n\n        for (const [dx, dy] of directions) {\n            const nx = x + dx;\n            const ny = y + dy;\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {\n                const newEffort = Math.max(effort, Math.abs(heights[nx][ny] - heights[x][y]));\n                if (newEffort < efforts[nx][ny]) {\n                    efforts[nx][ny] = newEffort;\n                    pq.offer([newEffort, nx, ny]);\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nclass PriorityQueue {\n    constructor(comparator) {\n        this.comparator = comparator;\n        this.data = [];\n    }\n\n    offer(elem) {\n        let i = this.data.length;\n        this.data.push(elem);\n\n        while (i > 0) {\n            const parent = Math.floor((i - 1) / 2);\n            if (this.comparator(this.data[i], this.data[parent]) >= 0) {\n                break;\n            }\n            [this.data[i], this.data[parent]] = [this.data[parent], this.data[i]];\n            i = parent;\n        }\n    }\n\n    poll() {\n        if (this.isEmpty()) return null;\n\n        const result = this.data[0];\n        const last = this.data.pop();\n\n        if (!this.isEmpty()) {\n            this.data[0] = last;\n            let i = 0;\n\n            while (true) {\n                const left = 2 * i + 1;\n                const right = 2 * i + 2;\n                let smallest = i;\n\n                if (left < this.data.length && this.comparator(this.data[left], this.data[smallest]) < 0) {\n                    smallest = left;\n                }\n\n                if (right < this.data.length && this.comparator(this.data[right], this.data[smallest]) < 0) {\n                    smallest = right;\n                }\n\n                if (smallest === i) break;\n\n                [this.data[i], this.data[smallest]] = [this.data[smallest], this.data[i]];\n                i = smallest;\n            }\n        }\n\n        return result;\n    }\n\n    isEmpty() {\n        return this.data.length === 0;\n    }\n}\n```\n\n    \n    The algorithm uses Dijkstra's shortest path algorithm to find the path with the minimum effort. Starting from position (0, 0), the algorithm maintains a priority queue of cells to visit, with their current efforts. At each step, the algorithm chooses the cell with the lowest effort, and then tries to move to its neighbors in all four possible directions. When updating the effort of its neighbor, the algorithm only takes into account the highest effort seen so far on its path, which is the maximum absolute difference in heights between two consecutive cells on its path. \n\nThe algorithm maintains a 2D effort array, where efforts[row][col] represents the minimum effort required to reach the cell (row, col). It then pushes these efforts into a priority queue that sorts the cells in non-decreasing order of their efforts.\n\nWhen the algorithm finally reaches the destination cell (rows-1, columns-1), it returns the corresponding effort.\n\nThe time complexity of the algorithm is O(rows*columns*log(rows*columns)), as it potentially visits all cells and uses a priority queue for the processing. The space complexity is O(rows*columns) due to the effort array and priority queue storage.\n    "}
{"id": 1754, "slug": "largest-merge-of-two-strings", "title": "Largest Merge Of Two Strings", "difficulty": "Medium", "content": "You are given two strings `word1` and `word2`. You want to construct a string `merge` in the following way: while either `word1` or `word2` are non-empty, choose **one** of the following options:\n\n*   If `word1` is non-empty, append the **first** character in `word1` to `merge` and delete it from `word1`.\n    *   For example, if `word1 = \"abc \"` and `merge = \"dv \"`, then after choosing this operation, `word1 = \"bc \"` and `merge = \"dva \"`.\n*   If `word2` is non-empty, append the **first** character in `word2` to `merge` and delete it from `word2`.\n    *   For example, if `word2 = \"abc \"` and `merge = \" \"`, then after choosing this operation, `word2 = \"bc \"` and `merge = \"a \"`.\n\nReturn _the lexicographically **largest**_ `merge` _you can construct_.\n\nA string `a` is lexicographically larger than a string `b` (of the same length) if in the first position where `a` and `b` differ, `a` has a character strictly larger than the corresponding character in `b`. For example, `\"abcd \"` is lexicographically larger than `\"abcc \"` because the first position they differ is at the fourth character, and `d` is greater than `c`.\n\n**Example 1:**\n\n**Input:** word1 =  \"cabaa \", word2 =  \"bcaaa \"\n**Output:**  \"cbcabaaaaa \"\n**Explanation:** One way to get the lexicographically largest merge is:\n- Take from word1: merge =  \"c \", word1 =  \"abaa \", word2 =  \"bcaaa \"\n- Take from word2: merge =  \"cb \", word1 =  \"abaa \", word2 =  \"caaa \"\n- Take from word2: merge =  \"cbc \", word1 =  \"abaa \", word2 =  \"aaa \"\n- Take from word1: merge =  \"cbca \", word1 =  \"baa \", word2 =  \"aaa \"\n- Take from word1: merge =  \"cbcab \", word1 =  \"aa \", word2 =  \"aaa \"\n- Append the remaining 5 a's from word1 and word2 at the end of merge.\n\n**Example 2:**\n\n**Input:** word1 =  \"abcabc \", word2 =  \"abdcaba \"\n**Output:**  \"abdcabcabcaba \"\n\n**Constraints:**\n\n*   `1 <= word1.length, word2.length <= 3000`\n*   `word1` and `word2` consist only of lowercase English letters.", "java": "\n    ```java\npublic String largestMerge(String word1, String word2) {\n    StringBuilder result = new StringBuilder();\n    while (!word1.isEmpty() || !word2.isEmpty()) {\n        if (word1.compareTo(word2) > 0) {\n            result.append(word1.charAt(0));\n            word1 = word1.substring(1);\n        } else {\n            result.append(word2.charAt(0));\n            word2 = word2.substring(1);\n        }\n    }\n    return result.toString();\n}\n```\n    \n    The algorithm iterates through both `word1` and `word2` until they are both empty. At each step, it compares the two strings and appends the first character of the lexicographically larger string to the `result` string. It then removes that character from its respective string (using `erase` in C++, `substring` in Java, slicing in Python, and `slice` in JavaScript). Once both `word1` and `word2` are empty, the loop ends, and the constructed `result` string is returned.\n\nThis algorithm ensures that we prioritize the lexicographically larger character when appending to the result, always creating the largest possible merged string.\n    ", "c++": "\n    ```cpp\nstd::string largestMerge(std::string word1, std::string word2) {\n    std::string result;\n    while (!word1.empty() || !word2.empty()) {\n        if (word1 > word2) {\n            result += word1[0];\n            word1.erase(word1.begin());\n        } else {\n            result += word2[0];\n            word2.erase(word2.begin());\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through both `word1` and `word2` until they are both empty. At each step, it compares the two strings and appends the first character of the lexicographically larger string to the `result` string. It then removes that character from its respective string (using `erase` in C++, `substring` in Java, slicing in Python, and `slice` in JavaScript). Once both `word1` and `word2` are empty, the loop ends, and the constructed `result` string is returned.\n\nThis algorithm ensures that we prioritize the lexicographically larger character when appending to the result, always creating the largest possible merged string.\n    ", "python": "\n    ```python\ndef largest_merge(word1: str, word2: str) -> str:\n    merge = []\n    while word1 or word2:\n        if word1 > word2:\n            merge.append(word1[0])\n            word1 = word1[1:]\n        else:\n            merge.append(word2[0])\n            word2 = word2[1:]\n    return ''.join(merge)\n```\n    \n    The algorithm iterates through both `word1` and `word2` until they are both empty. At each step, it compares the two strings and appends the first character of the lexicographically larger string to the `result` string. It then removes that character from its respective string (using `erase` in C++, `substring` in Java, slicing in Python, and `slice` in JavaScript). Once both `word1` and `word2` are empty, the loop ends, and the constructed `result` string is returned.\n\nThis algorithm ensures that we prioritize the lexicographically larger character when appending to the result, always creating the largest possible merged string.\n    ", "javascript": "\n    ```javascript\nfunction largestMerge(word1, word2) {\n    let result = '';\n    while (word1.length > 0 || word2.length > 0) {\n        if (word1 > word2) {\n            result += word1[0];\n            word1 = word1.slice(1);\n        } else {\n            result += word2[0];\n            word2 = word2.slice(1);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through both `word1` and `word2` until they are both empty. At each step, it compares the two strings and appends the first character of the lexicographically larger string to the `result` string. It then removes that character from its respective string (using `erase` in C++, `substring` in Java, slicing in Python, and `slice` in JavaScript). Once both `word1` and `word2` are empty, the loop ends, and the constructed `result` string is returned.\n\nThis algorithm ensures that we prioritize the lexicographically larger character when appending to the result, always creating the largest possible merged string.\n    "}
{"id": 1764, "slug": "form-array-by-concatenating-subarrays-of-another-array", "title": "Form Array by Concatenating Subarrays of Another Array", "difficulty": "Medium", "content": "You are given a 2D integer array `groups` of length `n`. You are also given an integer array `nums`.\n\nYou are asked if you can choose `n` **disjoint** subarrays from the array `nums` such that the `ith` subarray is equal to `groups[i]` (**0-indexed**), and if `i > 0`, the `(i-1)th` subarray appears **before** the `ith` subarray in `nums` (i.e. the subarrays must be in the same order as `groups`).\n\nReturn `true` _if you can do this task, and_ `false` _otherwise_.\n\nNote that the subarrays are **disjoint** if and only if there is no index `k` such that `nums[k]` belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.\n\n**Example 1:**\n\n**Input:** groups = \\[\\[1,-1,-1\\],\\[3,-2,0\\]\\], nums = \\[1,-1,0,1,-1,-1,3,-2,0\\]\n**Output:** true\n**Explanation:** You can choose the 0th subarray as \\[1,-1,0,**1,-1,-1**,3,-2,0\\] and the 1st one as \\[1,-1,0,1,-1,-1,**3,-2,0**\\].\nThese subarrays are disjoint as they share no common nums\\[k\\] element.\n\n**Example 2:**\n\n**Input:** groups = \\[\\[10,-2\\],\\[1,2,3,4\\]\\], nums = \\[1,2,3,4,10,-2\\]\n**Output:** false\n**Explanation:** Note that choosing the subarrays \\[**1,2,3,4**,10,-2\\] and \\[1,2,3,4,**10,-2**\\] is incorrect because they are not in the same order as in groups.\n\\[10,-2\\] must come before \\[1,2,3,4\\].\n\n**Example 3:**\n\n**Input:** groups = \\[\\[1,2,3\\],\\[3,4\\]\\], nums = \\[7,7,1,2,3,4,7,7\\]\n**Output:** false\n**Explanation:** Note that choosing the subarrays \\[7,7,**1,2,3**,4,7,7\\] and \\[7,7,1,2,**3,4**,7,7\\] is invalid because they are not disjoint.\nThey share a common elements nums\\[4\\] (0-indexed).\n\n**Constraints:**\n\n*   `groups.length == n`\n*   `1 <= n <= 103`\n*   `1 <= groups[i].length, sum(groups[i].length) <= 103`\n*   `1 <= nums.length <= 103`\n*   `-107 <= groups[i][j], nums[k] <= 107`", "java": "\n    ```java\npublic int maxKRepeating(String sequence, String word) {\n    int maxK = 0;\n    int seqLength = sequence.length();\n    int wordLength = word.length();\n    for (int i = 0; i <= seqLength - wordLength; i++) {\n        int k = 0;\n        while (sequence.startsWith(repeat(word, k + 1), i)) {\n            k++;\n        }\n        if (k > maxK) {\n            maxK = k;\n        }\n    }\n    return maxK;\n}\n\nprivate String repeat(String str, int count) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < count; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}\n```\n    \n    The algorithm iterates through the `sequence` string with a for loop until the `word` no longer fits (i.e., from index 0 to the length of the `sequence` minus the length of the `word` plus 1). For each index, a variable `k` is set to represent the current k-repeating value. It is initialized to 0. While `word` repeated `k+1` times can be found in the corresponding substring in the `sequence`, increment `k`. After the while loop breaks, update the maximum k-repeating value by comparing with the `maxK` variable using the `max()` function in Python, or a simple comparison for other languages. Return `maxK` as the final result.\n    ", "c++": "\n    ```cpp\n#include <string>\n\nint maxKRepeating(std::string sequence, std::string word) {\n    int maxK = 0;\n    int seqLength = sequence.length();\n    int wordLength = word.length();\n    for (int i = 0; i <= seqLength - wordLength; i++) {\n        int k = 0;\n        while (sequence.compare(i, wordLength * (k + 1), word.repeat(k + 1)) == 0) {\n            k++;\n        }\n        if (k > maxK) {\n            maxK = k;\n        }\n    }\n    return maxK;\n}\n```\n    \n    The algorithm iterates through the `sequence` string with a for loop until the `word` no longer fits (i.e., from index 0 to the length of the `sequence` minus the length of the `word` plus 1). For each index, a variable `k` is set to represent the current k-repeating value. It is initialized to 0. While `word` repeated `k+1` times can be found in the corresponding substring in the `sequence`, increment `k`. After the while loop breaks, update the maximum k-repeating value by comparing with the `maxK` variable using the `max()` function in Python, or a simple comparison for other languages. Return `maxK` as the final result.\n    ", "python": "\n    ```python\ndef max_k_repeating(sequence, word):\n    max_k = 0\n    seq_length = len(sequence)\n    word_length = len(word)\n    for i in range(seq_length - word_length + 1):\n        k = 0\n        while sequence[i:i + word_length * (k + 1)] == word * (k + 1):\n            k += 1\n        max_k = max(max_k, k)\n    return max_k\n```\n    \n    The algorithm iterates through the `sequence` string with a for loop until the `word` no longer fits (i.e., from index 0 to the length of the `sequence` minus the length of the `word` plus 1). For each index, a variable `k` is set to represent the current k-repeating value. It is initialized to 0. While `word` repeated `k+1` times can be found in the corresponding substring in the `sequence`, increment `k`. After the while loop breaks, update the maximum k-repeating value by comparing with the `maxK` variable using the `max()` function in Python, or a simple comparison for other languages. Return `maxK` as the final result.\n    ", "javascript": "\n    ```javascript\nfunction maxKRepeating(sequence, word) {\n    let maxK = 0;\n    const seqLength = sequence.length;\n    const wordLength = word.length;\n    for (let i = 0; i <= seqLength - wordLength; i++) {\n        let k = 0;\n        while (sequence.substr(i, wordLength * (k + 1)) === word.repeat(k + 1)) {\n            k++;\n        }\n        if (k > maxK) {\n            maxK = k;\n        }\n    }\n    return maxK;\n}\n```\n    \n    The algorithm iterates through the `sequence` string with a for loop until the `word` no longer fits (i.e., from index 0 to the length of the `sequence` minus the length of the `word` plus 1). For each index, a variable `k` is set to represent the current k-repeating value. It is initialized to 0. While `word` repeated `k+1` times can be found in the corresponding substring in the `sequence`, increment `k`. After the while loop breaks, update the maximum k-repeating value by comparing with the `maxK` variable using the `max()` function in Python, or a simple comparison for other languages. Return `maxK` as the final result.\n    "}
{"id": 1775, "slug": "equal-sum-arrays-with-minimum-number-of-operations", "title": "Equal Sum Arrays With Minimum Number of Operations", "difficulty": "Medium", "content": "You are given two arrays of integers `nums1` and `nums2`, possibly of different lengths. The values in the arrays are between `1` and `6`, inclusive.\n\nIn one operation, you can change any integer's value in **any** of the arrays to **any** value between `1` and `6`, inclusive.\n\nReturn _the minimum number of operations required to make the sum of values in_ `nums1` _equal to the sum of values in_ `nums2`_._ Return `-1`\u200b\u200b\u200b\u200b\u200b if it is not possible to make the sum of the two arrays equal.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,2,3,4,5,6\\], nums2 = \\[1,1,2,2,2,2\\]\n**Output:** 3\n**Explanation:** You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed.\n- Change nums2\\[0\\] to 6. nums1 = \\[1,2,3,4,5,6\\], nums2 = \\[**6**,1,2,2,2,2\\].\n- Change nums1\\[5\\] to 1. nums1 = \\[1,2,3,4,5,**1**\\], nums2 = \\[6,1,2,2,2,2\\].\n- Change nums1\\[2\\] to 2. nums1 = \\[1,2,**2**,4,5,1\\], nums2 = \\[6,1,2,2,2,2\\].\n\n**Example 2:**\n\n**Input:** nums1 = \\[1,1,1,1,1,1,1\\], nums2 = \\[6\\]\n**Output:** -1\n**Explanation:** There is no way to decrease the sum of nums1 or to increase the sum of nums2 to make them equal.\n\n**Example 3:**\n\n**Input:** nums1 = \\[6,6\\], nums2 = \\[1\\]\n**Output:** 3\n**Explanation:** You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed. \n- Change nums1\\[0\\] to 2. nums1 = \\[**2**,6\\], nums2 = \\[1\\].\n- Change nums1\\[1\\] to 2. nums1 = \\[2,**2**\\], nums2 = \\[1\\].\n- Change nums2\\[0\\] to 4. nums1 = \\[2,2\\], nums2 = \\[**4**\\].\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 105`\n*   `1 <= nums1[i], nums2[i] <= 6`", "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class OrderedStream {\n    private int ptr;\n    private HashMap<Integer, String> data;\n\n    public OrderedStream(int n) {\n        ptr = 1;\n        data = new HashMap<>();\n    }\n\n    public List<String> insert(int idKey, String value) {\n        data.put(idKey, value);\n        List<String> result = new ArrayList<>();\n        while (data.containsKey(ptr)) {\n            result.add(data.get(ptr));\n            ptr++;\n        }\n        return result;\n    }\n}\n```\n\n    \n    The algorithm follows the design of a class called `OrderedStream` that creates an object with two instance variables: `ptr` and `data`. The `ptr` variable is initialized to 1 and represents the next ID we expect to process. The `data` variable is a hash map that will store the values for each ID in the data stream.\nThe `insert` method receives an ID and a value as arguments. When a new (idKey, value) pair arrives, the value is stored in the hash map with the idKey as the key.\nThen we initialize an empty list called `result` and start a loop to check if the `ptr` ID exists in the hash map. If it exists, we add its value to the `result` list and increment the ptr by 1, indicating that we have processed that ID. This loop continues until we cannot find the next ID in the data stream. Finally, we return the `result` list.\n\nThe concatenation of all the chunks from the returned lists will result in a list of the sorted values as per the required increasing order of their IDs.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nclass OrderedStream {\npublic:\n    int ptr;\n    unordered_map<int, string> data;\n    \n    OrderedStream(int n) {\n        ptr = 1;\n    }\n    \n    vector<string> insert(int id, string value) {\n        data[id] = value;\n        vector<string> result;\n        while (data.find(ptr) != data.end()) {\n            result.push_back(data[ptr]);\n            ptr++;\n        }\n        return result;\n    }\n};\n```\n\n    \n    The algorithm follows the design of a class called `OrderedStream` that creates an object with two instance variables: `ptr` and `data`. The `ptr` variable is initialized to 1 and represents the next ID we expect to process. The `data` variable is a hash map that will store the values for each ID in the data stream.\nThe `insert` method receives an ID and a value as arguments. When a new (idKey, value) pair arrives, the value is stored in the hash map with the idKey as the key.\nThen we initialize an empty list called `result` and start a loop to check if the `ptr` ID exists in the hash map. If it exists, we add its value to the `result` list and increment the ptr by 1, indicating that we have processed that ID. This loop continues until we cannot find the next ID in the data stream. Finally, we return the `result` list.\n\nThe concatenation of all the chunks from the returned lists will result in a list of the sorted values as per the required increasing order of their IDs.\n    ", "python": "\n    ```python\nclass OrderedStream:\n    def __init__(self, n: int):\n        self.ptr = 1\n        self.data = {}\n\n    def insert(self, idKey: int, value: str):\n        self.data[idKey] = value\n        result = []\n        while self.ptr in self.data:\n            result.append(self.data[self.ptr])\n            self.ptr += 1\n        return result\n```\n\n    \n    The algorithm follows the design of a class called `OrderedStream` that creates an object with two instance variables: `ptr` and `data`. The `ptr` variable is initialized to 1 and represents the next ID we expect to process. The `data` variable is a hash map that will store the values for each ID in the data stream.\nThe `insert` method receives an ID and a value as arguments. When a new (idKey, value) pair arrives, the value is stored in the hash map with the idKey as the key.\nThen we initialize an empty list called `result` and start a loop to check if the `ptr` ID exists in the hash map. If it exists, we add its value to the `result` list and increment the ptr by 1, indicating that we have processed that ID. This loop continues until we cannot find the next ID in the data stream. Finally, we return the `result` list.\n\nThe concatenation of all the chunks from the returned lists will result in a list of the sorted values as per the required increasing order of their IDs.\n    ", "javascript": "\n    ```javascript\nclass OrderedStream {\n    constructor(n) {\n        this.ptr = 1;\n        this.data = {};\n    }\n\n    insert(idKey, value) {\n        this.data[idKey] = value;\n        let result = [];\n        while (this.data[this.ptr]) {\n            result.push(this.data[this.ptr]);\n            this.ptr++;\n        }\n        return result;\n    }\n}\n```\n\n    \n    The algorithm follows the design of a class called `OrderedStream` that creates an object with two instance variables: `ptr` and `data`. The `ptr` variable is initialized to 1 and represents the next ID we expect to process. The `data` variable is a hash map that will store the values for each ID in the data stream.\nThe `insert` method receives an ID and a value as arguments. When a new (idKey, value) pair arrives, the value is stored in the hash map with the idKey as the key.\nThen we initialize an empty list called `result` and start a loop to check if the `ptr` ID exists in the hash map. If it exists, we add its value to the `result` list and increment the ptr by 1, indicating that we have processed that ID. This loop continues until we cannot find the next ID in the data stream. Finally, we return the `result` list.\n\nThe concatenation of all the chunks from the returned lists will result in a list of the sorted values as per the required increasing order of their IDs.\n    "}
{"id": 1785, "slug": "minimum-elements-to-add-to-form-a-given-sum", "title": "Minimum Elements to Add to Form a Given Sum", "difficulty": "Medium", "content": "You are given an integer array `nums` and two integers `limit` and `goal`. The array `nums` has an interesting property that `abs(nums[i]) <= limit`.\n\nReturn _the minimum number of elements you need to add to make the sum of the array equal to_ `goal`. The array must maintain its property that `abs(nums[i]) <= limit`.\n\nNote that `abs(x)` equals `x` if `x >= 0`, and `-x` otherwise.\n\n**Example 1:**\n\n**Input:** nums = \\[1,-1,1\\], limit = 3, goal = -4\n**Output:** 2\n**Explanation:** You can add -2 and -3, then the sum of the array will be 1 - 1 + 1 - 2 - 3 = -4.\n\n**Example 2:**\n\n**Input:** nums = \\[1,-10,9,1\\], limit = 100, goal = 0\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= limit <= 106`\n*   `-limit <= nums[i] <= limit`\n*   `-109 <= goal <= 109`", "java": "\n    ```java\npublic int minElements(int[] nums, int limit, int goal) {\n    long sum = 0;\n    for (int num : nums) sum += num;\n    long diff = Math.abs(goal - sum);\n    \n    return (int)((diff + limit - 1) / limit);\n}\n```\n\n    \n    1. Calculate the sum of the elements in the input array `nums`. \n2. Calculate the absolute difference between the `goal` and the sum of `nums`. \n3. Divide the absolute difference by the `limit`, rounding up to the nearest integer. This gives the minimum number of elements needed to add to make the sum of the array `nums` equal to `goal` while maintaining the property that `abs(nums[i]) <= limit`.\n    ", "c++": "\n    ```cpp\nint minElements(vector<int>& nums, int limit, int goal) {\n    long long sum = 0;\n    for (int num : nums) sum += num;\n    long long diff = abs(goal - sum);\n    \n    return (diff + limit - 1) / limit;\n}\n```\n\n    \n    1. Calculate the sum of the elements in the input array `nums`. \n2. Calculate the absolute difference between the `goal` and the sum of `nums`. \n3. Divide the absolute difference by the `limit`, rounding up to the nearest integer. This gives the minimum number of elements needed to add to make the sum of the array `nums` equal to `goal` while maintaining the property that `abs(nums[i]) <= limit`.\n    ", "python": "\n    ```python\ndef minElements(nums, limit, goal):\n    sum_nums = sum(nums)\n    diff = abs(goal - sum_nums)\n    \n    return (diff + limit - 1) // limit\n```\n\n    \n    1. Calculate the sum of the elements in the input array `nums`. \n2. Calculate the absolute difference between the `goal` and the sum of `nums`. \n3. Divide the absolute difference by the `limit`, rounding up to the nearest integer. This gives the minimum number of elements needed to add to make the sum of the array `nums` equal to `goal` while maintaining the property that `abs(nums[i]) <= limit`.\n    ", "javascript": "\n    ```javascript\nfunction minElements(nums, limit, goal) {\n    let sum = nums.reduce((a, b) => a + b, 0);\n    let diff = Math.abs(goal - sum);\n    \n    return Math.ceil(diff / limit);\n}\n```\n\n    \n    1. Calculate the sum of the elements in the input array `nums`. \n2. Calculate the absolute difference between the `goal` and the sum of `nums`. \n3. Divide the absolute difference by the `limit`, rounding up to the nearest integer. This gives the minimum number of elements needed to add to make the sum of the array `nums` equal to `goal` while maintaining the property that `abs(nums[i]) <= limit`.\n    "}
{"id": 1788, "slug": "maximize-the-beauty-of-the-garden", "title": "Maximize the Beauty of the Garden", "difficulty": "Hard", "content": "There is a garden of `n` flowers, and each flower has an integer beauty value. The flowers are arranged in a line. You are given an integer array `flowers` of size `n` and each `flowers[i]` represents the beauty of the `ith` flower.\n\nA garden is **valid** if it meets these conditions:\n\n*   The garden has at least two flowers.\n*   The first and the last flower of the garden have the same beauty value.\n\nAs the appointed gardener, you have the ability to **remove** any (possibly none) flowers from the garden. You want to remove flowers in a way that makes the remaining garden **valid**. The beauty of the garden is the sum of the beauty of all the remaining flowers.\n\nReturn the maximum possible beauty of some **valid** garden after you have removed any (possibly none) flowers.\n\n**Example 1:**\n\n**Input:** flowers = \\[1,2,3,1,2\\]\n**Output:** 8\n**Explanation:** You can produce the valid garden \\[2,3,1,2\\] to have a total beauty of 2 + 3 + 1 + 2 = 8.\n\n**Example 2:**\n\n**Input:** flowers = \\[100,1,1,-3,1\\]\n**Output:** 3\n**Explanation:** You can produce the valid garden \\[1,1,1\\] to have a total beauty of 1 + 1 + 1 = 3.\n\n**Example 3:**\n\n**Input:** flowers = \\[-1,-2,0,-1\\]\n**Output:** -2\n**Explanation:** You can produce the valid garden \\[-1,-1\\] to have a total beauty of -1 + -1 = -2.\n\n**Constraints:**\n\n*   `2 <= flowers.length <= 105`\n*   `-104 <= flowers[i] <= 104`\n*   It is possible to create a valid garden by removing some (possibly none) flowers.", "java": "\n    ```java\npublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\n    int n = aliceValues.length;\n    Integer[] indexes = new Integer[n];\n    for (int i = 0; i < n; ++i) {\n        indexes[i] = i;\n    }\n\n    Arrays.sort(indexes, (a, b) -> (bobValues[b] + aliceValues[b]) - (bobValues[a] + aliceValues[a]));\n    \n    int aliceScore = 0, bobScore = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) aliceScore += aliceValues[indexes[i]];\n        else bobScore += bobValues[indexes[i]];\n    }\n    \n    return Integer.compare(aliceScore, bobScore);\n}\n```\n    \n    The game is played optimally. Therefore, each player will pick the stones that maximize the difference in scores. To achieve this, both players will consider the sum of their values and the opponent's values for each stone. Sort the stone indices in descending order according to the sums of Alice's and Bob's values. Then, each player takes turns picking stones according to this sorted order. Calculate the total scores for Alice and Bob. Finally, return 0 if the scores are equal, 1 if Alice has a higher score, and -1 if Bob has a higher score.\n    ", "c++": "\n    ```cpp\nint stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\n    int n = aliceValues.size();\n    vector<pair<int, int>> sums;\n    \n    for (int i = 0; i < n; ++i) {\n        sums.push_back({aliceValues[i] + bobValues[i], i});\n    }\n    \n    sort(sums.rbegin(), sums.rend());\n    \n    int aliceScore = 0, bobScore = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) aliceScore += aliceValues[sums[i].second];\n        else bobScore += bobValues[sums[i].second];\n    }\n    \n    return (aliceScore == bobScore) ? 0 : (aliceScore > bobScore) ? 1 : -1;\n}\n```\n    \n    The game is played optimally. Therefore, each player will pick the stones that maximize the difference in scores. To achieve this, both players will consider the sum of their values and the opponent's values for each stone. Sort the stone indices in descending order according to the sums of Alice's and Bob's values. Then, each player takes turns picking stones according to this sorted order. Calculate the total scores for Alice and Bob. Finally, return 0 if the scores are equal, 1 if Alice has a higher score, and -1 if Bob has a higher score.\n    ", "python": "\n    ```python\ndef stoneGameVI(aliceValues, bobValues):\n    n = len(aliceValues)\n    sums = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)\n    \n    aliceScore = sum(aliceValues[i] for _, i in sums[::2])\n    bobScore = sum(bobValues[i] for _, i in sums[1::2])\n    \n    return 0 if aliceScore == bobScore else 1 if aliceScore > bobScore else -1\n```\n    \n    The game is played optimally. Therefore, each player will pick the stones that maximize the difference in scores. To achieve this, both players will consider the sum of their values and the opponent's values for each stone. Sort the stone indices in descending order according to the sums of Alice's and Bob's values. Then, each player takes turns picking stones according to this sorted order. Calculate the total scores for Alice and Bob. Finally, return 0 if the scores are equal, 1 if Alice has a higher score, and -1 if Bob has a higher score.\n    ", "javascript": "\n    ```javascript\nfunction stoneGameVI(aliceValues, bobValues) {\n    const n = aliceValues.length;\n    const sums = aliceValues.map((v, i) => [v + bobValues[i], i]).sort((a, b) => b[0] - a[0]);\n\n    let aliceScore = 0, bobScore = 0;\n    for (let i = 0; i < n; ++i) {\n        if (i % 2 === 0) aliceScore += aliceValues[sums[i][1]];\n        else bobScore += bobValues[sums[i][1]];\n    }\n\n    return aliceScore === bobScore ? 0 : aliceScore > bobScore ? 1 : -1;\n}\n```\n    \n    The game is played optimally. Therefore, each player will pick the stones that maximize the difference in scores. To achieve this, both players will consider the sum of their values and the opponent's values for each stone. Sort the stone indices in descending order according to the sums of Alice's and Bob's values. Then, each player takes turns picking stones according to this sorted order. Calculate the total scores for Alice and Bob. Finally, return 0 if the scores are equal, 1 if Alice has a higher score, and -1 if Bob has a higher score.\n    "}
{"id": 1792, "slug": "maximum-average-pass-ratio", "title": "Maximum Average Pass Ratio", "difficulty": "Medium", "content": "There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array `classes`, where `classes[i] = [passi, totali]`. You know beforehand that in the `ith` class, there are `totali` total students, but only `passi` number of students will pass the exam.\n\nYou are also given an integer `extraStudents`. There are another `extraStudents` brilliant students that are **guaranteed** to pass the exam of any class they are assigned to. You want to assign each of the `extraStudents` students to a class in a way that **maximizes** the **average** pass ratio across **all** the classes.\n\nThe **pass ratio** of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The **average pass ratio** is the sum of pass ratios of all the classes divided by the number of the classes.\n\nReturn _the **maximum** possible average pass ratio after assigning the_ `extraStudents` _students._ Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** classes = \\[\\[1,2\\],\\[3,5\\],\\[2,2\\]\\], `extraStudents` = 2\n**Output:** 0.78333\n**Explanation:** You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.\n\n**Example 2:**\n\n**Input:** classes = \\[\\[2,4\\],\\[3,9\\],\\[4,5\\],\\[2,10\\]\\], `extraStudents` = 4\n**Output:** 0.53485\n\n**Constraints:**\n\n*   `1 <= classes.length <= 105`\n*   `classes[i].length == 2`\n*   `1 <= passi <= totali <= 105`\n*   `1 <= extraStudents <= 105`", "java": "\n    ```java\nimport java.util.Stack;\n\npublic int[] mostCompetitive(int[] nums, int k) {\n    Stack<Integer> stack = new Stack<>();\n    int n = nums.length;\n\n    for (int i = 0; i < n; i++) {\n        while (!stack.isEmpty() && nums[i] < stack.peek() && stack.size() + n - i > k) {\n            stack.pop();\n        }\n        if (stack.size() < k) {\n            stack.push(nums[i]);\n        }\n    }\n\n    int[] result = new int[k];\n    for (int i = k - 1; i >= 0; i--) {\n        result[i] = stack.pop();\n    }\n\n    return result;\n}\n```\n    \n    The algorithm utilizes a stack and goes through the `nums` array once. It decides whether to add an element to the stack based on the following criteria: \n1. The stack is not empty (to allow pop operation).\n2. The current element is smaller than the top element of the stack (the most recent element).\n3. The sum of stack size and remaining elements (n - i) in the array is greater than k, ensuring that we have enough elements left to form a subsequence of size `k`.\n\nThen, if the stack size is less than `k`, we add the current element of `nums` to the stack.\n\nFinally, we pop out the elements and add them to the result array in a reversed order, creating the most competitive subsequence with size `k`.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\n\nstd::vector<int> mostCompetitive(std::vector<int>& nums, int k) {\n    std::stack<int> stk;\n    int n = nums.size();\n\n    for (int i = 0; i < n; i++) {\n        while (!stk.empty() && nums[i] < stk.top() && stk.size() + n - i > k) {\n            stk.pop();\n        }\n        if (stk.size() < k) {\n            stk.push(nums[i]);\n        }\n    }\n\n    std::vector<int> result(k);\n    for (int i = k - 1; i >= 0; i--) {\n        result[i] = stk.top();\n        stk.pop();\n    }\n\n    return result;\n}\n```\n    \n    The algorithm utilizes a stack and goes through the `nums` array once. It decides whether to add an element to the stack based on the following criteria: \n1. The stack is not empty (to allow pop operation).\n2. The current element is smaller than the top element of the stack (the most recent element).\n3. The sum of stack size and remaining elements (n - i) in the array is greater than k, ensuring that we have enough elements left to form a subsequence of size `k`.\n\nThen, if the stack size is less than `k`, we add the current element of `nums` to the stack.\n\nFinally, we pop out the elements and add them to the result array in a reversed order, creating the most competitive subsequence with size `k`.\n    ", "python": "\n    ```python\ndef most_competitive(nums, k):\n    stack = []\n    n = len(nums)\n\n    for i in range(n):\n        while stack and nums[i] < stack[-1] and len(stack) + n - i > k:\n            stack.pop()\n        if len(stack) < k:\n            stack.append(nums[i])\n\n    return stack\n```\n    \n    The algorithm utilizes a stack and goes through the `nums` array once. It decides whether to add an element to the stack based on the following criteria: \n1. The stack is not empty (to allow pop operation).\n2. The current element is smaller than the top element of the stack (the most recent element).\n3. The sum of stack size and remaining elements (n - i) in the array is greater than k, ensuring that we have enough elements left to form a subsequence of size `k`.\n\nThen, if the stack size is less than `k`, we add the current element of `nums` to the stack.\n\nFinally, we pop out the elements and add them to the result array in a reversed order, creating the most competitive subsequence with size `k`.\n    ", "javascript": "\n    ```javascript\nfunction mostCompetitive(nums, k) {\n    const stack = [];\n    const n = nums.length;\n\n    for (let i = 0; i < n; i++) {\n        while (stack.length > 0 && nums[i] < stack[stack.length - 1] && stack.length + n - i > k) {\n            stack.pop();\n        }\n        if (stack.length < k) {\n            stack.push(nums[i]);\n        }\n    }\n\n    return stack;\n}\n```\n    \n    The algorithm utilizes a stack and goes through the `nums` array once. It decides whether to add an element to the stack based on the following criteria: \n1. The stack is not empty (to allow pop operation).\n2. The current element is smaller than the top element of the stack (the most recent element).\n3. The sum of stack size and remaining elements (n - i) in the array is greater than k, ensuring that we have enough elements left to form a subsequence of size `k`.\n\nThen, if the stack size is less than `k`, we add the current element of `nums` to the stack.\n\nFinally, we pop out the elements and add them to the result array in a reversed order, creating the most competitive subsequence with size `k`.\n    "}
{"id": 1794, "slug": "count-pairs-of-equal-substrings-with-minimum-difference", "title": "Count Pairs of Equal Substrings With Minimum Difference", "difficulty": "Medium", "content": "You are given two strings `firstString` and `secondString` that are **0-indexed** and consist only of lowercase English letters. Count the number of index quadruples `(i,j,a,b)` that satisfy the following conditions:\n\n*   `0 <= i <= j < firstString.length`\n*   `0 <= a <= b < secondString.length`\n*   The substring of `firstString` that starts at the `ith` character and ends at the `jth` character (inclusive) is **equal** to the substring of `secondString` that starts at the `ath` character and ends at the `bth` character (inclusive).\n*   `j - a` is the **minimum** possible value among all quadruples that satisfy the previous conditions.\n\nReturn _the **number** of such quadruples_.\n\n**Example 1:**\n\n**Input:** firstString =  \"abcd \", secondString =  \"bccda \"\n**Output:** 1\n**Explanation:** The quadruple (0,0,4,4) is the only one that satisfies all the conditions and minimizes j - a.\n\n**Example 2:**\n\n**Input:** firstString =  \"ab \", secondString =  \"cd \"\n**Output:** 0\n**Explanation:** There are no quadruples satisfying all the conditions.\n\n**Constraints:**\n\n*   `1 <= firstString.length, secondString.length <= 2 * 105`\n*   Both strings consist only of lowercase English letters.", "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int minimumDeviation(int[] nums) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n    int min_val = Integer.MAX_VALUE;\n    \n    for (int num : nums) {\n        if (num % 2 == 0) {\n            pq.offer(num);\n        } else {\n            pq.offer(num * 2);\n        }\n        min_val = Math.min(min_val, num);\n    }\n    \n    int result = Integer.MAX_VALUE;\n    while (true) {\n        int top = pq.poll();\n        result = Math.min(result, top - min_val);\n        \n        if (top % 2 == 1) break;\n        pq.offer(top / 2);\n        min_val = Math.min(min_val, top / 2);\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize a max priority queue and find the minimum value of the input array.\n2. Double the odd number elements in the array and push all the elements into the max priority queue.\n3. While the maximum value in the queue is even, divide the maximum value by 2 and push it back into the queue.\n4. Calculate the deviation as the difference between the max value and the min value and minimize the result.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint minimumDeviation(vector<int>& nums) {\n    priority_queue<int> pq;\n    int min_val = INT_MAX;\n    int n = nums.size();\n    \n    for (int num: nums) {\n        if (num % 2 == 0) {\n            pq.push(num);\n        } else {\n            pq.push(num * 2);\n        }\n        min_val = min(min_val, num);\n    }\n    \n    int result = INT_MAX;\n    while (true) {\n        int top = pq.top();\n        pq.pop();\n        result = min(result, top - min_val);\n        \n        if (top % 2 == 1) break;\n        pq.push(top / 2);\n        min_val = min(min_val, top / 2);\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize a max priority queue and find the minimum value of the input array.\n2. Double the odd number elements in the array and push all the elements into the max priority queue.\n3. While the maximum value in the queue is even, divide the maximum value by 2 and push it back into the queue.\n4. Calculate the deviation as the difference between the max value and the min value and minimize the result.\n    ", "python": "\n    ```python\nimport heapq\n\ndef minimum_deviation(nums):\n    pq = []\n    min_val = float(\"inf\")\n\n    for num in nums:\n        if num % 2 == 0:\n            heapq.heappush(pq, -num)\n        else:\n            heapq.heappush(pq, -(num * 2))\n        min_val = min(min_val, num)\n\n    result = float(\"inf\")\n    while True:\n        top = -heapq.heappop(pq)\n        result = min(result, top - min_val)\n\n        if top % 2 == 1:\n            break\n        heapq.heappush(pq, -(top // 2))\n        min_val = min(min_val, top // 2)\n\n    return result\n```\n\n    \n    1. Initialize a max priority queue and find the minimum value of the input array.\n2. Double the odd number elements in the array and push all the elements into the max priority queue.\n3. While the maximum value in the queue is even, divide the maximum value by 2 and push it back into the queue.\n4. Calculate the deviation as the difference between the max value and the min value and minimize the result.\n    ", "javascript": "\n    ```javascript\nfunction minimumDeviation(nums) {\n    const pq = new MaxPriorityQueue();\n    let min_val = Infinity;\n\n    for (const num of nums) {\n        if (num % 2 === 0) {\n            pq.enqueue(num);\n        } else {\n            pq.enqueue(num * 2);\n        }\n        min_val = Math.min(min_val, num);\n    }\n\n    let result = Infinity;\n    while (true) {\n        const top = pq.dequeue().element;\n        result = Math.min(result, top - min_val);\n\n        if (top % 2 === 1) break;\n        pq.enqueue(Math.floor(top / 2));\n        min_val = Math.min(min_val, Math.floor(top / 2));\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize a max priority queue and find the minimum value of the input array.\n2. Double the odd number elements in the array and push all the elements into the max priority queue.\n3. While the maximum value in the queue is even, divide the maximum value by 2 and push it back into the queue.\n4. Calculate the deviation as the difference between the max value and the min value and minimize the result.\n    "}
{"id": 1798, "slug": "maximum-number-of-consecutive-values-you-can-make", "title": "Maximum Number of Consecutive Values You Can Make", "difficulty": "Medium", "content": "You are given an integer array `coins` of length `n` which represents the `n` coins that you own. The value of the `ith` coin is `coins[i]`. You can **make** some value `x` if you can choose some of your `n` coins such that their values sum up to `x`.\n\nReturn the _maximum number of consecutive integer values that you **can** **make** with your coins **starting** from and **including**_ `0`.\n\nNote that you may have multiple coins of the same value.\n\n**Example 1:**\n\n**Input:** coins = \\[1,3\\]\n**Output:** 2\n**Explanation:** You can make the following values:\n- 0: take \\[\\]\n- 1: take \\[1\\]\nYou can make 2 consecutive integer values starting from 0.\n\n**Example 2:**\n\n**Input:** coins = \\[1,1,1,4\\]\n**Output:** 8\n**Explanation:** You can make the following values:\n- 0: take \\[\\]\n- 1: take \\[1\\]\n- 2: take \\[1,1\\]\n- 3: take \\[1,1,1\\]\n- 4: take \\[4\\]\n- 5: take \\[4,1\\]\n- 6: take \\[4,1,1\\]\n- 7: take \\[4,1,1,1\\]\nYou can make 8 consecutive integer values starting from 0.\n\n**Example 3:**\n\n**Input:** nums = \\[1,4,10,3,1\\]\n**Output:** 20\n\n**Constraints:**\n\n*   `coins.length == n`\n*   `1 <= n <= 4 * 104`\n*   `1 <= coins[i] <= 4 * 104`", "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int maxOperations(int[] nums, int k) {\n    Map<Integer, Integer> count = new HashMap<>();\n    int operations = 0;\n\n    for (int num : nums) {\n        if (count.getOrDefault(k - num, 0) > 0) {\n            count.put(k - num, count.get(k - num) - 1);\n            operations++;\n        }\n        else {\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n    }\n\n    return operations;\n}\n```\n\n    \n    The algorithm uses a hashmap (called \"count\") to store the count of each number in the array. For each number in the array, it checks if there is a complementary number, i.e., if the difference, `k - number`, is present in the hashmap with count greater than 0.\n\nIf found, it decrements the count and increments the operations performed. If not, it increments the count of the number in the hashmap. This process is performed for each number, and finally, the number of operations is returned. \n\nThis algorithm effectively iterates and counts the complement pairs in linear time (O(n)), where n is the length of the input array.\n    ", "c++": "\n    ```cpp\n#include <unordered_map>\n\nint maxOperations(std::vector<int>& nums, int k) {\n    std::unordered_map<int, int> count;\n    int operations = 0;\n\n    for (int num : nums) {\n        if (count[k - num] > 0) {\n            --count[k - num];\n            ++operations;\n        }\n        else {\n            ++count[num];\n        }\n    }\n\n    return operations;\n}\n```\n\n    \n    The algorithm uses a hashmap (called \"count\") to store the count of each number in the array. For each number in the array, it checks if there is a complementary number, i.e., if the difference, `k - number`, is present in the hashmap with count greater than 0.\n\nIf found, it decrements the count and increments the operations performed. If not, it increments the count of the number in the hashmap. This process is performed for each number, and finally, the number of operations is returned. \n\nThis algorithm effectively iterates and counts the complement pairs in linear time (O(n)), where n is the length of the input array.\n    ", "python": "\n    ```python\ndef maxOperations(nums, k):\n    count = {}\n    operations = 0\n\n    for num in nums:\n        if count.get(k - num, 0) > 0:\n            count[k - num] -= 1\n            operations += 1\n        else:\n            count[num] = count.get(num, 0) + 1\n\n    return operations\n```\n\n    \n    The algorithm uses a hashmap (called \"count\") to store the count of each number in the array. For each number in the array, it checks if there is a complementary number, i.e., if the difference, `k - number`, is present in the hashmap with count greater than 0.\n\nIf found, it decrements the count and increments the operations performed. If not, it increments the count of the number in the hashmap. This process is performed for each number, and finally, the number of operations is returned. \n\nThis algorithm effectively iterates and counts the complement pairs in linear time (O(n)), where n is the length of the input array.\n    ", "javascript": "\n    ```javascript\nfunction maxOperations(nums, k) {\n    let count = {};\n    let operations = 0;\n\n    for (let num of nums) {\n        if (count[k - num] > 0) {\n            count[k - num]--;\n            operations++;\n        }\n        else {\n            count[num] = (count[num] || 0) + 1;\n        }\n    }\n\n    return operations;\n}\n```\n\n    \n    The algorithm uses a hashmap (called \"count\") to store the count of each number in the array. For each number in the array, it checks if there is a complementary number, i.e., if the difference, `k - number`, is present in the hashmap with count greater than 0.\n\nIf found, it decrements the count and increments the operations performed. If not, it increments the count of the number in the hashmap. This process is performed for each number, and finally, the number of operations is returned. \n\nThis algorithm effectively iterates and counts the complement pairs in linear time (O(n)), where n is the length of the input array.\n    "}
{"id": 1802, "slug": "maximum-value-at-a-given-index-in-a-bounded-array", "title": "Maximum Value at a Given Index in a Bounded Array", "difficulty": "Medium", "content": "You are given three positive integers: `n`, `index`, and `maxSum`. You want to construct an array `nums` (**0-indexed**) that satisfies the following conditions:\n\n*   `nums.length == n`\n*   `nums[i]` is a **positive** integer where `0 <= i < n`.\n*   `abs(nums[i] - nums[i+1]) <= 1` where `0 <= i < n-1`.\n*   The sum of all the elements of `nums` does not exceed `maxSum`.\n*   `nums[index]` is **maximized**.\n\nReturn `nums[index]` _of the constructed array_.\n\nNote that `abs(x)` equals `x` if `x >= 0`, and `-x` otherwise.\n\n**Example 1:**\n\n**Input:** n = 4, index = 2,  maxSum = 6\n**Output:** 2\n**Explanation:** nums = \\[1,2,**2**,1\\] is one array that satisfies all the conditions.\nThere are no arrays that satisfy all the conditions and have nums\\[2\\] == 3, so 2 is the maximum nums\\[2\\].\n\n**Example 2:**\n\n**Input:** n = 6, index = 1,  maxSum = 10\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= n <= maxSum <= 109`\n*   `0 <= index < n`", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int countStudents(int[] students, int[] sandwiches) {\n        Queue<Integer> queue = new LinkedList<>();\n        for (int student : students) {\n            queue.add(student);\n        }\n\n        int index = 0, attempts = 0;\n        while (!queue.isEmpty()) {\n            int student = queue.peek();\n            if (student == sandwiches[index]) {\n                queue.poll();\n                index++;\n                attempts = 0;\n            } else {\n                queue.add(queue.poll());\n                attempts++;\n            }\n            if (attempts == queue.size()) break;\n        }\n\n        return queue.size();\n    }\n}\n```\n    \n    The algorithm starts by copying the students' preferences into a queue. Then, it iterates through the sandwiches and in each step, it checks if the student at the front of the queue matches the current sandwich on the stack. If the student prefers the current sandwich, they leave the queue as they can eat, and the iterator moves to the next sandwich. If the student does not prefer the current sandwich, they are moved to the back of the queue so that the next student has a chance to take the sandwich. The process continues until either all students get a sandwich or no student left in the queue can accept any further sandwiches (when the number of attempts becomes equal to the number of students remaining in the queue).\n\nFinally, the algorithm returns the number of students still in the queue (i.e., those who were unable to get a sandwich).\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint countStudents(vector<int>& students, vector<int>& sandwiches) {\n    queue<int> q;\n    for (int student : students)\n        q.push(student);\n\n    int index = 0, attempts = 0;\n    while (!q.empty()) {\n        int student = q.front();\n        if (student == sandwiches[index]) {\n            q.pop();\n            index++;\n            attempts = 0;\n        } else {\n            q.pop();\n            q.push(student);\n            attempts++;\n        }\n        if (attempts == q.size())\n            break;\n    }\n\n    return q.size();\n}\n```\n    \n    The algorithm starts by copying the students' preferences into a queue. Then, it iterates through the sandwiches and in each step, it checks if the student at the front of the queue matches the current sandwich on the stack. If the student prefers the current sandwich, they leave the queue as they can eat, and the iterator moves to the next sandwich. If the student does not prefer the current sandwich, they are moved to the back of the queue so that the next student has a chance to take the sandwich. The process continues until either all students get a sandwich or no student left in the queue can accept any further sandwiches (when the number of attempts becomes equal to the number of students remaining in the queue).\n\nFinally, the algorithm returns the number of students still in the queue (i.e., those who were unable to get a sandwich).\n    ", "python": "\n    ```python\nfrom collections import deque\n\ndef countStudents(students, sandwiches):\n    queue = deque(students)\n    index, attempts = 0, 0\n\n    while queue:\n        student = queue[0]\n        if student == sandwiches[index]:\n            queue.popleft()\n            index += 1\n            attempts = 0\n        else:\n            queue.rotate(-1)\n            attempts += 1\n\n        if attempts == len(queue):\n            break\n\n    return len(queue)\n```\n    \n    The algorithm starts by copying the students' preferences into a queue. Then, it iterates through the sandwiches and in each step, it checks if the student at the front of the queue matches the current sandwich on the stack. If the student prefers the current sandwich, they leave the queue as they can eat, and the iterator moves to the next sandwich. If the student does not prefer the current sandwich, they are moved to the back of the queue so that the next student has a chance to take the sandwich. The process continues until either all students get a sandwich or no student left in the queue can accept any further sandwiches (when the number of attempts becomes equal to the number of students remaining in the queue).\n\nFinally, the algorithm returns the number of students still in the queue (i.e., those who were unable to get a sandwich).\n    ", "javascript": "\n    ```javascript\nfunction countStudents(students, sandwiches) {\n    let queue = [...students];\n    let index = 0, attempts = 0;\n\n    while (queue.length) {\n        let student = queue[0];\n        if (student === sandwiches[index]) {\n            queue.shift();\n            index++;\n            attempts = 0;\n        } else {\n            queue.push(queue.shift());\n            attempts++;\n        }\n        if (attempts === queue.length) break;\n    }\n\n    return queue.length;\n}\n```\n    \n    The algorithm starts by copying the students' preferences into a queue. Then, it iterates through the sandwiches and in each step, it checks if the student at the front of the queue matches the current sandwich on the stack. If the student prefers the current sandwich, they leave the queue as they can eat, and the iterator moves to the next sandwich. If the student does not prefer the current sandwich, they are moved to the back of the queue so that the next student has a chance to take the sandwich. The process continues until either all students get a sandwich or no student left in the queue can accept any further sandwiches (when the number of attempts becomes equal to the number of students remaining in the queue).\n\nFinally, the algorithm returns the number of students still in the queue (i.e., those who were unable to get a sandwich).\n    "}
{"id": 1824, "slug": "minimum-sideway-jumps", "title": "Minimum Sideway Jumps", "difficulty": "Medium", "content": "There is a **3 lane road** of length `n` that consists of `n + 1` **points** labeled from `0` to `n`. A frog **starts** at point `0` in the **second** lane and wants to jump to point `n`. However, there could be obstacles along the way.\n\nYou are given an array `obstacles` of length `n + 1` where each `obstacles[i]` (**ranging from 0 to 3**) describes an obstacle on the lane `obstacles[i]` at point `i`. If `obstacles[i] == 0`, there are no obstacles at point `i`. There will be **at most one** obstacle in the 3 lanes at each point.\n\n*   For example, if `obstacles[2] == 1`, then there is an obstacle on lane 1 at point 2.\n\nThe frog can only travel from point `i` to point `i + 1` on the same lane if there is not an obstacle on the lane at point `i + 1`. To avoid obstacles, the frog can also perform a **side jump** to jump to **another** lane (even if they are not adjacent) at the **same** point if there is no obstacle on the new lane.\n\n*   For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\nReturn _the **minimum number of side jumps** the frog needs to reach **any lane** at point n starting from lane `2` at point 0._\n\n**Note:** There will be no obstacles on points `0` and `n`.\n\n**Example 1:**\n\n**Input:** obstacles = \\[0,1,2,3,0\\]\n**Output:** 2 \n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n\n**Example 2:**\n\n**Input:** obstacles = \\[0,1,1,3,3,0\\]\n**Output:** 0\n**Explanation:** There are no obstacles on lane 2. No side jumps are required.\n\n**Example 3:**\n\n**Input:** obstacles = \\[0,2,1,0,3,0\\]\n**Output:** 2\n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps.\n\n**Constraints:**\n\n*   `obstacles.length == n + 1`\n*   `1 <= n <= 5 * 105`\n*   `0 <= obstacles[i] <= 3`\n*   `obstacles[0] == obstacles[n] == 0`", "java": "\n    ```java\nimport java.util.*;\n\npublic int eatenApples(int[] apples, int[] days) {\n    int n = apples.length;\n    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n    int ans = 0;\n\n    for (int i = 0; i < n || !pq.isEmpty(); ++i) {\n        if (i < n && apples[i] > 0) {\n            pq.offer(new int[]{i + days[i], apples[i]});\n        }\n\n        while (!pq.isEmpty() && pq.peek()[0] <= i) {\n            pq.poll();\n        }\n\n        if (!pq.isEmpty()) {\n            ans++;\n            int[] curr_apple = pq.poll();\n            if (curr_apple[1] > 1) {\n                curr_apple[1]--;\n                pq.offer(curr_apple);\n            }\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    To find the maximum number of apples that can be eaten, we can use the following greedy approach using min-heap (priority_queue):\n\n1. Iterate through the days 0 to n, and for each day, add the apples grown and its expiration date (`i + days[i]`) to the min-heap.\n2. Keep popping elements from the min-heap if their expiration date is less than or equal to the current day, as they are not edible anymore.\n3. If the min-heap is not empty, eat one apple from the least expiration date, and reduce its count by 1. Put it back in the min-heap if there are more apples with that expiration date.\n4. Keep this process up until we've checked all the apples.\n\nThe time complexity of this solution is O(n log n) due to the use of a min-heap.\n    ", "c++": "\n    ```cpp\n#include <queue>\n\nint eatenApples(vector<int>& apples, vector<int>& days) {\n    int n = apples.size();\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    int ans = 0;\n\n    for (int i = 0; i < n || !pq.empty(); ++i) {\n        if (i < n && apples[i] > 0) {\n            pq.push({i + days[i], apples[i]});\n        }\n\n        while (!pq.empty() && pq.top().first <= i) {\n            pq.pop();\n        }\n\n        if (!pq.empty()) {\n            ans++;\n            auto curr_apple = pq.top();\n            pq.pop();\n            if (curr_apple.second > 1) {\n                curr_apple.second--;\n                pq.push(curr_apple);\n            }\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    To find the maximum number of apples that can be eaten, we can use the following greedy approach using min-heap (priority_queue):\n\n1. Iterate through the days 0 to n, and for each day, add the apples grown and its expiration date (`i + days[i]`) to the min-heap.\n2. Keep popping elements from the min-heap if their expiration date is less than or equal to the current day, as they are not edible anymore.\n3. If the min-heap is not empty, eat one apple from the least expiration date, and reduce its count by 1. Put it back in the min-heap if there are more apples with that expiration date.\n4. Keep this process up until we've checked all the apples.\n\nThe time complexity of this solution is O(n log n) due to the use of a min-heap.\n    ", "python": "\n    ```python\nimport heapq\n\ndef eatenApples(apples, days):\n    n = len(apples)\n    pq = []\n    ans = 0\n\n    for i in range(n + 1):\n        if i < n and apples[i] > 0:\n            heapq.heappush(pq, (i + days[i], apples[i]))\n\n        while pq and pq[0][0] <= i:\n            heapq.heappop(pq)\n\n        if pq:\n            ans += 1\n            curr_apple = heapq.heappop(pq)\n            if curr_apple[1] > 1:\n                heapq.heappush(pq, (curr_apple[0], curr_apple[1] - 1))\n\n    return ans\n```\n\n    \n    To find the maximum number of apples that can be eaten, we can use the following greedy approach using min-heap (priority_queue):\n\n1. Iterate through the days 0 to n, and for each day, add the apples grown and its expiration date (`i + days[i]`) to the min-heap.\n2. Keep popping elements from the min-heap if their expiration date is less than or equal to the current day, as they are not edible anymore.\n3. If the min-heap is not empty, eat one apple from the least expiration date, and reduce its count by 1. Put it back in the min-heap if there are more apples with that expiration date.\n4. Keep this process up until we've checked all the apples.\n\nThe time complexity of this solution is O(n log n) due to the use of a min-heap.\n    ", "javascript": "\n    ```javascript\nfunction eatenApples(apples, days) {\n    const n = apples.length;\n    const pq = new PriorityQueue();\n    let ans = 0;\n\n    for (let i = 0; i < n || !pq.isEmpty(); ++i) {\n        if (i < n && apples[i] > 0) {\n            pq.enqueue([i + days[i], apples[i]]);\n        }\n\n        while (!pq.isEmpty() && pq.peek()[0] <= i) {\n            pq.dequeue();\n        }\n\n        if (!pq.isEmpty()) {\n            ans++;\n            let curr_apple = pq.dequeue();\n            if (curr_apple[1] > 1) {\n                curr_apple[1]--;\n                pq.enqueue(curr_apple);\n            }\n        }\n    }\n\n    return ans;\n}\n\nclass PriorityQueue {\n    constructor(comparator = (a, b) => a[0] - b[0]) {\n        this._comparator = comparator;\n        this._queue = [];\n    }\n\n    // Additional methods and details omitted ...\n}\n```\n\n    \n    To find the maximum number of apples that can be eaten, we can use the following greedy approach using min-heap (priority_queue):\n\n1. Iterate through the days 0 to n, and for each day, add the apples grown and its expiration date (`i + days[i]`) to the min-heap.\n2. Keep popping elements from the min-heap if their expiration date is less than or equal to the current day, as they are not edible anymore.\n3. If the min-heap is not empty, eat one apple from the least expiration date, and reduce its count by 1. Put it back in the min-heap if there are more apples with that expiration date.\n4. Keep this process up until we've checked all the apples.\n\nThe time complexity of this solution is O(n log n) due to the use of a min-heap.\n    "}
{"id": 1827, "slug": "minimum-operations-to-make-the-array-increasing", "title": "Minimum Operations to Make the Array Increasing", "difficulty": "Easy", "content": "You are given an integer array `nums` (**0-indexed**). In one operation, you can choose an element of the array and increment it by `1`.\n\n*   For example, if `nums = [1,2,3]`, you can choose to increment `nums[1]` to make `nums = [1,**3**,3]`.\n\nReturn _the **minimum** number of operations needed to make_ `nums` _**strictly** **increasing**._\n\nAn array `nums` is **strictly increasing** if `nums[i] < nums[i+1]` for all `0 <= i < nums.length - 1`. An array of length `1` is trivially strictly increasing.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** 3\n**Explanation:** You can do the following operations:\n1) Increment nums\\[2\\], so nums becomes \\[1,1,**2**\\].\n2) Increment nums\\[1\\], so nums becomes \\[1,**2**,2\\].\n3) Increment nums\\[2\\], so nums becomes \\[1,2,**3**\\].\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,2,4,1\\]\n**Output:** 14\n\n**Example 3:**\n\n**Input:** nums = \\[8\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `1 <= nums[i] <= 104`", "java": "\n    ```java\npublic int minOperations(int[] nums) {\n    int operations = 0;\n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] <= nums[i - 1]) {\n            operations += (nums[i - 1] - nums[i]) + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm iterates through the input array `nums` from the second element (index 1) to the end. For each element, if it is less than or equal to its previous element, we need to increment it to make the array strictly increasing. We calculate the difference between the current element and the previous element and add 1 to it to find the required number of increments. We then update both the element in the array and the total count of operations. At the end, we return the total count of operations.\n    ", "c++": "\n    ```cpp\nint min_operations(vector<int>& nums) {\n    int operations = 0;\n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] <= nums[i - 1]) {\n            operations += (nums[i - 1] - nums[i]) + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm iterates through the input array `nums` from the second element (index 1) to the end. For each element, if it is less than or equal to its previous element, we need to increment it to make the array strictly increasing. We calculate the difference between the current element and the previous element and add 1 to it to find the required number of increments. We then update both the element in the array and the total count of operations. At the end, we return the total count of operations.\n    ", "python": "\n    ```python\ndef min_operations(nums):\n    operations = 0\n    for i in range(1, len(nums)):\n        if nums[i] <= nums[i - 1]:\n            operations += (nums[i - 1] - nums[i]) + 1\n            nums[i] = nums[i - 1] + 1\n    return operations\n```\n    \n    The algorithm iterates through the input array `nums` from the second element (index 1) to the end. For each element, if it is less than or equal to its previous element, we need to increment it to make the array strictly increasing. We calculate the difference between the current element and the previous element and add 1 to it to find the required number of increments. We then update both the element in the array and the total count of operations. At the end, we return the total count of operations.\n    ", "javascript": "\n    ```javascript\nfunction minOperations(nums) {\n    let operations = 0;\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] <= nums[i - 1]) {\n            operations += (nums[i - 1] - nums[i]) + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm iterates through the input array `nums` from the second element (index 1) to the end. For each element, if it is less than or equal to its previous element, we need to increment it to make the array strictly increasing. We calculate the difference between the current element and the previous element and add 1 to it to find the required number of increments. We then update both the element in the array and the total count of operations. At the end, we return the total count of operations.\n    "}
{"id": 1833, "slug": "maximum-ice-cream-bars", "title": "Maximum Ice Cream Bars", "difficulty": "Medium", "content": "It is a sweltering summer day, and a boy wants to buy some ice cream bars.\n\nAt the store, there are `n` ice cream bars. You are given an array `costs` of length `n`, where `costs[i]` is the price of the `ith` ice cream bar in coins. The boy initially has `coins` coins to spend, and he wants to buy as many ice cream bars as possible.\n\n**Note:** The boy can buy the ice cream bars in any order.\n\nReturn _the **maximum** number of ice cream bars the boy can buy with_ `coins` _coins._\n\nYou must solve the problem by counting sort.\n\n**Example 1:**\n\n**Input:** costs = \\[1,3,2,4,1\\], coins = 7\n**Output:** 4\n**Explanation:** The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.\n\n**Example 2:**\n\n**Input:** costs = \\[10,6,8,7,7,8\\], coins = 5\n**Output:** 0\n**Explanation:** The boy cannot afford any of the ice cream bars.\n\n**Example 3:**\n\n**Input:** costs = \\[1,6,3,1,2,5\\], coins = 20\n**Output:** 6\n**Explanation:** The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18.\n\n**Constraints:**\n\n*   `costs.length == n`\n*   `1 <= n <= 105`\n*   `1 <= costs[i] <= 105`\n*   `1 <= coins <= 108`", "java": "\n    ```java\npublic int largestAltitude(int[] gain) {\n    int max_altitude = 0, current_altitude = 0;\n    for (int i = 0; i < gain.length; i++) {\n        current_altitude += gain[i];\n        max_altitude = Math.max(max_altitude, current_altitude);\n    }\n    return max_altitude;\n}\n```\n    \n    The algorithm consists of iterating through the input `gain` array and keeping track of the current altitude and the maximum altitude reached:\n\n1. Initialize `max_altitude` and `current_altitude` variables to 0.\n2. For each element in the `gain` array, add the gain value to the `current_altitude`.\n3. Update the `max_altitude` if the `current_altitude` is greater than the `max_altitude`.\n4. Return the `max_altitude` after the loop.\n\nThis approach has a time complexity of O(n), where n is the length of the input array `gain`.\n    ", "c++": "\n    ```cpp\nint largestAltitude(vector<int>& gain) {\n    int max_altitude = 0, current_altitude = 0;\n    for (int i = 0; i < gain.size(); ++i) {\n        current_altitude += gain[i];\n        max_altitude = max(max_altitude, current_altitude);\n    }\n    return max_altitude;\n}\n```\n    \n    The algorithm consists of iterating through the input `gain` array and keeping track of the current altitude and the maximum altitude reached:\n\n1. Initialize `max_altitude` and `current_altitude` variables to 0.\n2. For each element in the `gain` array, add the gain value to the `current_altitude`.\n3. Update the `max_altitude` if the `current_altitude` is greater than the `max_altitude`.\n4. Return the `max_altitude` after the loop.\n\nThis approach has a time complexity of O(n), where n is the length of the input array `gain`.\n    ", "python": "\n    ```python\ndef largestAltitude(gain):\n    max_altitude, current_altitude = 0, 0\n    for i in gain:\n        current_altitude += i\n        max_altitude = max(max_altitude, current_altitude)\n    return max_altitude\n```\n    \n    The algorithm consists of iterating through the input `gain` array and keeping track of the current altitude and the maximum altitude reached:\n\n1. Initialize `max_altitude` and `current_altitude` variables to 0.\n2. For each element in the `gain` array, add the gain value to the `current_altitude`.\n3. Update the `max_altitude` if the `current_altitude` is greater than the `max_altitude`.\n4. Return the `max_altitude` after the loop.\n\nThis approach has a time complexity of O(n), where n is the length of the input array `gain`.\n    ", "javascript": "\n    ```javascript\nfunction largestAltitude(gain) {\n    let max_altitude = 0, current_altitude = 0;\n    for (let i = 0; i < gain.length; i++) {\n        current_altitude += gain[i];\n        max_altitude = Math.max(max_altitude, current_altitude);\n    }\n    return max_altitude;\n}\n```\n    \n    The algorithm consists of iterating through the input `gain` array and keeping track of the current altitude and the maximum altitude reached:\n\n1. Initialize `max_altitude` and `current_altitude` variables to 0.\n2. For each element in the `gain` array, add the gain value to the `current_altitude`.\n3. Update the `max_altitude` if the `current_altitude` is greater than the `max_altitude`.\n4. Return the `max_altitude` after the loop.\n\nThis approach has a time complexity of O(n), where n is the length of the input array `gain`.\n    "}
{"id": 1838, "slug": "frequency-of-the-most-frequent-element", "title": "Frequency of the Most Frequent Element", "difficulty": "Medium", "content": "The **frequency** of an element is the number of times it occurs in an array.\n\nYou are given an integer array `nums` and an integer `k`. In one operation, you can choose an index of `nums` and increment the element at that index by `1`.\n\nReturn _the **maximum possible frequency** of an element after performing **at most**_ `k` _operations_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,4\\], k = 5\n**Output:** 3\n**Explanation:** Increment the first element three times and the second element two times to make nums = \\[4,4,4\\].\n4 has a frequency of 3.\n\n**Example 2:**\n\n**Input:** nums = \\[1,4,8,13\\], k = 5\n**Output:** 2\n**Explanation:** There are multiple optimal solutions:\n- Increment the first element three times to make nums = \\[4,4,8,13\\]. 4 has a frequency of 2.\n- Increment the second element four times to make nums = \\[1,8,8,13\\]. 8 has a frequency of 2.\n- Increment the third element five times to make nums = \\[1,4,13,13\\]. 13 has a frequency of 2.\n\n**Example 3:**\n\n**Input:** nums = \\[3,9,6\\], k = 2\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`\n*   `1 <= k <= 105`", "java": "\n    ```java\npublic int maxFrequency(int[] nums, int k) {\n    Arrays.sort(nums);\n    int n = nums.length, i = 0;\n    long sum = 0;\n    int max_freq = 0;\n\n    for (int j = 0; j < n; j++) {\n        sum += nums[j];\n        while (sum + k < (long) nums[j] * (j - i + 1)) {\n            sum -= nums[i++];\n        }\n        max_freq = Math.max(max_freq, j - i + 1);\n    }\n\n    return max_freq;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize variables `n` as the length of `nums`, `i` as 0, `sum` as 0, and `max_freq` as 0.\n3. Iterate through the sorted array with index `j`.\n   a. Add each element to the `sum`.\n   b. In a while loop, if `sum + k` is less than `nums[j] * (j - i + 1)`, subtract `nums[i]` from `sum`, and increment `i`.\n   c. Update the `max_freq` by taking the maximum of the current `max_freq` and `j - i + 1`.\n4. Return the final `max_freq` as the answer.\n    ", "c++": "\n    ```cpp\nint maxFrequency(vector<int>& nums, int k) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size(), i = 0;\n    long long sum = 0;\n    int max_freq = 0;\n\n    for (int j = 0; j < n; j++) {\n        sum += nums[j];\n        while (sum + k < static_cast<long long>(nums[j]) * (j - i + 1)) {\n            sum -= nums[i++];\n        }\n        max_freq = max(max_freq, j - i + 1);\n    }\n\n    return max_freq;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize variables `n` as the length of `nums`, `i` as 0, `sum` as 0, and `max_freq` as 0.\n3. Iterate through the sorted array with index `j`.\n   a. Add each element to the `sum`.\n   b. In a while loop, if `sum + k` is less than `nums[j] * (j - i + 1)`, subtract `nums[i]` from `sum`, and increment `i`.\n   c. Update the `max_freq` by taking the maximum of the current `max_freq` and `j - i + 1`.\n4. Return the final `max_freq` as the answer.\n    ", "python": "\n    ```python\ndef maxFrequency(nums: List[int], k: int) -> int:\n    nums.sort()\n    n, i, s, max_freq = len(nums), 0, 0, 0\n\n    for j in range(n):\n        s += nums[j]\n        while s + k < nums[j] * (j - i + 1):\n            s -= nums[i]\n            i += 1\n        max_freq = max(max_freq, j - i + 1)\n\n    return max_freq\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize variables `n` as the length of `nums`, `i` as 0, `sum` as 0, and `max_freq` as 0.\n3. Iterate through the sorted array with index `j`.\n   a. Add each element to the `sum`.\n   b. In a while loop, if `sum + k` is less than `nums[j] * (j - i + 1)`, subtract `nums[i]` from `sum`, and increment `i`.\n   c. Update the `max_freq` by taking the maximum of the current `max_freq` and `j - i + 1`.\n4. Return the final `max_freq` as the answer.\n    ", "javascript": "\n    ```javascript\nfunction maxFrequency(nums, k) {\n    nums.sort((a, b) => a - b);\n    let n = nums.length, i = 0;\n    let sum = 0;\n    let max_freq = 0;\n\n    for (let j = 0; j < n; j++) {\n        sum += nums[j];\n        while (sum + k < nums[j] * (j - i + 1)) {\n            sum -= nums[i++];\n        }\n        max_freq = Math.max(max_freq, j - i + 1);\n    }\n\n    return max_freq;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize variables `n` as the length of `nums`, `i` as 0, `sum` as 0, and `max_freq` as 0.\n3. Iterate through the sorted array with index `j`.\n   a. Add each element to the `sum`.\n   b. In a while loop, if `sum + k` is less than `nums[j] * (j - i + 1)`, subtract `nums[i]` from `sum`, and increment `i`.\n   c. Update the `max_freq` by taking the maximum of the current `max_freq` and `j - i + 1`.\n4. Return the final `max_freq` as the answer.\n    "}
{"id": 1846, "slug": "maximum-element-after-decreasing-and-rearranging", "title": "Maximum Element After Decreasing and Rearranging", "difficulty": "Medium", "content": "You are given an array of positive integers `arr`. Perform some operations (possibly none) on `arr` so that it satisfies these conditions:\n\n*   The value of the **first** element in `arr` must be `1`.\n*   The absolute difference between any 2 adjacent elements must be **less than or equal to** `1`. In other words, `abs(arr[i] - arr[i - 1]) <= 1` for each `i` where `1 <= i < arr.length` (**0-indexed**). `abs(x)` is the absolute value of `x`.\n\nThere are 2 types of operations that you can perform any number of times:\n\n*   **Decrease** the value of any element of `arr` to a **smaller positive integer**.\n*   **Rearrange** the elements of `arr` to be in any order.\n\nReturn _the **maximum** possible value of an element in_ `arr` _after performing the operations to satisfy the conditions_.\n\n**Example 1:**\n\n**Input:** arr = \\[2,2,1,2,1\\]\n**Output:** 2\n**Explanation:** \nWe can satisfy the conditions by rearranging `arr` so it becomes `[1,2,2,2,1]`.\nThe largest element in `arr` is 2.\n\n**Example 2:**\n\n**Input:** arr = \\[100,1,1000\\]\n**Output:** 3\n**Explanation:** \nOne possible way to satisfy the conditions is by doing the following:\n1. Rearrange `arr` so it becomes `[1,100,1000]`.\n2. Decrease the value of the second element to 2.\n3. Decrease the value of the third element to 3.\nNow `arr = [1,2,3], which` satisfies the conditions.\nThe largest element in `arr is 3.`\n\n**Example 3:**\n\n**Input:** arr = \\[1,2,3,4,5\\]\n**Output:** 5\n**Explanation:** The array already satisfies the conditions, and the largest element is 5.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `1 <= arr[i] <= 109`", "java": "\n    ```java\npublic int maximumElementAfterDecrementingAndRearranging(int[] arr) {\n    Arrays.sort(arr);\n    arr[0] = 1;\n    for (int i = 1; i < arr.length; i++) {\n        arr[i] = Math.min(arr[i], arr[i - 1] + 1);\n    }\n    return arr[arr.length - 1];\n}\n```\n    \n    The main idea of this algorithm is to sort the array and modify it following these steps:\n1. Set the first element to 1.\n2. Iterate through the array starting from the second element. For each element, set its value to the minimum of its current value and the value of the previous element plus one.\n\nSince we sort the array, the absolute difference between adjacent elements after this transformation will always satisfy the conditions. Sorting ensures that we decrement the values as little as possible.\n\nOur goal is to return the maximum value, which will be the last element of the array after modifying it in this way.\n    ", "c++": "\n    ```cpp\nint maximumElementAfterDecrementingAndRearranging(vector<int>& arr) {\n    sort(arr.begin(), arr.end());\n    arr[0] = 1;\n    for (int i = 1; i < arr.size(); i++) {\n        arr[i] = min(arr[i], arr[i - 1] + 1);\n    }\n    return arr[arr.size() - 1];\n}\n```\n    \n    The main idea of this algorithm is to sort the array and modify it following these steps:\n1. Set the first element to 1.\n2. Iterate through the array starting from the second element. For each element, set its value to the minimum of its current value and the value of the previous element plus one.\n\nSince we sort the array, the absolute difference between adjacent elements after this transformation will always satisfy the conditions. Sorting ensures that we decrement the values as little as possible.\n\nOur goal is to return the maximum value, which will be the last element of the array after modifying it in this way.\n    ", "python": "\n    ```python\ndef maximumElementAfterDecrementingAndRearranging(arr: List[int]) -> int:\n    arr.sort()\n    arr[0] = 1\n    for i in range(1, len(arr)):\n        arr[i] = min(arr[i], arr[i - 1] + 1)\n    return arr[-1]\n```\n    \n    The main idea of this algorithm is to sort the array and modify it following these steps:\n1. Set the first element to 1.\n2. Iterate through the array starting from the second element. For each element, set its value to the minimum of its current value and the value of the previous element plus one.\n\nSince we sort the array, the absolute difference between adjacent elements after this transformation will always satisfy the conditions. Sorting ensures that we decrement the values as little as possible.\n\nOur goal is to return the maximum value, which will be the last element of the array after modifying it in this way.\n    ", "javascript": "\n    ```javascript\nfunction maximumElementAfterDecrementingAndRearranging(arr) {\n    arr.sort((a, b) => a - b);\n    arr[0] = 1;\n    for (let i = 1; i < arr.length; i++) {\n        arr[i] = Math.min(arr[i], arr[i - 1] + 1);\n    }\n    return arr[arr.length - 1];\n}\n```\n    \n    The main idea of this algorithm is to sort the array and modify it following these steps:\n1. Set the first element to 1.\n2. Iterate through the array starting from the second element. For each element, set its value to the minimum of its current value and the value of the previous element plus one.\n\nSince we sort the array, the absolute difference between adjacent elements after this transformation will always satisfy the conditions. Sorting ensures that we decrement the values as little as possible.\n\nOur goal is to return the maximum value, which will be the last element of the array after modifying it in this way.\n    "}
{"id": 1850, "slug": "minimum-adjacent-swaps-to-reach-the-kth-smallest-number", "title": "Minimum Adjacent Swaps to Reach the Kth Smallest Number", "difficulty": "Medium", "content": "You are given a string `num`, representing a large integer, and an integer `k`.\n\nWe call some integer **wonderful** if it is a **permutation** of the digits in `num` and is **greater in value** than `num`. There can be many wonderful integers. However, we only care about the **smallest-valued** ones.\n\n*   For example, when `num = \"5489355142 \"`:\n    *   The 1st smallest wonderful integer is `\"5489355214 \"`.\n    *   The 2nd smallest wonderful integer is `\"5489355241 \"`.\n    *   The 3rd smallest wonderful integer is `\"5489355412 \"`.\n    *   The 4th smallest wonderful integer is `\"5489355421 \"`.\n\nReturn _the **minimum number of adjacent digit swaps** that needs to be applied to_ `num` _to reach the_ `kth` _**smallest wonderful** integer_.\n\nThe tests are generated in such a way that `kth` smallest wonderful integer exists.\n\n**Example 1:**\n\n**Input:** num =  \"5489355142 \", k = 4\n**Output:** 2\n**Explanation:** The 4th smallest wonderful number is  \"5489355421 \". To get this number:\n- Swap index 7 with index 8:  \"5489355142 \" ->  \"5489355412 \"\n- Swap index 8 with index 9:  \"5489355412 \" ->  \"5489355421 \"\n\n**Example 2:**\n\n**Input:** num =  \"11112 \", k = 4\n**Output:** 4\n**Explanation:** The 4th smallest wonderful number is  \"21111 \". To get this number:\n- Swap index 3 with index 4:  \"11112 \" ->  \"11121 \"\n- Swap index 2 with index 3:  \"11121 \" ->  \"11211 \"\n- Swap index 1 with index 2:  \"11211 \" ->  \"12111 \"\n- Swap index 0 with index 1:  \"12111 \" ->  \"21111 \"\n\n**Example 3:**\n\n**Input:** num =  \"00123 \", k = 1\n**Output:** 1\n**Explanation:** The 1st smallest wonderful number is  \"00132 \". To get this number:\n- Swap index 3 with index 4:  \"00123 \" ->  \"00132 \"\n\n**Constraints:**\n\n*   `2 <= num.length <= 1000`\n*   `1 <= k <= 1000`\n*   `num` only consists of digits.", "java": "\n    ```java\npublic int minLengthAfterOperations(String s) {\n    int aCount = s.length() - s.replace(\"a\", \"\").length();\n    int bCount = s.length() - s.replace(\"b\", \"\").length();\n    int cCount = s.length() - s.replace(\"c\", \"\").length();\n\n    if (aCount % 2 == bCount % 2 && bCount % 2 == cCount % 2) {\n        return s.length() % 2;\n    }\n    return (s.length() + 1) % 2;\n}\n```\n    \n    The algorithm counts the occurrences of each character ('a', 'b', 'c') in the given string. Then, it checks if the counts are all even or all odd, which means that the count of the three characters has the same parity. In this case, the minimum length of the string after performing the operations would be the length of the string modulo 2. Otherwise, the minimum length would be the length of the string plus 1 modulo 2. This is because one character will always remain after performing the operations if the parities of the character counts aren't the same.\n    ", "c++": "\n    ```cpp\n#include <string>\n#include <algorithm>\n\nint min_length_after_operations(const std::string &s) {\n    int a_count = std::count(s.begin(), s.end(), 'a');\n    int b_count = std::count(s.begin(), s.end(), 'b');\n    int c_count = std::count(s.begin(), s.end(), 'c');\n\n    if (a_count % 2 == b_count % 2 && b_count % 2 == c_count % 2) {\n        return s.length() % 2;\n    }\n    return (s.length() + 1) % 2;\n}\n```\n    \n    The algorithm counts the occurrences of each character ('a', 'b', 'c') in the given string. Then, it checks if the counts are all even or all odd, which means that the count of the three characters has the same parity. In this case, the minimum length of the string after performing the operations would be the length of the string modulo 2. Otherwise, the minimum length would be the length of the string plus 1 modulo 2. This is because one character will always remain after performing the operations if the parities of the character counts aren't the same.\n    ", "python": "\n    ```python\ndef min_length_after_operations(s: str) -> int:\n    a_count = s.count('a')\n    b_count = s.count('b')\n    c_count = s.count('c')\n\n    if a_count % 2 == b_count % 2 and b_count % 2 == c_count % 2:\n        return len(s) % 2\n    return (len(s) + 1) % 2\n```\n    \n    The algorithm counts the occurrences of each character ('a', 'b', 'c') in the given string. Then, it checks if the counts are all even or all odd, which means that the count of the three characters has the same parity. In this case, the minimum length of the string after performing the operations would be the length of the string modulo 2. Otherwise, the minimum length would be the length of the string plus 1 modulo 2. This is because one character will always remain after performing the operations if the parities of the character counts aren't the same.\n    ", "javascript": "\n    ```javascript\nfunction minLengthAfterOperations(s) {\n    const aCount = s.split('a').length - 1;\n    const bCount = s.split('b').length - 1;\n    const cCount = s.split('c').length - 1;\n\n    if (aCount % 2 === bCount % 2 && bCount % 2 === cCount % 2) {\n        return s.length % 2;\n    }\n    return (s.length + 1) % 2;\n}\n```\n    \n    The algorithm counts the occurrences of each character ('a', 'b', 'c') in the given string. Then, it checks if the counts are all even or all odd, which means that the count of the three characters has the same parity. In this case, the minimum length of the string after performing the operations would be the length of the string modulo 2. Otherwise, the minimum length would be the length of the string plus 1 modulo 2. This is because one character will always remain after performing the operations if the parities of the character counts aren't the same.\n    "}
{"id": 1864, "slug": "minimum-number-of-swaps-to-make-the-binary-string-alternating", "title": "Minimum Number of Swaps to Make the Binary String Alternating", "difficulty": "Medium", "content": "Given a binary string `s`, return _the **minimum** number of character swaps to make it **alternating**, or_ `-1` _if it is impossible._\n\nThe string is called **alternating** if no two adjacent characters are equal. For example, the strings `\"010 \"` and `\"1010 \"` are alternating, while the string `\"0100 \"` is not.\n\nAny two characters may be swapped, even if they are **not adjacent**.\n\n**Example 1:**\n\n**Input:** s =  \"111000 \"\n**Output:** 1\n**Explanation:** Swap positions 1 and 4:  \"111000 \" ->  \"101010 \"\nThe string is now alternating.\n\n**Example 2:**\n\n**Input:** s =  \"010 \"\n**Output:** 0\n**Explanation:** The string is already alternating, no swaps are needed.\n\n**Example 3:**\n\n**Input:** s =  \"1110 \"\n**Output:** -1\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` is either `'0'` or `'1'`.", "java": "\n    ```java\npublic int minSwaps(String s) {\n    int zeroCount = 0, oneCount = 0;\n    for (char c : s.toCharArray()) {\n        if (c == '0') {\n            zeroCount++;\n        } else {\n            oneCount++;\n        }\n    }\n\n    if (Math.abs(zeroCount - oneCount) > 1) {\n        return -1;\n    }\n\n    int swaps1 = 0, swaps2 = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (i % 2 == 0 && s.charAt(i) != '0') {\n            swaps1++;\n        }\n        if (i % 2 == 1 && s.charAt(i) != '1') {\n            swaps1++;\n        }\n    }\n    swaps1 = swaps1 / 2;\n\n    for (int i = 0; i < s.length(); i++) {\n        if (i % 2 == 0 && s.charAt(i) != '1') {\n            swaps2++;\n        }\n        if (i % 2 == 1 && s.charAt(i) != '0') {\n            swaps2++;\n        }\n    }\n    swaps2 = swaps2 / 2;\n\n    if (zeroCount == oneCount) {\n        return Math.min(swaps1, swaps2);\n    }\n    return (zeroCount > oneCount) ? swaps2 : swaps1;\n}\n```\n    \n    1. Count the number of zeroes and ones in the string\n2. If the difference between the counts is greater than 1, it's impossible, return -1\n3. Calculate the number of swaps required for alternating starting with 0 and 1\n4. If the counts of 0's and 1's are equal, return the minimum of both swaps, else return the swaps for the smaller count.\n    ", "c++": "\n    ```cpp\nint minSwaps(string s) {\n    int zeroCount = 0, oneCount = 0;\n    for (char c : s) {\n        (c == '0') ? zeroCount++ : oneCount++;\n    }\n\n    if (abs(zeroCount - oneCount) > 1) {\n        return -1;\n    }\n\n    int swaps1 = 0, swaps2 = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (i % 2 == 0 && s[i] != '0') {\n            swaps1++;\n        }\n        if (i % 2 == 1 && s[i] != '1') {\n            swaps1++;\n        }\n    }\n    swaps1 = swaps1 / 2;\n\n    for (int i = 0; i < s.length(); i++) {\n        if (i % 2 == 0 && s[i] != '1') {\n            swaps2++;\n        }\n        if (i % 2 == 1 && s[i] != '0') {\n            swaps2++;\n        }\n    }\n    swaps2 = swaps2 / 2;\n\n    if (zeroCount == oneCount) {\n        return min(swaps1, swaps2);\n    }\n    return (zeroCount > oneCount) ? swaps2 : swaps1;\n}\n```\n    \n    1. Count the number of zeroes and ones in the string\n2. If the difference between the counts is greater than 1, it's impossible, return -1\n3. Calculate the number of swaps required for alternating starting with 0 and 1\n4. If the counts of 0's and 1's are equal, return the minimum of both swaps, else return the swaps for the smaller count.\n    ", "python": "\n    ```python\ndef minSwaps(s):\n    zeroCount = s.count('0')\n    oneCount = len(s) - zeroCount\n\n    if abs(zeroCount - oneCount) > 1:\n        return -1\n\n    swaps1 = swaps2 = 0\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '0':\n            swaps1 += 1\n        if i % 2 == 1 and c != '1':\n            swaps1 += 1\n    swaps1 = swaps1 // 2\n\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '1':\n            swaps2 += 1\n        if i % 2 == 1 and c != '0':\n            swaps2 += 1\n    swaps2 = swaps2 // 2\n\n    if zeroCount == oneCount:\n        return min(swaps1, swaps2)\n    return swaps2 if zeroCount > oneCount else swaps1\n```\n    \n    1. Count the number of zeroes and ones in the string\n2. If the difference between the counts is greater than 1, it's impossible, return -1\n3. Calculate the number of swaps required for alternating starting with 0 and 1\n4. If the counts of 0's and 1's are equal, return the minimum of both swaps, else return the swaps for the smaller count.\n    ", "javascript": "\n    ```javascript\nfunction minSwaps(s) {\n    let zeroCount = 0, oneCount = 0;\n    for (const c of s) {\n        (c === '0') ? zeroCount++ : oneCount++;\n    }\n\n    if (Math.abs(zeroCount - oneCount) > 1) {\n        return -1;\n    }\n\n    let swaps1 = 0, swaps2 = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (i % 2 === 0 && s[i] !== '0') {\n            swaps1++;\n        }\n        if (i % 2 === 1 && s[i] !== '1') {\n            swaps1++;\n        }\n    }\n    swaps1 = swaps1 / 2;\n\n    for (let i = 0; i < s.length; i++) {\n        if (i % 2 === 0 && s[i] !== '1') {\n            swaps2++;\n        }\n        if (i % 2 === 1 && s[i] !== '0') {\n            swaps2++;\n        }\n    }\n    swaps2 = swaps2 / 2;\n\n    if (zeroCount === oneCount) {\n        return Math.min(swaps1, swaps2);\n    }\n    return (zeroCount > oneCount) ? swaps2 : swaps1;\n}\n```\n    \n    1. Count the number of zeroes and ones in the string\n2. If the difference between the counts is greater than 1, it's impossible, return -1\n3. Calculate the number of swaps required for alternating starting with 0 and 1\n4. If the counts of 0's and 1's are equal, return the minimum of both swaps, else return the swaps for the smaller count.\n    "}
{"id": 1874, "slug": "minimize-product-sum-of-two-arrays", "title": "Minimize Product Sum of Two Arrays", "difficulty": "Medium", "content": "The **product sum** of two equal-length arrays `a` and `b` is equal to the sum of `a[i] * b[i]` for all `0 <= i < a.length` (**0-indexed**).\n\n*   For example, if `a = [1,2,3,4]` and `b = [5,2,3,1]`, the **product sum** would be `1*5 + 2*2 + 3*3 + 4*1 = 22`.\n\nGiven two arrays `nums1` and `nums2` of length `n`, return _the **minimum product sum** if you are allowed to **rearrange** the **order** of the elements in_ `nums1`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[5,3,4,2\\], nums2 = \\[4,2,2,5\\]\n**Output:** 40\n**Explanation:** We can rearrange nums1 to become \\[3,5,4,2\\]. The product sum of \\[3,5,4,2\\] and \\[4,2,2,5\\] is 3\\*4 + 5\\*2 + 4\\*2 + 2\\*5 = 40.\n\n**Example 2:**\n\n**Input:** nums1 = \\[2,1,4,5,7\\], nums2 = \\[3,2,4,8,6\\]\n**Output:** 65\n**Explanation:** We can rearrange nums1 to become \\[5,7,4,1,2\\]. The product sum of \\[5,7,4,1,2\\] and \\[3,2,4,8,6\\] is 5\\*3 + 7\\*2 + 4\\*4 + 1\\*8 + 2\\*6 = 65.\n\n**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `1 <= n <= 105`\n*   `1 <= nums1[i], nums2[i] <= 100`", "java": "\n    ```java\npublic boolean canChoose(int[][] groups, int[] nums) {\n    int g_i = 0, n_i = 0;\n    while (g_i < groups.length && n_i + groups[g_i].length <= nums.length) {\n        boolean match = true;\n        for (int i = 0; i < groups[g_i].length; ++i) {\n            if (groups[g_i][i] != nums[n_i + i]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            n_i += groups[g_i].length;\n            g_i++;\n        } else {\n            n_i++;\n        }\n    }\n    return g_i == groups.length;\n}\n```\n    \n    We initialize two indices, `g_i` for tracking the position in the `groups` array, and `n_i` for tracking the position in the `nums` array. We iterate using a `while` loop, checking if it's possible to process the next group. If it is, we compare the subarray in `nums` starting at `n_i` with the current `groups` element. If they match, we move to the next group and increment the index `n_i` based on the length of the current group. If not, we increment `n_i` by 1.\n\nIf we reach the end of the `groups` array, it means we've matched all the groups to disjoint subarrays, so we return true. Otherwise, we return false.\n    ", "c++": "\n    ```cpp\n#include <vector>\n\nbool canChoose(const std::vector<std::vector<int>>& groups, const std::vector<int>& nums) {\n    int g_i = 0, n_i = 0;\n    while (g_i < groups.size() && n_i + groups[g_i].size() <= nums.size()) {\n        bool match = true;\n        for (int i = 0; i < groups[g_i].size(); ++i) {\n            if (groups[g_i][i] != nums[n_i + i]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            n_i += groups[g_i].size();\n            g_i++;\n        } else {\n            n_i++;\n        }\n    }\n    return g_i == groups.size();\n}\n```\n    \n    We initialize two indices, `g_i` for tracking the position in the `groups` array, and `n_i` for tracking the position in the `nums` array. We iterate using a `while` loop, checking if it's possible to process the next group. If it is, we compare the subarray in `nums` starting at `n_i` with the current `groups` element. If they match, we move to the next group and increment the index `n_i` based on the length of the current group. If not, we increment `n_i` by 1.\n\nIf we reach the end of the `groups` array, it means we've matched all the groups to disjoint subarrays, so we return true. Otherwise, we return false.\n    ", "python": "\n    ```python\ndef can_choose(groups, nums):\n    g_i, n_i = 0, 0\n    while g_i < len(groups) and n_i + len(groups[g_i]) <= len(nums):\n        if nums[n_i : n_i + len(groups[g_i])] == groups[g_i]:\n            n_i += len(groups[g_i])\n            g_i += 1\n        else:\n            n_i += 1\n    return g_i == len(groups)\n```\n    \n    We initialize two indices, `g_i` for tracking the position in the `groups` array, and `n_i` for tracking the position in the `nums` array. We iterate using a `while` loop, checking if it's possible to process the next group. If it is, we compare the subarray in `nums` starting at `n_i` with the current `groups` element. If they match, we move to the next group and increment the index `n_i` based on the length of the current group. If not, we increment `n_i` by 1.\n\nIf we reach the end of the `groups` array, it means we've matched all the groups to disjoint subarrays, so we return true. Otherwise, we return false.\n    ", "javascript": "\n    ```javascript\nfunction canChoose(groups, nums) {\n    let g_i = 0, n_i = 0;\n    while (g_i < groups.length && n_i + groups[g_i].length <= nums.length) {\n        const match = groups[g_i].every((val, i) => val === nums[n_i + i]);\n        if (match) {\n            n_i += groups[g_i].length;\n            g_i++;\n        } else {\n            n_i++;\n        }\n    }\n    return g_i === groups.length;\n}\n```\n\n    \n    We initialize two indices, `g_i` for tracking the position in the `groups` array, and `n_i` for tracking the position in the `nums` array. We iterate using a `while` loop, checking if it's possible to process the next group. If it is, we compare the subarray in `nums` starting at `n_i` with the current `groups` element. If they match, we move to the next group and increment the index `n_i` based on the length of the current group. If not, we increment `n_i` by 1.\n\nIf we reach the end of the `groups` array, it means we've matched all the groups to disjoint subarrays, so we return true. Otherwise, we return false.\n    "}
{"id": 1877, "slug": "minimize-maximum-pair-sum-in-array", "title": "Minimize Maximum Pair Sum in Array", "difficulty": "Medium", "content": "The **pair sum** of a pair `(a,b)` is equal to `a + b`. The **maximum pair sum** is the largest **pair sum** in a list of pairs.\n\n*   For example, if we have pairs `(1,5)`, `(2,3)`, and `(4,4)`, the **maximum pair sum** would be `max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8`.\n\nGiven an array `nums` of **even** length `n`, pair up the elements of `nums` into `n / 2` pairs such that:\n\n*   Each element of `nums` is in **exactly one** pair, and\n*   The **maximum pair sum** is **minimized**.\n\nReturn _the minimized **maximum pair sum** after optimally pairing up the elements_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,5,2,3\\]\n**Output:** 7\n**Explanation:** The elements can be paired up into pairs (3,3) and (5,2).\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\n\n**Example 2:**\n\n**Input:** nums = \\[3,5,4,2,4,6\\]\n**Output:** 8\n**Explanation:** The elements can be paired up into pairs (3,5), (4,4), and (6,2).\nThe maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `2 <= n <= 105`\n*   `n` is **even**.\n*   `1 <= nums[i] <= 105`", "java": "\n    ```java\npublic int minPairSum(int[] nums) {\n    Arrays.sort(nums);\n    int maxSum = 0;\n    for (int i = 0; i < nums.length / 2; i++)\n        maxSum = Math.max(maxSum, nums[i] + nums[nums.length - 1 - i]);\n    return maxSum;\n}\n```\n    \n    First, we sort the nums array in ascending order. Then, we iterate through the first half of the nums and use the two-pointer technique to find pairs of elements that minimize the maximum pair sum. For each pair, we calculate the sum of the current element and the element at the opposite end of the array (last element minus the index). We then update max_sum with the max value between the current max_sum and the pair sum for each iteration. Finally, we return the max_sum.\n    ", "c++": "\n    ```cpp\nint minPairSum(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int max_sum = 0;\n    for (int i = 0; i < nums.size() / 2; ++i)\n        max_sum = max(max_sum, nums[i] + nums[nums.size() - 1 - i]);\n    return max_sum;\n}\n```\n    \n    First, we sort the nums array in ascending order. Then, we iterate through the first half of the nums and use the two-pointer technique to find pairs of elements that minimize the maximum pair sum. For each pair, we calculate the sum of the current element and the element at the opposite end of the array (last element minus the index). We then update max_sum with the max value between the current max_sum and the pair sum for each iteration. Finally, we return the max_sum.\n    ", "python": "\n    ```python\ndef minPairSum(nums):\n    nums.sort()\n    max_sum = 0\n    for i in range(len(nums) // 2):\n        max_sum = max(max_sum, nums[i] + nums[-1 - i])\n    return max_sum\n```\n    \n    First, we sort the nums array in ascending order. Then, we iterate through the first half of the nums and use the two-pointer technique to find pairs of elements that minimize the maximum pair sum. For each pair, we calculate the sum of the current element and the element at the opposite end of the array (last element minus the index). We then update max_sum with the max value between the current max_sum and the pair sum for each iteration. Finally, we return the max_sum.\n    ", "javascript": "\n    ```javascript\nfunction minPairSum(nums) {\n    nums.sort((a, b) => a - b);\n    let maxSum = 0;\n    for (let i = 0; i < nums.length / 2; i++)\n        maxSum = Math.max(maxSum, nums[i] + nums[nums.length - 1 - i]);\n    return maxSum;\n}\n```\n    \n    First, we sort the nums array in ascending order. Then, we iterate through the first half of the nums and use the two-pointer technique to find pairs of elements that minimize the maximum pair sum. For each pair, we calculate the sum of the current element and the element at the opposite end of the array (last element minus the index). We then update max_sum with the max value between the current max_sum and the pair sum for each iteration. Finally, we return the max_sum.\n    "}
{"id": 1881, "slug": "maximum-value-after-insertion", "title": "Maximum Value after Insertion", "difficulty": "Medium", "content": "You are given a very large integer `n`, represented as a string,\u200b\u200b\u200b\u200b\u200b\u200b and an integer digit `x`. The digits in `n` and the digit `x` are in the **inclusive** range `[1, 9]`, and `n` may represent a **negative** number.\n\nYou want to **maximize** `n`**'s numerical value** by inserting `x` anywhere in the decimal representation of `n`\u200b\u200b\u200b\u200b\u200b\u200b. You **cannot** insert `x` to the left of the negative sign.\n\n*   For example, if `n = 73` and `x = 6`, it would be best to insert it between `7` and `3`, making `n = 763`.\n*   If `n = -55` and `x = 2`, it would be best to insert it before the first `5`, making `n = -255`.\n\nReturn _a string representing the **maximum** value of_ `n`_\u200b\u200b\u200b\u200b\u200b\u200b after the insertion_.\n\n**Example 1:**\n\n**Input:** n =  \"99 \", x = 9\n**Output:**  \"999 \"\n**Explanation:** The result is the same regardless of where you insert 9.\n\n**Example 2:**\n\n**Input:** n =  \"-13 \", x = 2\n**Output:**  \"-123 \"\n**Explanation:** You can make n one of {-213, -123, -132}, and the largest of those three is -123.\n\n**Constraints:**\n\n*   `1 <= n.length <= 105`\n*   `1 <= x <= 9`\n*   The digits in `n`\u200b\u200b\u200b are in the range `[1, 9]`.\n*   `n` is a valid representation of an integer.\n*   In the case of a negative `n`,\u200b\u200b\u200b\u200b\u200b\u200b it will begin with `'-'`.", "java": "\n    ```java\nimport java.util.TreeSet;\n\npublic int minAbsDifference(int[] nums, int goal) {\n    int n = nums.length;\n    int half = n / 2;\n    int[] left = Arrays.copyOfRange(nums, 0, half);\n    int[] right = Arrays.copyOfRange(nums, half, n);\n    TreeSet<Integer> sums = new TreeSet<>();\n\n    for (int mask = 0; mask < (1 << left.length); ++mask) {\n        int sum = 0;\n        for (int i = 0; i < left.length; ++i) {\n            if ((mask & (1 << i)) != 0) {\n                sum += left[i];\n            }\n        }\n        sums.add(sum);\n    }\n\n    int ans = Math.abs(goal);\n\n    for (int mask = 0; mask < (1 << right.length); ++mask) {\n        int sum = 0;\n        for (int i = 0; i < right.length; ++i) {\n            if ((mask & (1 << i)) != 0) {\n                sum += right[i];\n            }\n        }\n        Integer ceiling = sums.ceiling(goal - sum);\n        if (ceiling != null) {\n            ans = Math.min(ans, Math.abs(ceiling + sum - goal));\n        }\n        Integer floor = sums.floor(goal - sum);\n        if (floor != null) {\n            ans = Math.min(ans, Math.abs(floor + sum - goal));\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm first splits the input array `nums` into two roughly equal halves, `left` and `right`. Then, it computes all possible sums for each of the half arrays by checking all subsequences using binary masks. For the left half array, it saves all possible sums in a set (`sums`).\n\nOnce all possible sums for the left half are saved, it computes all possible sums for the `right` half. For each sum in the right half, it finds the sum in the left half that is closest to the remaining value needed to reach the `goal`. In C++ and Java, this is done using `lower_bound` and `ceiling/floor` functions respectively, whereas in Python and JavaScript, this is done using the `min` function with an appropriate key or the `reduce` function.\n\nThe algorithm then updates the candidate answer by taking the minimum absolute difference between the current best answer and the calculated sum from both halves of the array. Finally, it returns the minimum absolute difference found.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <set>\n\nint minAbsDifference(std::vector<int>& nums, int goal) {\n    int n = nums.size();\n    std::vector<int> left(nums.begin(), nums.begin() + n / 2);\n    std::vector<int> right(nums.begin() + n / 2, nums.end());\n    std::set<int> sums;\n\n    for (int mask = 0; mask < (1 << left.size()); ++mask) {\n        int sum = 0;\n        for (int i = 0; i < left.size(); ++i) {\n            if (mask & (1 << i)) {\n                sum += left[i];\n            }\n        }\n        sums.insert(sum);\n    }\n\n    int ans = std::abs(goal);\n\n    for (int mask = 0; mask < (1 << right.size()); ++mask) {\n        int sum = 0;\n        for (int i = 0; i < right.size(); ++i) {\n            if (mask & (1 << i)) {\n                sum += right[i];\n            }\n        }\n        auto it = sums.lower_bound(goal - sum);\n        if (it != sums.end()) {\n            ans = std::min(ans, std::abs((*it) + sum - goal));\n        }\n        if (it != sums.begin()) {\n            ans = std::min(ans, std::abs((*std::prev(it)) + sum - goal));\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm first splits the input array `nums` into two roughly equal halves, `left` and `right`. Then, it computes all possible sums for each of the half arrays by checking all subsequences using binary masks. For the left half array, it saves all possible sums in a set (`sums`).\n\nOnce all possible sums for the left half are saved, it computes all possible sums for the `right` half. For each sum in the right half, it finds the sum in the left half that is closest to the remaining value needed to reach the `goal`. In C++ and Java, this is done using `lower_bound` and `ceiling/floor` functions respectively, whereas in Python and JavaScript, this is done using the `min` function with an appropriate key or the `reduce` function.\n\nThe algorithm then updates the candidate answer by taking the minimum absolute difference between the current best answer and the calculated sum from both halves of the array. Finally, it returns the minimum absolute difference found.\n    ", "python": "\n    ```python\nfrom itertools import combinations\n\ndef minAbsDifference(nums, goal):\n    n = len(nums)\n    left = nums[:n//2]\n    right = nums[n//2:]\n\n    sums_left = set()\n\n    for i in range(len(left) + 1):\n        for comb in combinations(left, i):\n            sums_left.add(sum(comb))\n\n    ans = abs(goal)\n\n    for i in range(len(right) + 1):\n        for comb in combinations(right, i):\n            sum_r = sum(comb)\n            sum_goal = goal - sum_r\n            sum_l = min(sums_left, key=lambda x: abs(x - sum_goal))\n\n            ans = min(ans, abs(sum_l + sum_r - goal))\n\n    return ans\n```\n    \n    The algorithm first splits the input array `nums` into two roughly equal halves, `left` and `right`. Then, it computes all possible sums for each of the half arrays by checking all subsequences using binary masks. For the left half array, it saves all possible sums in a set (`sums`).\n\nOnce all possible sums for the left half are saved, it computes all possible sums for the `right` half. For each sum in the right half, it finds the sum in the left half that is closest to the remaining value needed to reach the `goal`. In C++ and Java, this is done using `lower_bound` and `ceiling/floor` functions respectively, whereas in Python and JavaScript, this is done using the `min` function with an appropriate key or the `reduce` function.\n\nThe algorithm then updates the candidate answer by taking the minimum absolute difference between the current best answer and the calculated sum from both halves of the array. Finally, it returns the minimum absolute difference found.\n    ", "javascript": "\n    ```javascript\nfunction minAbsDifference(nums, goal) {\n    const n = nums.length;\n    const left = nums.slice(0, n / 2);\n    const right = nums.slice(n / 2);\n    const sums = new Set();\n\n    for (let mask = 0; mask < (1 << left.length); ++mask) {\n        let sum = 0;\n        for (let i = 0; i < left.length; ++i) {\n            if (mask & (1 << i)) {\n                sum += left[i];\n            }\n        }\n        sums.add(sum);\n    }\n\n    let ans = Math.abs(goal);\n\n    for (let mask = 0; mask < (1 << right.length); ++mask) {\n        let sum = 0;\n        for (let i = 0; i < right.length; ++i) {\n            if (mask & (1 << i)) {\n                sum += right[i];\n            }\n        }\n        const target = goal - sum;\n        const candidate = [...sums].reduce((a, b) => Math.abs(b - target) < Math.abs(a - target) ? b : a);\n\n        ans = Math.min(ans, Math.abs(candidate + sum - goal));\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm first splits the input array `nums` into two roughly equal halves, `left` and `right`. Then, it computes all possible sums for each of the half arrays by checking all subsequences using binary masks. For the left half array, it saves all possible sums in a set (`sums`).\n\nOnce all possible sums for the left half are saved, it computes all possible sums for the `right` half. For each sum in the right half, it finds the sum in the left half that is closest to the remaining value needed to reach the `goal`. In C++ and Java, this is done using `lower_bound` and `ceiling/floor` functions respectively, whereas in Python and JavaScript, this is done using the `min` function with an appropriate key or the `reduce` function.\n\nThe algorithm then updates the candidate answer by taking the minimum absolute difference between the current best answer and the calculated sum from both halves of the array. Finally, it returns the minimum absolute difference found.\n    "}
{"id": 1888, "slug": "minimum-number-of-flips-to-make-the-binary-string-alternating", "title": "Minimum Number of Flips to Make the Binary String Alternating", "difficulty": "Medium", "content": "You are given a binary string `s`. You are allowed to perform two types of operations on the string in any sequence:\n\n*   **Type-1: Remove** the character at the start of the string `s` and **append** it to the end of the string.\n*   **Type-2: Pick** any character in `s` and **flip** its value, i.e., if its value is `'0'` it becomes `'1'` and vice-versa.\n\nReturn _the **minimum** number of **type-2** operations you need to perform_ _such that_ `s` _becomes **alternating**._\n\nThe string is called **alternating** if no two adjacent characters are equal.\n\n*   For example, the strings `\"010 \"` and `\"1010 \"` are alternating, while the string `\"0100 \"` is not.\n\n**Example 1:**\n\n**Input:** s =  \"111000 \"\n**Output:** 2\n**Explanation**: Use the first operation two times to make s =  \"100011 \".\nThen, use the second operation on the third and sixth elements to make s =  \"101010 \".\n\n**Example 2:**\n\n**Input:** s =  \"010 \"\n**Output:** 0\n**Explanation**: The string is already alternating.\n\n**Example 3:**\n\n**Input:** s =  \"1110 \"\n**Output:** 1\n**Explanation**: Use the second operation on the second element to make s =  \"1010 \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'0'` or `'1'`.", "java": "\n    ```java\npublic int nearestValidPoint(int x, int y, int[][] points) {\n    int minDistance = Integer.MAX_VALUE;\n    int minIndex = -1;\n\n    for (int i = 0; i < points.length; i++) {\n        if (x == points[i][0] || y == points[i][1]) {\n            int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                minIndex = i;\n            }\n        }\n    }\n\n    return minIndex;\n}\n```\n    \n    The algorithm iterates through the array of points and checks, in each iteration, whether the point shares the same x-coordinate or the same y-coordinate with the given location. If it does, it calculates the Manhattan distance between the current point and the location. If this distance is smaller than the minimum distance found so far, the algorithm updates the minimum distance and the index of the point in the array.\n\nIn the end, if at least one valid point was found, the algorithm returns the index of the point with the smallest Manhattan distance. If no valid points were found, the algorithm returns -1.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <limits>\n\nint nearestValidPoint(int x, int y, std::vector<std::vector<int>>& points) {\n    int minDistance = std::numeric_limits<int>::max();\n    int minIndex = -1;\n\n    for (int i = 0; i < points.size(); ++i) {\n        if (x == points[i][0] || y == points[i][1]) {\n            int distance = std::abs(x - points[i][0]) + std::abs(y - points[i][1]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                minIndex = i;\n            }\n        }\n    }\n\n    return minIndex;\n}\n```\n    \n    The algorithm iterates through the array of points and checks, in each iteration, whether the point shares the same x-coordinate or the same y-coordinate with the given location. If it does, it calculates the Manhattan distance between the current point and the location. If this distance is smaller than the minimum distance found so far, the algorithm updates the minimum distance and the index of the point in the array.\n\nIn the end, if at least one valid point was found, the algorithm returns the index of the point with the smallest Manhattan distance. If no valid points were found, the algorithm returns -1.\n    ", "python": "\n    ```python\ndef nearestValidPoint(x, y, points):\n    min_distance = float('inf')\n    min_index = -1\n\n    for i, point in enumerate(points):\n        if x == point[0] or y == point[1]:\n            distance = abs(x - point[0]) + abs(y - point[1])\n            if distance < min_distance:\n                min_distance = distance\n                min_index = i\n\n    return min_index\n```\n    \n    The algorithm iterates through the array of points and checks, in each iteration, whether the point shares the same x-coordinate or the same y-coordinate with the given location. If it does, it calculates the Manhattan distance between the current point and the location. If this distance is smaller than the minimum distance found so far, the algorithm updates the minimum distance and the index of the point in the array.\n\nIn the end, if at least one valid point was found, the algorithm returns the index of the point with the smallest Manhattan distance. If no valid points were found, the algorithm returns -1.\n    ", "javascript": "\n    ```javascript\nfunction nearestValidPoint(x, y, points) {\n    let minDistance = Infinity;\n    let minIndex = -1;\n\n    for (let i = 0; i < points.length; i++) {\n        if (x === points[i][0] || y === points[i][1]) {\n            let distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                minIndex = i;\n            }\n        }\n    }\n\n    return minIndex;\n}\n```\n    \n    The algorithm iterates through the array of points and checks, in each iteration, whether the point shares the same x-coordinate or the same y-coordinate with the given location. If it does, it calculates the Manhattan distance between the current point and the location. If this distance is smaller than the minimum distance found so far, the algorithm updates the minimum distance and the index of the point in the array.\n\nIn the end, if at least one valid point was found, the algorithm returns the index of the point with the smallest Manhattan distance. If no valid points were found, the algorithm returns -1.\n    "}
{"id": 1899, "slug": "merge-triplets-to-form-target-triplet", "title": "Merge Triplets to Form Target Triplet", "difficulty": "Medium", "content": "A **triplet** is an array of three integers. You are given a 2D integer array `triplets`, where `triplets[i] = [ai, bi, ci]` describes the `ith` **triplet**. You are also given an integer array `target = [x, y, z]` that describes the **triplet** you want to obtain.\n\nTo obtain `target`, you may apply the following operation on `triplets` **any number** of times (possibly **zero**):\n\n*   Choose two indices (**0-indexed**) `i` and `j` (`i != j`) and **update** `triplets[j]` to become `[max(ai, aj), max(bi, bj), max(ci, cj)]`.\n    *   For example, if `triplets[i] = [2, 5, 3]` and `triplets[j] = [1, 7, 5]`, `triplets[j]` will be updated to `[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]`.\n\nReturn `true` _if it is possible to obtain the_ `target` _**triplet**_ `[x, y, z]` _as an **element** of_ `triplets`_, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** triplets = \\[\\[2,5,3\\],\\[1,8,4\\],\\[1,7,5\\]\\], target = \\[2,7,5\\]\n**Output:** true\n**Explanation:** Perform the following operations:\n- Choose the first and last triplets \\[\\[2,5,3\\],\\[1,8,4\\],\\[1,7,5\\]\\]. Update the last triplet to be \\[max(2,1), max(5,7), max(3,5)\\] = \\[2,7,5\\]. triplets = \\[\\[2,5,3\\],\\[1,8,4\\],\\[2,7,5\\]\\]\nThe target triplet \\[2,7,5\\] is now an element of triplets.\n\n**Example 2:**\n\n**Input:** triplets = \\[\\[3,4,5\\],\\[4,5,6\\]\\], target = \\[3,2,5\\]\n**Output:** false\n**Explanation:** It is impossible to have \\[3,2,5\\] as an element because there is no 2 in any of the triplets.\n\n**Example 3:**\n\n**Input:** triplets = \\[\\[2,5,3\\],\\[2,3,4\\],\\[1,2,5\\],\\[5,2,3\\]\\], target = \\[5,5,5\\]\n**Output:** true\n**Explanation:** Perform the following operations:\n- Choose the first and third triplets \\[\\[2,5,3\\],\\[2,3,4\\],\\[1,2,5\\],\\[5,2,3\\]\\]. Update the third triplet to be \\[max(2,1), max(5,2), max(3,5)\\] = \\[2,5,5\\]. triplets = \\[\\[2,5,3\\],\\[2,3,4\\],\\[2,5,5\\],\\[5,2,3\\]\\].\n- Choose the third and fourth triplets \\[\\[2,5,3\\],\\[2,3,4\\],\\[2,5,5\\],\\[5,2,3\\]\\]. Update the fourth triplet to be \\[max(2,5), max(5,2), max(5,3)\\] = \\[5,5,5\\]. triplets = \\[\\[2,5,3\\],\\[2,3,4\\],\\[2,5,5\\],\\[5,5,5\\]\\].\nThe target triplet \\[5,5,5\\] is now an element of triplets.\n\n**Constraints:**\n\n*   `1 <= triplets.length <= 105`\n*   `triplets[i].length == target.length == 3`\n*   `1 <= ai, bi, ci, x, y, z <= 1000`", "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n    Map<String, Integer> rule = new HashMap<>();\n    rule.put(\"type\", 0);\n    rule.put(\"color\", 1);\n    rule.put(\"name\", 2);\n    int count = 0;\n\n    for (List<String> item : items) {\n        if (item.get(rule.get(ruleKey)).equals(ruleValue)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n    \n    The function first initializes a dictionary called `rule` which maps `ruleKey` strings to the corresponding index in the items list. This helps in getting the correct index for the item property based on the given ruleKey. Then, a `count` variable is initialized to 0 to keep track of the number of items that match the rule.\n\nThe function then iterates through the `items` list and checks if the item property (type, color, or name) at the index found in the `rule` dictionary matches the given `ruleValue`. If they match, the `count` variable is incremented by 1.\n\nFinally, the `count` variable is returned as the number of items that match the given rule.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nint countMatches(vector<vector<string>>& items, string ruleKey, string ruleValue){\n    unordered_map<string, int> rule = {{\"type\", 0}, {\"color\", 1}, {\"name\", 2}};\n    int count = 0;\n\n    for (const auto& item : items) {\n        if (item[rule[ruleKey]] == ruleValue) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n    \n    The function first initializes a dictionary called `rule` which maps `ruleKey` strings to the corresponding index in the items list. This helps in getting the correct index for the item property based on the given ruleKey. Then, a `count` variable is initialized to 0 to keep track of the number of items that match the rule.\n\nThe function then iterates through the `items` list and checks if the item property (type, color, or name) at the index found in the `rule` dictionary matches the given `ruleValue`. If they match, the `count` variable is incremented by 1.\n\nFinally, the `count` variable is returned as the number of items that match the given rule.\n    ", "python": "\n    ```python\ndef count_matches(items, rule_key, rule_value):\n    rule = {\"type\": 0, \"color\": 1, \"name\": 2}\n    count = 0\n\n    for item in items:\n        if item[rule[rule_key]] == rule_value:\n            count += 1\n\n    return count\n```\n    \n    The function first initializes a dictionary called `rule` which maps `ruleKey` strings to the corresponding index in the items list. This helps in getting the correct index for the item property based on the given ruleKey. Then, a `count` variable is initialized to 0 to keep track of the number of items that match the rule.\n\nThe function then iterates through the `items` list and checks if the item property (type, color, or name) at the index found in the `rule` dictionary matches the given `ruleValue`. If they match, the `count` variable is incremented by 1.\n\nFinally, the `count` variable is returned as the number of items that match the given rule.\n    ", "javascript": "\n    ```javascript\nfunction countMatches(items, ruleKey, ruleValue) {\n    const rule = {\"type\": 0, \"color\": 1, \"name\": 2};\n    let count = 0;\n\n    for (const item of items) {\n        if (item[rule[ruleKey]] === ruleValue) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n    \n    The function first initializes a dictionary called `rule` which maps `ruleKey` strings to the corresponding index in the items list. This helps in getting the correct index for the item property based on the given ruleKey. Then, a `count` variable is initialized to 0 to keep track of the number of items that match the rule.\n\nThe function then iterates through the `items` list and checks if the item property (type, color, or name) at the index found in the `rule` dictionary matches the given `ruleValue`. If they match, the `count` variable is incremented by 1.\n\nFinally, the `count` variable is returned as the number of items that match the given rule.\n    "}
{"id": 1903, "slug": "largest-odd-number-in-string", "title": "Largest Odd Number in String", "difficulty": "Easy", "content": "You are given a string `num`, representing a large integer. Return _the **largest-valued odd** integer (as a string) that is a **non-empty substring** of_ `num`_, or an empty string_ `\" \"` _if no odd integer exists_.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n**Example 1:**\n\n**Input:** num =  \"52 \"\n**Output:**  \"5 \"\n**Explanation:** The only non-empty substrings are  \"5 \",  \"2 \", and  \"52 \".  \"5 \" is the only odd number.\n\n**Example 2:**\n\n**Input:** num =  \"4206 \"\n**Output:**  \" \"\n**Explanation:** There are no odd numbers in  \"4206 \".\n\n**Example 3:**\n\n**Input:** num =  \"35427 \"\n**Output:**  \"35427 \"\n**Explanation:**  \"35427 \" is already an odd number.\n\n**Constraints:**\n\n*   `1 <= num.length <= 105`\n*   `num` only consists of digits and does not contain any leading zeros.", "java": "\n    ```java\npublic String largestOddNumber(String num) {\n    for (int i = num.length() - 1; i >= 0; i--) {\n        if ((num.charAt(i) - '0') % 2 != 0) {\n            return num.substring(0, i + 1);\n        }\n    }\n    return \"\";\n}\n```\n    \n    The algorithm starts iterating through the given string `num` from the last character to the first one. Since we only need the largest odd number as a substring, we only need to find the first odd digit when iterating from right to left. When we find an odd digit, that means the current non-empty substring is the largest odd number, and we return that substring. If no odd digits are found, the function returns an empty string. The time complexity is O(n), where n is the length of the string `num`.\n    ", "c++": "\n    ```cpp\nstd::string largestOddNumber(std::string num) {\n    for (int i = num.length() - 1; i >= 0; i--) {\n        if ((num[i] - '0') % 2 != 0) {\n            return num.substr(0, i + 1);\n        }\n    }\n    return \"\";\n}\n```\n    \n    The algorithm starts iterating through the given string `num` from the last character to the first one. Since we only need the largest odd number as a substring, we only need to find the first odd digit when iterating from right to left. When we find an odd digit, that means the current non-empty substring is the largest odd number, and we return that substring. If no odd digits are found, the function returns an empty string. The time complexity is O(n), where n is the length of the string `num`.\n    ", "python": "\n    ```python\ndef largest_odd_number(num: str) -> str:\n    for i in range(len(num) - 1, -1, -1):\n        if int(num[i]) % 2 != 0:\n            return num[:i + 1]\n    return \"\"\n```\n    \n    The algorithm starts iterating through the given string `num` from the last character to the first one. Since we only need the largest odd number as a substring, we only need to find the first odd digit when iterating from right to left. When we find an odd digit, that means the current non-empty substring is the largest odd number, and we return that substring. If no odd digits are found, the function returns an empty string. The time complexity is O(n), where n is the length of the string `num`.\n    ", "javascript": "\n    ```javascript\nfunction largestOddNumber(num) {\n    for (let i = num.length - 1; i >= 0; i--) {\n        if ((num.charCodeAt(i) - '0'.charCodeAt(0)) % 2 !== 0) {\n            return num.slice(0, i + 1);\n        }\n    }\n    return \"\";\n}\n```\n    \n    The algorithm starts iterating through the given string `num` from the last character to the first one. Since we only need the largest odd number as a substring, we only need to find the first odd digit when iterating from right to left. When we find an odd digit, that means the current non-empty substring is the largest odd number, and we return that substring. If no odd digits are found, the function returns an empty string. The time complexity is O(n), where n is the length of the string `num`.\n    "}
{"id": 1921, "slug": "eliminate-maximum-number-of-monsters", "title": "Eliminate Maximum Number of Monsters", "difficulty": "Medium", "content": "You are playing a video game where you are defending your city from a group of `n` monsters. You are given a **0-indexed** integer array `dist` of size `n`, where `dist[i]` is the **initial distance** in kilometers of the `ith` monster from the city.\n\nThe monsters walk toward the city at a **constant** speed. The speed of each monster is given to you in an integer array `speed` of size `n`, where `speed[i]` is the speed of the `ith` monster in kilometers per minute.\n\nYou have a weapon that, once fully charged, can eliminate a **single** monster. However, the weapon takes **one minute** to charge.The weapon is fully charged at the very start.\n\nYou lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a **loss**, and the game ends before you can use your weapon.\n\nReturn _the **maximum** number of monsters that you can eliminate before you lose, or_ `n` _if you can eliminate all the monsters before they reach the city._\n\n**Example 1:**\n\n**Input:** dist = \\[1,3,4\\], speed = \\[1,1,1\\]\n**Output:** 3\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[1,3,4\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,2,3\\]. You eliminate the second monster.\nAfter a minute, the distances of the monsters are \\[X,X,2\\]. You eliminate the thrid monster.\nAll 3 monsters can be eliminated.\n\n**Example 2:**\n\n**Input:** dist = \\[1,1,2,3\\], speed = \\[1,1,1,1\\]\n**Output:** 1\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[1,1,2,3\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,0,1,2\\], so you lose.\nYou can only eliminate 1 monster.\n\n**Example 3:**\n\n**Input:** dist = \\[3,2,4\\], speed = \\[5,3,2\\]\n**Output:** 1\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[3,2,4\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,0,2\\], so you lose.\nYou can only eliminate 1 monster.\n\n**Constraints:**\n\n*   `n == dist.length == speed.length`\n*   `1 <= n <= 105`\n*   `1 <= dist[i], speed[i] <= 105`", "java": "\n    ```java\npublic int eliminateMaximum(int[] dist, int[] speed) {\n    int n = dist.length;\n    int[] timeToReachCity = new int[n];\n    for (int i = 0; i < n; i++) {\n        timeToReachCity[i] = (dist[i] + speed[i] - 1) / speed[i];\n    }\n    Arrays.sort(timeToReachCity);\n    int eliminated = 0;\n    for (int i = 0; i < n && timeToReachCity[i] > i; i++) {\n        eliminated++;\n    }\n    return eliminated;\n}\n```\n    \n    1. Calculate the time it takes for each monster to reach the city, and store these times in an array `time_to_reach_city`.\n2. Sort the `time_to_reach_city` array in ascending order.\n3. Iterate through the array and check if the time it takes for the monster to reach the city is greater than the current time (index `i`). If it is, eliminate the monster and increment the `eliminated` counter.\n4. If the time it takes for any remaining monster to reach the city is less than or equal to the current time, break out of the loop.\n5. Return the number of eliminated monsters.\n    ", "c++": "\n    ```cpp\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\n    int n = dist.size();\n    vector<int> time_to_reach_city(n);\n    for (int i = 0; i < n; i++) {\n        time_to_reach_city[i] = (dist[i] + speed[i] - 1) / speed[i];\n    }\n    sort(time_to_reach_city.begin(), time_to_reach_city.end());\n    int eliminated = 0;\n    for (int i = 0; i < n && time_to_reach_city[i] > i; i++) {\n        eliminated++;\n    }\n    return eliminated;\n}\n```\n    \n    1. Calculate the time it takes for each monster to reach the city, and store these times in an array `time_to_reach_city`.\n2. Sort the `time_to_reach_city` array in ascending order.\n3. Iterate through the array and check if the time it takes for the monster to reach the city is greater than the current time (index `i`). If it is, eliminate the monster and increment the `eliminated` counter.\n4. If the time it takes for any remaining monster to reach the city is less than or equal to the current time, break out of the loop.\n5. Return the number of eliminated monsters.\n    ", "python": "\n    ```python\ndef eliminate_maximum(dist, speed):\n    n = len(dist)\n    time_to_reach_city = [(dist[i] + speed[i] - 1) // speed[i] for i in range(n)]\n    time_to_reach_city.sort()\n    eliminated = 0\n    for i in range(n):\n        if time_to_reach_city[i] > i:\n            eliminated += 1\n        else:\n            break\n    return eliminated\n```\n    \n    1. Calculate the time it takes for each monster to reach the city, and store these times in an array `time_to_reach_city`.\n2. Sort the `time_to_reach_city` array in ascending order.\n3. Iterate through the array and check if the time it takes for the monster to reach the city is greater than the current time (index `i`). If it is, eliminate the monster and increment the `eliminated` counter.\n4. If the time it takes for any remaining monster to reach the city is less than or equal to the current time, break out of the loop.\n5. Return the number of eliminated monsters.\n    ", "javascript": "\n    ```javascript\nfunction eliminateMaximum(dist, speed) {\n    const n = dist.length;\n    const timeToReachCity = dist.map((d, i) => Math.ceil(d / speed[i])).sort((a, b) => a - b);\n    let eliminated = 0;\n    for (let i = 0; i < n && timeToReachCity[i] > i; i++) {\n        eliminated++;\n    }\n    return eliminated;\n}\n```\n    \n    1. Calculate the time it takes for each monster to reach the city, and store these times in an array `time_to_reach_city`.\n2. Sort the `time_to_reach_city` array in ascending order.\n3. Iterate through the array and check if the time it takes for the monster to reach the city is greater than the current time (index `i`). If it is, eliminate the monster and increment the `eliminated` counter.\n4. If the time it takes for any remaining monster to reach the city is less than or equal to the current time, break out of the loop.\n5. Return the number of eliminated monsters.\n    "}
{"id": 1927, "slug": "sum-game", "title": "Sum Game", "difficulty": "Medium", "content": "Alice and Bob take turns playing a game, with **Alice** **starting first**.\n\nYou are given a string `num` of **even length** consisting of digits and `'?'` characters. On each turn, a player will do the following if there is still at least one `'?'` in `num`:\n\n1.  Choose an index `i` where `num[i] == '?'`.\n2.  Replace `num[i]` with any digit between `'0'` and `'9'`.\n\nThe game ends when there are no more `'?'` characters in `num`.\n\nFor Bob to win, the sum of the digits in the first half of `num` must be **equal** to the sum of the digits in the second half. For Alice to win, the sums must **not be equal**.\n\n*   For example, if the game ended with `num = \"243801 \"`, then Bob wins because `2+4+3 = 8+0+1`. If the game ended with `num = \"243803 \"`, then Alice wins because `2+4+3 != 8+0+3`.\n\nAssuming Alice and Bob play **optimally**, return `true` _if Alice will win and_ `false` _if Bob will win_.\n\n**Example 1:**\n\n**Input:** num =  \"5023 \"\n**Output:** false\n**Explanation:** There are no moves to be made.\nThe sum of the first half is equal to the sum of the second half: 5 + 0 = 2 + 3.\n\n**Example 2:**\n\n**Input:** num =  \"25?? \"\n**Output:** true\n**Explanation:** Alice can replace one of the '?'s with '9' and it will be impossible for Bob to make the sums equal.\n\n**Example 3:**\n\n**Input:** num =  \"?3295??? \"\n**Output:** false\n**Explanation:** It can be proven that Bob will always win. One possible outcome is:\n- Alice replaces the first '?' with '9'. num =  \"93295??? \".\n- Bob replaces one of the '?' in the right half with '9'. num =  \"932959?? \".\n- Alice replaces one of the '?' in the right half with '2'. num =  \"9329592? \".\n- Bob replaces the last '?' in the right half with '7'. num =  \"93295927 \".\nBob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7.\n\n**Constraints:**\n\n*   `2 <= num.length <= 105`\n*   `num.length` is **even**.\n*   `num` consists of only digits and `'?'`.", "java": "\n    ```java\npublic int maxAscendingSum(int[] nums) {\n    int maxSum = 0, currentSum = nums[0];\n\n    for (int i = 1; i < nums.length; ++i) {\n        if (nums[i] > nums[i - 1]) {\n            currentSum += nums[i];\n        } else {\n            maxSum = Math.max(maxSum, currentSum);\n            currentSum = nums[i];\n        }\n    }\n\n    return Math.max(maxSum, currentSum);\n}\n```\n    \n    1. Initialize `maxSum` and `currentSum` as the first element of the input array.\n2. Iterate through the input array, starting from the second element.\n3. If the current element is greater than the previous element, add the current element to `currentSum`. Else, Compare and get the maximum between `maxSum` and `currentSum`, and set `currentSum` to the current element.\n4. After iteration, compare and get the maximum between `maxSum` and `currentSum` one last time, and return the result.\n    ", "c++": "\n    ```cpp\nint maxAscendingSum(vector<int>& nums) {\n    int maxSum = 0, currentSum = nums[0];\n\n    for (int i = 1; i < nums.size(); ++i) {\n        if (nums[i] > nums[i - 1]) {\n            currentSum += nums[i];\n        } else {\n            maxSum = max(maxSum, currentSum);\n            currentSum = nums[i];\n        }\n    }\n\n    return max(maxSum, currentSum);\n}\n```\n    \n    1. Initialize `maxSum` and `currentSum` as the first element of the input array.\n2. Iterate through the input array, starting from the second element.\n3. If the current element is greater than the previous element, add the current element to `currentSum`. Else, Compare and get the maximum between `maxSum` and `currentSum`, and set `currentSum` to the current element.\n4. After iteration, compare and get the maximum between `maxSum` and `currentSum` one last time, and return the result.\n    ", "python": "\n    ```python\ndef max_ascending_sum(nums):\n    max_sum = current_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            current_sum += nums[i]\n        else:\n            max_sum = max(max_sum, current_sum)\n            current_sum = nums[i]\n\n    return max(max_sum, current_sum)\n```\n    \n    1. Initialize `maxSum` and `currentSum` as the first element of the input array.\n2. Iterate through the input array, starting from the second element.\n3. If the current element is greater than the previous element, add the current element to `currentSum`. Else, Compare and get the maximum between `maxSum` and `currentSum`, and set `currentSum` to the current element.\n4. After iteration, compare and get the maximum between `maxSum` and `currentSum` one last time, and return the result.\n    ", "javascript": "\n    ```javascript\nfunction maxAscendingSum(nums) {\n    let maxSum = 0, currentSum = nums[0];\n\n    for (let i = 1; i < nums.length; ++i) {\n        if (nums[i] > nums[i - 1]) {\n            currentSum += nums[i];\n        } else {\n            maxSum = Math.max(maxSum, currentSum);\n            currentSum = nums[i];\n        }\n    }\n\n    return Math.max(maxSum, currentSum);\n}\n```\n    \n    1. Initialize `maxSum` and `currentSum` as the first element of the input array.\n2. Iterate through the input array, starting from the second element.\n3. If the current element is greater than the previous element, add the current element to `currentSum`. Else, Compare and get the maximum between `maxSum` and `currentSum`, and set `currentSum` to the current element.\n4. After iteration, compare and get the maximum between `maxSum` and `currentSum` one last time, and return the result.\n    "}
{"id": 1936, "slug": "add-minimum-number-of-rungs", "title": "Add Minimum Number of Rungs", "difficulty": "Medium", "content": "You are given a **strictly increasing** integer array `rungs` that represents the **height** of rungs on a ladder. You are currently on the **floor** at height `0`, and you want to reach the last rung.\n\nYou are also given an integer `dist`. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is **at most** `dist`. You are able to insert rungs at any positive **integer** height if a rung is not already there.\n\nReturn _the **minimum** number of rungs that must be added to the ladder in order for you to climb to the last rung._\n\n**Example 1:**\n\n**Input:** rungs = \\[1,3,5,10\\], dist = 2\n**Output:** 2\n**Explanation:**\nYou currently cannot reach the last rung.\nAdd rungs at heights 7 and 8 to climb this ladder. \nThe ladder will now have rungs at \\[1,3,5,7,8,10\\].\n\n**Example 2:**\n\n**Input:** rungs = \\[3,6,8,10\\], dist = 3\n**Output:** 0\n**Explanation:**\nThis ladder can be climbed without adding additional rungs.\n\n**Example 3:**\n\n**Input:** rungs = \\[3,4,6,7\\], dist = 2\n**Output:** 1\n**Explanation:**\nYou currently cannot reach the first rung from the ground.\nAdd a rung at height 1 to climb this ladder.\nThe ladder will now have rungs at \\[1,3,4,6,7\\].\n\n**Constraints:**\n\n*   `1 <= rungs.length <= 105`\n*   `1 <= rungs[i] <= 109`\n*   `1 <= dist <= 109`\n*   `rungs` is **strictly increasing**.", "java": "\n    ```java\npublic int numberOfNiceDivisors(int primeFactors) {\n    int MOD = 1000000007;\n    long result = 1;\n    for (int p = 2; p <= primeFactors; ++p) {\n        if (primeFactors % p == 0) {\n            int count = 0;\n            while (primeFactors % p == 0) {\n                primeFactors /= p;\n                ++count;\n            }\n            result = (result * (count * 2 + 1)) % MOD;\n        }\n    }\n    return (int) result;\n}\n```\n    \n    The algorithm iterates through all integers from 2 to the given positive integer `primeFactors`. For each of the divisors, it checks if it's divisible by the divisor. If it is, we increment the count and divide `primeFactors` by the divisor. We then update the result with the product of `(count * 2 + 1)` and the result modulo 10^9 + 7. Once the divisor loop is complete, we return the result as our answer.\n    ", "c++": "\n    ```cpp\n#include <cmath>\n\nconst int MOD = 1e9 + 7;\n\nint numberOfNiceDivisors(int primeFactors) {\n    long long result = 1;\n    for (int p = 2; p <= primeFactors; ++p) {\n        if (primeFactors % p == 0) {\n            int count = 0;\n            while (primeFactors % p == 0) {\n                primeFactors /= p;\n                ++count;\n            }\n            result = (result * (count * 2 + 1)) % MOD;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through all integers from 2 to the given positive integer `primeFactors`. For each of the divisors, it checks if it's divisible by the divisor. If it is, we increment the count and divide `primeFactors` by the divisor. We then update the result with the product of `(count * 2 + 1)` and the result modulo 10^9 + 7. Once the divisor loop is complete, we return the result as our answer.\n    ", "python": "\n    ```python\ndef numberOfNiceDivisors(primeFactors):\n    MOD = 1000000007\n    result = 1\n    p = 2\n    while p <= primeFactors:\n        if primeFactors % p == 0:\n            count = 0\n            while primeFactors % p == 0:\n                primeFactors //= p\n                count += 1\n            result = (result * (count * 2 + 1)) % MOD\n        p += 1\n    return result\n```\n    \n    The algorithm iterates through all integers from 2 to the given positive integer `primeFactors`. For each of the divisors, it checks if it's divisible by the divisor. If it is, we increment the count and divide `primeFactors` by the divisor. We then update the result with the product of `(count * 2 + 1)` and the result modulo 10^9 + 7. Once the divisor loop is complete, we return the result as our answer.\n    ", "javascript": "\n    ```javascript\nfunction numberOfNiceDivisors(primeFactors) {\n    const MOD = 1000000007;\n    let result = 1;\n    for (let p = 2; p <= primeFactors; ++p) {\n        if (primeFactors % p === 0) {\n            let count = 0;\n            while (primeFactors % p === 0) {\n                primeFactors /= p;\n                ++count;\n            }\n            result = (result * (count * 2 + 1)) % MOD;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through all integers from 2 to the given positive integer `primeFactors`. For each of the divisors, it checks if it's divisible by the divisor. If it is, we increment the count and divide `primeFactors` by the divisor. We then update the result with the product of `(count * 2 + 1)` and the result modulo 10^9 + 7. Once the divisor loop is complete, we return the result as our answer.\n    "}
{"id": 1946, "slug": "largest-number-after-mutating-substring", "title": "Largest Number After Mutating Substring", "difficulty": "Medium", "content": "You are given a string `num`, which represents a large integer. You are also given a **0-indexed** integer array `change` of length `10` that maps each digit `0-9` to another digit. More formally, digit `d` maps to digit `change[d]`.\n\nYou may **choose** to **mutate a single substring** of `num`. To mutate a substring, replace each digit `num[i]` with the digit it maps to in `change` (i.e. replace `num[i]` with `change[num[i]]`).\n\nReturn _a string representing the **largest** possible integer after **mutating** (or choosing not to) a **single substring** of_ `num`.\n\nA **substring** is a contiguous sequence of characters within the string.\n\n**Example 1:**\n\n**Input:** num =  \"132 \", change = \\[9,8,5,0,3,6,4,2,6,8\\]\n**Output:**  \"832 \"\n**Explanation:** Replace the substring  \"1 \":\n- 1 maps to change\\[1\\] = 8.\nThus,  \"132 \" becomes  \"832 \".\n \"832 \" is the largest number that can be created, so return it.\n\n**Example 2:**\n\n**Input:** num =  \"021 \", change = \\[9,4,3,5,7,2,1,9,0,6\\]\n**Output:**  \"934 \"\n**Explanation:** Replace the substring  \"021 \":\n- 0 maps to change\\[0\\] = 9.\n- 2 maps to change\\[2\\] = 3.\n- 1 maps to change\\[1\\] = 4.\nThus,  \"021 \" becomes  \"934 \".\n \"934 \" is the largest number that can be created, so return it.\n\n**Example 3:**\n\n**Input:** num =  \"5 \", change = \\[1,4,7,5,3,2,5,6,9,4\\]\n**Output:**  \"5 \"\n**Explanation:**  \"5 \" is already the largest number that can be created, so return it.\n\n**Constraints:**\n\n*   `1 <= num.length <= 105`\n*   `num` consists of only digits `0-9`.\n*   `change.length == 10`\n*   `0 <= change[d] <= 9`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int minAbsoluteSumDiff(int[] nums1, int[] nums2) {\n    int n = nums1.length;\n    long total = 0;\n    int maxDiff = 0;\n    int mod = 1_000_000_007;\n    int[] sortedNums1 = nums1.clone();\n    Arrays.sort(sortedNums1);\n    \n    for (int i = 0; i < n; i++) {\n        int diff = Math.abs(nums1[i] - nums2[i]);\n        total += diff;\n        \n        int pos = Arrays.binarySearch(sortedNums1, nums2[i]);\n        if (pos < 0) {\n            pos = ~pos;\n        }\n        if (pos != n) {\n            maxDiff = Math.max(maxDiff, diff - Math.abs(sortedNums1[pos] - nums2[i]));\n        }\n        if (pos != 0) {\n            maxDiff = Math.max(maxDiff, diff - Math.abs(sortedNums1[pos - 1] - nums2[i]));\n        }\n    }\n    return (int)((total - maxDiff + mod) % mod);\n}\n```\n    \n    The algorithm:\n1. Calculate the total absolute difference of the original two arrays.\n2. Find the maximum possible reduction in the absolute difference due to swapping an element in nums1 with another.\n3. Use binary search to find the position of the element in the sorted copy of nums1.\n4. Check both the position found and the position before it, if any. Calculate the potential absolute difference after replacement and update the maxDiff.\n5. Return the result as (total - maxDiff) modulo 1e9 + 7.\n    ", "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint minAbsoluteSumDiff(std::vector<int>& nums1, std::vector<int>& nums2) {\n    int n = nums1.size();\n    long long total = 0;\n    int maxDiff = 0;\n    int mod = 1e9 + 7;\n    std::vector<int> sorted_nums1 = nums1;\n    std::sort(sorted_nums1.begin(), sorted_nums1.end());\n    \n    for (int i = 0; i < n; ++i) {\n        int diff = abs(nums1[i] - nums2[i]);\n        total += diff;\n        \n        int pos = lower_bound(sorted_nums1.begin(), sorted_nums1.end(), nums2[i]) - sorted_nums1.begin();\n        if (pos != n) {\n            maxDiff = max(maxDiff, diff - abs(sorted_nums1[pos] - nums2[i]));\n        }\n        if (pos != 0) {\n            maxDiff = max(maxDiff, diff - abs(sorted_nums1[pos - 1] - nums2[i]));\n        }\n    }\n    return (total - maxDiff + mod) % mod;\n}\n```\n    \n    The algorithm:\n1. Calculate the total absolute difference of the original two arrays.\n2. Find the maximum possible reduction in the absolute difference due to swapping an element in nums1 with another.\n3. Use binary search to find the position of the element in the sorted copy of nums1.\n4. Check both the position found and the position before it, if any. Calculate the potential absolute difference after replacement and update the maxDiff.\n5. Return the result as (total - maxDiff) modulo 1e9 + 7.\n    ", "python": "\n    ```python\nimport bisect\n\ndef minAbsoluteSumDiff(nums1, nums2):\n    n = len(nums1)\n    total = 0\n    max_diff = 0\n    mod = 10**9 + 7\n    sorted_nums1 = sorted(nums1)\n    \n    for i in range(n):\n        diff = abs(nums1[i] - nums2[i])\n        total += diff\n        \n        pos = bisect_left(sorted_nums1, nums2[i])\n        if pos != n:\n            max_diff = max(max_diff, diff - abs(sorted_nums1[pos] - nums2[i]))\n        if pos != 0:\n            max_diff = max(max_diff, diff - abs(sorted_nums1[pos - 1] - nums2[i]))\n    \n    return (total - max_diff + mod) % mod\n```\n    \n    The algorithm:\n1. Calculate the total absolute difference of the original two arrays.\n2. Find the maximum possible reduction in the absolute difference due to swapping an element in nums1 with another.\n3. Use binary search to find the position of the element in the sorted copy of nums1.\n4. Check both the position found and the position before it, if any. Calculate the potential absolute difference after replacement and update the maxDiff.\n5. Return the result as (total - maxDiff) modulo 1e9 + 7.\n    ", "javascript": "\n    ```javascript\nfunction minAbsoluteSumDiff(nums1, nums2) {\n    const n = nums1.length;\n    let total = 0;\n    let maxDiff = 0;\n    const mod = 1e9 + 7;\n    const sortedNums1 = [...nums1].sort((a, b) => a - b);\n    \n    for (let i = 0; i < n; i++) {\n        const diff = Math.abs(nums1[i] - nums2[i]);\n        total += diff;\n        \n        const pos = sortedNums1.findIndex(x => x >= nums2[i]);\n        if (pos !== n) {\n            maxDiff = Math.max(maxDiff, diff - Math.abs(sortedNums1[pos] - nums2[i]));\n        }\n        if (pos !== 0) {\n            maxDiff = Math.max(maxDiff, diff - Math.abs(sortedNums1[pos - 1] - nums2[i]));\n        }\n    }\n    return (total - maxDiff + mod) % mod;\n}\n```\n    \n    The algorithm:\n1. Calculate the total absolute difference of the original two arrays.\n2. Find the maximum possible reduction in the absolute difference due to swapping an element in nums1 with another.\n3. Use binary search to find the position of the element in the sorted copy of nums1.\n4. Check both the position found and the position before it, if any. Calculate the potential absolute difference after replacement and update the maxDiff.\n5. Return the result as (total - maxDiff) modulo 1e9 + 7.\n    "}
{"id": 1953, "slug": "maximum-number-of-weeks-for-which-you-can-work", "title": "Maximum Number of Weeks for Which You Can Work", "difficulty": "Medium", "content": "There are `n` projects numbered from `0` to `n - 1`. You are given an integer array `milestones` where each `milestones[i]` denotes the number of milestones the `ith` project has.\n\nYou can work on the projects following these two rules:\n\n*   Every week, you will finish **exactly one** milestone of **one** project. You **must** work every week.\n*   You **cannot** work on two milestones from the same project for two **consecutive** weeks.\n\nOnce all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will **stop working**. Note that you may not be able to finish every project's milestones due to these constraints.\n\nReturn _the **maximum** number of weeks you would be able to work on the projects without violating the rules mentioned above_.\n\n**Example 1:**\n\n**Input:** milestones = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** One possible scenario is:\n\u200b\u200b\u200b\u200b- During the 1st week, you will work on a milestone of project 0.\n- During the 2nd week, you will work on a milestone of project 2.\n- During the 3rd week, you will work on a milestone of project 1.\n- During the 4th week, you will work on a milestone of project 2.\n- During the 5th week, you will work on a milestone of project 1.\n- During the 6th week, you will work on a milestone of project 2.\nThe total number of weeks is 6.\n\n**Example 2:**\n\n**Input:** milestones = \\[5,2,1\\]\n**Output:** 7\n**Explanation:** One possible scenario is:\n- During the 1st week, you will work on a milestone of project 0.\n- During the 2nd week, you will work on a milestone of project 1.\n- During the 3rd week, you will work on a milestone of project 0.\n- During the 4th week, you will work on a milestone of project 1.\n- During the 5th week, you will work on a milestone of project 0.\n- During the 6th week, you will work on a milestone of project 2.\n- During the 7th week, you will work on a milestone of project 0.\nThe total number of weeks is 7.\nNote that you cannot work on the last milestone of project 0 on 8th week because it would violate the rules.\nThus, one milestone in project 0 will remain unfinished.\n\n**Constraints:**\n\n*   `n == milestones.length`\n*   `1 <= n <= 105`\n*   `1 <= milestones[i] <= 109`", "java": "\n    ```java\nimport java.util.*;\n\nclass MKAverage {\n    int m, k;\n    long sum = 0;\n    TreeSet<Integer> minSet, midSet, maxSet;\n    Queue<Integer> q;\n\n    public MKAverage(int m, int k) {\n        this.m = m;\n        this.k = k;\n        this.minSet = new TreeSet<>();\n        this.midSet = new TreeSet<>();\n        this.maxSet = new TreeSet<>();\n        this.q = new LinkedList<>();\n    }\n    \n    public void addElement(int num) {\n        if (q.size() == m) {\n            removeElement();\n        }\n\n        minSet.add(num);\n        sum += num;\n        \n        if (minSet.size() > k) {\n            int temp = minSet.last();\n            minSet.remove(temp);\n            midSet.add(temp);\n            sum += temp;\n        }\n\n        if (!midSet.isEmpty() && minSet.last() > midSet.first()) {\n            int temp1 = minSet.last();\n            int temp2 = midSet.first();\n            minSet.remove(temp1);\n            midSet.remove(temp2);\n            minSet.add(temp2);\n            midSet.add(temp1);\n            sum += temp2 - temp1;\n        }\n\n        maxSet.add(midSet.last());\n        sum -= midSet.last();\n        midSet.remove(midSet.last());\n\n        if (maxSet.size() > k) {\n            int temp = maxSet.first();\n            maxSet.remove(temp);\n            midSet.add(temp);\n            sum += temp;\n        }\n        \n        q.add(num);\n    }\n    \n    public int calculateMKAverage() {\n        if (q.size() < m) {\n            return -1;\n        }\n        return (int) (sum / (m - 2 * k));\n    }\n    \n    void removeElement() {\n        int temp = q.poll();\n\n        if (minSet.contains(temp)) {\n            minSet.remove(temp);\n        } else if (midSet.contains(temp)) {\n            midSet.remove(temp);\n            sum -= temp;\n        } else {\n            maxSet.remove(temp);\n        }\n    }\n}\n```\n\n    \n    - Initialize variables including m, k, sum and three sets: minSet, midSet and maxSet.\n- For `addElement()`:\n    1. Remove an element if the queue size equals m.\n    2. Add the new element to minSet, update the sum.\n    3. Adjust the elements between minSet, midSet, and maxSet. Ensure after each adding there are k elements in minSet and maxSet, and the rest in midSet.\n- For `calculateMKAverage()`, check if the queue size is less than m, return -1. Otherwise, calculate and return the average value of the elements in midSet.\n- For `removeElement()`, remove the element from minSet, midSet or maxSet according to the corresponding set.\n    ", "c++": "\n    ```cpp\n#include <set>\n#include <queue>\n#include <algorithm>\n\nclass MKAverage {\npublic:\n    int m, k;\n    long long sum = 0;\n    multiset<int> minSet, midSet, maxSet;\n    queue<int> q;\n\n    MKAverage(int m, int k) : m(m), k(k) {}\n    \n    void addElement(int num) {\n        if (q.size() == m) {\n            removeElement();\n        }\n\n        minSet.insert(num);\n        sum += num;\n        \n        if (minSet.size() > k) {\n            int temp = *minSet.rbegin();\n            minSet.erase(minSet.find(temp));\n            midSet.insert(temp);\n            sum += temp;\n        }\n\n        if (!midSet.empty() && *minSet.rbegin() > *midSet.begin()) {\n            int temp1 = *minSet.rbegin();\n            int temp2 = *midSet.begin();\n            minSet.erase(minSet.find(temp1));\n            midSet.erase(midSet.find(temp2));\n            minSet.insert(temp2);\n            midSet.insert(temp1);\n            sum += temp2 - temp1;\n        }\n\n        maxSet.insert(*midSet.rbegin());\n        sum -= *midSet.rbegin();\n        midSet.erase(prev(midSet.end()));\n\n        if (maxSet.size() > k) {\n            int temp = *maxSet.begin();\n            maxSet.erase(maxSet.find(temp));\n            midSet.insert(temp);\n            sum += temp;\n        }\n        \n        q.push(num);\n    }\n    \n    int calculateMKAverage() {\n        if (q.size() < m) {\n            return -1;\n        }\n        return sum / (m - 2 * k);\n    }\n    \n    void removeElement() {\n        int temp = q.front();\n        q.pop();\n\n        if (minSet.count(temp)) {\n            minSet.erase(minSet.find(temp));\n        } else if (midSet.count(temp)) {\n            midSet.erase(midSet.find(temp));\n            sum -= temp;\n        } else {\n            maxSet.erase(maxSet.find(temp));\n        }\n    }\n};\n```\n\n    \n    - Initialize variables including m, k, sum and three sets: minSet, midSet and maxSet.\n- For `addElement()`:\n    1. Remove an element if the queue size equals m.\n    2. Add the new element to minSet, update the sum.\n    3. Adjust the elements between minSet, midSet, and maxSet. Ensure after each adding there are k elements in minSet and maxSet, and the rest in midSet.\n- For `calculateMKAverage()`, check if the queue size is less than m, return -1. Otherwise, calculate and return the average value of the elements in midSet.\n- For `removeElement()`, remove the element from minSet, midSet or maxSet according to the corresponding set.\n    ", "python": "\n    ```python\nfrom collections import deque\nfrom sortedcontainers import SortedList\n\nclass MKAverage:\n\n    def __init__(self, m: int, k: int):\n        self.m = m\n        self.k = k\n        self.sum = 0\n        self.min_set = SortedList()\n        self.mid_set = SortedList()\n        self.max_set = SortedList()\n        self.q = deque()\n\n    def add_element(self, num: int) -> None:\n        if len(self.q) == self.m:\n            self.remove_element()\n\n        self.min_set.add(num)\n        self.sum += num\n        \n        if len(self.min_set) > self.k:\n            temp = self.min_set.pop()\n            self.mid_set.add(temp)\n            self.sum += temp\n\n        if self.min_set and self.mid_set and self.min_set[-1] > self.mid_set[0]:\n            temp1 = self.min_set.pop()\n            temp2 = self.mid_set.pop(0)\n            self.min_set.add(temp2)\n            self.mid_set.add(temp1)\n            self.sum += temp2 - temp1\n\n        self.max_set.add(self.mid_set.pop())\n        self.sum -= self.mid_set.pop()\n        self.mid_set.add(self.max_set.pop(0))\n\n        if len(self.max_set) > self.k:\n            temp = self.max_set.pop(0)\n            self.mid_set.add(temp)\n            self.sum += temp\n        \n        self.q.append(num)\n\n    def calculate_mkaverage(self) -> int:\n        if len(self.q) < self.m:\n            return -1\n        return self.sum // (self.m - 2 * self.k)\n\n    def remove_element(self) -> None:\n        temp = self.q.popleft()\n\n        if temp in self.min_set:\n            self.min_set.remove(temp)\n        elif temp in self.mid_set:\n            self.mid_set.remove(temp)\n            self.sum -= temp\n        else:\n            self.max_set.remove(temp)\n```\n\n    \n    - Initialize variables including m, k, sum and three sets: minSet, midSet and maxSet.\n- For `addElement()`:\n    1. Remove an element if the queue size equals m.\n    2. Add the new element to minSet, update the sum.\n    3. Adjust the elements between minSet, midSet, and maxSet. Ensure after each adding there are k elements in minSet and maxSet, and the rest in midSet.\n- For `calculateMKAverage()`, check if the queue size is less than m, return -1. Otherwise, calculate and return the average value of the elements in midSet.\n- For `removeElement()`, remove the element from minSet, midSet or maxSet according to the corresponding set.\n    ", "javascript": "\n    ```javascript\nclass MKAverage {\n    constructor(m, k) {\n        this.m = m;\n        this.k = k;\n        this.sum = 0;\n        this.minSet = new Set();\n        this.midSet = new Set();\n        this.maxSet = new Set();\n        this.q = [];\n    }\n\n    addElement(num) {\n        if (this.q.length === this.m) {\n            this.removeElement();\n        }\n\n        this.minSet.add(num);\n        this.sum += num;\n\n        if (this.minSet.size > this.k) {\n            let temp = Math.max(...this.minSet);\n            this.minSet.delete(temp);\n            this.midSet.add(temp);\n            this.sum += temp;\n        }\n\n        if (this.midSet.size && Math.max(...this.minSet) > Math.min(...this.midSet)) {\n            let temp1 = Math.max(...this.minSet);\n            let temp2 = Math.min(...this.midSet);\n            this.minSet.delete(temp1);\n            this.midSet.delete(temp2);\n            this.minSet.add(temp2);\n            this.midSet.add(temp1);\n            this.sum += temp2 - temp1;\n        }\n\n        const maxVal = Math.max(...this.midSet);\n        this.maxSet.add(maxVal);\n        this.sum -= maxVal;\n        this.midSet.delete(maxVal);\n\n        if (this.maxSet.size > this.k) {\n            let temp = Math.min(...this.maxSet);\n            this.maxSet.delete(temp);\n            this.midSet.add(temp);\n            this.sum += temp;\n        }\n\n        this.q.push(num);\n    }\n\n    calculateMKAverage() {\n        if (this.q.length < this.m) {\n            return -1;\n        }\n        return Math.floor(this.sum / (this.m - 2 * this.k));\n    }\n\n    removeElement() {\n        const temp = this.q.shift();\n\n        if (this.minSet.has(temp)) {\n            this.minSet.delete(temp);\n        } else if (this.midSet.has(temp)) {\n            this.midSet.delete(temp);\n            this.sum -= temp;\n        } else {\n            this.maxSet.delete(temp);\n        }\n    }\n}\n```\n\n    \n    - Initialize variables including m, k, sum and three sets: minSet, midSet and maxSet.\n- For `addElement()`:\n    1. Remove an element if the queue size equals m.\n    2. Add the new element to minSet, update the sum.\n    3. Adjust the elements between minSet, midSet, and maxSet. Ensure after each adding there are k elements in minSet and maxSet, and the rest in midSet.\n- For `calculateMKAverage()`, check if the queue size is less than m, return -1. Otherwise, calculate and return the average value of the elements in midSet.\n- For `removeElement()`, remove the element from minSet, midSet or maxSet according to the corresponding set.\n    "}
{"id": 1962, "slug": "remove-stones-to-minimize-the-total", "title": "Remove Stones to Minimize the Total", "difficulty": "Medium", "content": "You are given a **0-indexed** integer array `piles`, where `piles[i]` represents the number of stones in the `ith` pile, and an integer `k`. You should apply the following operation **exactly** `k` times:\n\n*   Choose any `piles[i]` and **remove** `floor(piles[i] / 2)` stones from it.\n\n**Notice** that you can apply the operation on the **same** pile more than once.\n\nReturn _the **minimum** possible total number of stones remaining after applying the_ `k` _operations_.\n\n`floor(x)` is the **greatest** integer that is **smaller** than or **equal** to `x` (i.e., rounds `x` down).\n\n**Example 1:**\n\n**Input:** piles = \\[5,4,9\\], k = 2\n**Output:** 12\n**Explanation:** Steps of a possible scenario are:\n- Apply the operation on pile 2. The resulting piles are \\[5,4,5\\].\n- Apply the operation on pile 0. The resulting piles are \\[3,4,5\\].\nThe total number of stones in \\[3,4,5\\] is 12.\n\n**Example 2:**\n\n**Input:** piles = \\[4,3,6,7\\], k = 3\n**Output:** 12\n**Explanation:** Steps of a possible scenario are:\n- Apply the operation on pile 2. The resulting piles are \\[4,3,3,7\\].\n- Apply the operation on pile 3. The resulting piles are \\[4,3,3,4\\].\n- Apply the operation on pile 0. The resulting piles are \\[2,3,3,4\\].\nThe total number of stones in \\[2,3,3,4\\] is 12.\n\n**Constraints:**\n\n*   `1 <= piles.length <= 105`\n*   `1 <= piles[i] <= 104`\n*   `1 <= k <= 105`", "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n        Integer[] taskIndices = new Integer[tasks.length];\n        for (int i = 0; i < tasks.length; i++) taskIndices[i] = i;\n\n        Arrays.sort(taskIndices, (a, b) -> tasks[a][0] - tasks[b][0]);\n\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> {\n            if (a[1] == b[1]) return a[0] - b[0];\n            return a[1] - b[1];\n        });\n\n        long time = 0;\n        int taskIdx = 0;\n        List<Integer> result = new ArrayList<>();\n\n        while (!isEmpty(taskIndices)) {\n            while (taskIdx < taskIndices.length && tasks[taskIndices[taskIdx]][0] <= time) {\n                int idx = taskIndices[taskIdx];\n                minHeap.add(new int[]{idx, tasks[idx][1]});\n                taskIndices[taskIdx] = null;\n                taskIdx++;\n            }\n\n            if (!minHeap.isEmpty()) {\n                int[] task = minHeap.poll();\n                time += task[1];\n                result.add(task[0]);\n            } else if (taskIdx < taskIndices.length) {\n                time = Math.max(time, (long)tasks[taskIndices[taskIdx]][0]);\n            }\n        }\n\n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n\n    private boolean isEmpty(Integer[] arr) {\n        for (Integer elem : arr) {\n            if (elem != null) return false;\n        }\n        return true;\n    }\n}\n```\n\n    \n    The algorithm works as follows:\n\n1. First, sort the task indices based on their enqueue times.\n2. Initialize a min heap with a custom comparator that prioritizes tasks with the least processing time and ties are broken by their original index.\n3. Initialize time, task index, and an array to hold the results.\n4. While there are still tasks to process, follow these steps:\n   - If there is a task that can be started (enqueue time is less than or equal to the current time), add it to the min heap and increment the task index.\n   - If there is a task in the min heap, process the task with the lowest processing time (from the min heap) and add its index to the result array.\n   - Update the time to be the max of the current time and the next available task's enqueue time.\n5. Return the result array containing the order in which tasks were processed by the CPU.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nvector<int> getOrder(vector<vector<int>>& tasks) {\n    vector<int> taskIndices(tasks.size());\n    for (int i = 0; i < tasks.size(); i++) taskIndices[i] = i;\n\n    sort(taskIndices.begin(), taskIndices.end(), [&](int a, int b) {\n        return tasks[a][0] < tasks[b][0];\n    });\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;\n    long long time = 0;\n    int taskIdx = 0;\n    vector<int> result;\n\n    while (!taskIndices.empty()) {\n        while (taskIdx < taskIndices.size() && tasks[taskIndices[taskIdx]][0] <= time) {\n            int idx = taskIndices[taskIdx];\n            minHeap.push({tasks[idx][1], idx});\n            taskIdx++;\n        }\n\n        if (!minHeap.empty()) {\n            auto [processingTime, index] = minHeap.top();\n            minHeap.pop();\n            time += processingTime;\n            result.push_back(index);\n            taskIndices.erase(remove(taskIndices.begin(), taskIndices.end(), index), taskIndices.end());\n        } else if (taskIdx < taskIndices.size()) {\n            time = max(time, (long long)tasks[taskIndices[taskIdx]][0]);\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm works as follows:\n\n1. First, sort the task indices based on their enqueue times.\n2. Initialize a min heap with a custom comparator that prioritizes tasks with the least processing time and ties are broken by their original index.\n3. Initialize time, task index, and an array to hold the results.\n4. While there are still tasks to process, follow these steps:\n   - If there is a task that can be started (enqueue time is less than or equal to the current time), add it to the min heap and increment the task index.\n   - If there is a task in the min heap, process the task with the lowest processing time (from the min heap) and add its index to the result array.\n   - Update the time to be the max of the current time and the next available task's enqueue time.\n5. Return the result array containing the order in which tasks were processed by the CPU.\n    ", "python": "\n    ```python\nfrom queue import PriorityQueue\n\ndef getOrder(tasks):\n    task_indices = sorted(range(len(tasks)), key=lambda i: tasks[i][0])\n    min_heap = PriorityQueue()\n    time = 0\n    task_idx = 0\n    result = []\n\n    while task_indices:\n        while task_idx < len(task_indices) and tasks[task_indices[task_idx]][0] <= time:\n            idx = task_indices[task_idx]\n            min_heap.put((tasks[idx][1], idx))\n            task_idx += 1\n\n        if not min_heap.empty():\n            processing_time, index = min_heap.get()\n            time += processing_time\n            result.append(index)\n            task_indices.remove(index)\n        elif task_idx < len(task_indices):\n            time = max(time, tasks[task_indices[task_idx]][0])\n\n    return result\n```\n\n    \n    The algorithm works as follows:\n\n1. First, sort the task indices based on their enqueue times.\n2. Initialize a min heap with a custom comparator that prioritizes tasks with the least processing time and ties are broken by their original index.\n3. Initialize time, task index, and an array to hold the results.\n4. While there are still tasks to process, follow these steps:\n   - If there is a task that can be started (enqueue time is less than or equal to the current time), add it to the min heap and increment the task index.\n   - If there is a task in the min heap, process the task with the lowest processing time (from the min heap) and add its index to the result array.\n   - Update the time to be the max of the current time and the next available task's enqueue time.\n5. Return the result array containing the order in which tasks were processed by the CPU.\n    ", "javascript": "\n    ```javascript\nfunction getOrder(tasks) {\n    const taskIndices = tasks.map((_, i) => i).sort((a, b) => tasks[a][0] - tasks[b][0]);\n    const minHeap = new MinHeap((a, b) => {\n        if (a[1] === b[1]) return a[0] - b[0];\n        return a[1] - b[1];\n    });\n\n    let time = 0;\n    let taskIdx = 0;\n    const result = [];\n\n    while (taskIndices.length > 0) {\n        while (taskIdx < taskIndices.length && tasks[taskIndices[taskIdx]][0] <= time) {\n            const idx = taskIndices[taskIdx];\n            minHeap.push([idx, tasks[idx][1]]);\n            taskIdx++;\n        }\n\n        if (!minHeap.isEmpty()) {\n            const [index, processingTime] = minHeap.pop();\n            time += processingTime;\n            result.push(index);\n            taskIndices.splice(taskIndices.indexOf(index), 1);\n        } else if (taskIdx < taskIndices.length) {\n            time = Math.max(time, tasks[taskIndices[taskIdx]][0]);\n        }\n    }\n\n    return result;\n}\n\nclass MinHeap {\n    constructor(comparator) {\n        this.comparator = comparator;\n        this.heap = [];\n    }\n\n    push(value) {\n        this.heap.push(value);\n        this.bubbleUp(this.heap.length - 1);\n    }\n\n    pop() {\n        if (this.heap.length === 0) return undefined;\n        const result = this.heap[0];\n        const lastValue = this.heap.pop();\n        if (this.heap.length > 0) {\n            this.heap[0] = lastValue;\n            this.bubbleDown(0);\n        }\n        return result;\n    }\n\n    bubbleUp(idx) {\n        while (idx > 0) {\n            const parentIdx = Math.floor((idx - 1) / 2);\n            if (this.comparator(this.heap[idx], this.heap[parentIdx]) < 0) {\n                const temp = this.heap[parentIdx];\n                this.heap[parentIdx] = this.heap[idx];\n                this.heap[idx] = temp;\n                idx = parentIdx;\n            } else {\n                break;\n            }\n        }\n    }\n\n    bubbleDown(idx) {\n        while (2 * idx + 1 < this.heap.length) {\n            let childIdx = 2 * idx + 1;\n            if (childIdx + 1 < this.heap.length && this.comparator(this.heap[childIdx], this.heap[childIdx + 1]) > 0) {\n                childIdx++;\n            }\n            if (this.comparator(this.heap[idx], this.heap[childIdx]) > 0) {\n                const temp = this.heap[childIdx];\n                this.heap[childIdx] = this.heap[idx];\n                this.heap[idx] = temp;\n                idx = childIdx;\n            } else {\n                break;\n            }\n        }\n    }\n\n    isEmpty() {\n        return this.heap.length === 0;\n    }\n}\n```\n\n    \n    The algorithm works as follows:\n\n1. First, sort the task indices based on their enqueue times.\n2. Initialize a min heap with a custom comparator that prioritizes tasks with the least processing time and ties are broken by their original index.\n3. Initialize time, task index, and an array to hold the results.\n4. While there are still tasks to process, follow these steps:\n   - If there is a task that can be started (enqueue time is less than or equal to the current time), add it to the min heap and increment the task index.\n   - If there is a task in the min heap, process the task with the lowest processing time (from the min heap) and add its index to the result array.\n   - Update the time to be the max of the current time and the next available task's enqueue time.\n5. Return the result array containing the order in which tasks were processed by the CPU.\n    "}
{"id": 1963, "slug": "minimum-number-of-swaps-to-make-the-string-balanced", "title": "Minimum Number of Swaps to Make the String Balanced", "difficulty": "Medium", "content": "You are given a **0-indexed** string `s` of **even** length `n`. The string consists of **exactly** `n / 2` opening brackets `'['` and `n / 2` closing brackets `']'`.\n\nA string is called **balanced** if and only if:\n\n*   It is the empty string, or\n*   It can be written as `AB`, where both `A` and `B` are **balanced** strings, or\n*   It can be written as `[C]`, where `C` is a **balanced** string.\n\nYou may swap the brackets at **any** two indices **any** number of times.\n\nReturn _the **minimum** number of swaps to make_ `s` _**balanced**_.\n\n**Example 1:**\n\n**Input:** s =  \"\\]\\[\\]\\[ \"\n**Output:** 1\n**Explanation:** You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is  \"\\[\\[\\]\\] \".\n\n**Example 2:**\n\n**Input:** s =  \"\\]\\]\\]\\[\\[\\[ \"\n**Output:** 2\n**Explanation:** You can do the following to make the string balanced:\n- Swap index 0 with index 4. s =  \"\\[\\]\\]\\[\\]\\[ \".\n- Swap index 1 with index 5. s =  \"\\[\\[\\]\\[\\]\\] \".\nThe resulting string is  \"\\[\\[\\]\\[\\]\\] \".\n\n**Example 3:**\n\n**Input:** s =  \"\\[\\] \"\n**Output:** 0\n**Explanation:** The string is already balanced.\n\n**Constraints:**\n\n*   `n == s.length`\n*   `2 <= n <= 106`\n*   `n` is even.\n*   `s[i]` is either `'['` or `']'`.\n*   The number of opening brackets `'['` equals `n / 2`, and the number of closing brackets `']'` equals `n / 2`.", "java": "\n    ```java\npublic int getXORSum(int[] arr1, int[] arr2) {\n    int xor_arr1 = 0, xor_arr2 = 0;\n    for (int i : arr1) xor_arr1 ^= i;\n    for (int j : arr2) xor_arr2 ^= j;\n    return xor_arr1 & xor_arr2;\n}\n```\n    \n    1. Initialize two variables `xor_arr1` and `xor_arr2` to store the XOR sum of arr1 and arr2, respectively.\n2. Iterate over `arr1` and compute its XOR sum by using the XOR `^=` operator.\n3. Iterate over `arr2` and compute its XOR sum similarly.\n4. Return the bitwise AND `&` of the two computed XOR sums (`xor_arr1` and `xor_arr2`). As per the problem statement, this will be the XOR sum of the list containing the result of arr1[i] AND arr2[j].\n    ", "c++": "\n    ```cpp\nint getXORSum(std::vector<int>& arr1, std::vector<int>& arr2) {\n    int xor_arr1 = 0, xor_arr2 = 0;\n    for (int i : arr1) xor_arr1 ^= i;\n    for (int j : arr2) xor_arr2 ^= j;\n    return xor_arr1 & xor_arr2;\n}\n```\n    \n    1. Initialize two variables `xor_arr1` and `xor_arr2` to store the XOR sum of arr1 and arr2, respectively.\n2. Iterate over `arr1` and compute its XOR sum by using the XOR `^=` operator.\n3. Iterate over `arr2` and compute its XOR sum similarly.\n4. Return the bitwise AND `&` of the two computed XOR sums (`xor_arr1` and `xor_arr2`). As per the problem statement, this will be the XOR sum of the list containing the result of arr1[i] AND arr2[j].\n    ", "python": "\n    ```python\ndef get_xor_sum(arr1, arr2):\n    xor_arr1 = xor_arr2 = 0\n    for i in arr1:\n        xor_arr1 ^= i\n    for j in arr2:\n        xor_arr2 ^= j\n    return xor_arr1 & xor_arr2\n```\n    \n    1. Initialize two variables `xor_arr1` and `xor_arr2` to store the XOR sum of arr1 and arr2, respectively.\n2. Iterate over `arr1` and compute its XOR sum by using the XOR `^=` operator.\n3. Iterate over `arr2` and compute its XOR sum similarly.\n4. Return the bitwise AND `&` of the two computed XOR sums (`xor_arr1` and `xor_arr2`). As per the problem statement, this will be the XOR sum of the list containing the result of arr1[i] AND arr2[j].\n    ", "javascript": "\n    ```javascript\nfunction getXORSum(arr1, arr2) {\n    let xor_arr1 = 0, xor_arr2 = 0;\n    for (let i of arr1) xor_arr1 ^= i;\n    for (let j of arr2) xor_arr2 ^= j;\n    return xor_arr1 & xor_arr2;\n}\n```\n    \n    1. Initialize two variables `xor_arr1` and `xor_arr2` to store the XOR sum of arr1 and arr2, respectively.\n2. Iterate over `arr1` and compute its XOR sum by using the XOR `^=` operator.\n3. Iterate over `arr2` and compute its XOR sum similarly.\n4. Return the bitwise AND `&` of the two computed XOR sums (`xor_arr1` and `xor_arr2`). As per the problem statement, this will be the XOR sum of the list containing the result of arr1[i] AND arr2[j].\n    "}
{"id": 1968, "slug": "array-with-elements-not-equal-to-average-of-neighbors", "title": "Array With Elements Not Equal to Average of Neighbors", "difficulty": "Medium", "content": "You are given a **0-indexed** array `nums` of **distinct** integers. You want to rearrange the elements in the array such that every element in the rearranged array is **not** equal to the **average** of its neighbors.\n\nMore formally, the rearranged array should have the property such that for every `i` in the range `1 <= i < nums.length - 1`, `(nums[i-1] + nums[i+1]) / 2` is **not** equal to `nums[i]`.\n\nReturn _**any** rearrangement of_ `nums` _that meets the requirements_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5\\]\n**Output:** \\[1,2,4,5,3\\]\n**Explanation:**\nWhen i=1, nums\\[i\\] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.\nWhen i=2, nums\\[i\\] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.\nWhen i=3, nums\\[i\\] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.\n\n**Example 2:**\n\n**Input:** nums = \\[6,2,0,9,7\\]\n**Output:** \\[9,7,6,2,0\\]\n**Explanation:**\nWhen i=1, nums\\[i\\] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.\nWhen i=2, nums\\[i\\] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.\nWhen i=3, nums\\[i\\] = 2, and the average of its neighbors is (6+0) / 2 = 3.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 105`\n*   `0 <= nums[i] <= 105`", "java": "\n    ```java\npublic int maxBuilding(int n, int[][] restrictions) {\n    List<int[]> list = new ArrayList<>(Arrays.asList(restrictions));\n    list.add(new int[]{1, 0});\n    list.add(new int[]{n, n - 1});\n    list.sort(Comparator.comparingInt(a -> a[0]));\n\n    int size = list.size();\n    for (int i = 1; i < size; i++)\n        list.get(i)[1] = Math.min(list.get(i)[1], list.get(i - 1)[1] + list.get(i)[0] - list.get(i - 1)[0]);\n    for (int i = size - 2; i >= 0; i--)\n        list.get(i)[1] = Math.min(list.get(i)[1], list.get(i + 1)[1] + list.get(i + 1)[0] - list.get(i)[0]);\n\n    int maxHeight = 0;\n    for (int i = 1; i < size; i++) {\n        int height = (list.get(i)[1] + list.get(i - 1)[1] + list.get(i)[0] - list.get(i - 1)[0]) / 2;\n        maxHeight = Math.max(maxHeight, height);\n    }\n\n    return maxHeight;\n}\n```\n\n    \n    1. Add the first building with height 0 and the last building with height n-1 to the restrictions list.\n2. Sort the restrictions list based on the building ids.\n3. Do a forward pass on the restrictions list, updating each building's maxHeight according to the previous building's maxHeight.\n4. Do a backward pass on the restrictions list, updating each building's maxHeight according to the next building's maxHeight.\n5. Iterate through the restrictions list, finding the maximum height that can be achieved legally.\n6. Return the maximum height found in step 5.\n    ", "c++": "\n    ```cpp\nint maxBuilding(int n, vector<vector<int>>& restrictions) {\n    restrictions.push_back({1, 0});\n    restrictions.push_back({n, n - 1});\n    sort(restrictions.begin(), restrictions.end());\n\n    int size = restrictions.size();\n    for (int i = 1; i < size; i++)\n        restrictions[i][1] = min(restrictions[i][1], restrictions[i - 1][1] + restrictions[i][0] - restrictions[i - 1][0]);\n\n    for (int i = size - 2; i >= 0; i--)\n        restrictions[i][1] = min(restrictions[i][1], restrictions[i + 1][1] + restrictions[i + 1][0] - restrictions[i][0]);\n\n    int maxHeight = 0;\n    for (int i = 1; i < size; i++) {\n        int height = (restrictions[i][1] + restrictions[i - 1][1] + restrictions[i][0] - restrictions[i - 1][0]) / 2;\n        maxHeight = max(maxHeight, height);\n    }\n\n    return maxHeight;\n}\n```\n\n    \n    1. Add the first building with height 0 and the last building with height n-1 to the restrictions list.\n2. Sort the restrictions list based on the building ids.\n3. Do a forward pass on the restrictions list, updating each building's maxHeight according to the previous building's maxHeight.\n4. Do a backward pass on the restrictions list, updating each building's maxHeight according to the next building's maxHeight.\n5. Iterate through the restrictions list, finding the maximum height that can be achieved legally.\n6. Return the maximum height found in step 5.\n    ", "python": "\n    ```python\ndef max_building(n, restrictions):\n    restrictions += [[1, 0], [n, n - 1]]\n    restrictions.sort()\n\n    for i in range(1, len(restrictions)):\n        restrictions[i][1] = min(restrictions[i][1], restrictions[i - 1][1] + restrictions[i][0] - restrictions[i - 1][0])\n\n    for i in range(len(restrictions) - 2, -1, -1):\n        restrictions[i][1] = min(restrictions[i][1], restrictions[i + 1][1] + restrictions[i + 1][0] - restrictions[i][0])\n\n    maxHeight = 0\n    for i in range(1, len(restrictions)):\n        height = (restrictions[i][1] + restrictions[i - 1][1] + restrictions[i][0] - restrictions[i - 1][0]) // 2\n        maxHeight = max(maxHeight, height)\n\n    return maxHeight\n```\n\n    \n    1. Add the first building with height 0 and the last building with height n-1 to the restrictions list.\n2. Sort the restrictions list based on the building ids.\n3. Do a forward pass on the restrictions list, updating each building's maxHeight according to the previous building's maxHeight.\n4. Do a backward pass on the restrictions list, updating each building's maxHeight according to the next building's maxHeight.\n5. Iterate through the restrictions list, finding the maximum height that can be achieved legally.\n6. Return the maximum height found in step 5.\n    ", "javascript": "\n    ```javascript\nfunction maxBuilding(n, restrictions) {\n    restrictions.push([1, 0], [n, n - 1]);\n    restrictions.sort((a, b) => a[0] - b[0]);\n\n    for (let i = 1; i < restrictions.length; i++) {\n        restrictions[i][1] = Math.min(restrictions[i][1], restrictions[i - 1][1] + restrictions[i][0] - restrictions[i - 1][0]);\n    }\n\n    for (let i = restrictions.length - 2; i >= 0; i--) {\n        restrictions[i][1] = Math.min(restrictions[i][1], restrictions[i + 1][1] + restrictions[i + 1][0] - restrictions[i][0]);\n    }\n\n    let maxHeight = 0;\n    for (let i = 1; i < restrictions.length; i++) {\n        const height = (restrictions[i][1] + restrictions[i - 1][1] + restrictions[i][0] - restrictions[i - 1][0]) >> 1;\n        maxHeight = Math.max(maxHeight, height);\n    }\n\n    return maxHeight;\n}\n```\n\n    \n    1. Add the first building with height 0 and the last building with height n-1 to the restrictions list.\n2. Sort the restrictions list based on the building ids.\n3. Do a forward pass on the restrictions list, updating each building's maxHeight according to the previous building's maxHeight.\n4. Do a backward pass on the restrictions list, updating each building's maxHeight according to the next building's maxHeight.\n5. Iterate through the restrictions list, finding the maximum height that can be achieved legally.\n6. Return the maximum height found in step 5.\n    "}
{"id": 1969, "slug": "minimum-non-zero-product-of-the-array-elements", "title": "Minimum Non-Zero Product of the Array Elements", "difficulty": "Medium", "content": "You are given a positive integer `p`. Consider an array `nums` (**1-indexed**) that consists of the integers in the **inclusive** range `[1, 2p - 1]` in their binary representations. You are allowed to do the following operation **any** number of times:\n\n*   Choose two elements `x` and `y` from `nums`.\n*   Choose a bit in `x` and swap it with its corresponding bit in `y`. Corresponding bit refers to the bit that is in the **same position** in the other integer.\n\nFor example, if `x = 1101` and `y = 0011`, after swapping the `2nd` bit from the right, we have `x = 1111` and `y = 0001`.\n\nFind the **minimum non-zero** product of `nums` after performing the above operation **any** number of times. Return _this product_ _**modulo**_ `109 + 7`.\n\n**Note:** The answer should be the minimum product **before** the modulo operation is done.\n\n**Example 1:**\n\n**Input:** p = 1\n**Output:** 1\n**Explanation:** nums = \\[1\\].\nThere is only one element, so the product equals that element.\n\n**Example 2:**\n\n**Input:** p = 2\n**Output:** 6\n**Explanation:** nums = \\[01, 10, 11\\].\nAny swap would either make the product 0 or stay the same.\nThus, the array product of 1 \\* 2 \\* 3 = 6 is already minimized.\n\n**Example 3:**\n\n**Input:** p = 3\n**Output:** 1512\n**Explanation:** nums = \\[001, 010, 011, 100, 101, 110, 111\\]\n- In the first operation we can swap the leftmost bit of the second and fifth elements.\n    - The resulting array is \\[001, 110, 011, 100, 001, 110, 111\\].\n- In the second operation we can swap the middle bit of the third and fourth elements.\n    - The resulting array is \\[001, 110, 001, 110, 001, 110, 111\\].\nThe array product is 1 \\* 6 \\* 1 \\* 6 \\* 1 \\* 6 \\* 7 = 1512, which is the minimum possible product.\n\n**Constraints:**\n\n*   `1 <= p <= 60`", "java": "\n    ```java\npublic int minNonZeroProduct(int p) {\n    int mod = 1000000007;\n    long x = (1L << p) - 1;\n    long y = (1L << p) - 2;\n    long z = modPow(y, x - 1, mod);\n    return (int) (x * z % mod);\n}\n\nprivate long modPow(long x, long y, int mod) {\n    long res = 1L;\n    while (y > 0) {\n        if ((y & 1) == 1) {\n            res = res * x % mod;\n        }\n        x = x * x % mod;\n        y >>= 1;\n    }\n    return res;\n}\n```\n    \n    The problem asks us to find the minimum non-zero product after swapping any number of times the corresponding bits in the numbers from the array `nums`.\n\nFirst, note that the array nums consists of integers in the inclusive range `[1, 2^p - 1]`. So, the largest number in nums can be expressed as `111...1` (p times).\n\nLet's consider `x` as the largest number in nums (`2^p - 1`). We also need the second largest number `y` computed as `x - 1 = 2^p - 2`.\n\nNow, notice that the minimum product will always be a product of pairs such that the sum of the pairs equals the largest number in nums, this is because when swapping bits, we are just distributing the bits differently among the pairs, but the sum should always be the same.\n\nSo, the minimum product can be found by multiplying `x` (the largest number) by the result of `y` raised to the power of `(x - 1)` or `(y ^ (x - 1))`. It's (x - 1) because we have `x - 1` pairs in nums, and each pair contributes to the product with its corresponding `y`.\n\nFinally, we need to remember to return the product modulo `10^9 + 7`.\n\nThe code for each language first initializes the variables x, y, and z as described above. The `mod_pow` (or `modPow`) function in C++, Java, and JavaScript implements a fast exponentiation algorithm for computing `(y ^ (x - 1))` modulo `10^9 + 7`. The Python code uses the built-in `pow` function which can also compute it directly with its optional third argument as the modulo.\n\nAfter computing the needed variables, the function returns the product modulo `10^9 + 7`.\n    ", "c++": "\n    ```cpp\nlong long mod_pow(long long x, long long y, long long mod) {\n    long long res = 1;\n    while (y) {\n        if (y & 1) res = res * x % mod;\n        x = x * x % mod;\n        y >>= 1;\n    }\n    return res;\n}\n\nint minNonZeroProduct(int p) {\n    const int mod = 1e9 + 7;\n    long long x = (1LL << p) - 1;\n    long long y = (1LL << p) - 2;\n    long long z = mod_pow(y, x - 1, mod);\n    return x * z % mod;\n}\n```\n    \n    The problem asks us to find the minimum non-zero product after swapping any number of times the corresponding bits in the numbers from the array `nums`.\n\nFirst, note that the array nums consists of integers in the inclusive range `[1, 2^p - 1]`. So, the largest number in nums can be expressed as `111...1` (p times).\n\nLet's consider `x` as the largest number in nums (`2^p - 1`). We also need the second largest number `y` computed as `x - 1 = 2^p - 2`.\n\nNow, notice that the minimum product will always be a product of pairs such that the sum of the pairs equals the largest number in nums, this is because when swapping bits, we are just distributing the bits differently among the pairs, but the sum should always be the same.\n\nSo, the minimum product can be found by multiplying `x` (the largest number) by the result of `y` raised to the power of `(x - 1)` or `(y ^ (x - 1))`. It's (x - 1) because we have `x - 1` pairs in nums, and each pair contributes to the product with its corresponding `y`.\n\nFinally, we need to remember to return the product modulo `10^9 + 7`.\n\nThe code for each language first initializes the variables x, y, and z as described above. The `mod_pow` (or `modPow`) function in C++, Java, and JavaScript implements a fast exponentiation algorithm for computing `(y ^ (x - 1))` modulo `10^9 + 7`. The Python code uses the built-in `pow` function which can also compute it directly with its optional third argument as the modulo.\n\nAfter computing the needed variables, the function returns the product modulo `10^9 + 7`.\n    ", "python": "\n    ```python\ndef minNonZeroProduct(p: int) -> int:\n    mod = 10**9 + 7\n    x = (1 << p) - 1\n    y = (1 << p) - 2\n    z = pow(y, x - 1, mod)\n    return x * z % mod\n```\n    \n    The problem asks us to find the minimum non-zero product after swapping any number of times the corresponding bits in the numbers from the array `nums`.\n\nFirst, note that the array nums consists of integers in the inclusive range `[1, 2^p - 1]`. So, the largest number in nums can be expressed as `111...1` (p times).\n\nLet's consider `x` as the largest number in nums (`2^p - 1`). We also need the second largest number `y` computed as `x - 1 = 2^p - 2`.\n\nNow, notice that the minimum product will always be a product of pairs such that the sum of the pairs equals the largest number in nums, this is because when swapping bits, we are just distributing the bits differently among the pairs, but the sum should always be the same.\n\nSo, the minimum product can be found by multiplying `x` (the largest number) by the result of `y` raised to the power of `(x - 1)` or `(y ^ (x - 1))`. It's (x - 1) because we have `x - 1` pairs in nums, and each pair contributes to the product with its corresponding `y`.\n\nFinally, we need to remember to return the product modulo `10^9 + 7`.\n\nThe code for each language first initializes the variables x, y, and z as described above. The `mod_pow` (or `modPow`) function in C++, Java, and JavaScript implements a fast exponentiation algorithm for computing `(y ^ (x - 1))` modulo `10^9 + 7`. The Python code uses the built-in `pow` function which can also compute it directly with its optional third argument as the modulo.\n\nAfter computing the needed variables, the function returns the product modulo `10^9 + 7`.\n    ", "javascript": "\n    ```javascript\nfunction minNonZeroProduct(p) {\n    const mod = 1e9 + 7;\n    const x = (1n << BigInt(p)) - 1n;\n    const y = (1n << BigInt(p)) - 2n;\n    const z = modPow(y, x - 1n, mod);\n    return Number(x * z % BigInt(mod));\n}\n\nfunction modPow(x, y, mod) {\n    let res = 1n;\n    while (y) {\n        if (y & 1n) res = res * x % BigInt(mod);\n        x = x * x % BigInt(mod);\n        y >>= 1n;\n    }\n    return res;\n}\n```\n    \n    The problem asks us to find the minimum non-zero product after swapping any number of times the corresponding bits in the numbers from the array `nums`.\n\nFirst, note that the array nums consists of integers in the inclusive range `[1, 2^p - 1]`. So, the largest number in nums can be expressed as `111...1` (p times).\n\nLet's consider `x` as the largest number in nums (`2^p - 1`). We also need the second largest number `y` computed as `x - 1 = 2^p - 2`.\n\nNow, notice that the minimum product will always be a product of pairs such that the sum of the pairs equals the largest number in nums, this is because when swapping bits, we are just distributing the bits differently among the pairs, but the sum should always be the same.\n\nSo, the minimum product can be found by multiplying `x` (the largest number) by the result of `y` raised to the power of `(x - 1)` or `(y ^ (x - 1))`. It's (x - 1) because we have `x - 1` pairs in nums, and each pair contributes to the product with its corresponding `y`.\n\nFinally, we need to remember to return the product modulo `10^9 + 7`.\n\nThe code for each language first initializes the variables x, y, and z as described above. The `mod_pow` (or `modPow`) function in C++, Java, and JavaScript implements a fast exponentiation algorithm for computing `(y ^ (x - 1))` modulo `10^9 + 7`. The Python code uses the built-in `pow` function which can also compute it directly with its optional third argument as the modulo.\n\nAfter computing the needed variables, the function returns the product modulo `10^9 + 7`.\n    "}
{"id": 1974, "slug": "minimum-time-to-type-word-using-special-typewriter", "title": "Minimum Time to Type Word Using Special Typewriter", "difficulty": "Easy", "content": "There is a special typewriter with lowercase English letters `'a'` to `'z'` arranged in a **circle** with a **pointer**. A character can **only** be typed if the pointer is pointing to that character. The pointer is **initially** pointing to the character `'a'`.\n\nEach second, you may perform one of the following operations:\n\n*   Move the pointer one character **counterclockwise** or **clockwise**.\n*   Type the character the pointer is **currently** on.\n\nGiven a string `word`, return the **minimum** number of seconds to type out the characters in `word`.\n\n**Example 1:**\n\n**Input:** word =  \"abc \"\n**Output:** 5\n**Explanation:** \nThe characters are printed as follows:\n- Type the character 'a' in 1 second since the pointer is initially on 'a'.\n- Move the pointer clockwise to 'b' in 1 second.\n- Type the character 'b' in 1 second.\n- Move the pointer clockwise to 'c' in 1 second.\n- Type the character 'c' in 1 second.\n\n**Example 2:**\n\n**Input:** word =  \"bza \"\n**Output:** 7\n**Explanation:**\nThe characters are printed as follows:\n- Move the pointer clockwise to 'b' in 1 second.\n- Type the character 'b' in 1 second.\n- Move the pointer counterclockwise to 'z' in 2 seconds.\n- Type the character 'z' in 1 second.\n- Move the pointer clockwise to 'a' in 1 second.\n- Type the character 'a' in 1 second.\n\n**Example 3:**\n\n**Input:** word =  \"zjpc \"\n**Output:** 34\n**Explanation:**\nThe characters are printed as follows:\n- Move the pointer counterclockwise to 'z' in 1 second.\n- Type the character 'z' in 1 second.\n- Move the pointer clockwise to 'j' in 10 seconds.\n- Type the character 'j' in 1 second.\n- Move the pointer clockwise to 'p' in 6 seconds.\n- Type the character 'p' in 1 second.\n- Move the pointer counterclockwise to 'c' in 13 seconds.\n- Type the character 'c' in 1 second.\n\n**Constraints:**\n\n*   `1 <= word.length <= 100`\n*   `word` consists of lowercase English letters.", "java": "\n    ```java\npublic int minTimeToType(String word) {\n    int time = 0, position = 0;\n    for (char c : word.toCharArray()) {\n        int next_position = c - 'a';\n        int diff = Math.abs(next_position - position);\n        time += Math.min(diff, 26 - diff) + 1;\n        position = next_position;\n    }\n    return time;\n}\n```\n    \n    1. Initialize the time and position to 0.\n2. Iterate through the characters of the word.\n3. Calculate the next position based on the ASCII value of the character and 'a'.\n4. Calculate the difference between the next position and the current position.\n5. Update the time by adding the minimum of the difference and (26 - difference), and 1 extra second for typing the character.\n6. Update the current position to the next position.\n7. Return the total time after processing all characters in the word.\n    ", "c++": "\n    ```cpp\nint minTimeToType(string word) {\n    int time = 0, position = 0;\n    for (char c : word) {\n        int next_position = c - 'a';\n        int diff = abs(next_position - position);\n        time += min(diff, 26 - diff) + 1;\n        position = next_position;\n    }\n    return time;\n}\n```\n    \n    1. Initialize the time and position to 0.\n2. Iterate through the characters of the word.\n3. Calculate the next position based on the ASCII value of the character and 'a'.\n4. Calculate the difference between the next position and the current position.\n5. Update the time by adding the minimum of the difference and (26 - difference), and 1 extra second for typing the character.\n6. Update the current position to the next position.\n7. Return the total time after processing all characters in the word.\n    ", "python": "\n    ```python\ndef minTimeToType(word: str) -> int:\n    time = 0\n    position = 0\n    for c in word:\n        next_position = ord(c) - ord('a')\n        diff = abs(next_position - position)\n        time += min(diff, 26 - diff) + 1\n        position = next_position\n    return time\n```\n    \n    1. Initialize the time and position to 0.\n2. Iterate through the characters of the word.\n3. Calculate the next position based on the ASCII value of the character and 'a'.\n4. Calculate the difference between the next position and the current position.\n5. Update the time by adding the minimum of the difference and (26 - difference), and 1 extra second for typing the character.\n6. Update the current position to the next position.\n7. Return the total time after processing all characters in the word.\n    ", "javascript": "\n    ```javascript\nfunction minTimeToType(word) {\n    let time = 0, position = 0;\n    for (const c of word) {\n        let next_position = c.charCodeAt(0) - 'a'.charCodeAt(0);\n        let diff = Math.abs(next_position - position);\n        time += Math.min(diff, 26 - diff) + 1;\n        position = next_position;\n    }\n    return time;\n}\n```\n    \n    1. Initialize the time and position to 0.\n2. Iterate through the characters of the word.\n3. Calculate the next position based on the ASCII value of the character and 'a'.\n4. Calculate the difference between the next position and the current position.\n5. Update the time by adding the minimum of the difference and (26 - difference), and 1 extra second for typing the character.\n6. Update the current position to the next position.\n7. Return the total time after processing all characters in the word.\n    "}
{"id": 1975, "slug": "maximum-matrix-sum", "title": "Maximum Matrix Sum", "difficulty": "Medium", "content": "You are given an `n x n` integer `matrix`. You can do the following operation **any** number of times:\n\n*   Choose any two **adjacent** elements of `matrix` and **multiply** each of them by `-1`.\n\nTwo elements are considered **adjacent** if and only if they share a **border**.\n\nYour goal is to **maximize** the summation of the matrix's elements. Return _the **maximum** sum of the matrix's elements using the operation mentioned above._\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,-1\\],\\[-1,1\\]\\]\n**Output:** 4\n**Explanation:** We can follow the following steps to reach sum equals 4:\n- Multiply the 2 elements in the first row by -1.\n- Multiply the 2 elements in the first column by -1.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[1,2,3\\],\\[-1,-2,-3\\],\\[1,2,3\\]\\]\n**Output:** 16\n**Explanation:** We can follow the following step to reach sum equals 16:\n- Multiply the 2 last elements in the second row by -1.\n\n**Constraints:**\n\n*   `n == matrix.length == matrix[i].length`\n*   `2 <= n <= 250`\n*   `-105 <= matrix[i][j] <= 105`", "java": "\n    ```java\npublic int findTargetDistance(int[] nums, int target, int start) {\n    int minDistance = Integer.MAX_VALUE;\n    for(int i = 0; i < nums.length; i++) {\n        if(nums[i] == target) {\n            int distance = Math.abs(i - start);\n            minDistance = Math.min(minDistance, distance);\n        }\n    }\n    return minDistance;\n}\n```\n    \n    The algorithm iterates through the input array `nums`, and for each element, it checks if it is equal to the target. If it is, the algorithm computes the absolute difference between the current index `i` and the `start` index. It keeps track of the minimum distance found so far and updates it whenever it finds a smaller distance. Finally, it returns the minimum distance.\n\nThis approach has a time complexity of O(n), where n is the length of the `nums` array, as it iterates through the entire array once. There are no additional memory requirements other than a few variables, so its space complexity is O(1).\n    ", "c++": "\n    ```cpp\nint find_target_distance(vector<int>& nums, int target, int start) {\n    int min_distance = INT_MAX;\n    for(int i = 0; i < nums.size(); ++i) {\n        if(nums[i] == target) {\n            int distance = abs(i - start);\n            min_distance = min(min_distance, distance);\n        }\n    }\n    return min_distance;\n}\n```\n    \n    The algorithm iterates through the input array `nums`, and for each element, it checks if it is equal to the target. If it is, the algorithm computes the absolute difference between the current index `i` and the `start` index. It keeps track of the minimum distance found so far and updates it whenever it finds a smaller distance. Finally, it returns the minimum distance.\n\nThis approach has a time complexity of O(n), where n is the length of the `nums` array, as it iterates through the entire array once. There are no additional memory requirements other than a few variables, so its space complexity is O(1).\n    ", "python": "\n    ```python\ndef find_target_distance(nums, target, start):\n    min_distance = float('inf')\n    for i, num in enumerate(nums):\n        if num == target:\n            distance = abs(i - start)\n            min_distance = min(min_distance, distance)\n    return min_distance\n```\n    \n    The algorithm iterates through the input array `nums`, and for each element, it checks if it is equal to the target. If it is, the algorithm computes the absolute difference between the current index `i` and the `start` index. It keeps track of the minimum distance found so far and updates it whenever it finds a smaller distance. Finally, it returns the minimum distance.\n\nThis approach has a time complexity of O(n), where n is the length of the `nums` array, as it iterates through the entire array once. There are no additional memory requirements other than a few variables, so its space complexity is O(1).\n    ", "javascript": "\n    ```javascript\nfunction findTargetDistance(nums, target, start) {\n    let minDistance = Infinity;\n    for(let i = 0; i < nums.length; i++) {\n        if(nums[i] === target) {\n            const distance = Math.abs(i - start);\n            minDistance = Math.min(minDistance, distance);\n        }\n    }\n    return minDistance;\n}\n```\n    \n    The algorithm iterates through the input array `nums`, and for each element, it checks if it is equal to the target. If it is, the algorithm computes the absolute difference between the current index `i` and the `start` index. It keeps track of the minimum distance found so far and updates it whenever it finds a smaller distance. Finally, it returns the minimum distance.\n\nThis approach has a time complexity of O(n), where n is the length of the `nums` array, as it iterates through the entire array once. There are no additional memory requirements other than a few variables, so its space complexity is O(1).\n    "}
{"id": 1989, "slug": "maximum-number-of-people-that-can-be-caught-in-tag", "title": "Maximum Number of People That Can Be Caught in Tag", "difficulty": "Medium", "content": "You are playing a game of tag with your friends. In tag, people are divided into two teams: people who are \"it \", and people who are not \"it \". The people who are \"it \" want to catch as many people as possible who are not \"it \".\n\nYou are given a **0-indexed** integer array `team` containing only zeros (denoting people who are **not** \"it \") and ones (denoting people who are \"it \"), and an integer `dist`. A person who is \"it \" at index `i` can catch any **one** person whose index is in the range `[i - dist, i + dist]` (**inclusive**) and is **not** \"it \".\n\nReturn _the **maximum** number of people that the people who are \"it \" can catch_.\n\n**Example 1:**\n\n**Input:** team = \\[0,1,0,1,0\\], dist = 3\n**Output:** 2\n**Explanation:**\nThe person who is  \"it \" at index 1 can catch people in the range \\[i-dist, i+dist\\] = \\[1-3, 1+3\\] = \\[-2, 4\\].\nThey can catch the person who is not  \"it \" at index 2.\nThe person who is  \"it \" at index 3 can catch people in the range \\[i-dist, i+dist\\] = \\[3-3, 3+3\\] = \\[0, 6\\].\nThey can catch the person who is not  \"it \" at index 0.\nThe person who is not  \"it \" at index 4 will not be caught because the people at indices 1 and 3 are already catching one person.\n\n**Example 2:**\n\n**Input:** team = \\[1\\], dist = 1\n**Output:** 0\n**Explanation:**\nThere are no people who are not  \"it \" to catch.\n\n**Example 3:**\n\n**Input:** team = \\[0\\], dist = 1\n**Output:** 0\n**Explanation:**\nThere are no people who are  \"it \" to catch people.\n\n**Constraints:**\n\n*   `1 <= team.length <= 105`\n*   `0 <= team[i] <= 1`\n*   `1 <= dist <= team.length`", "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int minimumXorSum(int[] nums1, int[] nums2) {\n    Arrays.sort(nums2);\n    int xorSum = 0;\n    for (int i = 0; i < nums1.length; i++) {\n        xorSum += nums1[i] ^ nums2[i];\n    }\n    return xorSum;\n}\n```\n    \n    The algorithm to minimize XOR sum works as follows:\n\n1. Sort the array nums2 in ascending order.\n2. Calculate the XOR sum between elements of array nums1 and nums2, iterating through both arrays simultaneously.\n3. Return the XOR sum of the two arrays.\n\nBy sorting the nums2 array, we are effectively minimizing the XOR sum because when doing bitwise XOR, if the corresponding bit is 1 in one number and 0 in the other number, the resultant bit will be 1. Sorting nums2 guarantees that we minimize the number of 1's in the resultant XOR operation.\n    ", "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint minimum_xor_sum(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::sort(nums2.begin(), nums2.end());\n    int xor_sum = 0;\n    for (int i = 0; i < nums1.size(); ++i) {\n        xor_sum += nums1[i] ^ nums2[i];\n    }\n    return xor_sum;\n}\n```\n    \n    The algorithm to minimize XOR sum works as follows:\n\n1. Sort the array nums2 in ascending order.\n2. Calculate the XOR sum between elements of array nums1 and nums2, iterating through both arrays simultaneously.\n3. Return the XOR sum of the two arrays.\n\nBy sorting the nums2 array, we are effectively minimizing the XOR sum because when doing bitwise XOR, if the corresponding bit is 1 in one number and 0 in the other number, the resultant bit will be 1. Sorting nums2 guarantees that we minimize the number of 1's in the resultant XOR operation.\n    ", "python": "\n    ```python\ndef minimum_xor_sum(nums1, nums2):\n    nums2.sort()\n    xor_sum = 0\n    for i in range(len(nums1)):\n        xor_sum += nums1[i] ^ nums2[i]\n    return xor_sum\n```\n    \n    The algorithm to minimize XOR sum works as follows:\n\n1. Sort the array nums2 in ascending order.\n2. Calculate the XOR sum between elements of array nums1 and nums2, iterating through both arrays simultaneously.\n3. Return the XOR sum of the two arrays.\n\nBy sorting the nums2 array, we are effectively minimizing the XOR sum because when doing bitwise XOR, if the corresponding bit is 1 in one number and 0 in the other number, the resultant bit will be 1. Sorting nums2 guarantees that we minimize the number of 1's in the resultant XOR operation.\n    ", "javascript": "\n    ```javascript\nfunction minimumXorSum(nums1, nums2) {\n    nums2.sort((a, b) => a - b);\n    let xorSum = 0;\n    for (let i = 0; i < nums1.length; i++) {\n        xorSum += nums1[i] ^ nums2[i];\n    }\n    return xorSum;\n}\n```\n    \n    The algorithm to minimize XOR sum works as follows:\n\n1. Sort the array nums2 in ascending order.\n2. Calculate the XOR sum between elements of array nums1 and nums2, iterating through both arrays simultaneously.\n3. Return the XOR sum of the two arrays.\n\nBy sorting the nums2 array, we are effectively minimizing the XOR sum because when doing bitwise XOR, if the corresponding bit is 1 in one number and 0 in the other number, the resultant bit will be 1. Sorting nums2 guarantees that we minimize the number of 1's in the resultant XOR operation.\n    "}
{"id": 1996, "slug": "the-number-of-weak-characters-in-the-game", "title": "The Number of Weak Characters in the Game", "difficulty": "Medium", "content": "You are playing a game that contains multiple characters, and each of the characters has **two** main properties: **attack** and **defense**. You are given a 2D integer array `properties` where `properties[i] = [attacki, defensei]` represents the properties of the `ith` character in the game.\n\nA character is said to be **weak** if any other character has **both** attack and defense levels **strictly greater** than this character's attack and defense levels. More formally, a character `i` is said to be **weak** if there exists another character `j` where `attackj > attacki` and `defensej > defensei`.\n\nReturn _the number of **weak** characters_.\n\n**Example 1:**\n\n**Input:** properties = \\[\\[5,5\\],\\[6,3\\],\\[3,6\\]\\]\n**Output:** 0\n**Explanation:** No character has strictly greater attack and defense than the other.\n\n**Example 2:**\n\n**Input:** properties = \\[\\[2,2\\],\\[3,3\\]\\]\n**Output:** 1\n**Explanation:** The first character is weak because the second character has a strictly greater attack and defense.\n\n**Example 3:**\n\n**Input:** properties = \\[\\[1,5\\],\\[10,4\\],\\[4,3\\]\\]\n**Output:** 1\n**Explanation:** The third character is weak because the second character has a strictly greater attack and defense.\n\n**Constraints:**\n\n*   `2 <= properties.length <= 105`\n*   `properties[i].length == 2`\n*   `1 <= attacki, defensei <= 105`", "java": "\n    ```java\nint numberOfSticks(int n, int k) {\n    final int MOD = (int) 1e9 + 7;\n    if (n < k) return 0;\n    int[][] dp = new int[n+1][n+1];\n\n    for (int i = 1; i <= n; i++) {\n        dp[i][1] = 1;\n        for (int j = 2; j <= i; j++)\n            dp[i][j] = (dp[i-1][j-1] + (i-1) * dp[i-1][j]) % MOD;\n    }\n    return dp[n][k];\n}\n```\n    \n    We will use dynamic programming to solve this problem. We will have a 2D array `dp[i][j]` that represents the number of ways to arrange i sticks such that exactly j sticks are visible from the left. We initialize `dp[i][1] = 1` for all i, because there is always 1 way to arrange i sticks such that only 1 stick is visible from the left (placing the largest stick at the beginning).\n\nNow let's fill out the dp array iteratively. At each step, we can either make the current stick visible or not visible. If we make the stick visible, there would be `dp[i-1][j-1]` ways to arrange the remaining sticks, since there are now j-1 visible sticks needed for the first i-1 sticks. If we don't make the stick visible, there would be `(i-1) * dp[i-1][j]` ways to arrange the remaining sticks, because there are still j visible sticks needed but there are now i-1 positions to place the current stick (it can be placed behind any of the first i-1 sticks). We add these two cases together and take the result modulo 10^9+7.\n\nThe function returns `dp[n][k]` as the final result.\n    ", "c++": "\n    ```cpp\nint numberOfSticks(int n, int k) {\n    const int MOD = 1e9 + 7;\n    if (n < k) return 0;\n    int dp[n+1][n+1];\n    memset(dp, 0, sizeof(dp));\n\n    for (int i = 1; i <= n; i++) {\n        dp[i][1] = 1;\n        for (int j = 2; j <= i; j++)\n            dp[i][j] = (dp[i-1][j-1] + (i-1) * dp[i-1][j]) % MOD;\n    }\n    return dp[n][k];\n}\n```\n    \n    We will use dynamic programming to solve this problem. We will have a 2D array `dp[i][j]` that represents the number of ways to arrange i sticks such that exactly j sticks are visible from the left. We initialize `dp[i][1] = 1` for all i, because there is always 1 way to arrange i sticks such that only 1 stick is visible from the left (placing the largest stick at the beginning).\n\nNow let's fill out the dp array iteratively. At each step, we can either make the current stick visible or not visible. If we make the stick visible, there would be `dp[i-1][j-1]` ways to arrange the remaining sticks, since there are now j-1 visible sticks needed for the first i-1 sticks. If we don't make the stick visible, there would be `(i-1) * dp[i-1][j]` ways to arrange the remaining sticks, because there are still j visible sticks needed but there are now i-1 positions to place the current stick (it can be placed behind any of the first i-1 sticks). We add these two cases together and take the result modulo 10^9+7.\n\nThe function returns `dp[n][k]` as the final result.\n    ", "python": "\n    ```python\ndef numberOfSticks(n, k):\n    MOD = 10**9 + 7\n    if n < k: return 0\n    dp = [[0] * (n+1) for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        dp[i][1] = 1\n        for j in range(2, i+1):\n            dp[i][j] = (dp[i-1][j-1] + (i-1) * dp[i-1][j]) % MOD\n\n    return dp[n][k]\n```\n    \n    We will use dynamic programming to solve this problem. We will have a 2D array `dp[i][j]` that represents the number of ways to arrange i sticks such that exactly j sticks are visible from the left. We initialize `dp[i][1] = 1` for all i, because there is always 1 way to arrange i sticks such that only 1 stick is visible from the left (placing the largest stick at the beginning).\n\nNow let's fill out the dp array iteratively. At each step, we can either make the current stick visible or not visible. If we make the stick visible, there would be `dp[i-1][j-1]` ways to arrange the remaining sticks, since there are now j-1 visible sticks needed for the first i-1 sticks. If we don't make the stick visible, there would be `(i-1) * dp[i-1][j]` ways to arrange the remaining sticks, because there are still j visible sticks needed but there are now i-1 positions to place the current stick (it can be placed behind any of the first i-1 sticks). We add these two cases together and take the result modulo 10^9+7.\n\nThe function returns `dp[n][k]` as the final result.\n    ", "javascript": "\n    ```javascript\nfunction numberOfSticks(n, k) {\n    const MOD = 1e9 + 7;\n    if (n < k) return 0;\n    let dp = Array.from({ length: n+1 }, () => Array(n+1).fill(0));\n\n    for (let i = 1; i <= n; i++) {\n        dp[i][1] = 1;\n        for (let j = 2; j <= i; j++)\n            dp[i][j] = (dp[i-1][j-1] + (i-1) * dp[i-1][j]) % MOD;\n    }\n    return dp[n][k];\n}\n```\n    \n    We will use dynamic programming to solve this problem. We will have a 2D array `dp[i][j]` that represents the number of ways to arrange i sticks such that exactly j sticks are visible from the left. We initialize `dp[i][1] = 1` for all i, because there is always 1 way to arrange i sticks such that only 1 stick is visible from the left (placing the largest stick at the beginning).\n\nNow let's fill out the dp array iteratively. At each step, we can either make the current stick visible or not visible. If we make the stick visible, there would be `dp[i-1][j-1]` ways to arrange the remaining sticks, since there are now j-1 visible sticks needed for the first i-1 sticks. If we don't make the stick visible, there would be `(i-1) * dp[i-1][j]` ways to arrange the remaining sticks, because there are still j visible sticks needed but there are now i-1 positions to place the current stick (it can be placed behind any of the first i-1 sticks). We add these two cases together and take the result modulo 10^9+7.\n\nThe function returns `dp[n][k]` as the final result.\n    "}
